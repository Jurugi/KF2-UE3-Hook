/*
#############################################################################################
# Killing Floor 2 (1.8787) SDK
# Generated with TheFeckless UE3 SDK Generator v1.4_Beta-Rev.51
# ========================================================================================= #
# File: Engine_classes.h
# ========================================================================================= #
# Credits: uNrEaL, Tamimego, SystemFiles, R00T88, _silencer, the1domo, K@N@VEL
# Thanks: HOOAH07, lowHertz
# Forums: www.uc-forum.com, www.gamedeception.net
#############################################################################################
*/

#ifdef _MSC_VER
	#pragma pack ( push, 0x4 )
#endif

/*
# ========================================================================================= #
# Constants
# ========================================================================================= #
*/

#define CONST_MINFLOORZ                                          0.7
#define CONST_ACTORMAXSTEPHEIGHT                                 35.0
#define CONST_RBSTATE_LINVELSCALE                                10.0
#define CONST_RBSTATE_ANGVELSCALE                                1000.0
#define CONST_RB_None                                            0x00
#define CONST_RB_NeedsUpdate                                     0x01
#define CONST_RB_Sleeping                                        0x02
#define CONST_REP_RBLOCATION_ERROR_TOLERANCE_SQ                  16.0f
#define CONST_TRACEFLAG_ForceController                          16
#define CONST_TRACEFLAG_Blocking                                 8
#define CONST_TRACEFLAG_SkipMovers                               4
#define CONST_TRACEFLAG_PhysicsVolumes                           2
#define CONST_TRACEFLAG_Bullet                                   1
#define CONST_SDPG_NumBits                                       3
#define CONST_PIT_All                                            0x001F
#define CONST_PIT_GameDemo                                       0x0010
#define CONST_PIT_Durable                                        0x0008
#define CONST_PIT_Consumable                                     0x0004
#define CONST_PIT_App                                            0x0002
#define CONST_PIT_Game                                           0x0001
#define CONST_LATENT_MOVETOWARD                                  503
#define CONST_MAX_ACTIVE_CAMERA_ANIMS                            8
#define CONST_MAXCLIENTUPDATEINTERVAL                            0.25
#define CONST_CLIENTADJUSTUPDATECOST                             180.0
#define CONST_MAXVEHICLEPOSITIONERRORSQUARED                     900.0
#define CONST_MAXNEARZEROVELOCITYSQUARED                         9.0
#define CONST_MAXPOSITIONERRORSQUARED                            3.0
#define CONST_BLOCKEDPATHCOST                                    10000000
#define CONST_INFINITE_PATH_COST                                 10000000
#define CONST_GET_SAVE_SLOT_INVALID                              -1
#define CONST_GET_SAVE_SLOT_ERROR                                -2
#define CONST_COMMON_DATA_SAVE_SLOT_INDEX                        -1
#define CONST_SAVE_SYSTEM_VERSION_KEY                            "CloudSaveSystemVersion"
#define CONST_SAVE_DATA_BLOB_NAME_KEY                            "DataBlobName"
#define CONST_DATA_STORE_ID_KEY                                  "DataStoreID"
#define CONST_NUM_SAVE_SLOTS_KEY                                 "NumSaveSlots"
#define CONST_DEFAULT_SIZE_X                                     1024
#define CONST_DEFAULT_SIZE_Y                                     768
#define CONST_MAX_SUPPORTED_GAMEPADS                             24
#define CONST_MaxHistory                                         16
#define CONST_COVERLINK_DangerDist                               1536.f
#define CONST_COVERLINK_EdgeExposureDot                          0.85f
#define CONST_COVERLINK_EdgeCheckDot                             0.25f
#define CONST_COVERLINK_ExposureDot                              0.4f
#define CONST_NULLCHARACTER                                      127
#define CONST_MAX_INSTANCES_PER_CLASS                            5
#define CONST_MAX_BOOKMARK_NUMBER                                10
#define CONST_FSM_DEFAULTRECYCLETIME                             0.2
#define CONST_HeaderFlags_NoEventStrings                         1
#define CONST_GAMEEVENT_MATCH_STARTED                            0
#define CONST_GAMEEVENT_MATCH_ENDED                              1
#define CONST_GAMEEVENT_ROUND_STARTED                            2
#define CONST_GAMEEVENT_ROUND_ENDED                              3
#define CONST_GAMEEVENT_GAME_CLASS                               6
#define CONST_GAMEEVENT_GAME_OPTION_URL                          7
#define CONST_GAMEEVENT_GAME_MAPNAME                             8
#define CONST_GAMEEVENT_MEMORYUSAGE_POLL                         35
#define CONST_GAMEEVENT_FRAMERATE_POLL                           36
#define CONST_GAMEEVENT_NETWORKUSAGEIN_POLL                      37
#define CONST_GAMEEVENT_NETWORKUSAGEOUT_POLL                     38
#define CONST_GAMEEVENT_PING_POLL                                39
#define CONST_GAMEEVENT_RENDERTHREAD_POLL                        40
#define CONST_GAMEEVENT_GAMETHREAD_POLL                          41
#define CONST_GAMEEVENT_GPUFRAMETIME_POLL                        42
#define CONST_GAMEEVENT_FRAMETIME_POLL                           43
#define CONST_GAMEEVENT_TEAM_CREATED                             50
#define CONST_GAMEEVENT_TEAM_GAME_SCORE                          51
#define CONST_GAMEEVENT_TEAM_MATCH_WON                           4
#define CONST_GAMEEVENT_TEAM_ROUND_WON                           5
#define CONST_GAMEEVENT_TEAM_ROUND_STALEMATE                     52
#define CONST_GAMEEVENT_PLAYER_LOGIN                             100
#define CONST_GAMEEVENT_PLAYER_LOGOUT                            101
#define CONST_GAMEEVENT_PLAYER_SPAWN                             102
#define CONST_GAMEEVENT_PLAYER_MATCH_WON                         103
#define CONST_GAMEEVENT_PLAYER_KILL                              104
#define CONST_GAMEEVENT_PLAYER_LOCATION_POLL                     105
#define CONST_GAMEEVENT_PLAYER_TEAMCHANGE                        106
#define CONST_GAMEEVENT_PLAYER_KILL_STREAK                       107
#define CONST_GAMEEVENT_PLAYER_DEATH                             108
#define CONST_GAMEEVENT_PLAYER_ROUND_WON                         109
#define CONST_GAMEEVENT_PLAYER_ROUND_STALEMATE                   110
#define CONST_GAMEEVENT_WEAPON_DAMAGE                            150
#define CONST_GAMEEVENT_WEAPON_DAMAGE_MELEE                      151
#define CONST_GAMEEVENT_WEAPON_FIRED                             152
#define CONST_GAMEEVENT_PLAYER_KILL_NORMAL                       200
#define CONST_GAMEEVENT_GENERIC_PARAM_LIST_START                 300
#define CONST_GAMEEVENT_GENERIC_PARAM_LIST_END                   400
#define CONST_GAMEEVENT_GAME_SPECIFIC                            1000
#define CONST_GAMEEVENT_MAX_EVENTID                              0x0000FFFF
#define CONST_SCENEFILTER_None                                   0x00000000
#define CONST_SCENEFILTER_IncludeTransient                       0x00000001
#define CONST_SCENEFILTER_InputProcessorOnly                     0x00000002
#define CONST_SCENEFILTER_PausersOnly                            0x00000004
#define CONST_SCENEFILTER_PrimitiveUsersOnly                     0x00000008
#define CONST_SCENEFILTER_UsesPostProcessing                     0x00000010
#define CONST_SCENEFILTER_ReceivesFocus                          0x00000020
#define CONST_SCENEFILTER_Any                                    0xFFFFFFFF
#define CONST_MAX_AIGROUP_NUMBER                                 10
#define CONST_LINECHECK_GRANULARITY                              768.f
#define CONST_NUM_PATHFINDING_PARAMS                             9
#define CONST_NumBreadCrumbs                                     10
#define CONST_PROCBUILDING_VERSION                               1
#define CONST_ROOF_MINZ                                          0.7

/*
# ========================================================================================= #
# Enums
# ========================================================================================= #
*/

// Enum Engine.Actor.EActorMetricsType
/*enum EActorMetricsType
{
	METRICS_VERTS                                      = 0,
	METRICS_TRIS                                       = 1,
	METRICS_SECTIONS                                   = 2,
	METRICS_MAX                                        = 3
};*/

// Enum Engine.Actor.EPhysics
/*enum EPhysics
{
	PHYS_None                                          = 0,
	PHYS_Walking                                       = 1,
	PHYS_Falling                                       = 2,
	PHYS_Swimming                                      = 3,
	PHYS_Flying                                        = 4,
	PHYS_Rotating                                      = 5,
	PHYS_Projectile                                    = 6,
	PHYS_Interpolating                                 = 7,
	PHYS_Spider                                        = 8,
	PHYS_Ladder                                        = 9,
	PHYS_RigidBody                                     = 10,
	PHYS_SoftBody                                      = 11,
	PHYS_NavMeshWalking                                = 12,
	PHYS_Unused                                        = 13,
	PHYS_Custom                                        = 14,
	PHYS_MAX                                           = 15
};*/

// Enum Engine.Actor.EMoveDir
/*enum EMoveDir
{
	MD_Stationary                                      = 0,
	MD_Forward                                         = 1,
	MD_Backward                                        = 2,
	MD_Left                                            = 3,
	MD_Right                                           = 4,
	MD_Up                                              = 5,
	MD_Down                                            = 6,
	MD_MAX                                             = 7
};*/

// Enum Engine.Actor.ECollisionType
/*enum ECollisionType
{
	COLLIDE_CustomDefault                              = 0,
	COLLIDE_NoCollision                                = 1,
	COLLIDE_BlockAll                                   = 2,
	COLLIDE_BlockWeapons                               = 3,
	COLLIDE_TouchAll                                   = 4,
	COLLIDE_TouchWeapons                               = 5,
	COLLIDE_BlockAllButWeapons                         = 6,
	COLLIDE_TouchAllButWeapons                         = 7,
	COLLIDE_BlockWeaponsKickable                       = 8,
	COLLIDE_MAX                                        = 9
};*/

// Enum Engine.Actor.ETravelType
/*enum ETravelType
{
	TRAVEL_Absolute                                    = 0,
	TRAVEL_Partial                                     = 1,
	TRAVEL_Relative                                    = 2,
	TRAVEL_MAX                                         = 3
};*/

// Enum Engine.Actor.EDoubleClickDir
/*enum EDoubleClickDir
{
	DCLICK_None                                        = 0,
	DCLICK_Left                                        = 1,
	DCLICK_Right                                       = 2,
	DCLICK_Forward                                     = 3,
	DCLICK_Back                                        = 4,
	DCLICK_Active                                      = 5,
	DCLICK_Done                                        = 6,
	DCLICK_MAX                                         = 7
};*/

// Enum Engine.Actor.EZedTimeType
/*enum EZedTimeType
{
	ZTT_ClientEffect                                   = 0,
	ZTT_Always                                         = 1,
	ZTT_Never                                          = 2,
	ZTT_Manual                                         = 3,
	ZTT_MAX                                            = 4
};*/

// Enum Engine.Actor.ENetRole
/*enum ENetRole
{
	ROLE_None                                          = 0,
	ROLE_SimulatedProxy                                = 1,
	ROLE_AutonomousProxy                               = 2,
	ROLE_Authority                                     = 3,
	ROLE_MAX                                           = 4
};*/

// Enum Engine.PrimitiveComponent.GJKResult
/*enum GJKResult
{
	GJK_Intersect                                      = 0,
	GJK_NoIntersection                                 = 1,
	GJK_Fail                                           = 2,
	GJK_MAX                                            = 3
};*/

// Enum Engine.Scene.EDetailMode
/*enum EDetailMode
{
	DM_Low                                             = 0,
	DM_Medium                                          = 1,
	DM_High                                            = 2,
	DM_MAX                                             = 3
};*/

// Enum Engine.Scene.ESceneDepthPriorityGroup
/*enum ESceneDepthPriorityGroup
{
	SDPG_UnrealEdBackground                            = 0,
	SDPG_World                                         = 1,
	SDPG_Foreground                                    = 2,
	SDPG_UnrealEdForeground                            = 3,
	SDPG_PostProcess                                   = 4,
	SDPG_MAX                                           = 5
};*/

// Enum Engine.PrimitiveComponent.ERBCollisionChannel
/*enum ERBCollisionChannel
{
	RBCC_Default                                       = 0,
	RBCC_Nothing                                       = 1,
	RBCC_Pawn                                          = 2,
	RBCC_Vehicle                                       = 3,
	RBCC_Water                                         = 4,
	RBCC_GameplayPhysics                               = 5,
	RBCC_EffectPhysics                                 = 6,
	RBCC_Untitled1                                     = 7,
	RBCC_Untitled2                                     = 8,
	RBCC_Untitled3                                     = 9,
	RBCC_Untitled4                                     = 10,
	RBCC_Cloth                                         = 11,
	RBCC_FluidDrain                                    = 12,
	RBCC_SoftBody                                      = 13,
	RBCC_FracturedMeshPart                             = 14,
	RBCC_BlockingVolume                                = 15,
	RBCC_DeadPawn                                      = 16,
	RBCC_Clothing                                      = 17,
	RBCC_ClothingCollision                             = 18,
	RBCC_Pickup                                        = 19,
	RBCC_FlexAsset                                     = 20,
	RBCC_CanBecomeDynamic                              = 21,
	RBCC_KnockedDownPawn                               = 22,
	RBCC_Visibility                                    = 23,
	RBCC_MAX                                           = 24
};*/

// Enum Engine.PrimitiveComponent.ERadialImpulseFalloff
/*enum ERadialImpulseFalloff
{
	RIF_Constant                                       = 0,
	RIF_Linear                                         = 1,
	RIF_MAX                                            = 2
};*/

// Enum Engine.Texture.TextureCompressionSettings
/*enum TextureCompressionSettings
{
	TC_Default                                         = 0,
	TC_Normalmap                                       = 1,
	TC_Displacementmap                                 = 2,
	TC_NormalmapAlpha                                  = 3,
	TC_Grayscale                                       = 4,
	TC_HighDynamicRange                                = 5,
	TC_OneBitAlpha                                     = 6,
	TC_NormalmapUncompressed                           = 7,
	TC_NormalmapBC5                                    = 8,
	TC_OneBitMonochrome                                = 9,
	TC_SimpleLightmapModification                      = 10,
	TC_VectorDisplacementmap                           = 11,
	TC_MAX                                             = 12
};*/

// Enum Engine.Texture.EPixelFormat
/*enum EPixelFormat
{
	PF_Unknown                                         = 0,
	PF_A32B32G32R32F                                   = 1,
	PF_A8R8G8B8                                        = 2,
	PF_G8                                              = 3,
	PF_G16                                             = 4,
	PF_DXT1                                            = 5,
	PF_DXT3                                            = 6,
	PF_DXT5                                            = 7,
	PF_UYVY                                            = 8,
	PF_FloatRGB                                        = 9,
	PF_FloatRGBA                                       = 10,
	PF_DepthStencil                                    = 11,
	PF_ShadowDepth                                     = 12,
	PF_FilteredShadowDepth                             = 13,
	PF_R32F                                            = 14,
	PF_G16R16                                          = 15,
	PF_G16R16F                                         = 16,
	PF_G16R16F_FILTER                                  = 17,
	PF_G32R32F                                         = 18,
	PF_A2B10G10R10                                     = 19,
	PF_A16B16G16R16                                    = 20,
	PF_D24                                             = 21,
	PF_R16F                                            = 22,
	PF_R16F_FILTER                                     = 23,
	PF_BC5                                             = 24,
	PF_V8U8                                            = 25,
	PF_A1                                              = 26,
	PF_FloatR11G11B10                                  = 27,
	PF_A4R4G4B4                                        = 28,
	PF_R5G6B5                                          = 29,
	PF_R8G8                                            = 30,
	PF_R32_UINT                                        = 31,
	PF_MAX                                             = 32
};*/

// Enum Engine.Texture.TextureFilter
/*enum TextureFilter
{
	TF_Nearest                                         = 0,
	TF_Linear                                          = 1,
	TF_MAX                                             = 2
};*/

// Enum Engine.Texture.TextureAddress
/*enum TextureAddress
{
	TA_Wrap                                            = 0,
	TA_Clamp                                           = 1,
	TA_Mirror                                          = 2,
	TA_MAX                                             = 3
};*/

// Enum Engine.Texture.TextureGroup
/*enum TextureGroup
{
	TEXTUREGROUP_World                                 = 0,
	TEXTUREGROUP_WorldNormalMap                        = 1,
	TEXTUREGROUP_WorldSpecular                         = 2,
	TEXTUREGROUP_Character                             = 3,
	TEXTUREGROUP_CharacterNormalMap                    = 4,
	TEXTUREGROUP_CharacterSpecular                     = 5,
	TEXTUREGROUP_Weapon                                = 6,
	TEXTUREGROUP_WeaponNormalMap                       = 7,
	TEXTUREGROUP_WeaponSpecular                        = 8,
	TEXTUREGROUP_Vehicle                               = 9,
	TEXTUREGROUP_VehicleNormalMap                      = 10,
	TEXTUREGROUP_VehicleSpecular                       = 11,
	TEXTUREGROUP_Cinematic                             = 12,
	TEXTUREGROUP_Effects                               = 13,
	TEXTUREGROUP_EffectsNotFiltered                    = 14,
	TEXTUREGROUP_Skybox                                = 15,
	TEXTUREGROUP_UI                                    = 16,
	TEXTUREGROUP_Lightmap                              = 17,
	TEXTUREGROUP_RenderTarget                          = 18,
	TEXTUREGROUP_MobileFlattened                       = 19,
	TEXTUREGROUP_ProcBuilding_Face                     = 20,
	TEXTUREGROUP_ProcBuilding_LightMap                 = 21,
	TEXTUREGROUP_Shadowmap                             = 22,
	TEXTUREGROUP_ColorLookupTable                      = 23,
	TEXTUREGROUP_Terrain_Heightmap                     = 24,
	TEXTUREGROUP_Terrain_Weightmap                     = 25,
	TEXTUREGROUP_ImageBasedReflection                  = 26,
	TEXTUREGROUP_Bokeh                                 = 27,
	TEXTUREGROUP_Creature                              = 28,
	TEXTUREGROUP_CreatureNormalMap                     = 29,
	TEXTUREGROUP_CreatureSpecular                      = 30,
	TEXTUREGROUP_Weapon3rd                             = 31,
	TEXTUREGROUP_Weapon3rdNormalMap                    = 32,
	TEXTUREGROUP_Weapon3rdSpecular                     = 33,
	TEXTUREGROUP_Splattermap                           = 34,
	TEXTUREGROUP_Cosmetic                              = 35,
	TEXTUREGROUP_CosmeticNormalMap                     = 36,
	TEXTUREGROUP_CosmeticSpecular                      = 37,
	TEXTUREGROUP_UIWithMips                            = 38,
	TEXTUREGROUP_UIStreamable                          = 39,
	TEXTUREGROUP_MAX                                   = 40
};*/

// Enum Engine.Texture.TextureMipGenSettings
/*enum TextureMipGenSettings
{
	TMGS_FromTextureGroup                              = 0,
	TMGS_SimpleAverage                                 = 1,
	TMGS_Sharpen0                                      = 2,
	TMGS_Sharpen1                                      = 3,
	TMGS_Sharpen2                                      = 4,
	TMGS_Sharpen3                                      = 5,
	TMGS_Sharpen4                                      = 6,
	TMGS_Sharpen5                                      = 7,
	TMGS_Sharpen6                                      = 8,
	TMGS_Sharpen7                                      = 9,
	TMGS_Sharpen8                                      = 10,
	TMGS_Sharpen9                                      = 11,
	TMGS_Sharpen10                                     = 12,
	TMGS_NoMipmaps                                     = 13,
	TMGS_LeaveExistingMips                             = 14,
	TMGS_Blur1                                         = 15,
	TMGS_Blur2                                         = 16,
	TMGS_Blur3                                         = 17,
	TMGS_Blur4                                         = 18,
	TMGS_Blur5                                         = 19,
	TMGS_MAX                                           = 20
};*/

// Enum Engine.Texture.ETextureMipCount
/*enum ETextureMipCount
{
	TMC_ResidentMips                                   = 0,
	TMC_AllMips                                        = 1,
	TMC_AllMipsBiased                                  = 2,
	TMC_MAX                                            = 3
};*/

// Enum Engine.OnlineSubsystem.EPartyNotificationStatus
/*enum EPartyNotificationStatus
{
	PNS_NonExistent                                    = 0,
	PNS_Creating                                       = 1,
	PNS_Created                                        = 2,
	PNS_Complete                                       = 3,
	PNS_Dissolving                                     = 4,
	PNS_Dissolved                                      = 5,
	PNS_MAX                                            = 6
};*/

// Enum Engine.OnlineSubsystem.ENATType
/*enum ENATType
{
	NAT_Unknown                                        = 0,
	NAT_Open                                           = 1,
	NAT_Moderate                                       = 2,
	NAT_Strict                                         = 3,
	NAT_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EOnlineServerConnectionStatus
/*enum EOnlineServerConnectionStatus
{
	OSCS_NotConnected                                  = 0,
	OSCS_Connected                                     = 1,
	OSCS_ConnectionDropped                             = 2,
	OSCS_NoNetworkConnection                           = 3,
	OSCS_ServiceUnavailable                            = 4,
	OSCS_UpdateRequired                                = 5,
	OSCS_ServersTooBusy                                = 6,
	OSCS_DuplicateLoginDetected                        = 7,
	OSCS_InvalidUser                                   = 8,
	OSCS_Banned                                        = 9,
	OSCS_TooYoung                                      = 10,
	OSCS_PSNUnavailable                                = 11,
	OSCS_XBLiveUnavailable                             = 12,
	OSCS_MAX                                           = 13
};*/

// Enum Engine.OnlineSubsystem.ELoginStatus
/*enum ELoginStatus
{
	LS_NotLoggedIn                                     = 0,
	LS_UsingLocalProfile                               = 1,
	LS_LoggedIn                                        = 2,
	LS_MAX                                             = 3
};*/

// Enum Engine.OnlineSubsystem.ItemType
/*enum ItemType
{
	ITP_WeaponSkin                                     = 0,
	ITP_CharacterSkin                                  = 1,
	ITP_KeyCrate                                       = 2,
	ITP_Item                                           = 3,
	ITP_CraftingComponent                              = 4,
	ITP_Emote                                          = 5,
	ITP_SFX                                            = 6,
	ITP_NONE                                           = 7,
	ITP_MAX                                            = 8
};*/

// Enum Engine.OnlineSubsystem.ItemRarity
/*enum ItemRarity
{
	ITR_Common                                         = 0,
	ITR_Uncommon                                       = 1,
	ITR_Rare                                           = 2,
	ITR_Mythical                                       = 3,
	ITR_Legendary                                      = 4,
	ITR_ExceedinglyRare                                = 5,
	ITR_NONE                                           = 6,
	ITR_MAX                                            = 7
};*/

// Enum Engine.OnlineSubsystem.ESessionMemberStatus
/*enum ESessionMemberStatus
{
	DSMS_Reserved                                      = 0,
	DSMS_Inactive                                      = 1,
	DSMS_Ready                                         = 2,
	DSMS_Active                                        = 3,
	DSMS_MAX                                           = 4
};*/

// Enum Engine.OnlineSubsystem.EOnlineNewsType
/*enum EOnlineNewsType
{
	ONT_Unknown                                        = 0,
	ONT_GameNews                                       = 1,
	ONT_ContentAnnouncements                           = 2,
	ONT_Misc                                           = 3,
	ONT_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EInventoryItemState
/*enum EInventoryItemState
{
	IIS_Unknown                                        = 0,
	IIS_All                                            = 1,
	IIS_Enabled                                        = 2,
	IIS_Suspended                                      = 3,
	IIS_Expired                                        = 4,
	IIS_Canceled                                       = 5,
	IIS_MAX                                            = 6
};*/

// Enum Engine.OnlineSubsystem.EMediaItemType
/*enum EMediaItemType
{
	MIT_Unknown                                        = 0,
	MIT_Game                                           = 1,
	MIT_Application                                    = 2,
	MIT_GameContent                                    = 3,
	MIT_GameConsumable                                 = 4,
	MIT_Subscription                                   = 5,
	MIT_All                                            = 6,
	MIT_MAX                                            = 7
};*/

// Enum Engine.OnlineSubsystem.EOnlineEnumerationReadState
/*enum EOnlineEnumerationReadState
{
	OERS_NotStarted                                    = 0,
	OERS_InProgress                                    = 1,
	OERS_Done                                          = 2,
	OERS_Failed                                        = 3,
	OERS_MAX                                           = 4
};*/

// Enum Engine.OnlineSubsystem.EOnlineGameState
/*enum EOnlineGameState
{
	OGS_NoSession                                      = 0,
	OGS_Pending                                        = 1,
	OGS_Starting                                       = 2,
	OGS_InProgress                                     = 3,
	OGS_Ending                                         = 4,
	OGS_Ended                                          = 5,
	OGS_MAX                                            = 6
};*/

// Enum Engine.OnlineSubsystem.ECatalogSortOrder
/*enum ECatalogSortOrder
{
	CSO_FreeAndPaidCountDaily                          = 0,
	CSO_PaidCountAllTime                               = 1,
	CSO_PaidCountDail                                  = 2,
	CSO_DigitalReleaseDate                             = 3,
	CSO_ReleaseDate                                    = 4,
	CSO_UserRatings                                    = 5,
	CSO_MAX                                            = 6
};*/

// Enum Engine.OnlineSubsystem.EAchievementUnlockType
/*enum EAchievementUnlockType
{
	AUT_Unknown                                        = 0,
	AUT_All                                            = 1,
	AUT_Persistent                                     = 2,
	AUT_Challenge                                      = 3,
	AUT_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EAchievementMediaAssetType
/*enum EAchievementMediaAssetType
{
	AMAT_Unknown                                       = 0,
	AMAT_Icon                                          = 1,
	AMAT_Art                                           = 2,
	AMAT_MAX                                           = 3
};*/

// Enum Engine.OnlineSubsystem.EAchievementParticipationType
/*enum EAchievementParticipationType
{
	EAPT_Unknown                                       = 0,
	EAPT_Individual                                    = 1,
	EAPT_Group                                         = 2,
	EAPT_MAX                                           = 3
};*/

// Enum Engine.OnlineSubsystem.EAchievementProgressState
/*enum EAchievementProgressState
{
	APS_Unknown                                        = 0,
	APS_Achieved                                       = 1,
	APS_NotStarted                                     = 2,
	APS_InProgress                                     = 3,
	APS_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EAchievementRewardType
/*enum EAchievementRewardType
{
	ART_Unknown                                        = 0,
	ART_Gamerscore                                     = 1,
	ART_InApp                                          = 2,
	ART_Art                                            = 3,
	ART_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EOnlineFileType
/*enum EOnlineFileType
{
	OFT_Unknown                                        = 0,
	OFT_Binary                                         = 1,
	OFT_Json                                           = 2,
	OFT_MAX                                            = 3
};*/

// Enum Engine.OnlineSubsystem.EOnlineAccountCreateStatus
/*enum EOnlineAccountCreateStatus
{
	OACS_CreateSuccessful                              = 0,
	OACS_UnknownError                                  = 1,
	OACS_InvalidUserName                               = 2,
	OACS_InvalidPassword                               = 3,
	OACS_InvalidUniqueUserName                         = 4,
	OACS_UniqueUserNameInUse                           = 5,
	OACS_ServiceUnavailable                            = 6,
	OACS_MAX                                           = 7
};*/

// Enum Engine.OnlineSubsystem.ELanBeaconState
/*enum ELanBeaconState
{
	LANB_NotUsingLanBeacon                             = 0,
	LANB_Hosting                                       = 1,
	LANB_Searching                                     = 2,
	LANB_MAX                                           = 3
};*/

// Enum Engine.OnlineSubsystem.EOnlineContentType
/*enum EOnlineContentType
{
	OCT_Downloaded                                     = 0,
	OCT_SaveGame                                       = 1,
	OCT_MAX                                            = 2
};*/

// Enum Engine.OnlineSubsystem.EFreeTrialNotification
/*enum EFreeTrialNotification
{
	FTN_FeatureUnavailable                             = 0,
	FTN_NetworkCheckFailed                             = 1,
	FTN_BuyGame                                        = 2,
	FTN_MAX                                            = 3
};*/

// Enum Engine.OnlineSubsystem.EOnlineFriendState
/*enum EOnlineFriendState
{
	OFS_Offline                                        = 0,
	OFS_Online                                         = 1,
	OFS_Away                                           = 2,
	OFS_Busy                                           = 3,
	OFS_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EOnlineCreateGameSessionFlag
/*enum EOnlineCreateGameSessionFlag
{
	OCGSF_New                                          = 0,
	OCGSF_ReSubmit                                     = 1,
	OCGSF_MAX                                          = 2
};*/

// Enum Engine.OnlineSubsystem.EOnlineAccountTier
/*enum EOnlineAccountTier
{
	OAT_Unknown                                        = 0,
	OAT_NewUser                                        = 1,
	OAT_Silver                                         = 2,
	OAT_Gold                                           = 3,
	OAT_FamilyGold                                     = 4,
	OAT_MAX                                            = 5
};*/

// Enum Engine.OnlineSubsystem.OnGameInviteAcceptedResult
/*enum OnGameInviteAcceptedResult
{
	OGIAR_Success                                      = 0,
	OGIAR_GeneralFailure                               = 1,
	OGIAR_ServerActivity                               = 2,
	OGIAR_WrongAccount                                 = 3,
	OGIAR_MAX                                          = 4
};*/

// Enum Engine.OnlineSubsystem.ENetworkNotificationPosition
/*enum ENetworkNotificationPosition
{
	NNP_TopLeft                                        = 0,
	NNP_TopCenter                                      = 1,
	NNP_TopRight                                       = 2,
	NNP_CenterLeft                                     = 3,
	NNP_Center                                         = 4,
	NNP_CenterRight                                    = 5,
	NNP_BottomLeft                                     = 6,
	NNP_BottomCenter                                   = 7,
	NNP_BottomRight                                    = 8,
	NNP_MAX                                            = 9
};*/

// Enum Engine.OnlineSubsystem.EReputationFeedbackType
/*enum EReputationFeedbackType
{
	RFBT_CommunicationsAbusiveVoice                    = 0,
	RFBT_CommunicationsInappropriateVideo              = 1,
	RFBT_FairPlayCheater                               = 2,
	RFBT_FairPlayKicked                                = 3,
	RFBT_FairPlayKillsTeammates                        = 4,
	RFBT_FairPlayQuitter                               = 5,
	RFBT_FairPlayTampering                             = 6,
	RFBT_InappropriateUserGeneratedContent             = 7,
	RFBT_PositiveHelpfulPlayer                         = 8,
	RFBT_PositiveHighQualityUserGeneratedContent       = 9,
	RFBT_PositiveSkilledPlayer                         = 10,
	RFBT_MAX                                           = 11
};*/

// Enum Engine.OnlineSubsystem.EFeaturePrivilegeLevel
/*enum EFeaturePrivilegeLevel
{
	FPL_Disabled                                       = 0,
	FPL_EnabledFriendsOnly                             = 1,
	FPL_Enabled                                        = 2,
	FPL_Unknown                                        = 3,
	FPL_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EFeaturePrivilege
/*enum EFeaturePrivilege
{
	FP_OnlinePlay                                      = 0,
	FP_CommunicationText                               = 1,
	FP_CommunicationVideo                              = 2,
	FP_CommunicationVoice                              = 3,
	FP_ShareUserCreatedContent                         = 4,
	FP_PurchaseContent                                 = 5,
	FP_ViewPlayerProfile                               = 6,
	FP_ShowPresenceInformation                         = 7,
	FP_RecordDVRClips                                  = 8,
	FP_CloudStorage                                    = 9,
	FP_PremiumContent                                  = 10,
	FP_PremiumVideoContent                             = 11,
	FP_BrowseInternet                                  = 12,
	FP_SocialNetworkSharing                            = 13,
	FP_KinectSharing                                   = 14,
	FP_FitnessUpload                                   = 15,
	FP_MAX                                             = 16
};*/

// Enum Engine.OnlineAuthInterface.EAuthStatus
/*enum EAuthStatus
{
	AUS_NotStarted                                     = 0,
	AUS_Pending                                        = 1,
	AUS_Authenticated                                  = 2,
	AUS_Failed                                         = 3,
	AUS_MAX                                            = 4
};*/

// Enum Engine.Camera.EViewTargetBlendFunction
/*enum EViewTargetBlendFunction
{
	VTBlend_Linear                                     = 0,
	VTBlend_Cubic                                      = 1,
	VTBlend_EaseIn                                     = 2,
	VTBlend_EaseOut                                    = 3,
	VTBlend_EaseInOut                                  = 4,
	VTBlend_MAX                                        = 5
};*/

// Enum Engine.DOFEffect.EFocusType
/*enum EFocusType
{
	FOCUS_Distance                                     = 0,
	FOCUS_Position                                     = 1,
	FOCUS_MAX                                          = 2
};*/

// Enum Engine.Camera.ECameraAnimPlaySpace
/*enum ECameraAnimPlaySpace
{
	CAPS_CameraLocal                                   = 0,
	CAPS_World                                         = 1,
	CAPS_UserDefined                                   = 2,
	CAPS_MAX                                           = 3
};*/

// Enum Engine.SeqAct_ControlMovieTexture.EMovieControlType
/*enum EMovieControlType
{
	MCT_Play                                           = 0,
	MCT_Stop                                           = 1,
	MCT_Pause                                          = 2,
	MCT_MAX                                            = 3
};*/

// Enum Engine.Settings.EPropertyValueMappingType
/*enum EPropertyValueMappingType
{
	PVMT_RawValue                                      = 0,
	PVMT_PredefinedValues                              = 1,
	PVMT_Ranged                                        = 2,
	PVMT_IdMapped                                      = 3,
	PVMT_MAX                                           = 4
};*/

// Enum Engine.Settings.ESettingsDataType
/*enum ESettingsDataType
{
	SDT_Empty                                          = 0,
	SDT_Int32                                          = 1,
	SDT_Int64                                          = 2,
	SDT_Double                                         = 3,
	SDT_String                                         = 4,
	SDT_Float                                          = 5,
	SDT_Blob                                           = 6,
	SDT_DateTime                                       = 7,
	SDT_UInt32                                         = 8,
	SDT_UInt64                                         = 9,
	SDT_MAX                                            = 10
};*/

// Enum Engine.Settings.EOnlineDataAdvertisementType
/*enum EOnlineDataAdvertisementType
{
	ODAT_DontAdvertise                                 = 0,
	ODAT_OnlineService                                 = 1,
	ODAT_QoS                                           = 2,
	ODAT_OnlineServiceAndQoS                           = 3,
	ODAT_MAX                                           = 4
};*/

// Enum Engine.OnlineGameSearch.EOnlineGameSearchComparisonType
/*enum EOnlineGameSearchComparisonType
{
	OGSCT_Equals                                       = 0,
	OGSCT_NotEquals                                    = 1,
	OGSCT_GreaterThan                                  = 2,
	OGSCT_GreaterThanEquals                            = 3,
	OGSCT_LessThan                                     = 4,
	OGSCT_LessThanEquals                               = 5,
	OGSCT_MAX                                          = 6
};*/

// Enum Engine.OnlineGameSearch.EOnlineGameSearchEntryType
/*enum EOnlineGameSearchEntryType
{
	OGSET_Property                                     = 0,
	OGSET_LocalizedSetting                             = 1,
	OGSET_ObjectProperty                               = 2,
	OGSET_MAX                                          = 3
};*/

// Enum Engine.OnlineGameSearch.EOnlineGameSearchSortType
/*enum EOnlineGameSearchSortType
{
	OGSSO_Ascending                                    = 0,
	OGSSO_Descending                                   = 1,
	OGSSO_MAX                                          = 2
};*/

// Enum Engine.PlayerController.EProgressMessageType
/*enum EProgressMessageType
{
	PMT_Clear                                          = 0,
	PMT_Information                                    = 1,
	PMT_AdminMessage                                   = 2,
	PMT_DownloadProgress                               = 3,
	PMT_ConnectionFailure                              = 4,
	PMT_PeerConnectionFailure                          = 5,
	PMT_PeerHostMigrationFailure                       = 6,
	PMT_SocketFailure                                  = 7,
	PMT_MAX                                            = 8
};*/

// Enum Engine.SkeletalMeshComponent.EPhysBodyOp
/*enum EPhysBodyOp
{
	PBO_None                                           = 0,
	PBO_Term                                           = 1,
	PBO_Disable                                        = 2,
	PBO_MAX                                            = 3
};*/

// Enum Engine.SkeletalMeshComponent.EFaceFXRegOp
/*enum EFaceFXRegOp
{
	FXRO_Add                                           = 0,
	FXRO_Multiply                                      = 1,
	FXRO_Replace                                       = 2,
	FXRO_MAX                                           = 3
};*/

// Enum Engine.SkeletalMeshComponent.EBoneVisibilityStatus
/*enum EBoneVisibilityStatus
{
	BVS_HiddenByParent                                 = 0,
	BVS_Visible                                        = 1,
	BVS_ExplicitlyHidden                               = 2,
	BVS_MAX                                            = 3
};*/

// Enum Engine.SkeletalMeshComponent.EFaceFXBlendMode
/*enum EFaceFXBlendMode
{
	FXBM_Overwrite                                     = 0,
	FXBM_Additive                                      = 1,
	FXBM_MAX                                           = 2
};*/

// Enum Engine.SkeletalMeshComponent.EInstanceWeightUsage
/*enum EInstanceWeightUsage
{
	IWU_PartialSwap                                    = 0,
	IWU_FullSwap                                       = 1,
	IWU_MAX                                            = 2
};*/

// Enum Engine.SkeletalMeshComponent.EAnimRotationOnly
/*enum EAnimRotationOnly
{
	EARO_AnimSet                                       = 0,
	EARO_ForceEnabled                                  = 1,
	EARO_ForceDisabled                                 = 2,
	EARO_MAX                                           = 3
};*/

// Enum Engine.SkeletalMeshComponent.ERootMotionRotationMode
/*enum ERootMotionRotationMode
{
	RMRM_Ignore                                        = 0,
	RMRM_RotateActor                                   = 1,
	RMRM_MAX                                           = 2
};*/

// Enum Engine.SkeletalMeshComponent.ERootMotionMode
/*enum ERootMotionMode
{
	RMM_Translate                                      = 0,
	RMM_Velocity                                       = 1,
	RMM_Ignore                                         = 2,
	RMM_Accel                                          = 3,
	RMM_Relative                                       = 4,
	RMM_MAX                                            = 5
};*/

// Enum Engine.SkeletalMeshComponent.EMaxDistanceScaleMode
/*enum EMaxDistanceScaleMode
{
	MDSM_Multiply                                      = 0,
	MDSM_Substract                                     = 1,
	MDSM_MAX                                           = 2
};*/

// Enum Engine.PlayerController.EInputMatchAction
/*enum EInputMatchAction
{
	IMA_GreaterThan                                    = 0,
	IMA_LessThan                                       = 1,
	IMA_MAX                                            = 2
};*/

// Enum Engine.PlayerController.EInputTypes
/*enum EInputTypes
{
	IT_XAxis                                           = 0,
	IT_YAxis                                           = 1,
	IT_MAX                                             = 2
};*/

// Enum Engine.Pylon.ENavMeshEdgeType
/*enum ENavMeshEdgeType
{
	NAVEDGE_UnknownType                                = 0,
	NAVEDGE_Normal                                     = 1,
	NAVEDGE_Mantle                                     = 2,
	NAVEDGE_Coverslip                                  = 3,
	NAVEDGE_SwatTurn                                   = 4,
	NAVEDGE_DropDown                                   = 5,
	NAVEDGE_PathObject                                 = 6,
	NAVEDGE_BackRefDummy                               = 7,
	NAVEDGE_Jump                                       = 8,
	NAVEDGE_CrossPylon                                 = 9,
	NAVEDGE_OneWayEdge                                 = 10,
	NAVEDGE_MAX                                        = 11
};*/

// Enum Engine.PlatformInterfaceBase.EPlatformInterfaceDataType
/*enum EPlatformInterfaceDataType
{
	PIDT_None                                          = 0,
	PIDT_Int                                           = 1,
	PIDT_Float                                         = 2,
	PIDT_String                                        = 3,
	PIDT_Object                                        = 4,
	PIDT_Custom                                        = 5,
	PIDT_MAX                                           = 6
};*/

// Enum Engine.AmbientOcclusionEffect.EAmbientOcclusionQuality
/*enum EAmbientOcclusionQuality
{
	AO_High                                            = 0,
	AO_Medium                                          = 1,
	AO_Low                                             = 2,
	AO_MAX                                             = 3
};*/

// Enum Engine.AmbientOcclusionEffect.EHBAOBlurRadius
/*enum EHBAOBlurRadius
{
	HBAO_BLUR_RADIUS                                   = 0,
	HBAO_BLUR_RADIUS01                                 = 1,
	HBAO_BLUR_RADIUS02                                 = 2,
	HBAO_BLUR_RADIUS_MAX                               = 3
};*/

// Enum Engine.Brush.ECsgOper
/*enum ECsgOper
{
	CSG_Active                                         = 0,
	CSG_Add                                            = 1,
	CSG_Subtract                                       = 2,
	CSG_Intersect                                      = 3,
	CSG_Deintersect                                    = 4,
	CSG_MAX                                            = 5
};*/

// Enum Engine.ReverbVolume.ReverbPreset
/*enum ReverbPreset
{
	REVERB_Default                                     = 0,
	REVERB_Bathroom                                    = 1,
	REVERB_StoneRoom                                   = 2,
	REVERB_Auditorium                                  = 3,
	REVERB_ConcertHall                                 = 4,
	REVERB_Cave                                        = 5,
	REVERB_Hallway                                     = 6,
	REVERB_StoneCorridor                               = 7,
	REVERB_Alley                                       = 8,
	REVERB_Forest                                      = 9,
	REVERB_City                                        = 10,
	REVERB_Mountains                                   = 11,
	REVERB_Quarry                                      = 12,
	REVERB_Plain                                       = 13,
	REVERB_ParkingLot                                  = 14,
	REVERB_SewerPipe                                   = 15,
	REVERB_Underwater                                  = 16,
	REVERB_SmallRoom                                   = 17,
	REVERB_MediumRoom                                  = 18,
	REVERB_LargeRoom                                   = 19,
	REVERB_MediumHall                                  = 20,
	REVERB_LargeHall                                   = 21,
	REVERB_Plate                                       = 22,
	REVERB_MAX                                         = 23
};*/

// Enum Engine.EngineTypes.EPathFindingError
/*enum EPathFindingError
{
	PATHERROR_STARTPOLYNOTFOUND                        = 0,
	PATHERROR_GOALPOLYNOTFOUND                         = 1,
	PATHERROR_ANCHORPYLONNOTFOUND                      = 2,
	PATHERROR_NOPATHFOUND                              = 3,
	PATHERROR_COMPUTEVALIDFINALDEST_FAIL               = 4,
	PATHERROR_GETNEXTMOVELOCATION_FAIL                 = 5,
	PATHERROR_MOVETIMEOUT                              = 6,
	PATHERROR_MAX                                      = 7
};*/

// Enum Engine.AudioDevice.EDebugState
/*enum EDebugState
{
	DEBUGSTATE_None                                    = 0,
	DEBUGSTATE_IsolateDryAudio                         = 1,
	DEBUGSTATE_IsolateReverb                           = 2,
	DEBUGSTATE_TestLPF                                 = 3,
	DEBUGSTATE_TestStereoBleed                         = 4,
	DEBUGSTATE_TestLFEBleed                            = 5,
	DEBUGSTATE_DisableLPF                              = 6,
	DEBUGSTATE_DisableRadio                            = 7,
	DEBUGSTATE_MAX                                     = 8
};*/

// Enum Engine.AudioDevice.ETTSSpeaker
/*enum ETTSSpeaker
{
	TTSSPEAKER_Paul                                    = 0,
	TTSSPEAKER_Harry                                   = 1,
	TTSSPEAKER_Frank                                   = 2,
	TTSSPEAKER_Dennis                                  = 3,
	TTSSPEAKER_Kit                                     = 4,
	TTSSPEAKER_Betty                                   = 5,
	TTSSPEAKER_Ursula                                  = 6,
	TTSSPEAKER_Rita                                    = 7,
	TTSSPEAKER_Wendy                                   = 8,
	TTSSPEAKER_MAX                                     = 9
};*/

// Enum Engine.AudioDevice.ESoundClassName
/*enum ESoundClassName
{
	Ambient                                            = 0,
	Exceptions                                         = 1,
	Master                                             = 2,
	Music                                              = 3,
	SFX                                                = 4,
	Voice                                              = 5,
	Weapons                                            = 6,
	ESoundClassName_MAX                                = 7
};*/

// Enum Engine.SoundNodeAttenuation.ESoundDistanceCalc
/*enum ESoundDistanceCalc
{
	SOUNDDISTANCE_Normal                               = 0,
	SOUNDDISTANCE_InfiniteXYPlane                      = 1,
	SOUNDDISTANCE_InfiniteXZPlane                      = 2,
	SOUNDDISTANCE_InfiniteYZPlane                      = 3,
	SOUNDDISTANCE_MAX                                  = 4
};*/

// Enum Engine.SoundNodeAttenuation.SoundDistanceModel
/*enum SoundDistanceModel
{
	ATTENUATION_Linear                                 = 0,
	ATTENUATION_Logarithmic                            = 1,
	ATTENUATION_Inverse                                = 2,
	ATTENUATION_LogReverse                             = 3,
	ATTENUATION_NaturalSound                           = 4,
	ATTENUATION_MAX                                    = 5
};*/

// Enum Engine.AnimSequence.AnimationKeyFormat
/*enum AnimationKeyFormat
{
	AKF_ConstantKeyLerp                                = 0,
	AKF_VariableKeyLerp                                = 1,
	AKF_PerTrackCompression                            = 2,
	AKF_MAX                                            = 3
};*/

// Enum Engine.AnimSequence.AnimationCompressionFormat
/*enum AnimationCompressionFormat
{
	ACF_None                                           = 0,
	ACF_Float96NoW                                     = 1,
	ACF_Fixed48NoW                                     = 2,
	ACF_IntervalFixed32NoW                             = 3,
	ACF_Fixed32NoW                                     = 4,
	ACF_Float32NoW                                     = 5,
	ACF_Identity                                       = 6,
	ACF_MAX                                            = 7
};*/

// Enum Engine.AnimNode.ESliderType
/*enum ESliderType
{
	ST_1D                                              = 0,
	ST_2D                                              = 1,
	ST_MAX                                             = 2
};*/

// Enum Engine.AnimNode_MultiBlendPerBone.EWeightCheck
/*enum EWeightCheck
{
	EWC_AnimNodeSlotNotPlaying                         = 0,
	EWC_MAX                                            = 1
};*/

// Enum Engine.AnimNode_MultiBlendPerBone.EBlendType
/*enum EBlendType
{
	EBT_ParentBoneSpace                                = 0,
	EBT_MeshSpace                                      = 1,
	EBT_MAX                                            = 2
};*/

// Enum Engine.AnimNodeAimOffset.EAnimAimDir
/*enum EAnimAimDir
{
	ANIMAIM_LEFTUP                                     = 0,
	ANIMAIM_CENTERUP                                   = 1,
	ANIMAIM_RIGHTUP                                    = 2,
	ANIMAIM_LEFTCENTER                                 = 3,
	ANIMAIM_CENTERCENTER                               = 4,
	ANIMAIM_RIGHTCENTER                                = 5,
	ANIMAIM_LEFTDOWN                                   = 6,
	ANIMAIM_CENTERDOWN                                 = 7,
	ANIMAIM_RIGHTDOWN                                  = 8,
	ANIMAIM_MAX                                        = 9
};*/

// Enum Engine.AnimNodeAimOffset.EAimID
/*enum EAimID
{
	EAID_LeftUp                                        = 0,
	EAID_LeftDown                                      = 1,
	EAID_RightUp                                       = 2,
	EAID_RightDown                                     = 3,
	EAID_ZeroUp                                        = 4,
	EAID_ZeroDown                                      = 5,
	EAID_ZeroLeft                                      = 6,
	EAID_ZeroRight                                     = 7,
	EAID_CellLU                                        = 8,
	EAID_CellCU                                        = 9,
	EAID_CellRU                                        = 10,
	EAID_CellLC                                        = 11,
	EAID_CellCC                                        = 12,
	EAID_CellRC                                        = 13,
	EAID_CellLD                                        = 14,
	EAID_CellCD                                        = 15,
	EAID_CellRD                                        = 16,
	EAID_MAX                                           = 17
};*/

// Enum Engine.AnimNodeBlendByBase.EBaseBlendType
/*enum EBaseBlendType
{
	BBT_ByActorTag                                     = 0,
	BBT_ByActorClass                                   = 1,
	BBT_MAX                                            = 2
};*/

// Enum Engine.AnimNodeSequence.ERootRotationOption
/*enum ERootRotationOption
{
	RRO_Default                                        = 0,
	RRO_Discard                                        = 1,
	RRO_Extract                                        = 2,
	RRO_MAX                                            = 3
};*/

// Enum Engine.AnimNodeSequence.ERootBoneAxis
/*enum ERootBoneAxis
{
	RBA_Default                                        = 0,
	RBA_Discard                                        = 1,
	RBA_Translate                                      = 2,
	RBA_MAX                                            = 3
};*/

// Enum Engine.EngineTypes.EBlendMode
/*enum EBlendMode
{
	BLEND_Opaque                                       = 0,
	BLEND_Masked                                       = 1,
	BLEND_Translucent                                  = 2,
	BLEND_Additive                                     = 3,
	BLEND_Modulate                                     = 4,
	BLEND_ModulateAndAdd                               = 5,
	BLEND_SoftMasked                                   = 6,
	BLEND_AlphaComposite                               = 7,
	BLEND_DitheredTranslucent                          = 8,
	BLEND_MAX                                          = 9
};*/

// Enum Engine.EngineTypes.EMaterialLightingModel
/*enum EMaterialLightingModel
{
	MLM_Phong                                          = 0,
	MLM_NonDirectional                                 = 1,
	MLM_Unlit                                          = 2,
	MLM_SHPRT                                          = 3,
	MLM_Custom                                         = 4,
	MLM_Anisotropic                                    = 5,
	MLM_MAX                                            = 6
};*/

// Enum Engine.EngineTypes.EMaterialTessellationMode
/*enum EMaterialTessellationMode
{
	MTM_NoTessellation                                 = 0,
	MTM_FlatTessellation                               = 1,
	MTM_PNTriangles                                    = 2,
	MTM_MAX                                            = 3
};*/

// Enum Engine.EngineTypes.EMobileValueSource
/*enum EMobileValueSource
{
	MVS_Constant                                       = 0,
	MVS_VertexColorRed                                 = 1,
	MVS_VertexColorGreen                               = 2,
	MVS_VertexColorBlue                                = 3,
	MVS_VertexColorAlpha                               = 4,
	MVS_BaseTextureRed                                 = 5,
	MVS_BaseTextureGreen                               = 6,
	MVS_BaseTextureBlue                                = 7,
	MVS_BaseTextureAlpha                               = 8,
	MVS_MaskTextureRed                                 = 9,
	MVS_MaskTextureGreen                               = 10,
	MVS_MaskTextureBlue                                = 11,
	MVS_MaskTextureAlpha                               = 12,
	MVS_NormalTextureAlpha                             = 13,
	MVS_EmissiveTextureRed                             = 14,
	MVS_EmissiveTextureGreen                           = 15,
	MVS_EmissiveTextureBlue                            = 16,
	MVS_EmissiveTextureAlpha                           = 17,
	MVS_MAX                                            = 18
};*/

// Enum Engine.EngineTypes.EMobileTextureBlendFactorSource
/*enum EMobileTextureBlendFactorSource
{
	MTBFS_VertexColor                                  = 0,
	MTBFS_MaskTexture                                  = 1,
	MTBFS_MAX                                          = 2
};*/

// Enum Engine.EngineTypes.EMobileTexCoordsSource
/*enum EMobileTexCoordsSource
{
	MTCS_TexCoords0                                    = 0,
	MTCS_TexCoords1                                    = 1,
	MTCS_TexCoords2                                    = 2,
	MTCS_TexCoords3                                    = 3,
	MTCS_MAX                                           = 4
};*/

// Enum Engine.EngineTypes.EMobileAlphaValueSource
/*enum EMobileAlphaValueSource
{
	MAVS_DiffuseTextureAlpha                           = 0,
	MAVS_MaskTextureRed                                = 1,
	MAVS_MaskTextureGreen                              = 2,
	MAVS_MaskTextureBlue                               = 3,
	MAVS_MAX                                           = 4
};*/

// Enum Engine.EngineTypes.EMobileColorMultiplySource
/*enum EMobileColorMultiplySource
{
	MCMS_None                                          = 0,
	MCMS_BaseTextureRed                                = 1,
	MCMS_BaseTextureGreen                              = 2,
	MCMS_BaseTextureBlue                               = 3,
	MCMS_BaseTextureAlpha                              = 4,
	MCMS_MaskTextureRed                                = 5,
	MCMS_MaskTextureGreen                              = 6,
	MCMS_MaskTextureBlue                               = 7,
	MCMS_MaskTextureAlpha                              = 8,
	MCMS_MAX                                           = 9
};*/

// Enum Engine.EngineTypes.EMobileEmissiveColorSource
/*enum EMobileEmissiveColorSource
{
	MECS_EmissiveTexture                               = 0,
	MECS_BaseTexture                                   = 1,
	MECS_Constant                                      = 2,
	MECS_MAX                                           = 3
};*/

// Enum Engine.EngineTypes.EMobileEnvironmentBlendMode
/*enum EMobileEnvironmentBlendMode
{
	MEBM_Add                                           = 0,
	MEBM_Lerp                                          = 1,
	MEBM_MAX                                           = 2
};*/

// Enum Engine.EngineTypes.EMobileSpecularMask
/*enum EMobileSpecularMask
{
	MSM_Constant                                       = 0,
	MSM_Luminance                                      = 1,
	MSM_DiffuseRed                                     = 2,
	MSM_DiffuseGreen                                   = 3,
	MSM_DiffuseBlue                                    = 4,
	MSM_DiffuseAlpha                                   = 5,
	MSM_MaskTextureRGB                                 = 6,
	MSM_MaskTextureRed                                 = 7,
	MSM_MaskTextureGreen                               = 8,
	MSM_MaskTextureBlue                                = 9,
	MSM_MaskTextureAlpha                               = 10,
	MSM_MAX                                            = 11
};*/

// Enum Engine.EngineTypes.EMobileAmbientOcclusionSource
/*enum EMobileAmbientOcclusionSource
{
	MAOS_Disabled                                      = 0,
	MAOS_VertexColorRed                                = 1,
	MAOS_VertexColorGreen                              = 2,
	MAOS_VertexColorBlue                               = 3,
	MAOS_VertexColorAlpha                              = 4,
	MAOS_MAX                                           = 5
};*/

// Enum Engine.EngineTypes.ELightingBuildQuality
/*enum ELightingBuildQuality
{
	Quality_Preview                                    = 0,
	Quality_Medium                                     = 1,
	Quality_High                                       = 2,
	Quality_Production                                 = 3,
	Quality_NoGlobalIllumination                       = 4,
	Quality_MAX                                        = 5
};*/

// Enum Engine.EngineTypes.EPrecomputedVisibilityBuildType
/*enum EPrecomputedVisibilityBuildType
{
	BuildType_IncrementalBuild                         = 0,
	BuildType_FullRebuild                              = 1,
	BuildType_DoNotBuild                               = 2,
	BuildType_MAX                                      = 3
};*/

// Enum Engine.Pawn.EPathSearchType
/*enum EPathSearchType
{
	PST_Default                                        = 0,
	PST_Breadth                                        = 1,
	PST_NewBestPathTo                                  = 2,
	PST_Constraint                                     = 3,
	PST_MAX                                            = 4
};*/

// Enum Engine.DynamicLightEnvironmentComponent.EDynamicLightEnvironmentBoundsMethod
/*enum EDynamicLightEnvironmentBoundsMethod
{
	DLEB_OwnerComponents                               = 0,
	DLEB_ManualOverride                                = 1,
	DLEB_ActiveComponents                              = 2,
	DLEB_MAX                                           = 3
};*/

// Enum Engine.ApexDestructibleAsset.EImpactDamageOverride
/*enum EImpactDamageOverride
{
	IDO_None                                           = 0,
	IDO_On                                             = 1,
	IDO_Off                                            = 2,
	IDO_MAX                                            = 3
};*/

// Enum Engine.ApexDestructibleDamageParameters.EDamageParameterOverrideMode
/*enum EDamageParameterOverrideMode
{
	DPOM_Absolute                                      = 0,
	DPOM_Multiplier                                    = 1,
	DPOM_MAX                                           = 2
};*/

// Enum Engine.StaticMeshComponent.ELightmapModificationFunction
/*enum ELightmapModificationFunction
{
	MLMF_Modulate                                      = 0,
	MLMF_ModulateAlpha                                 = 1,
	MLMF_MAX                                           = 2
};*/

// Enum Engine.CameraShake.EInitialOscillatorOffset
/*enum EInitialOscillatorOffset
{
	EOO_OffsetRandom                                   = 0,
	EOO_OffsetZero                                     = 1,
	EOO_MAX                                            = 2
};*/

// Enum Engine.Canvas.ECanvasBlendMode
/*enum ECanvasBlendMode
{
	BLEND_CANVAS_Opaque                                = 0,
	BLEND_CANVAS_Masked                                = 1,
	BLEND_CANVAS_Translucent                           = 2,
	BLEND_CANVAS_Additive                              = 3,
	BLEND_CANVAS_Modulate                              = 4,
	BLEND_CANVAS_ModulateAndAdd                        = 5,
	BLEND_CANVAS_SoftMasked                            = 6,
	BLEND_CANVAS_AlphaComposite                        = 7,
	BLEND_CANVAS_DitheredTranslucent                   = 8,
	BLEND_CANVAS_AlphaOnly                             = 9,
	BLEND_CANVAS_MAX                                   = 10
};*/

// Enum Engine.CloudSaveSystem.SaveDataVersionSupport
/*enum SaveDataVersionSupport
{
	SaveDataVersionSupportLessThenEqual                = 0,
	SaveDataVersionSupportEqual                        = 1,
	SaveDataVersionSupportAny                          = 2,
	SaveDataVersionSupport_MAX                         = 3
};*/

// Enum Engine.CloudSaveSystem.SaveSlotOperationEnum
/*enum SaveSlotOperationEnum
{
	SSO_SET                                            = 0,
	SSO_GET                                            = 1,
	SSO_DELETE                                         = 2,
	SSO_MAX                                            = 3
};*/

// Enum Engine.CloudStorageBase.ECloudStorageDelegate
/*enum ECloudStorageDelegate
{
	CSD_KeyValueReadComplete                           = 0,
	CSD_KeyValueWriteComplete                          = 1,
	CSD_ValueChanged                                   = 2,
	CSD_DocumentQueryComplete                          = 3,
	CSD_DocumentReadComplete                           = 4,
	CSD_DocumentWriteComplete                          = 5,
	CSD_DocumentConflictDetected                       = 6,
	CSD_MAX                                            = 7
};*/

// Enum Engine.UIRoot.EInputPlatformType
/*enum EInputPlatformType
{
	IPT_PC                                             = 0,
	IPT                                                = 1,
	IPT_PS3                                            = 2,
	IPT_MAX                                            = 3
};*/

// Enum Engine.Interaction.ETouchType
/*enum ETouchType
{
	Touch_Began                                        = 0,
	Touch_Moved                                        = 1,
	Touch_Stationary                                   = 2,
	Touch_Ended                                        = 3,
	Touch_Cancelled                                    = 4,
	Touch_MAX                                          = 5
};*/

// Enum Engine.CoverGroup.ECoverGroupFillAction
/*enum ECoverGroupFillAction
{
	CGFA_Overwrite                                     = 0,
	CGFA_Add                                           = 1,
	CGFA_Remove                                        = 2,
	CGFA_Clear                                         = 3,
	CGFA_Cylinder                                      = 4,
	CGFA_MAX                                           = 5
};*/

// Enum Engine.CoverLink.ECoverLocationDescription
/*enum ECoverLocationDescription
{
	CoverDesc_None                                     = 0,
	CoverDesc_InWindow                                 = 1,
	CoverDesc_InDoorway                                = 2,
	CoverDesc_BehindCar                                = 3,
	CoverDesc_BehindTruck                              = 4,
	CoverDesc_OnTruck                                  = 5,
	CoverDesc_BehindBarrier                            = 6,
	CoverDesc_BehindColumn                             = 7,
	CoverDesc_BehindCrate                              = 8,
	CoverDesc_BehindWall                               = 9,
	CoverDesc_BehindStatue                             = 10,
	CoverDesc_BehindSandbags                           = 11,
	CoverDesc_MAX                                      = 12
};*/

// Enum Engine.CoverLink.ECoverAction
/*enum ECoverAction
{
	CA_Default                                         = 0,
	CA_BlindLeft                                       = 1,
	CA_BlindRight                                      = 2,
	CA_LeanLeft                                        = 3,
	CA_LeanRight                                       = 4,
	CA_PopUp                                           = 5,
	CA_BlindUp                                         = 6,
	CA_PeekLeft                                        = 7,
	CA_PeekRight                                       = 8,
	CA_PeekUp                                          = 9,
	CA_MAX                                             = 10
};*/

// Enum Engine.CoverLink.ECoverType
/*enum ECoverType
{
	CT_None                                            = 0,
	CT_Standing                                        = 1,
	CT_MidLevel                                        = 2,
	CT_MAX                                             = 3
};*/

// Enum Engine.CoverLink.EFireLinkID
/*enum EFireLinkID
{
	FLI_FireLink                                       = 0,
	FLI_RejectedFireLink                               = 1,
	FLI_MAX                                            = 2
};*/

// Enum Engine.CoverLink.ECoverDirection
/*enum ECoverDirection
{
	CD_Default                                         = 0,
	CD_Left                                            = 1,
	CD_Right                                           = 2,
	CD_Up                                              = 3,
	CD_MAX                                             = 4
};*/

// Enum Engine.DecalComponent.EDecalTransform
/*enum EDecalTransform
{
	DecalTransform_OwnerAbsolute                       = 0,
	DecalTransform_OwnerRelative                       = 1,
	DecalTransform_SpawnRelative                       = 2,
	DecalTransform_MAX                                 = 3
};*/

// Enum Engine.DecalComponent.EFilterMode
/*enum EFilterMode
{
	FM_None                                            = 0,
	FM_Ignore                                          = 1,
	FM_Affect                                          = 2,
	FM_MAX                                             = 3
};*/

// Enum Engine.MaterialInterface.EMaterialUsage
/*enum EMaterialUsage
{
	MATUSAGE_SkeletalMesh                              = 0,
	MATUSAGE_FracturedMeshes                           = 1,
	MATUSAGE_ParticleSprites                           = 2,
	MATUSAGE_BeamTrails                                = 3,
	MATUSAGE_ParticleSubUV                             = 4,
	MATUSAGE_SpeedTree                                 = 5,
	MATUSAGE_StaticLighting                            = 6,
	MATUSAGE_GammaCorrection                           = 7,
	MATUSAGE_LensFlare                                 = 8,
	MATUSAGE_InstancedMeshParticles                    = 9,
	MATUSAGE_FluidSurface                              = 10,
	MATUSAGE_Decals                                    = 11,
	MATUSAGE_MaterialEffect                            = 12,
	MATUSAGE_MorphTargets                              = 13,
	MATUSAGE_FogVolumes                                = 14,
	MATUSAGE_RadialBlur                                = 15,
	MATUSAGE_InstancedMeshes                           = 16,
	MATUSAGE_SplineMesh                                = 17,
	MATUSAGE_ScreenDoorFade                            = 18,
	MATUSAGE_APEXMesh                                  = 19,
	MATUSAGE_Terrain                                   = 20,
	MATUSAGE_Landscape                                 = 21,
	MATUSAGE_MobileLandscape                           = 22,
	MATUSAGE_SPHFluid                                  = 23,
	MATUSAGE_SPHFluidThickness                         = 24,
	MATUSAGE_MAX                                       = 25
};*/

// Enum Engine.Light.ELightAnimationTechnique
/*enum ELightAnimationTechnique
{
	LightAnim_None                                     = 0,
	LightAnim_Flicker                                  = 1,
	LightAnim_Pulse                                    = 2,
	LightAnim_Strobe                                   = 3,
	LightAnim_ChaoticFlicker                           = 4,
	LightAnim_InverseChaoticFlicker                    = 5,
	LightAnim_MAX                                      = 6
};*/

// Enum Engine.LightComponent.ELightAffectsClassification
/*enum ELightAffectsClassification
{
	LAC_USER_SELECTED                                  = 0,
	LAC_DYNAMIC_AFFECTING                              = 1,
	LAC_STATIC_AFFECTING                               = 2,
	LAC_DYNAMIC_AND_STATIC_AFFECTING                   = 3,
	LAC_MAX                                            = 4
};*/

// Enum Engine.LightComponent.ELightShadowMode
/*enum ELightShadowMode
{
	LightShadow_Normal                                 = 0,
	LightShadow_Modulate                               = 1,
	LightShadow_ModulateBetter                         = 2,
	LightShadow_MAX                                    = 3
};*/

// Enum Engine.LightComponent.EShadowProjectionTechnique
/*enum EShadowProjectionTechnique
{
	ShadowProjTech_Default                             = 0,
	ShadowProjTech_PCF                                 = 1,
	ShadowProjTech_VSM                                 = 2,
	ShadowProjTech_BPCF_Low                            = 3,
	ShadowProjTech_BPCF_Medium                         = 4,
	ShadowProjTech_BPCF_High                           = 5,
	ShadowProjTech_MAX                                 = 6
};*/

// Enum Engine.LightComponent.EShadowFilterQuality
/*enum EShadowFilterQuality
{
	SFQ_Low                                            = 0,
	SFQ_Medium                                         = 1,
	SFQ_High                                           = 2,
	SFQ_MAX                                            = 3
};*/

// Enum Engine.DistributionFloatParameterBase.DistributionParamMode
/*enum DistributionParamMode
{
	DPM_Normal                                         = 0,
	DPM_Abs                                            = 1,
	DPM_Direct                                         = 2,
	DPM_MAX                                            = 3
};*/

// Enum Engine.DOFAndBloomEffect.EDOFType
/*enum EDOFType
{
	DOFType_SimpleDOF                                  = 0,
	DOFType_ReferenceDOF                               = 1,
	DOFType_BokehDOF                                   = 2,
	DOFType_VariableWidthDOF                           = 3,
	DOFType_MAX                                        = 4
};*/

// Enum Engine.DOFAndBloomEffect.EDOFQuality
/*enum EDOFQuality
{
	DOFQuality_Low                                     = 0,
	DOFQuality_Medium                                  = 1,
	DOFQuality_High                                    = 2,
	DOFQuality_MAX                                     = 3
};*/

// Enum Engine.DoorMarker.EDoorType
/*enum EDoorType
{
	DOOR_Shoot                                         = 0,
	DOOR_Touch                                         = 1,
	DOOR_MAX                                           = 2
};*/

// Enum Engine.ParticleSystemComponent.EParticleSysParamType
/*enum EParticleSysParamType
{
	PSPT_None                                          = 0,
	PSPT_Scalar                                        = 1,
	PSPT_ScalarRand                                    = 2,
	PSPT_Vector                                        = 3,
	PSPT_VectorRand                                    = 4,
	PSPT_Color                                         = 5,
	PSPT_Actor                                         = 6,
	PSPT_Material                                      = 7,
	PSPT_MAX                                           = 8
};*/

// Enum Engine.ParticleSystemComponent.ParticleReplayState
/*enum ParticleReplayState
{
	PRS_Disabled                                       = 0,
	PRS_Capturing                                      = 1,
	PRS_Replaying                                      = 2,
	PRS_MAX                                            = 3
};*/

// Enum Engine.ParticleSystemComponent.EParticleEventType
/*enum EParticleEventType
{
	EPET_Any                                           = 0,
	EPET_Spawn                                         = 1,
	EPET_Death                                         = 2,
	EPET_Collision                                     = 3,
	EPET_WorldAttractorCollision                       = 4,
	EPET_Kismet                                        = 5,
	EPET_MAX                                           = 6
};*/

// Enum Engine.ParticleSystem.ParticleSystemLODMethod
/*enum ParticleSystemLODMethod
{
	PARTICLESYSTEMLODMETHOD_Automatic                  = 0,
	PARTICLESYSTEMLODMETHOD_DirectSet                  = 1,
	PARTICLESYSTEMLODMETHOD_ActivateAutomatic          = 2,
	PARTICLESYSTEMLODMETHOD_MAX                        = 3
};*/

// Enum Engine.Engine.ETransitionType
/*enum ETransitionType
{
	TT_None                                            = 0,
	TT_Paused                                          = 1,
	TT_Loading                                         = 2,
	TT_Saving                                          = 3,
	TT_Connecting                                      = 4,
	TT_Precaching                                      = 5,
	TT_MAX                                             = 6
};*/

// Enum Engine.FacebookIntegration.EFacebookIntegrationDelegate
/*enum EFacebookIntegrationDelegate
{
	FID_AuthorizationComplete                          = 0,
	FID_FacebookRequestComplete                        = 1,
	FID_DialogComplete                                 = 2,
	FID_FriendsListComplete                            = 3,
	FID_MAX                                            = 4
};*/

// Enum Engine.FileWriter.FWFileType
/*enum FWFileType
{
	FWFT_Log                                           = 0,
	FWFT_Stats                                         = 1,
	FWFT_HTML                                          = 2,
	FWFT_User                                          = 3,
	FWFT_Debug                                         = 4,
	FWFT_MAX                                           = 5
};*/

// Enum Engine.FlexAsset.EFlexAssetType
/*enum EFlexAssetType
{
	FLEX_Cloth                                         = 0,
	FLEX_Solid                                         = 1,
	FLEX_MAX                                           = 2
};*/

// Enum Engine.FlexContainer.RelaxationMode
/*enum RelaxationMode
{
	RelaxationMode_Global                              = 0,
	RelaxationMode_Local                               = 1,
	RelaxationMode_MAX                                 = 2
};*/

// Enum Engine.FluidInfluenceComponent.EInfluenceType
/*enum EInfluenceType
{
	Fluid_Flow                                         = 0,
	Fluid_Raindrops                                    = 1,
	Fluid_Wave                                         = 2,
	Fluid_Sphere                                       = 3,
	Fluid_MAX                                          = 4
};*/

// Enum Engine.FontImportOptions.EFontImportCharacterSet
/*enum EFontImportCharacterSet
{
	FontICS_Default                                    = 0,
	FontICS_Ansi                                       = 1,
	FontICS_Symbol                                     = 2,
	FontICS_MAX                                        = 3
};*/

// Enum Engine.ForceFeedbackWaveform.EWaveformFunction
/*enum EWaveformFunction
{
	WF_Constant                                        = 0,
	WF_LinearIncreasing                                = 1,
	WF_LinearDecreasing                                = 2,
	WF_Sin0to90                                        = 3,
	WF_Sin90to180                                      = 4,
	WF_Sin0to180                                       = 5,
	WF_Noise                                           = 6,
	WF_MAX                                             = 7
};*/

// Enum Engine.WorldInfo.EHostMigrationProgress
/*enum EHostMigrationProgress
{
	HostMigration_None                                 = 0,
	HostMigration_FindingNewHost                       = 1,
	HostMigration_MigratingAsHost                      = 2,
	HostMigration_MigratingAsClient                    = 3,
	HostMigration_ClientTravel                         = 4,
	HostMigration_HostReadyToTravel                    = 5,
	HostMigration_Failed                               = 6,
	HostMigration_MAX                                  = 7
};*/

// Enum Engine.WorldInfo.EConsoleType
/*enum EConsoleType
{
	CONSOLE_Any                                        = 0,
	CONSOLE_Xbox360                                    = 1,
	CONSOLE_PS3                                        = 2,
	CONSOLE_Mobile                                     = 3,
	CONSOLE_IPhone                                     = 4,
	CONSOLE_Android                                    = 5,
	CONSOLE_WiiU                                       = 6,
	CONSOLE_Flash                                      = 7,
	CONSOLE_Orbis                                      = 8,
	CONSOLE_Durango                                    = 9,
	CONSOLE_MAX                                        = 10
};*/

// Enum Engine.WorldInfo.EPreferredLightmapType
/*enum EPreferredLightmapType
{
	EPLT_Default                                       = 0,
	EPLT_Directional                                   = 1,
	EPLT_Simple                                        = 2,
	EPLT_MAX                                           = 3
};*/

// Enum Engine.WorldInfo.EVisibilityAggressiveness
/*enum EVisibilityAggressiveness
{
	VIS_LeastAggressive                                = 0,
	VIS_ModeratelyAggressive                           = 1,
	VIS_MostAggressive                                 = 2,
	VIS_Max                                            = 3
};*/

// Enum Engine.WorldInfo.ENetMode
/*enum ENetMode
{
	NM_Standalone                                      = 0,
	NM_DedicatedServer                                 = 1,
	NM_ListenServer                                    = 2,
	NM_Client                                          = 3,
	NM_MAX                                             = 4
};*/

// Enum Engine.GameEngine.EFullyLoadPackageType
/*enum EFullyLoadPackageType
{
	FULLYLOAD_Map                                      = 0,
	FULLYLOAD_Game_PreLoadClass                        = 1,
	FULLYLOAD_Game_PostLoadClass                       = 2,
	FULLYLOAD_Always                                   = 3,
	FULLYLOAD_Mutator                                  = 4,
	FULLYLOAD_MAX                                      = 5
};*/

// Enum Engine.GameInfo.EStandbyType
/*enum EStandbyType
{
	STDBY_Rx                                           = 0,
	STDBY_Tx                                           = 1,
	STDBY_BadPing                                      = 2,
	STDBY_MAX                                          = 3
};*/

// Enum Engine.GamePadLightbarSubsystem.LightBarState
/*enum LightBarState
{
	ELBS_Standby                                       = 0,
	ELBS_Lerping                                       = 1,
	ELBS_Pulsing                                       = 2,
	ELBS_MAX                                           = 3
};*/

// Enum Engine.GameplayEvents.EGameStatGroups
/*enum EGameStatGroups
{
	GSG_EngineStats                                    = 0,
	GSG_Game                                           = 1,
	GSG_Team                                           = 2,
	GSG_Player                                         = 3,
	GSG_Weapon                                         = 4,
	GSG_Damage                                         = 5,
	GSG_Projectile                                     = 6,
	GSG_Pawn                                           = 7,
	GSG_GameSpecific                                   = 8,
	GSG_Aggregate                                      = 9,
	GSG_MAX                                            = 10
};*/

// Enum Engine.GameViewportClient.ESplitScreenType
/*enum ESplitScreenType
{
	eSST_NONE                                          = 0,
	eSST_2P_HORIZONTAL                                 = 1,
	eSST_2P_VERTICAL                                   = 2,
	eSST_3P_FAVOR_TOP                                  = 3,
	eSST_3P_FAVOR_BOTTOM                               = 4,
	eSST_4P                                            = 5,
	eSST_MAX                                           = 6
};*/

// Enum Engine.GameViewportClient.ESafeZoneType
/*enum ESafeZoneType
{
	eSZ_TOP                                            = 0,
	eSZ_BOTTOM                                         = 1,
	eSZ_LEFT                                           = 2,
	eSZ_RIGHT                                          = 3,
	eSZ_MAX                                            = 4
};*/

// Enum Engine.GameViewportClient.ESetMode
/*enum ESetMode
{
	SetMode_Toggle                                     = 0,
	SetMode_Enable                                     = 1,
	SetMode_Disable                                    = 2,
	SetMode_MAX                                        = 3
};*/

// Enum Engine.InAppMessageBase.EInAppMessageInterfaceDelegate
/*enum EInAppMessageInterfaceDelegate
{
	IAMD_InAppSMSUIComplete                            = 0,
	IAMD_InAppEmailComplete                            = 1,
	IAMD_MAX                                           = 2
};*/

// Enum Engine.InGameAdManager.EAdManagerDelegate
/*enum EAdManagerDelegate
{
	AMD_ClickedBanner                                  = 0,
	AMD_UserClosedAd                                   = 1,
	AMD_MAX                                            = 2
};*/

// Enum Engine.InstancedFoliageSettings.FoliageCullOption
/*enum FoliageCullOption
{
	FOLIAGECULL_Cull                                   = 0,
	FOLIAGECULL_ScaleZ                                 = 1,
	FOLIAGECULL_ScaleXYZ                               = 2,
	FOLIAGECULL_TranslateZ                             = 3,
	FOLIAGECULL_MAX                                    = 4
};*/

// Enum Engine.Interface_NavMeshPathObstacle.EEdgeHandlingStatus
/*enum EEdgeHandlingStatus
{
	EHS_AddedBothDirs                                  = 0,
	EHS_Added0to1                                      = 1,
	EHS_Added1to0                                      = 2,
	EHS_AddedNone                                      = 3,
	EHS_MAX                                            = 4
};*/

// Enum Engine.InterpTrack.ETrackActiveCondition
/*enum ETrackActiveCondition
{
	ETAC_Always                                        = 0,
	ETAC_GoreEnabled                                   = 1,
	ETAC_GoreDisabled                                  = 2,
	ETAC_MAX                                           = 3
};*/

// Enum Engine.InterpTrackHeadTracking.EHeadTrackingAction
/*enum EHeadTrackingAction
{
	EHTA_DisableHeadTracking                           = 0,
	EHTA_EnableHeadTracking                            = 1,
	EHTA_MAX                                           = 2
};*/

// Enum Engine.InterpTrackToggle.ETrackToggleAction
/*enum ETrackToggleAction
{
	ETTA_Off                                           = 0,
	ETTA_On                                            = 1,
	ETTA_Toggle                                        = 2,
	ETTA_Trigger                                       = 3,
	ETTA_MAX                                           = 4
};*/

// Enum Engine.InterpTrackVisibility.EVisibilityTrackCondition
/*enum EVisibilityTrackCondition
{
	EVTC_Always                                        = 0,
	EVTC_GoreEnabled                                   = 1,
	EVTC_GoreDisabled                                  = 2,
	EVTC_MAX                                           = 3
};*/

// Enum Engine.InterpTrackVisibility.EVisibilityTrackAction
/*enum EVisibilityTrackAction
{
	EVTA_Hide                                          = 0,
	EVTA_Show                                          = 1,
	EVTA_Toggle                                        = 2,
	EVTA_MAX                                           = 3
};*/

// Enum Engine.InterpTrackMove.EInterpTrackMoveFrame
/*enum EInterpTrackMoveFrame
{
	IMF_World                                          = 0,
	IMF_RelativeToInitial                              = 1,
	IMF_MAX                                            = 2
};*/

// Enum Engine.InterpTrackMove.EInterpTrackMoveRotMode
/*enum EInterpTrackMoveRotMode
{
	IMR_Keyframed                                      = 0,
	IMR_LookAtGroup                                    = 1,
	IMR_Ignore                                         = 2,
	IMR_MAX                                            = 3
};*/

// Enum Engine.InterpTrackMoveAxis.EInterpMoveAxis
/*enum EInterpMoveAxis
{
	AXIS_TranslationX                                  = 0,
	AXIS_TranslationY                                  = 1,
	AXIS_TranslationZ                                  = 2,
	AXIS_RotationX                                     = 3,
	AXIS_RotationY                                     = 4,
	AXIS_RotationZ                                     = 5,
	AXIS_MAX                                           = 6
};*/

// Enum Engine.Landscape.ELandscapeSetupErrors
/*enum ELandscapeSetupErrors
{
	LSE_None                                           = 0,
	LSE_NoLandscapeInfo                                = 1,
	LSE_CollsionXY                                     = 2,
	LSE_NoLayerInfo                                    = 3,
	LSE_MAX                                            = 4
};*/

// Enum Engine.LandscapeGizmoActiveActor.ELandscapeGizmoType
/*enum ELandscapeGizmoType
{
	LGT_None                                           = 0,
	LGT_Height                                         = 1,
	LGT_Weight                                         = 2,
	LGT_MAX                                            = 3
};*/

// Enum Engine.LevelGridVolume.LevelGridCellShape
/*enum LevelGridCellShape
{
	LGCS_Box                                           = 0,
	LGCS_Hex                                           = 1,
	LGCS_MAX                                           = 2
};*/

// Enum Engine.LevelStreamingVolume.EStreamingVolumeUsage
/*enum EStreamingVolumeUsage
{
	SVB_Loading                                        = 0,
	SVB_LoadingAndVisibility                           = 1,
	SVB_VisibilityBlockingOnLoad                       = 2,
	SVB_BlockingOnLoad                                 = 3,
	SVB_LoadingNotVisible                              = 4,
	SVB_MAX                                            = 5
};*/

// Enum Engine.MaterialExpressionAntialiasedTextureMask.ETextureColorChannel
/*enum ETextureColorChannel
{
	TCC_Red                                            = 0,
	TCC_Green                                          = 1,
	TCC_Blue                                           = 2,
	TCC_Alpha                                          = 3,
	TCC_MAX                                            = 4
};*/

// Enum Engine.MaterialExpressionCustom.ECustomMaterialOutputType
/*enum ECustomMaterialOutputType
{
	CMOT_Float1                                        = 0,
	CMOT_Float2                                        = 1,
	CMOT_Float3                                        = 2,
	CMOT_Float4                                        = 3,
	CMOT_MAX                                           = 4
};*/

// Enum Engine.MaterialExpressionDepthOfFieldFunction.EDepthOfFieldFunctionValue
/*enum EDepthOfFieldFunctionValue
{
	TDOF_NearAndFarMask                                = 0,
	TDOF_NearMask                                      = 1,
	TDOF_FarMask                                       = 2,
	TDOF_MAX                                           = 3
};*/

// Enum Engine.MaterialExpressionFunctionInput.EFunctionInputType
/*enum EFunctionInputType
{
	FunctionInput_Scalar                               = 0,
	FunctionInput_Vector2                              = 1,
	FunctionInput_Vector3                              = 2,
	FunctionInput_Vector4                              = 3,
	FunctionInput_Texture2D                            = 4,
	FunctionInput_TextureCube                          = 5,
	FunctionInput_StaticBool                           = 6,
	FunctionInput_MAX                                  = 7
};*/

// Enum Engine.MaterialExpressionLandscapeLayerBlend.ELandscapeLayerBlendType
/*enum ELandscapeLayerBlendType
{
	LB_AlphaBlend                                      = 0,
	LB_HeightBlend                                     = 1,
	LB_MAX                                             = 2
};*/

// Enum Engine.MaterialExpressionSceneTexture.ESceneTextureType
/*enum ESceneTextureType
{
	SceneTex_Lighting                                  = 0,
	SceneTex_MAX                                       = 1
};*/

// Enum Engine.MaterialExpressionTerrainLayerCoords.ETerrainCoordMappingType
/*enum ETerrainCoordMappingType
{
	TCMT_Auto                                          = 0,
	TCMT_XY                                            = 1,
	TCMT_XZ                                            = 2,
	TCMT_YZ                                            = 3,
	TCMT_MAX                                           = 4
};*/

// Enum Engine.MaterialExpressionTransform.EMaterialVectorCoordTransformSource
/*enum EMaterialVectorCoordTransformSource
{
	TRANSFORMSOURCE_World                              = 0,
	TRANSFORMSOURCE_Local                              = 1,
	TRANSFORMSOURCE_Tangent                            = 2,
	TRANSFORMSOURCE_View                               = 3,
	TRANSFORMSOURCE_MAX                                = 4
};*/

// Enum Engine.MaterialExpressionTransform.EMaterialVectorCoordTransform
/*enum EMaterialVectorCoordTransform
{
	TRANSFORM_World                                    = 0,
	TRANSFORM_View                                     = 1,
	TRANSFORM_Local                                    = 2,
	TRANSFORM_Tangent                                  = 3,
	TRANSFORM_MAX                                      = 4
};*/

// Enum Engine.MaterialExpressionTransformPosition.EMaterialPositionTransformSource
/*enum EMaterialPositionTransformSource
{
	TRANSFORMPOSSOURCE_Local                           = 0,
	TRANSFORMPOSSOURCE_PostProjection                  = 1,
	TRANSFORMPOSSOURCE_MAX                             = 2
};*/

// Enum Engine.MaterialExpressionTransformPosition.EMaterialPositionTransform
/*enum EMaterialPositionTransform
{
	TRANSFORMPOS_World                                 = 0,
	TRANSFORMPOS_MAX                                   = 1
};*/

// Enum Engine.MicroTransactionBase.EMicroTransactionDelegate
/*enum EMicroTransactionDelegate
{
	MTD_PurchaseQueryComplete                          = 0,
	MTD_PurchaseComplete                               = 1,
	MTD_MAX                                            = 2
};*/

// Enum Engine.MicroTransactionBase.EMicroTransactionResult
/*enum EMicroTransactionResult
{
	MTR_Succeeded                                      = 0,
	MTR_Failed                                         = 1,
	MTR_Canceled                                       = 2,
	MTR_RestoredFromServer                             = 3,
	MTR_MAX                                            = 4
};*/

// Enum Engine.NxForceFieldGeneric.FFG_ForceFieldCoordinates
/*enum FFG_ForceFieldCoordinates
{
	FFG_CARTESIAN                                      = 0,
	FFG_SPHERICAL                                      = 1,
	FFG_CYLINDRICAL                                    = 2,
	FFG_TOROIDAL                                       = 3,
	FFG_MAX                                            = 4
};*/

// Enum Engine.NxGenericForceFieldBrush.FFB_ForceFieldCoordinates
/*enum FFB_ForceFieldCoordinates
{
	FFB_CARTESIAN                                      = 0,
	FFB_SPHERICAL                                      = 1,
	FFB_CYLINDRICAL                                    = 2,
	FFB_TOROIDAL                                       = 3,
	FFB_MAX                                            = 4
};*/

// Enum Engine.OnlineGameDownloadInterface.EDownloadSpeed
/*enum EDownloadSpeed
{
	EDLS_Pause                                         = 0,
	EDLS_Slow                                          = 1,
	EDLS_Fast                                          = 2,
	EDLS_MAX                                           = 3
};*/

// Enum Engine.OnlineGameInterface.ESteamMatchmakingType
/*enum ESteamMatchmakingType
{
	SMT_Invalid                                        = 0,
	SMT_LAN                                            = 1,
	SMT_Internet                                       = 2,
	SMT_Favorites                                      = 3,
	SMT_Friends                                        = 4,
	SMT_History                                        = 5,
	SMT_MAX                                            = 6
};*/

// Enum Engine.OnlinePlayerStorage.EOnlineProfilePropertyOwner
/*enum EOnlineProfilePropertyOwner
{
	OPPO_None                                          = 0,
	OPPO_OnlineService                                 = 1,
	OPPO_Game                                          = 2,
	OPPO_MAX                                           = 3
};*/

// Enum Engine.OnlinePlayerStorage.EOnlinePlayerStorageAsyncState
/*enum EOnlinePlayerStorageAsyncState
{
	OPAS_NotStarted                                    = 0,
	OPAS_Read                                          = 1,
	OPAS_Write                                         = 2,
	OPAS_Finished                                      = 3,
	OPAS_MAX                                           = 4
};*/

// Enum Engine.OnlineProfileSettings.EProfileSettingID
/*enum EProfileSettingID
{
	PSI_Unknown                                        = 0,
	PSI_ControllerVibration                            = 1,
	PSI_YInversion                                     = 2,
	PSI_GamerCred                                      = 3,
	PSI_GamerRep                                       = 4,
	PSI_VoiceMuted                                     = 5,
	PSI_VoiceThruSpeakers                              = 6,
	PSI_VoiceVolume                                    = 7,
	PSI_GamerPictureKey                                = 8,
	PSI_GamerMotto                                     = 9,
	PSI_GamerTitlesPlayed                              = 10,
	PSI_GamerAchievementsEarned                        = 11,
	PSI_GameDifficulty                                 = 12,
	PSI_ControllerSensitivity                          = 13,
	PSI_PreferredColor1                                = 14,
	PSI_PreferredColor2                                = 15,
	PSI_AutoAim                                        = 16,
	PSI_AutoCenter                                     = 17,
	PSI_MovementControl                                = 18,
	PSI_RaceTransmission                               = 19,
	PSI_RaceCameraLocation                             = 20,
	PSI_RaceBrakeControl                               = 21,
	PSI_RaceAcceleratorControl                         = 22,
	PSI_GameCredEarned                                 = 23,
	PSI_GameAchievementsEarned                         = 24,
	PSI_EndLiveIds                                     = 25,
	PSI_ProfileVersionNum                              = 26,
	PSI_ProfileSaveCount                               = 27,
	PSI_MAX                                            = 28
};*/

// Enum Engine.OnlineProfileSettings.EProfileDifficultyOptions
/*enum EProfileDifficultyOptions
{
	PDO_Normal                                         = 0,
	PDO_Easy                                           = 1,
	PDO_Hard                                           = 2,
	PDO_MAX                                            = 3
};*/

// Enum Engine.OnlineProfileSettings.EProfileControllerSensitivityOptions
/*enum EProfileControllerSensitivityOptions
{
	PCSO_Medium                                        = 0,
	PCSO_Low                                           = 1,
	PCSO_High                                          = 2,
	PCSO_MAX                                           = 3
};*/

// Enum Engine.OnlineProfileSettings.EProfilePreferredColorOptions
/*enum EProfilePreferredColorOptions
{
	PPCO_None                                          = 0,
	PPCO_Black                                         = 1,
	PPCO_White                                         = 2,
	PPCO_Yellow                                        = 3,
	PPCO_Orange                                        = 4,
	PPCO_Pink                                          = 5,
	PPCO_Red                                           = 6,
	PPCO_Purple                                        = 7,
	PPCO_Blue                                          = 8,
	PPCO_Green                                         = 9,
	PPCO_Brown                                         = 10,
	PPCO_Silver                                        = 11,
	PPCO_MAX                                           = 12
};*/

// Enum Engine.OnlineProfileSettings.EProfileAutoAimOptions
/*enum EProfileAutoAimOptions
{
	PAAO_Off                                           = 0,
	PAAO_On                                            = 1,
	PAAO_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileAutoCenterOptions
/*enum EProfileAutoCenterOptions
{
	PACO_Off                                           = 0,
	PACO_On                                            = 1,
	PACO_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileMovementControlOptions
/*enum EProfileMovementControlOptions
{
	PMCO_L_Thumbstick                                  = 0,
	PMCO_R_Thumbstick                                  = 1,
	PMCO_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileRaceTransmissionOptions
/*enum EProfileRaceTransmissionOptions
{
	PRTO_Auto                                          = 0,
	PRTO_Manual                                        = 1,
	PRTO_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileRaceCameraLocationOptions
/*enum EProfileRaceCameraLocationOptions
{
	PRCLO_Behind                                       = 0,
	PRCLO_Front                                        = 1,
	PRCLO_Inside                                       = 2,
	PRCLO_MAX                                          = 3
};*/

// Enum Engine.OnlineProfileSettings.EProfileRaceBrakeControlOptions
/*enum EProfileRaceBrakeControlOptions
{
	PRBCO_Trigger                                      = 0,
	PRBCO_Button                                       = 1,
	PRBCO_MAX                                          = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileRaceAcceleratorControlOptions
/*enum EProfileRaceAcceleratorControlOptions
{
	PRACO_Trigger                                      = 0,
	PRACO_Button                                       = 1,
	PRACO_MAX                                          = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileYInversionOptions
/*enum EProfileYInversionOptions
{
	PYIO_Off                                           = 0,
	PYIO_On                                            = 1,
	PYIO_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileXInversionOptions
/*enum EProfileXInversionOptions
{
	PXIO_Off                                           = 0,
	PXIO_On                                            = 1,
	PXIO_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileOmniDirEvadeOptions
/*enum EProfileOmniDirEvadeOptions
{
	PODI_Off                                           = 0,
	PODI_On                                            = 1,
	PODI_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileControllerVibrationToggleOptions
/*enum EProfileControllerVibrationToggleOptions
{
	PCVTO_Off                                          = 0,
	PCVTO_IgnoreThis                                   = 1,
	PCVTO_IgnoreThis2                                  = 2,
	PCVTO_On                                           = 3,
	PCVTO_MAX                                          = 4
};*/

// Enum Engine.OnlineProfileSettings.EProfileVoiceThruSpeakersOptions
/*enum EProfileVoiceThruSpeakersOptions
{
	PVTSO_Off                                          = 0,
	PVTSO_On                                           = 1,
	PVTSO_Both                                         = 2,
	PVTSO_MAX                                          = 3
};*/

// Enum Engine.ParticleEmitter.EParticleBurstMethod
/*enum EParticleBurstMethod
{
	EPBM_Instant                                       = 0,
	EPBM_Interpolated                                  = 1,
	EPBM_MAX                                           = 2
};*/

// Enum Engine.ParticleEmitter.EParticleSubUVInterpMethod
/*enum EParticleSubUVInterpMethod
{
	PSUVIM_None                                        = 0,
	PSUVIM_Linear                                      = 1,
	PSUVIM_Linear_Blend                                = 2,
	PSUVIM_Random                                      = 3,
	PSUVIM_Random_Blend                                = 4,
	PSUVIM_MAX                                         = 5
};*/

// Enum Engine.ParticleEmitter.EEmitterRenderMode
/*enum EEmitterRenderMode
{
	ERM_Normal                                         = 0,
	ERM_Point                                          = 1,
	ERM_Cross                                          = 2,
	ERM_None                                           = 3,
	ERM_MAX                                            = 4
};*/

// Enum Engine.ParticleModule.EModuleType
/*enum EModuleType
{
	EPMT_General                                       = 0,
	EPMT_TypeData                                      = 1,
	EPMT_Beam                                          = 2,
	EPMT_Trail                                         = 3,
	EPMT_Spawn                                         = 4,
	EPMT_Required                                      = 5,
	EPMT_Event                                         = 6,
	EPMT_MAX                                           = 7
};*/

// Enum Engine.ParticleModule.EParticleSourceSelectionMethod
/*enum EParticleSourceSelectionMethod
{
	EPSSM_Random                                       = 0,
	EPSSM_Sequential                                   = 1,
	EPSSM_MAX                                          = 2
};*/

// Enum Engine.ParticleModuleAttractorBoneSocket.EBoneSocketAttractorFalloffType
/*enum EBoneSocketAttractorFalloffType
{
	BSFOFF_Constant                                    = 0,
	BSFOFF_Linear                                      = 1,
	BSFOFF_Exponent                                    = 2,
	BSFOFF_MAX                                         = 3
};*/

// Enum Engine.ParticleModuleAttractorBoneSocket.ELocationBoneSocketDestination
/*enum ELocationBoneSocketDestination
{
	BONESOCKETDEST_Bones                               = 0,
	BONESOCKETDEST_Sockets                             = 1,
	BONESOCKETDEST_MAX                                 = 2
};*/

// Enum Engine.ParticleModuleAttractorBoneSocket.ELocationBoneSocketDestSelectionMethod
/*enum ELocationBoneSocketDestSelectionMethod
{
	BONESOCKETDESTSEL_Sequential                       = 0,
	BONESOCKETDESTSEL_Random                           = 1,
	BONESOCKETDESTSEL_RandomExhaustive                 = 2,
	BONESOCKETDESTSEL_BlendAll                         = 3,
	BONESOCKETDESTSEL_MAX                              = 4
};*/

// Enum Engine.ParticleModuleAttractorParticle.EAttractorParticleSelectionMethod
/*enum EAttractorParticleSelectionMethod
{
	EAPSM_Random                                       = 0,
	EAPSM_Sequential                                   = 1,
	EAPSM_MAX                                          = 2
};*/

// Enum Engine.ParticleModuleAttractorSkelVertSurface.EVertSurfaceAttractorFalloffType
/*enum EVertSurfaceAttractorFalloffType
{
	VSFOFF_Constant                                    = 0,
	VSFOFF_Linear                                      = 1,
	VSFOFF_Exponent                                    = 2,
	VSFOFF_MAX                                         = 3
};*/

// Enum Engine.ParticleModuleAttractorSkelVertSurface.EAttractorSkelVertSurfaceDestination
/*enum EAttractorSkelVertSurfaceDestination
{
	VERTSURFACEDEST_Vert                               = 0,
	VERTSURFACEDEST_Surface                            = 1,
	VERTSURFACEDEST_MAX                                = 2
};*/

// Enum Engine.ParticleModuleBeamBase.Beam2SourceTargetMethod
/*enum Beam2SourceTargetMethod
{
	PEB2STM_Default                                    = 0,
	PEB2STM_UserSet                                    = 1,
	PEB2STM_Emitter                                    = 2,
	PEB2STM_Particle                                   = 3,
	PEB2STM_Actor                                      = 4,
	PEB2STM_ActorSocket                                = 5,
	PEB2STM_MAX                                        = 6
};*/

// Enum Engine.ParticleModuleBeamBase.Beam2SourceTargetTangentMethod
/*enum Beam2SourceTargetTangentMethod
{
	PEB2STTM_Direct                                    = 0,
	PEB2STTM_UserSet                                   = 1,
	PEB2STTM_Distribution                              = 2,
	PEB2STTM_Emitter                                   = 3,
	PEB2STTM_MAX                                       = 4
};*/

// Enum Engine.ParticleModuleBeamModifier.BeamModifierType
/*enum BeamModifierType
{
	PEB2MT_Source                                      = 0,
	PEB2MT_Target                                      = 1,
	PEB2MT_MAX                                         = 2
};*/

// Enum Engine.ParticleModuleCameraOffset.EParticleCameraOffsetUpdateMethod
/*enum EParticleCameraOffsetUpdateMethod
{
	EPCOUM_DirectSet                                   = 0,
	EPCOUM_Additive                                    = 1,
	EPCOUM_Scalar                                      = 2,
	EPCOUM_MAX                                         = 3
};*/

// Enum Engine.ParticleModuleCollisionBase.EParticleCollisionComplete
/*enum EParticleCollisionComplete
{
	EPCC_Kill                                          = 0,
	EPCC_Freeze                                        = 1,
	EPCC_HaltCollisions                                = 2,
	EPCC_FreezeTranslation                             = 3,
	EPCC_FreezeRotation                                = 4,
	EPCC_FreezeMovement                                = 5,
	EPCC_MAX                                           = 6
};*/

// Enum Engine.ParticleModuleCollision.ParticleAttractorActionType
/*enum ParticleAttractorActionType
{
	PAAT_None                                          = 0,
	PAAT_Destroy                                       = 1,
	PAAT_Freeze                                        = 2,
	PAAT_Event                                         = 3,
	PAAT_MAX                                           = 4
};*/

// Enum Engine.ParticleModuleLocationBoneSocket.ELocationBoneSocketSource
/*enum ELocationBoneSocketSource
{
	BONESOCKETSOURCE_Bones                             = 0,
	BONESOCKETSOURCE_Sockets                           = 1,
	BONESOCKETSOURCE_MAX                               = 2
};*/

// Enum Engine.ParticleModuleLocationBoneSocket.ELocationBoneSocketSelectionMethod
/*enum ELocationBoneSocketSelectionMethod
{
	BONESOCKETSEL_Sequential                           = 0,
	BONESOCKETSEL_Random                               = 1,
	BONESOCKETSEL_RandomExhaustive                     = 2,
	BONESOCKETSEL_MAX                                  = 3
};*/

// Enum Engine.ParticleModuleLocationEmitter.ELocationEmitterSelectionMethod
/*enum ELocationEmitterSelectionMethod
{
	ELESM_Random                                       = 0,
	ELESM_Sequential                                   = 1,
	ELESM_MAX                                          = 2
};*/

// Enum Engine.ParticleModuleLocationPrimitiveCylinder.CylinderHeightAxis
/*enum CylinderHeightAxis
{
	PMLPC_HEIGHTAXIS_X                                 = 0,
	PMLPC_HEIGHTAXIS_Y                                 = 1,
	PMLPC_HEIGHTAXIS_Z                                 = 2,
	PMLPC_HEIGHTAXIS_MAX                               = 3
};*/

// Enum Engine.ParticleModuleLocationSkelVertSurface.ELocationSkelVertSurfaceSource
/*enum ELocationSkelVertSurfaceSource
{
	VERTSURFACESOURCE_Vert                             = 0,
	VERTSURFACESOURCE_Surface                          = 1,
	VERTSURFACESOURCE_MAX                              = 2
};*/

// Enum Engine.ParticleModuleLocationStaticVertSurface.ELocationStaticVertSurfaceSource
/*enum ELocationStaticVertSurfaceSource
{
	VERTSTATICSURFACESOURCE_Vert                       = 0,
	VERTSTATICSURFACESOURCE_Surface                    = 1,
	VERTSTATICSURFACESOURCE_MAX                        = 2
};*/

// Enum Engine.ParticleModuleOrbit.EOrbitChainMode
/*enum EOrbitChainMode
{
	EOChainMode_Add                                    = 0,
	EOChainMode_Scale                                  = 1,
	EOChainMode_Link                                   = 2,
	EOChainMode_MAX                                    = 3
};*/

// Enum Engine.ParticleModuleOrientationAxisLock.EParticleAxisLock
/*enum EParticleAxisLock
{
	EPAL_NONE                                          = 0,
	EPAL_X                                             = 1,
	EPAL_Y                                             = 2,
	EPAL_Z                                             = 3,
	EPAL_NEGATIVE_X                                    = 4,
	EPAL_NEGATIVE_Y                                    = 5,
	EPAL_NEGATIVE_Z                                    = 6,
	EPAL_ROTATE_X                                      = 7,
	EPAL_ROTATE_Y                                      = 8,
	EPAL_ROTATE_Z                                      = 9,
	EPAL_MAX                                           = 10
};*/

// Enum Engine.ParticleModuleParameterDynamic.EEmitterDynamicParameterValue
/*enum EEmitterDynamicParameterValue
{
	EDPV_UserSet                                       = 0,
	EDPV_VelocityX                                     = 1,
	EDPV_VelocityY                                     = 2,
	EDPV_VelocityZ                                     = 3,
	EDPV_VelocityMag                                   = 4,
	EDPV_MAX                                           = 5
};*/

// Enum Engine.ParticleModulePhysicsVolumes.EParticleLevelInfluenceType
/*enum EParticleLevelInfluenceType
{
	LIT_Never                                          = 0,
	LIT_OutsidePhysicsVolumes                          = 1,
	LIT_Always                                         = 2,
	LIT_MAX                                            = 3
};*/

// Enum Engine.ParticleSpriteEmitter.EParticleScreenAlignment
/*enum EParticleScreenAlignment
{
	PSA_Square                                         = 0,
	PSA_Rectangle                                      = 1,
	PSA_Velocity                                       = 2,
	PSA_TypeSpecific                                   = 3,
	PSA_MAX                                            = 4
};*/

// Enum Engine.ParticleModuleRequired.EParticleSortMode
/*enum EParticleSortMode
{
	PSORTMODE_None                                     = 0,
	PSORTMODE_ViewProjDepth                            = 1,
	PSORTMODE_DistanceToView                           = 2,
	PSORTMODE_Age_OldestFirst                          = 3,
	PSORTMODE_Age_NewestFirst                          = 4,
	PSORTMODE_MAX                                      = 5
};*/

// Enum Engine.ParticleModuleRequired.EEmitterNormalsMode
/*enum EEmitterNormalsMode
{
	ENM_CameraFacing                                   = 0,
	ENM_Spherical                                      = 1,
	ENM_Cylindrical                                    = 2,
	ENM_MAX                                            = 3
};*/

// Enum Engine.ParticleModuleTrailSource.ETrail2SourceMethod
/*enum ETrail2SourceMethod
{
	PET2SRCM_Default                                   = 0,
	PET2SRCM_Particle                                  = 1,
	PET2SRCM_Actor                                     = 2,
	PET2SRCM_MAX                                       = 3
};*/

// Enum Engine.ParticleModuleTrailSpawn.ETrail2SpawnMethod
/*enum ETrail2SpawnMethod
{
	PET2SM_Emitter                                     = 0,
	PET2SM_Velocity                                    = 1,
	PET2SM_Distance                                    = 2,
	PET2SM_MAX                                         = 3
};*/

// Enum Engine.ParticleModuleTrailTaper.ETrailTaperMethod
/*enum ETrailTaperMethod
{
	PETTM_None                                         = 0,
	PETTM_Full                                         = 1,
	PETTM_Partial                                      = 2,
	PETTM_MAX                                          = 3
};*/

// Enum Engine.ParticleModuleTypeDataBeam.EBeamMethod
/*enum EBeamMethod
{
	PEBM_Distance                                      = 0,
	PEBM_EndPoints                                     = 1,
	PEBM_EndPoints_Interpolated                        = 2,
	PEBM_UserSet_EndPoints                             = 3,
	PEBM_UserSet_EndPoints_Interpolated                = 4,
	PEBM_MAX                                           = 5
};*/

// Enum Engine.ParticleModuleTypeDataBeam.EBeamEndPointMethod
/*enum EBeamEndPointMethod
{
	PEBEPM_Calculated                                  = 0,
	PEBEPM_Distribution                                = 1,
	PEBEPM_Distribution_Constant                       = 2,
	PEBEPM_MAX                                         = 3
};*/

// Enum Engine.ParticleModuleTypeDataBeam2.EBeam2Method
/*enum EBeam2Method
{
	PEB2M_Distance                                     = 0,
	PEB2M_Target                                       = 1,
	PEB2M_Branch                                       = 2,
	PEB2M_MAX                                          = 3
};*/

// Enum Engine.ParticleModuleTypeDataBeam2.EBeamTaperMethod
/*enum EBeamTaperMethod
{
	PEBTM_None                                         = 0,
	PEBTM_Full                                         = 1,
	PEBTM_Partial                                      = 2,
	PEBTM_MAX                                          = 3
};*/

// Enum Engine.ParticleModuleTypeDataMesh.EMeshScreenAlignment
/*enum EMeshScreenAlignment
{
	PSMA_MeshFaceCameraWithRoll                        = 0,
	PSMA_MeshFaceCameraWithSpin                        = 1,
	PSMA_MeshFaceCameraWithLockedAxis                  = 2,
	PSMA_MAX                                           = 3
};*/

// Enum Engine.ParticleModuleTypeDataMesh.EMeshCameraFacingUpAxis
/*enum EMeshCameraFacingUpAxis
{
	CameraFacing_NoneUP                                = 0,
	CameraFacing_ZUp                                   = 1,
	CameraFacing_NegativeZUp                           = 2,
	CameraFacing_YUp                                   = 3,
	CameraFacing_NegativeYUp                           = 4,
	CameraFacing_MAX                                   = 5
};*/

// Enum Engine.ParticleModuleTypeDataMesh.EMeshCameraFacingOptions
/*enum EMeshCameraFacingOptions
{
	XAxisFacing_NoUp                                   = 0,
	XAxisFacing_ZUp                                    = 1,
	XAxisFacing_NegativeZUp                            = 2,
	XAxisFacing_YUp                                    = 3,
	XAxisFacing_NegativeYUp                            = 4,
	LockedAxis_ZAxisFacing                             = 5,
	LockedAxis_NegativeZAxisFacing                     = 6,
	LockedAxis_YAxisFacing                             = 7,
	LockedAxis_NegativeYAxisFacing                     = 8,
	VelocityAligned_ZAxisFacing                        = 9,
	VelocityAligned_NegativeZAxisFacing                = 10,
	VelocityAligned_YAxisFacing                        = 11,
	VelocityAligned_NegativeYAxisFacing                = 12,
	EMeshCameraFacingOptions_MAX                       = 13
};*/

// Enum Engine.ParticleModuleTypeDataMeshPhysX.EPhysXMeshRotationMethod
/*enum EPhysXMeshRotationMethod
{
	PMRM_Disabled                                      = 0,
	PMRM_Spherical                                     = 1,
	PMRM_Box                                           = 2,
	PMRM_LongBox                                       = 3,
	PMRM_FlatBox                                       = 4,
	PMRM_Velocity                                      = 5,
	PMRM_MAX                                           = 6
};*/

// Enum Engine.ParticleModuleTypeDataRibbon.ETrailsRenderAxisOption
/*enum ETrailsRenderAxisOption
{
	Trails_CameraUp                                    = 0,
	Trails_SourceUp                                    = 1,
	Trails_WorldUp                                     = 2,
	Trails_MAX                                         = 3
};*/

// Enum Engine.ParticleSystem.EParticleSystemOcclusionBoundsMethod
/*enum EParticleSystemOcclusionBoundsMethod
{
	EPSOBM_None                                        = 0,
	EPSOBM_ParticleBounds                              = 1,
	EPSOBM_CustomBounds                                = 2,
	EPSOBM_MAX                                         = 3
};*/

// Enum Engine.ParticleSystem.EParticleSystemOveridePhysXLevel
/*enum EParticleSystemOveridePhysXLevel
{
	EPSOP_NoOverride                                   = 0,
	EPSOP_PhysXLevel1                                  = 1,
	EPSOP_PhysXLevel2                                  = 2,
	EPSOP_MAX                                          = 3
};*/

// Enum Engine.ParticleSystem.EParticleSystemUpdateMode
/*enum EParticleSystemUpdateMode
{
	EPSUM_RealTime                                     = 0,
	EPSUM_FixedTime                                    = 1,
	EPSUM_MAX                                          = 2
};*/

// Enum Engine.ProcBuildingRuleset.EProcBuildingAxis
/*enum EProcBuildingAxis
{
	EPBAxis_X                                          = 0,
	EPBAxis_Z                                          = 1,
	EPBAxis_MAX                                        = 2
};*/

// Enum Engine.ProcBuilding.EScopeEdge
/*enum EScopeEdge
{
	EPSA_Top                                           = 0,
	EPSA_Bottom                                        = 1,
	EPSA_Left                                          = 2,
	EPSA_Right                                         = 3,
	EPSA_None                                          = 4,
	EPSA_MAX                                           = 5
};*/

// Enum Engine.ProcBuilding.EBuildingStatsBrowserColumns
/*enum EBuildingStatsBrowserColumns
{
	BSBC_Name                                          = 0,
	BSBC_Ruleset                                       = 1,
	BSBC_NumStaticMeshComps                            = 2,
	BSBC_NumInstancedStaticMeshComps                   = 3,
	BSBC_NumInstancedTris                              = 4,
	BSBC_LightmapMemBytes                              = 5,
	BSBC_ShadowmapMemBytes                             = 6,
	BSBC_LODDiffuseMemBytes                            = 7,
	BSBC_LODLightingMemBytes                           = 8,
	BSBC_MAX                                           = 9
};*/

// Enum Engine.ProcBuilding.EPBCornerType
/*enum EPBCornerType
{
	EPBC_Default                                       = 0,
	EPBC_Chamfer                                       = 1,
	EPBC_Round                                         = 2,
	EPBC_MAX                                           = 3
};*/

// Enum Engine.PBRuleNodeEdgeAngle.EProcBuildingEdge
/*enum EProcBuildingEdge
{
	EPBE_Top                                           = 0,
	EPBE_Bottom                                        = 1,
	EPBE_Left                                          = 2,
	EPBE_Right                                         = 3,
	EPBE_MAX                                           = 4
};*/

// Enum Engine.PhysicalMaterial.EPhysEffectType
/*enum EPhysEffectType
{
	EPMET_Impact                                       = 0,
	EPMET_Slide                                        = 1,
	EPMET_MAX                                          = 2
};*/

// Enum Engine.PhysicalMaterialPropertyBase.EMaterialTypes
/*enum EMaterialTypes
{
	EMT_None                                           = 0,
	EMT_Rock                                           = 1,
	EMT_Dirt                                           = 2,
	EMT_Dust                                           = 3,
	EMT_Mud                                            = 4,
	EMT_Poop                                           = 5,
	EMT_Grass                                          = 6,
	EMT_Plant                                          = 7,
	EMT_Water                                          = 8,
	EMT_WaterShallow                                   = 9,
	EMT_Ice                                            = 10,
	EMT_Snow                                           = 11,
	EMT_Metal                                          = 12,
	EMT_MetalHollow                                    = 13,
	EMT_MetalArmor                                     = 14,
	EMT_Wood                                           = 15,
	EMT_WoodHollow                                     = 16,
	EMT_BrickRed                                       = 17,
	EMT_BrickWhite                                     = 18,
	EMT_Plaster                                        = 19,
	EMT_Glass                                          = 20,
	EMT_GlassBroken                                    = 21,
	EMT_Gravel                                         = 22,
	EMT_Concrete                                       = 23,
	EMT_ConcreteWet                                    = 24,
	EMT_Paper                                          = 25,
	EMT_Cloth                                          = 26,
	EMT_Rubber                                         = 27,
	EMT_Asphalt                                        = 28,
	EMT_Flesh                                          = 29,
	EMT_PlasticBag                                     = 30,
	EMT_Sand                                           = 31,
	EMT_Lava                                           = 32,
	EMT_Custom0                                        = 33,
	EMT_Custom1                                        = 34,
	EMT_Custom2                                        = 35,
	EMT_Custom3                                        = 36,
	EMT_Custom4                                        = 37,
	EMT_MAX                                            = 38
};*/

// Enum Engine.PhysXParticleSystem.ESimulationMethod
/*enum ESimulationMethod
{
	ESM_SPH                                            = 0,
	ESM_NO_PARTICLE_INTERACTION                        = 1,
	ESM_MIXED_MODE                                     = 2,
	ESM_MAX                                            = 3
};*/

// Enum Engine.PhysXParticleSystem.EPacketSizeMultiplier
/*enum EPacketSizeMultiplier
{
	EPSM                                               = 0,
	EPSM01                                             = 1,
	EPSM02                                             = 2,
	EPSM03                                             = 3,
	EPSM04                                             = 4,
	EPSM05                                             = 5,
	EPSM_MAX                                           = 6
};*/

// Enum Engine.SceneCaptureComponent.ESceneCaptureViewMode
/*enum ESceneCaptureViewMode
{
	SceneCapView_Lit                                   = 0,
	SceneCapView_Unlit                                 = 1,
	SceneCapView_LitNoShadows                          = 2,
	SceneCapView_Wire                                  = 3,
	SceneCapView_MAX                                   = 4
};*/

// Enum Engine.RB_BodySetup.ESleepFamily
/*enum ESleepFamily
{
	SF_Normal                                          = 0,
	SF_Sensitive                                       = 1,
	SF_MAX                                             = 2
};*/

// Enum Engine.RB_RadialForceActor.ERadialForceType
/*enum ERadialForceType
{
	RFT_Force                                          = 0,
	RFT_Impulse                                        = 1,
	RFT_MAX                                            = 2
};*/

// Enum Engine.Route.ERouteDirection
/*enum ERouteDirection
{
	ERD_Forward                                        = 0,
	ERD_Reverse                                        = 1,
	ERD_MAX                                            = 2
};*/

// Enum Engine.Route.ERouteType
/*enum ERouteType
{
	ERT_Linear                                         = 0,
	ERT_Loop                                           = 1,
	ERT_Circle                                         = 2,
	ERT_MAX                                            = 3
};*/

// Enum Engine.Route.ERouteFillAction
/*enum ERouteFillAction
{
	RFA_Overwrite                                      = 0,
	RFA_Add                                            = 1,
	RFA_Remove                                         = 2,
	RFA_Clear                                          = 3,
	RFA_MAX                                            = 4
};*/

// Enum Engine.SeqAct_ActorFactory.EPointSelection
/*enum EPointSelection
{
	PS_Normal                                          = 0,
	PS_Random                                          = 1,
	PS_Reverse                                         = 2,
	PS_MAX                                             = 3
};*/

// Enum Engine.SeqAct_SetMesh.EMeshType
/*enum EMeshType
{
	MeshType_StaticMesh                                = 0,
	MeshType_SkeletalMesh                              = 1,
	MeshType_MAX                                       = 2
};*/

// Enum Engine.WorldAttractor.EWorldAttractorFalloffType
/*enum EWorldAttractorFalloffType
{
	FOFF_Constant                                      = 0,
	FOFF_Linear                                        = 1,
	FOFF_Exponent                                      = 2,
	FOFF_MAX                                           = 3
};*/

// Enum Engine.SeqEvent_ParticleEvent.EParticleEventOutputType
/*enum EParticleEventOutputType
{
	ePARTICLEOUT_Spawn                                 = 0,
	ePARTICLEOUT_Death                                 = 1,
	ePARTICLEOUT_Collision                             = 2,
	ePARTICLEOUT_AttractorCollision                    = 3,
	ePARTICLEOUT_Kismet                                = 4,
	ePARTICLEOUT_MAX                                   = 5
};*/

// Enum Engine.SkelControlBase.EBoneControlSpace
/*enum EBoneControlSpace
{
	BCS_WorldSpace                                     = 0,
	BCS_ActorSpace                                     = 1,
	BCS_ComponentSpace                                 = 2,
	BCS_ParentBoneSpace                                = 3,
	BCS_BoneSpace                                      = 4,
	BCS_OtherBoneSpace                                 = 5,
	BCS_BaseMeshSpace                                  = 6,
	BCS_MAX                                            = 7
};*/

// Enum Engine.SkelControlSpline.ESplineControlRotMode
/*enum ESplineControlRotMode
{
	SCR_NoChange                                       = 0,
	SCR_AlongSpline                                    = 1,
	SCR_Interpolate                                    = 2,
	SCR_MAX                                            = 3
};*/

// Enum Engine.SkeletalMesh.SoftBodyBoneType
/*enum SoftBodyBoneType
{
	SOFTBODYBONE_Fixed                                 = 0,
	SOFTBODYBONE_BreakableAttachment                   = 1,
	SOFTBODYBONE_TwoWayAttachment                      = 2,
	SOFTBODYBONE_MAX                                   = 3
};*/

// Enum Engine.SkeletalMesh.ClothBoneType
/*enum ClothBoneType
{
	CLOTHBONE_Fixed                                    = 0,
	CLOTHBONE_BreakableAttachment                      = 1,
	CLOTHBONE_TearLine                                 = 2,
	CLOTHBONE_MAX                                      = 3
};*/

// Enum Engine.SkeletalMesh.SkeletalMeshOptimizationNormalMode
/*enum SkeletalMeshOptimizationNormalMode
{
	SMONM_Recalculate                                  = 0,
	SMONM_RecalculateSoft                              = 1,
	SMONM_RecalculateHard                              = 2,
	SMONM_MAX                                          = 3
};*/

// Enum Engine.SkeletalMesh.SkeletalMeshOptimizationImportance
/*enum SkeletalMeshOptimizationImportance
{
	SMOI_Off                                           = 0,
	SMOI_Lowest                                        = 1,
	SMOI_Low                                           = 2,
	SMOI_Normal                                        = 3,
	SMOI_High                                          = 4,
	SMOI_Highest                                       = 5,
	SMOI_MAX                                           = 6
};*/

// Enum Engine.SkeletalMesh.SkeletalMeshOptimizationType
/*enum SkeletalMeshOptimizationType
{
	SMOT_NumOfTriangles                                = 0,
	SMOT_MaxDeviation                                  = 1,
	SMOT_MAX                                           = 2
};*/

// Enum Engine.SkeletalMesh.TriangleSortOption
/*enum TriangleSortOption
{
	TRISORT_None                                       = 0,
	TRISORT_CenterRadialDistance                       = 1,
	TRISORT_Random                                     = 2,
	TRISORT_MergeContiguous                            = 3,
	TRISORT_Custom                                     = 4,
	TRISORT_CustomLeftRight                            = 5,
	TRISORT_MAX                                        = 6
};*/

// Enum Engine.SkeletalMesh.BoneBreakOption
/*enum BoneBreakOption
{
	BONEBREAK_SoftPreferred                            = 0,
	BONEBREAK_AutoDetect                               = 1,
	BONEBREAK_RigidPreferred                           = 2,
	BONEBREAK_MAX                                      = 3
};*/

// Enum Engine.SkeletalMesh.TriangleSortAxis
/*enum TriangleSortAxis
{
	TSA_X_Axis                                         = 0,
	TSA_Y_Axis                                         = 1,
	TSA_Z_Axis                                         = 2,
	TSA_MAX                                            = 3
};*/

// Enum Engine.SkeletalMesh.ClothMovementScaleGen
/*enum ClothMovementScaleGen
{
	ECMDM_DistToFixedVert                              = 0,
	ECMDM_VertexBoneWeight                             = 1,
	ECMDM_Empty                                        = 2,
	ECMDM_MAX                                          = 3
};*/

// Enum Engine.SoundNodeWave.EDecompressionType
/*enum EDecompressionType
{
	DTYPE_Setup                                        = 0,
	DTYPE_Invalid                                      = 1,
	DTYPE_Preview                                      = 2,
	DTYPE_Native                                       = 3,
	DTYPE_RealTime                                     = 4,
	DTYPE_Procedural                                   = 5,
	DTYPE_Xenon                                        = 6,
	DTYPE_Dingo                                        = 7,
	DTYPE_MAX                                          = 8
};*/

// Enum Engine.SpeedTreeComponent.ESpeedTreeMeshType
/*enum ESpeedTreeMeshType
{
	STMT_MinMinusOne                                   = 0,
	STMT_Branches1                                     = 1,
	STMT_Branches2                                     = 2,
	STMT_Fronds                                        = 3,
	STMT_LeafCards                                     = 4,
	STMT_LeafMeshes                                    = 5,
	STMT_Billboards                                    = 6,
	STMT_Max                                           = 7
};*/

// Enum Engine.SVehicleWheel.EWheelSide
/*enum EWheelSide
{
	SIDE_None                                          = 0,
	SIDE_Left                                          = 1,
	SIDE_Right                                         = 2,
	SIDE_MAX                                           = 3
};*/

// Enum Engine.StaticMesh.EFlexCollisionLevel
/*enum EFlexCollisionLevel
{
	Auto                                               = 0,
	On                                                 = 1,
	Off                                                = 2,
	EFlexCollisionLevel_MAX                            = 3
};*/

// Enum Engine.TerrainMaterial.ETerrainMappingType
/*enum ETerrainMappingType
{
	TMT_Auto                                           = 0,
	TMT_XY                                             = 1,
	TMT_XZ                                             = 2,
	TMT_YZ                                             = 3,
	TMT_MAX                                            = 4
};*/

// Enum Engine.TextureFlipBook.TextureFlipBookMethod
/*enum TextureFlipBookMethod
{
	TFBM_UL_ROW                                        = 0,
	TFBM_UL_COL                                        = 1,
	TFBM_UR_ROW                                        = 2,
	TFBM_UR_COL                                        = 3,
	TFBM_LL_ROW                                        = 4,
	TFBM_LL_COL                                        = 5,
	TFBM_LR_ROW                                        = 6,
	TFBM_LR_COL                                        = 7,
	TFBM_RANDOM                                        = 8,
	TFBM_MAX                                           = 9
};*/

// Enum Engine.TextureMovie.EMovieStreamSource
/*enum EMovieStreamSource
{
	MovieStream_File                                   = 0,
	MovieStream_Memory                                 = 1,
	MovieStream_MAX                                    = 2
};*/

// Enum Engine.TwitterIntegrationBase.ETwitterRequestMethod
/*enum ETwitterRequestMethod
{
	TRM_Get                                            = 0,
	TRM_Post                                           = 1,
	TRM_Delete                                         = 2,
	TRM_MAX                                            = 3
};*/

// Enum Engine.TwitterIntegrationBase.ETwitterIntegrationDelegate
/*enum ETwitterIntegrationDelegate
{
	TID_AuthorizeComplete                              = 0,
	TID_TweetUIComplete                                = 1,
	TID_RequestComplete                                = 2,
	TID_MAX                                            = 3
};*/

// Enum Engine.TWOnlineLobby.ELobbyVisibility
/*enum ELobbyVisibility
{
	LV_Public                                          = 0,
	LV_Friends                                         = 1,
	LV_Private                                         = 2,
	LV_Invisible                                       = 3,
	LV_MAX                                             = 4
};*/

// Enum Engine.UberPostProcessEffect.EPostProcessAAType
/*enum EPostProcessAAType
{
	PostProcessAA_Off                                  = 0,
	PostProcessAA_FXAA0                                = 1,
	PostProcessAA_FXAA1                                = 2,
	PostProcessAA_FXAA2                                = 3,
	PostProcessAA_FXAA3                                = 4,
	PostProcessAA_FXAA4                                = 5,
	PostProcessAA_FXAA5                                = 6,
	PostProcessAA_MLAA                                 = 7,
	PostProcessAA_MAX                                  = 8
};*/

// Enum Engine.UberPostProcessEffect.ETonemapperType
/*enum ETonemapperType
{
	Tonemapper_Off                                     = 0,
	Tonemapper_Filmic                                  = 1,
	Tonemapper_Customizable                            = 2,
	Tonemapper_MAX                                     = 3
};*/

// Enum Engine.UIDataProvider_MenuItem.EMenuOptionType
/*enum EMenuOptionType
{
	MENUOT_ComboReadOnly                               = 0,
	MENUOT_ComboNumeric                                = 1,
	MENUOT_CheckBox                                    = 2,
	MENUOT_Slider                                      = 3,
	MENUOT_Spinner                                     = 4,
	MENUOT_EditBox                                     = 5,
	MENUOT_CollectionCheckBox                          = 6,
	MENUOT_CollapsingList                              = 7,
	MENUOT_MAX                                         = 8
};*/

// Enum Engine.UIDataStore_OnlineStats.EStatsFetchType
/*enum EStatsFetchType
{
	SFT_Player                                         = 0,
	SFT_CenteredOnPlayer                               = 1,
	SFT_Friends                                        = 2,
	SFT_TopRankings                                    = 3,
	SFT_MAX                                            = 4
};*/

// Enum Engine.Weapon.EWeaponFireType
/*enum EWeaponFireType
{
	EWFT_InstantHit                                    = 0,
	EWFT_Projectile                                    = 1,
	EWFT_Custom                                        = 2,
	EWFT_None                                          = 3,
	EWFT_MAX                                           = 4
};*/


/*
# ========================================================================================= #
# Classes
# ========================================================================================= #
*/

// Class Engine.Actor
// 0x01E4 (0x0244 - 0x0060)
class AActor : public UObject
{
public:
	TArray< class UActorComponent* >                   Components;                                       		// 0x0060 (0x0010) [0x0000000000000000]              
	TArray< class UActorComponent* >                   AllComponents;                                    		// 0x0070 (0x0010) [0x0000000000000000]              
	struct FVector                                     Location;                                         		// 0x0080 (0x000C) [0x0000000000000000]              
	struct FRotator                                    Rotation;                                         		// 0x008C (0x000C) [0x0000000000010000]              ( CPF_Travel )
	float                                              DrawScale;                                        		// 0x0098 (0x0004) [0x000000000002033A]              ( CPF_Const | CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_OutParm | CPF_SkipParm | CPF_EditConst )
	struct FVector                                     DrawScale3D;                                      		// 0x009C (0x000C) [0x0000000000000000]              
	struct FVector                                     PrePivot;                                         		// 0x00A8 (0x000C) [0x0000000000000000]              
	struct FColor                                      EditorIconColor;                                  		// 0x00B4 (0x0004) [0x0000000000000000]              
	struct FRenderCommandFence                         DetachFence;                                      		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              CustomTimeDilation;                               		// 0x00BC (0x0004) [0x0000000000000000]              
	unsigned char                                      Physics;                                          		// 0x00C0 (0x0001) [0x000000000003018D]              ( CPF_Edit | CPF_Input | CPF_ExportObject | CPF_Parm | CPF_OutParm | CPF_Travel | CPF_EditConst )
	unsigned char                                      RemoteRole;                                       		// 0x00C1 (0x0001) [0x00000000000402BA]              ( CPF_Const | CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_Parm | CPF_SkipParm | CPF_GlobalConfig )
	unsigned char                                      Role;                                             		// 0x00C2 (0x0001) [0x00000000000502BA]              ( CPF_Const | CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_Parm | CPF_SkipParm | CPF_Travel | CPF_GlobalConfig )
	unsigned char                                      CollisionType;                                    		// 0x00C3 (0x0001) [0x0000000000000000]              
	unsigned char                                      ReplicatedCollisionType;                          		// 0x00C4 (0x0001) [0x000000000006033A]              ( CPF_Const | CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_OutParm | CPF_SkipParm | CPF_EditConst | CPF_GlobalConfig )
	unsigned char                                      TickGroup;                                        		// 0x00C5 (0x0001) [0x0000000000000000]              
	class AActor*                                      Owner;                                            		// 0x00C8 (0x0008) [0x000000000007037A]              ( CPF_Const | CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_EditConstArray | CPF_OutParm | CPF_SkipParm | CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
	class AActor*                                      Base;                                             		// 0x00D0 (0x0008) [0x00000000000800B8]              ( CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_Parm | CPF_Component )
	TArray< struct FTimerData >                        Timers;                                           		// 0x00D8 (0x0010) [0x0000000000000000]              
	DWORD                                              bStatic : 1;                                      		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bHidden : 1;                                      		// 0x00E8 (0x0004) [0x000000000009021C] [0x00000002] ( CPF_Input | CPF_ExportObject | CPF_OptionalParm | CPF_SkipParm | CPF_Travel | CPF_Component )
	DWORD                                              bNoDelete : 1;                                    		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bDeleteMe : 1;                                    		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bTicked : 1;                                      		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bOnlyOwnerSee : 1;                                		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bTickIsDisabled : 1;                              		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bWorldGeometry : 1;                               		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bIgnoreRigidBodyPawns : 1;                        		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bOrientOnSlope : 1;                               		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bIgnoreEncroachers : 1;                           		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bPushedByEncroachers : 1;                         		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bDestroyedByInterpActor : 1;                      		// 0x00E8 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bRouteBeginPlayEvenIfStatic : 1;                  		// 0x00E8 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bIsMoving : 1;                                    		// 0x00E8 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bAlwaysEncroachCheck : 1;                         		// 0x00E8 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bHasAlternateTargetLocation : 1;                  		// 0x00E8 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bCanStepUpOn : 1;                                 		// 0x00E8 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bNetTemporary : 1;                                		// 0x00E8 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bOnlyRelevantToOwner : 1;                         		// 0x00E8 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bNetDirty : 1;                                    		// 0x00E8 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bAlwaysRelevant : 1;                              		// 0x00E8 (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bReplicateInstigator : 1;                         		// 0x00E8 (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bReplicateMovement : 1;                           		// 0x00E8 (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bSkipActorPropertyReplication : 1;                		// 0x00E8 (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bUpdateSimulatedPosition : 1;                     		// 0x00E8 (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bTearOff : 1;                                     		// 0x00E8 (0x0004) [0x00000000000A02BA] [0x04000000] ( CPF_Const | CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_Parm | CPF_SkipParm | CPF_EditConst | CPF_Component )
	DWORD                                              bOnlyDirtyReplication : 1;                        		// 0x00E8 (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bAllowFluidSurfaceInteraction : 1;                		// 0x00E8 (0x0004) [0x0000000000000000] [0x10000000] 
	DWORD                                              bDemoRecording : 1;                               		// 0x00E8 (0x0004) [0x0000000000000000] [0x20000000] 
	DWORD                                              bDemoOwner : 1;                                   		// 0x00E8 (0x0004) [0x0000000000000000] [0x40000000] 
	DWORD                                              bForceDemoRelevant : 1;                           		// 0x00E8 (0x0004) [0x0000000000000000] [0x80000000] 
	DWORD                                              bNetInitialRotation : 1;                          		// 0x00EC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bReplicateRigidBodyLocation : 1;                  		// 0x00EC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bKillDuringLevelTransition : 1;                   		// 0x00EC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bExchangedRoles : 1;                              		// 0x00EC (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bConsiderAllStaticMeshComponentsForStreaming : 1; 		// 0x00EC (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bDebug : 1;                                       		// 0x00EC (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bPostRenderIfNotVisible : 1;                      		// 0x00EC (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bForceNetUpdate : 1;                              		// 0x00EC (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bPendingNetUpdate : 1;                            		// 0x00EC (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bHardAttach : 1;                                  		// 0x00EC (0x0004) [0x00000000000B01EB] [0x00000200] ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Net | CPF_EditConstArray | CPF_Parm | CPF_OutParm | CPF_Travel | CPF_EditConst | CPF_Component )
	DWORD                                              bIgnoreBaseRotation : 1;                          		// 0x00EC (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bShadowParented : 1;                              		// 0x00EC (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bSkipAttachedMoves : 1;                           		// 0x00EC (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bCanBeAdheredTo : 1;                              		// 0x00EC (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bCanBeFrictionedTo : 1;                           		// 0x00EC (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bHurtEntry : 1;                                   		// 0x00EC (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bGameRelevant : 1;                                		// 0x00EC (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bMovable : 1;                                     		// 0x00EC (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bDestroyInPainVolume : 1;                         		// 0x00EC (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bCanBeDamaged : 1;                                		// 0x00EC (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bShouldBaseAtStartup : 1;                         		// 0x00EC (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bPendingDelete : 1;                               		// 0x00EC (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bCanTeleport : 1;                                 		// 0x00EC (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bAlwaysTick : 1;                                  		// 0x00EC (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bBlocksNavigation : 1;                            		// 0x00EC (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              BlockRigidBody : 1;                               		// 0x00EC (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bCollideWhenPlacing : 1;                          		// 0x00EC (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bCollideActors : 1;                               		// 0x00EC (0x0004) [0x00000000000C033A] [0x08000000] ( CPF_Const | CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_OutParm | CPF_SkipParm | CPF_GlobalConfig | CPF_Component )
	DWORD                                              bCollideWorld : 1;                                		// 0x00EC (0x0004) [0x00000000000D033A] [0x10000000] ( CPF_Const | CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_OutParm | CPF_SkipParm | CPF_Travel | CPF_GlobalConfig | CPF_Component )
	DWORD                                              bCollideComplex : 1;                              		// 0x00EC (0x0004) [0x0000000000000000] [0x20000000] 
	DWORD                                              bBlockActors : 1;                                 		// 0x00EC (0x0004) [0x00000000000E025C] [0x40000000] ( CPF_Input | CPF_ExportObject | CPF_OptionalParm | CPF_EditConstArray | CPF_SkipParm | CPF_EditConst | CPF_GlobalConfig | CPF_Component )
	DWORD                                              bProjTarget : 1;                                  		// 0x00EC (0x0004) [0x00000000000F025C] [0x80000000] ( CPF_Input | CPF_ExportObject | CPF_OptionalParm | CPF_EditConstArray | CPF_SkipParm | CPF_Travel | CPF_EditConst | CPF_GlobalConfig | CPF_Component )
	DWORD                                              bBlocksTeleport : 1;                              		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bMoveIgnoresDestruction : 1;                      		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bProjectileMoveSingleBlocking : 1;                		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bNoEncroachCheck : 1;                             		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bCollideAsEncroacher : 1;                         		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bPhysRigidBodyOutOfWorldCheck : 1;                		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bComponentOutsideWorld : 1;                       		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bForceOctreeSNFilter : 1;                         		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bForceOctreeMNFilter : 1;                         		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bRigidBodyWasAwake : 1;                           		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bCallRigidBodyWakeEvents : 1;                     		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bBounce : 1;                                      		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bJustTeleported : 1;                              		// 0x00F0 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bEnableMobileTouch : 1;                           		// 0x00F0 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bNetInitial : 1;                                  		// 0x00F0 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bNetOwner : 1;                                    		// 0x00F0 (0x0004) [0x00000000001002BA] [0x00008000] ( CPF_Const | CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_Parm | CPF_SkipParm )
	DWORD                                              bHiddenEd : 1;                                    		// 0x00F0 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bEditable : 1;                                    		// 0x00F0 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bHiddenEdGroup : 1;                               		// 0x00F0 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bHiddenEdLayer : 1;                               		// 0x00F0 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bHiddenEdCustom : 1;                              		// 0x00F0 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bHiddenEdTemporary : 1;                           		// 0x00F0 (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bHiddenEdLevel : 1;                               		// 0x00F0 (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bHiddenEdScene : 1;                               		// 0x00F0 (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bEdShouldSnap : 1;                                		// 0x00F0 (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bTempEditor : 1;                                  		// 0x00F0 (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bPathColliding : 1;                               		// 0x00F0 (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bPathTemp : 1;                                    		// 0x00F0 (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bScriptInitialized : 1;                           		// 0x00F0 (0x0004) [0x0000000000000000] [0x10000000] 
	DWORD                                              bLockLocation : 1;                                		// 0x00F0 (0x0004) [0x0000000000000000] [0x20000000] 
	DWORD                                              bForceAllowKismetModification : 1;                		// 0x00F0 (0x0004) [0x0000000000000000] [0x40000000] 
	DWORD                                              bDebugEffectIsRelevant : 1;                       		// 0x00F0 (0x0004) [0x0000000000000000] [0x80000000] 
	DWORD                                              bLoadIfPhysXLevel0 : 1;                           		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLoadIfPhysXLevel1 : 1;                           		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bLoadIfPhysXLevel2 : 1;                           		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bCrawlable : 1;                                   		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bIgnoreAudioOcclusion : 1;                        		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bIgnoreNetRelevancyCollision : 1;                 		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bOverride_OcclusionFlags : 1;                     		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bSkipPostTickComponentUpdate : 1;                 		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000080] 
	int                                                SkelMeshCompTickTag;                              		// 0x00F8 (0x0004) [0x0000000000000000]              
	int                                                NetTag;                                           		// 0x00FC (0x0004) [0x0000000000000000]              
	float                                              NetUpdateTime;                                    		// 0x0100 (0x0004) [0x0000000000000000]              
	float                                              NetUpdateFrequency;                               		// 0x0104 (0x0004) [0x0000000000000000]              
	float                                              NetPriority;                                      		// 0x0108 (0x0004) [0x0000000000000000]              
	float                                              LastNetUpdateTime;                                		// 0x010C (0x0004) [0x0000000000000000]              
	float                                              TimeSinceLastTick;                                		// 0x0110 (0x0004) [0x0000000000000000]              
	class APawn*                                       Instigator;                                       		// 0x0114 (0x0008) [0x00000000001102EB]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Net | CPF_EditConstArray | CPF_Parm | CPF_SkipParm | CPF_Travel )
	class AWorldInfo*                                  WorldInfo;                                        		// 0x011C (0x0008) [0x0000000000000000]              
	float                                              LifeSpan;                                         		// 0x0124 (0x0004) [0x0000000000000000]              
	float                                              CreationTime;                                     		// 0x0128 (0x0004) [0x0000000000000000]              
	float                                              LastRenderTime;                                   		// 0x012C (0x0004) [0x0000000000000000]              
	struct FName                                       Tag;                                              		// 0x0130 (0x0008) [0x0000000000000000]              
	struct FName                                       InitialState;                                     		// 0x0138 (0x0008) [0x0000000000000000]              
	struct FName                                       Layer;                                            		// 0x0140 (0x0008) [0x0000000000000000]              
	struct FName                                       Group;                                            		// 0x0148 (0x0008) [0x0000000000000000]              
	struct FQWord                                      HiddenEditorViews;                                		// 0x0150 (0x0008) [0x0000000000000000]              
	TArray< class AActor* >                            Touching;                                         		// 0x0158 (0x0010) [0x0000000000000000]              
	TArray< class AActor* >                            Children;                                         		// 0x0168 (0x0010) [0x0000000000000000]              
	float                                              LatentFloat;                                      		// 0x0178 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           LatentSeqNode;                                    		// 0x017C (0x0008) [0x0000000000000000]              
	class APhysicsVolume*                              PhysicsVolume;                                    		// 0x0184 (0x0008) [0x0000000000000000]              
	struct FVector                                     Velocity;                                         		// 0x018C (0x000C) [0x000000000012018D]              ( CPF_Edit | CPF_Input | CPF_ExportObject | CPF_Parm | CPF_OutParm | CPF_EditConst )
	struct FVector                                     Acceleration;                                     		// 0x0198 (0x000C) [0x0000000000000000]              
	struct FVector                                     AngularVelocity;                                  		// 0x01A4 (0x000C) [0x0000000000000000]              
	class USkeletalMeshComponent*                      BaseSkelComponent;                                		// 0x01B0 (0x0008) [0x0000000000000000]              
	struct FName                                       BaseBoneName;                                     		// 0x01B8 (0x0008) [0x0000000000000000]              
	TArray< class AActor* >                            Attached;                                         		// 0x01C0 (0x0010) [0x0000000000000000]              
	struct FVector                                     RelativeLocation;                                 		// 0x01D0 (0x000C) [0x00000000001300F8]              ( CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_EditConstArray | CPF_Parm | CPF_Travel | CPF_EditConst )
	struct FRotator                                    RelativeRotation;                                 		// 0x01DC (0x000C) [0x00000000001400F8]              ( CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_EditConstArray | CPF_Parm | CPF_GlobalConfig )
	class UPrimitiveComponent*                         CollisionComponent;                               		// 0x01E8 (0x0008) [0x0000000000000000]              
	int                                                OverlapTag;                                       		// 0x01F0 (0x0004) [0x0000000000000000]              
	struct FRotator                                    RotationRate;                                     		// 0x01F4 (0x000C) [0x0000000000000000]              
	class AActor*                                      PendingTouch;                                     		// 0x0200 (0x0008) [0x0000000000000000]              
	class UClass*                                      MessageClass;                                     		// 0x0208 (0x0008) [0x0000000000000000]              
	TArray< class UClass* >                            SupportedEvents;                                  		// 0x0210 (0x0010) [0x0000000000000000]              
	TArray< class USequenceEvent* >                    GeneratedEvents;                                  		// 0x0220 (0x0010) [0x0000000000000000]              
	TArray< class USeqAct_Latent* >                    LatentActions;                                    		// 0x0230 (0x0010) [0x0000000000000000]              
	float                                              ActorTimeSeconds;                                 		// 0x0240 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Actor" );

		return pClassPointer;
	};

	void ActorTimeSince ( );
	void GetActorTimeSeconds ( );
	void OnAnimNotifyParticleSystemSpawned ( );
	void AdjustRadiusDamage ( );
	void GetActorSpriteComponent ( );
	void GetActorMetrics ( );
	void eventOnMobileTouch ( );
	void IsMobileTouchEnabled ( );
	void ShouldBeHiddenBySHOW_NavigationNodes ( );
	void WillOverlap ( );
	void GetAvoidanceVector ( );
	void eventReplicationEnded ( );
	void eventPostDemoRewind ( );
	void eventAnimTreeUpdated ( );
	void SupportsKismetModification ( );
	void GetAnimTrailParticleSystem ( );
	void eventTrailsNotifyEnd ( );
	void eventTrailsNotifyTick ( );
	void eventTrailsNotify ( );
	void eventCreateForceField ( );
	void eventPlayParticleEffect ( );
	void GetAimAdhesionExtent ( );
	void GetAimFrictionExtent ( );
	void IsInPersistentLevel ( );
	void eventOnRigidBodySpringOverextension ( );
	void GetPackageGuid ( );
	void eventPostInitAnimTree ( );
	void eventRootMotionExtracted ( );
	void eventRootMotionProcessed ( );
	void eventRootMotionModeChanged ( );
	void eventPostRenderFor ( );
	void NativePostRenderFor ( );
	void SetHUDLocation ( );
	void eventOnRanOver ( );
	void eventRigidBodyCollision ( );
	void eventInterpolationChanged ( );
	void eventInterpolationFinished ( );
	void eventInterpolationStarted ( );
	void eventSpawnedByKismet ( );
	void GetTargetLocation ( );
	void FindGoodEndView ( );
	void NotifyLocalPlayerTeamReceived ( );
	void eventScriptGetTeamNum ( );
	void GetTeamNum ( );
	void PawnBaseDied ( );
	void IsPlayerOwned ( );
	void eventGetActorEyesViewPoint ( );
	void IsStationary ( );
	void eventGetActorFaceFXAsset ( );
	void CanActorPlayFaceFXAnim ( );
	void IsActorPlayingFaceFXAnim ( );
	void eventTickSkelControl ( );
	void eventSetSkelControlScale ( );
	void eventSetMorphWeight ( );
	void eventStopActorFaceFXAnim ( );
	void eventPlayActorFaceFXAnim ( );
	void eventFinishAnimControl ( );
	void eventSetAnimPosition ( );
	void eventBeginAnimControl ( );
	void eventOnAnimPlay ( );
	void eventOnAnimEnd ( );
	void DoKismetAttachment ( );
	void OnAttachToActor ( );
	void OnToggleHidden ( );
	void OnChangeCollision ( );
	void OnSetPhysics ( );
	void OnSetBlockRigidBody ( );
	void OnSetVelocity ( );
	void OnTeleport ( );
	void OnModifyHealth ( );
	void PrestreamTextures ( );
	void eventShutDown ( );
	void SetNetUpdateTime ( );
	void eventForceNetRelevant ( );
	void OnDestroy ( );
	void ClearLatentAction ( );
	void FindEventsOfClass ( );
	void ActivateEventClass ( );
	void TriggerGlobalEventClass ( );
	void eventReceivedNewEvent ( );
	void TriggerEventClass ( );
	void eventDebugMessagePlayer ( );
	void ImpactEffectIsRelevant ( );
	void ActorEffectIsRelevant ( );
	void EffectIsRelevant ( );
	void ApplyFluidSurfaceImpact ( );
	void CanSplash ( );
	void PlayTeleportEffect ( );
	void IsInPain ( );
	void eventReset ( );
	void eventGetFaceFXAudioComponent ( );
	void eventModifyHearSoundComponent ( );
	void GetPhysicsName ( );
	void DisplayDebug ( );
	void GetDebugName ( );
	void MatchStarting ( );
	void GetLocalString ( );
	void ReplaceText ( );
	void GetHumanReadableName ( );
	void GetItemName ( );
	void CalcCamera ( );
	void eventEndViewTarget ( );
	void eventBecomeViewTarget ( );
	void CheckForErrors ( );
	void eventDebugFreezeGame ( );
	void GetGravityZ ( );
	void CheckHitInfo ( );
	void TakeRadiusDamage ( );
	void eventHealDamage ( );
	void eventTakeDamage ( );
	void KilledBy ( );
	void HurtRadius ( );
	void StopsProjectile ( );
	void eventNotifySkelControlBeyondLimit ( );
	void eventConstraintBrokenNotify ( );
	void eventSetInitialState ( );
	void eventPostBeginPlay ( );
	void eventBroadcastLocalizedTeamMessage ( );
	void eventBroadcastLocalizedMessage ( );
	void eventPreBeginPlay ( );
	void GetALocalPlayerController ( );
	void LocalPlayerControllers ( );
	void AllOwnedComponents ( );
	void ComponentList ( );
	void OverlappingActors ( );
	void CollidingActors ( );
	void VisibleCollidingActors ( );
	void VisibleActors ( );
	void TraceActors ( );
	void TouchingActors ( );
	void BasedActors ( );
	void ChildActors ( );
	void DynamicActors ( );
	void AllActors ( );
	void GetURLMap ( );
	void PostTeleport ( );
	void PreTeleport ( );
	void GetDestination ( );
	void CalculateMinSpeedTrajectory ( );
	void SuggestTossVelocity ( );
	void PlayerCanSeeMe ( );
	void MakeNoise ( );
	void ActivateOcclusion ( );
	void PostTrigger ( );
	void SetSwitch ( );
	void SetState ( );
	void GetAKRotation ( );
	void SetRTPCValue ( );
	void StopAkEventsOnBone ( );
	void PostAkEventOnBone ( );
	void PostAkEventAtLocation ( );
	void PostAkEvent ( );
	void PlaySoundBase ( );
	void PlayAkEvent ( );
	void PlaySound ( );
	void CreateAudioComponent ( );
	void ResetTimerTimeDilation ( );
	void ModifyTimerTimeDilation ( );
	void GetRemainingTimeForTimer ( );
	void GetTimerRate ( );
	void GetTimerCount ( );
	void IsTimerActive ( );
	void PauseTimer ( );
	void ClearAllTimers ( );
	void ClearTimer ( );
	void SetTimer ( );
	void eventTornOff ( );
	void Destroy ( );
	void Spawn ( );
	void IsBlockedBy ( );
	void GetBoundingCylinder ( );
	void GetComponentsBoundingBox ( );
	void IsOverlapping ( );
	void ContainsPoint ( );
	void FindSpot ( );
	void TraceAllPhysicsAssetInteractions ( );
	void FastTrace ( );
	void PointCheckComponent ( );
	void TraceComponent ( );
	bool Trace(FVector Start, FVector End, AActor* Hit);
	void VolumeBasedDestroy ( );
	void eventOutsideWorldBounds ( );
	void eventFellOutOfWorld ( );
	void UsedBy ( );
	void eventOverRotated ( );
	void ClampRotation ( );
	void eventOnSleepRBPhysics ( );
	void eventOnWakeRBPhysics ( );
	void eventRanInto ( );
	void eventEncroachedBy ( );
	void eventEncroachingOn ( );
	void eventCollisionChanged ( );
	void eventSpecialHandling ( );
	void eventDetach ( );
	void eventAttach ( );
	void eventBaseChange ( );
	void eventBump ( );
	void eventUnTouch ( );
	void eventPostTouch ( );
	void eventTouch ( );
	void eventPhysicsVolumeChange ( );
	void eventLanded ( );
	void eventFalling ( );
	void eventHitWall ( );
	void eventTimer ( );
	void eventTick ( );
	void eventLostChild ( );
	void eventGainedChild ( );
	void eventDestroyed ( );
	void SetTickIsDisabled ( );
	void SetTickGroup ( );
	void ReattachComponent ( );
	void DetachComponent ( );
	void AttachComponent ( );
	void UnClock ( );
	void Clock ( );
	void SetPhysics ( );
	void SetOnlyOwnerSee ( );
	void SetHidden ( );
	void ChartData ( );
	void FlushDebugStrings ( );
	void DrawDebugFrustrum ( );
	void DrawDebugString ( );
	void DrawDebugCone ( );
	void DrawDebugCylinder ( );
	void DrawDebugSphere ( );
	void DrawDebugCoordinateSystem ( );
	void DrawDebugStar ( );
	void DrawDebugBox ( );
	void DrawDebugPoint ( );
	void DrawDebugLine ( );
	void FlushPersistentDebugLines ( );
	void GetBasedPosition ( );
	void SetBasedPosition ( );
	void BP2Vect ( );
	void Vect2BP ( );
	void SetForcedInitialReplicatedProperty ( );
	void eventReplicatedEvent ( );
	void GetAggregateBaseVelocity ( );
	void IsOwnedBy ( );
	void GetBaseMost ( );
	void IsBasedOn ( );
	void SearchForBaseBelow ( );
	void FindBase ( );
	void SetOwner ( );
	void SetBase ( );
	void GetTerminalVelocity ( );
	void AutonomousPhysics ( );
	void MoveSmooth ( );
	void fixedTurn ( );
	void SetShadowParentOnAllAttachedComponents ( );
	void SetHardAttach ( );
	void SetRelativeLocation ( );
	void SetRelativeRotation ( );
	void SetZone ( );
	void MovingWhichWay ( );
	void SetRotation ( );
	void SetLocation ( );
	void Move ( );
	void SetDrawScale3D ( );
	void SetDrawScale ( );
	void SetCollisionType ( );
	void SetCollisionSize ( );
	void SetCollision ( );
	void FinishAnim ( );
	void Sleep ( );
	void ConsoleCommand ( );
	void ForceUpdateComponents ( );
};

UClass* AActor::pClassPointer = NULL;

// Class Engine.Info
// 0x0000 (0x0244 - 0x0244)
class AInfo : public AActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Info" );

		return pClassPointer;
	};

};

UClass* AInfo::pClassPointer = NULL;

// Class Engine.ZoneInfo
// 0x0014 (0x0258 - 0x0244)
class AZoneInfo : public AInfo
{
public:
	float                                              KillZ;                                            		// 0x0244 (0x0004) [0x0000000000000000]              
	float                                              SoftKill;                                         		// 0x0248 (0x0004) [0x0000000000000000]              
	class UClass*                                      KillZDamageType;                                  		// 0x024C (0x0008) [0x0000000000000000]              
	DWORD                                              bSoftKillZ : 1;                                   		// 0x0254 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ZoneInfo" );

		return pClassPointer;
	};

};

UClass* AZoneInfo::pClassPointer = NULL;

// Class Engine.WorldInfo
// 0x0A88 (0x0CE0 - 0x0258)
class AWorldInfo : public AZoneInfo
{
public:
	DWORD                                              UseCheckbackMatchmaking : 1;                      		// 0x0258 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPersistPostProcessToNextLevel : 1;               		// 0x0258 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDisableWholeSceneDominantShadow : 1;             		// 0x0258 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bFogEnabled : 1;                                  		// 0x0258 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bBumpOffsetEnabled : 1;                           		// 0x0258 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bUseGammaCorrection : 1;                          		// 0x0258 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bMapNeedsLightingFullyRebuilt : 1;                		// 0x0258 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bMapHasMultipleDominantLightsAffectingOnePrimitive : 1;		// 0x0258 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bMapHasPathingErrors : 1;                         		// 0x0258 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bRequestedBlockOnAsyncLoading : 1;                		// 0x0258 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bBegunPlay : 1;                                   		// 0x0258 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bPlayersOnly : 1;                                 		// 0x0258 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bPlayersOnlyPending : 1;                          		// 0x0258 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bSuspendAI : 1;                                   		// 0x0258 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bDropDetail : 1;                                  		// 0x0258 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bAggressiveLOD : 1;                               		// 0x0258 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bStartup : 1;                                     		// 0x0258 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bPathsRebuilt : 1;                                		// 0x0258 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bHasPathNodes : 1;                                		// 0x0258 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bIsMenuLevel : 1;                                 		// 0x0258 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bDebugPauseExecution : 1;                         		// 0x0258 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bDebugStepExecution : 1;                          		// 0x0258 (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bUseConsoleInput : 1;                             		// 0x0258 (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bMapNeedsSplatterMapsRebuilt : 1;                 		// 0x0258 (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bMapNeedsPrecomputedVisibilityRebuilt : 1;        		// 0x0258 (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bMinimizeBSPSections : 1;                         		// 0x0258 (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bNoDefaultInventoryForPlayer : 1;                 		// 0x0258 (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bNoPathWarnings : 1;                              		// 0x0258 (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bNoMobileMapWarnings : 1;                         		// 0x0258 (0x0004) [0x0000000000000000] [0x10000000] 
	DWORD                                              bHighPriorityLoading : 1;                         		// 0x0258 (0x0004) [0x0000000000150000] [0x20000000] ( CPF_Travel | CPF_GlobalConfig )
	DWORD                                              bHighPriorityLoadingLocal : 1;                    		// 0x0258 (0x0004) [0x0000000000000000] [0x40000000] 
	DWORD                                              bUseProcBuildingRulesetOverride : 1;              		// 0x0258 (0x0004) [0x0000000000000000] [0x80000000] 
	DWORD                                              bInteractiveMode : 1;                             		// 0x025C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSupportDoubleBufferedPhysics : 1;                		// 0x025C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bPhysicsIgnoreDeltaTime : 1;                      		// 0x025C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bEnableChanceOfPhysicsChunkOverride : 1;          		// 0x025C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bLimitExplosionChunkSize : 1;                     		// 0x025C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bLimitDamageChunkSize : 1;                        		// 0x025C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bPrecomputeVisibility : 1;                        		// 0x025C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bPlaceCellsOnSurfaces : 1;                        		// 0x025C (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bPlaceCellsOnOpaqueOnly : 1;                      		// 0x025C (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bCompressVisibilityData : 1;                      		// 0x025C (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bAllowTemporalAA : 1;                             		// 0x025C (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bUseGlobalIllumination : 1;                       		// 0x025C (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bForceNoPrecomputedLighting : 1;                  		// 0x025C (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bHaveActiveCrowd : 1;                             		// 0x025C (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bAllowHostMigration : 1;                          		// 0x025C (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bGameplayFramePause : 1;                          		// 0x025C (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bUsePxVisibilityCollision : 1;                    		// 0x025C (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bAllowExplosionLights : 1;                        		// 0x025C (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bDropHighDetail : 1;                              		// 0x025C (0x0004) [0x0000000000000000] [0x00040000] 
	struct FPostProcessSettings                        DefaultPostProcessSettings;                       		// 0x0260 (0x0220) [0x0000000000000000]              
	class UPostProcessChain*                           WorldPostProcessChain;                            		// 0x0480 (0x0008) [0x0000000000000000]              
	float                                              SquintModeKernelSize;                             		// 0x0488 (0x0004) [0x0000000000000000]              
	float                                              LevelShadowDepthBias;                             		// 0x048C (0x0004) [0x0000000000000000]              
	class APostProcessVolume*                          HighestPriorityPostProcessVolume;                 		// 0x0490 (0x0008) [0x0000000000000000]              
	struct FReverbSettings                             DefaultReverbSettings;                            		// 0x0498 (0x0010) [0x0000000000000000]              
	struct FInteriorSettings                           DefaultAmbientZoneSettings;                       		// 0x04A8 (0x0024) [0x0000000000000000]              
	float                                              FogStart;                                         		// 0x04CC (0x0004) [0x0000000000000000]              
	float                                              FogEnd;                                           		// 0x04D0 (0x0004) [0x0000000000000000]              
	struct FColor                                      FogColor;                                         		// 0x04D4 (0x0004) [0x0000000000000000]              
	float                                              BumpEnd;                                          		// 0x04D8 (0x0004) [0x0000000000000000]              
	class AReverbVolume*                               HighestPriorityReverbVolume;                      		// 0x04DC (0x0008) [0x0000000000000000]              
	TArray< class AMassiveLODOverrideVolume* >         MassiveLODOverrideVolumes;                        		// 0x04E4 (0x0010) [0x0000000000000000]              
	TArray< class APortalVolume* >                     PortalVolumes;                                    		// 0x04F4 (0x0010) [0x0000000000000000]              
	TArray< class AEnvironmentVolume* >                EnvironmentVolumes;                               		// 0x0504 (0x0010) [0x0000000000000000]              
	TArray< class ULevelStreaming* >                   StreamingLevels;                                  		// 0x0514 (0x0010) [0x0000000000000000]              
	struct FDouble                                     LastTimeUnbuiltLightingWasEncountered;            		// 0x0524 (0x0008) [0x0000000000000000]              
	class UBookMark*                                   BookMarks[ 0xA ];                                 		// 0x052C (0x0050) [0x0000000000000000]              
	class UKismetBookMark*                             KismetBookMarks[ 0xA ];                           		// 0x057C (0x0050) [0x0000000000000000]              
	TArray< class UClipPadEntry* >                     ClipPadEntries;                                   		// 0x05CC (0x0010) [0x0000000000000000]              
	float                                              TimeDilation;                                     		// 0x05DC (0x0004) [0x0000000000160000]              ( CPF_EditConst | CPF_GlobalConfig )
	float                                              DemoPlayTimeDilation;                             		// 0x05E0 (0x0004) [0x0000000000000000]              
	float                                              TimeSeconds;                                      		// 0x05E4 (0x0004) [0x0000000000000000]              
	float                                              RealTimeSeconds;                                  		// 0x05E8 (0x0004) [0x0000000000000000]              
	float                                              AudioTimeSeconds;                                 		// 0x05EC (0x0004) [0x0000000000000000]              
	float                                              DeltaSeconds;                                     		// 0x05F0 (0x0004) [0x0000000000000000]              
	float                                              PauseDelay;                                       		// 0x05F4 (0x0004) [0x0000000000000000]              
	float                                              RealTimeToUnPause;                                		// 0x05F8 (0x0004) [0x0000000000000000]              
	class APlayerReplicationInfo*                      Pauser;                                           		// 0x05FC (0x0008) [0x0000000000170000]              ( CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
	struct FString                                     VisibleGroups;                                    		// 0x0604 (0x0010) [0x0000000000000000]              
	struct FString                                     VisibleLayers;                                    		// 0x0614 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  DefaultTexture;                                   		// 0x0624 (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  WireframeTexture;                                 		// 0x062C (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  WhiteSquareTexture;                               		// 0x0634 (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  LargeVertex;                                      		// 0x063C (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  BSPVertex;                                        		// 0x0644 (0x0008) [0x0000000000000000]              
	TArray< struct FString >                           DeferredExecs;                                    		// 0x064C (0x0010) [0x0000000000000000]              
	class AGameReplicationInfo*                        GRI;                                              		// 0x065C (0x0008) [0x0000000000000000]              
	unsigned char                                      NetMode;                                          		// 0x0664 (0x0001) [0x0000000000000000]              
	unsigned char                                      NextTravelType;                                   		// 0x0665 (0x0001) [0x0000000000000000]              
	unsigned char                                      VisibilityAggressiveness;                         		// 0x0666 (0x0001) [0x0000000000000000]              
	unsigned char                                      PreferredLightmapType;                            		// 0x0667 (0x0001) [0x0000000000000000]              
	unsigned char                                      LevelLightingQuality;                             		// 0x0668 (0x0001) [0x0000000000000000]              
	struct FString                                     ComputerName;                                     		// 0x066C (0x0010) [0x0000000000000000]              
	struct FString                                     EngineVersion;                                    		// 0x067C (0x0010) [0x0000000000000000]              
	struct FString                                     MinNetVersion;                                    		// 0x068C (0x0010) [0x0000000000000000]              
	class AGameInfo*                                   Game;                                             		// 0x069C (0x0008) [0x0000000000000000]              
	float                                              StallZ;                                           		// 0x06A4 (0x0004) [0x0000000000000000]              
	float                                              WorldGravityZ;                                    		// 0x06A8 (0x0004) [0x0000000000180000]              ( CPF_Component )
	float                                              DefaultGravityZ;                                  		// 0x06AC (0x0004) [0x0000000000000000]              
	float                                              GlobalGravityZ;                                   		// 0x06B0 (0x0004) [0x0000000000000000]              
	float                                              RBPhysicsGravityScaling;                          		// 0x06B4 (0x0004) [0x0000000000000000]              
	class ANavigationPoint*                            NavigationPointList;                              		// 0x06B8 (0x0008) [0x0000000000000000]              
	class AController*                                 ControllerList;                                   		// 0x06C0 (0x0008) [0x0000000000000000]              
	class APawn*                                       PawnList;                                         		// 0x06C8 (0x0008) [0x0000000000000000]              
	class ACoverLink*                                  CoverList;                                        		// 0x06D0 (0x0008) [0x0000000000000000]              
	class APylon*                                      PylonList;                                        		// 0x06D8 (0x0008) [0x0000000000000000]              
	float                                              MoveRepSize;                                      		// 0x06E0 (0x0004) [0x0000000000000000]              
	TArray< struct FNetViewer >                        ReplicationViewers;                               		// 0x06E4 (0x0010) [0x0000000000000000]              
	struct FString                                     NextURL;                                          		// 0x06F4 (0x0010) [0x0000000000000000]              
	float                                              NextSwitchCountdown;                              		// 0x0704 (0x0004) [0x0000000000000000]              
	int                                                PackedLightAndShadowMapTextureSize;               		// 0x0708 (0x0004) [0x0000000000000000]              
	struct FVector                                     DefaultColorScale;                                		// 0x070C (0x000C) [0x0000000000000000]              
	class UClass*                                      DefaultGameType;                                  		// 0x0718 (0x0008) [0x0000000000000000]              
	TArray< class UClass* >                            GameTypesSupportedOnThisMap;                      		// 0x0720 (0x0010) [0x0000000000000000]              
	class UClass*                                      GameTypeForPIE;                                   		// 0x0730 (0x0008) [0x0000000000000000]              
	TArray< class UObject* >                           ClientDestroyedActorContent;                      		// 0x0738 (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             PreparingLevelNames;                              		// 0x0748 (0x0010) [0x0000000000000000]              
	struct FName                                       CommittedPersistentLevelName;                     		// 0x0758 (0x0008) [0x0000000000000000]              
	class UObjectReferencer*                           PersistentMapForcedObjects;                       		// 0x0760 (0x0008) [0x0000000000000000]              
	class UAudioComponent*                             MusicComp;                                        		// 0x0768 (0x0008) [0x0000000000000000]              
	struct FMusicTrackStruct                           CurrentMusicTrack;                                		// 0x0770 (0x002C) [0x0000000000000000]              
	struct FMusicTrackStruct                           ReplicatedMusicTrack;                             		// 0x079C (0x002C) [0x0000000000190000]              ( CPF_Travel | CPF_Component )
	struct FString                                     Title;                                            		// 0x07C8 (0x0010) [0x0000000000000000]              
	struct FString                                     Author;                                           		// 0x07D8 (0x0010) [0x0000000000000000]              
	class UMapInfo*                                    MyMapInfo;                                        		// 0x07E8 (0x0008) [0x0000000000000000]              
	struct FString                                     EmitterPoolClassPath;                             		// 0x07F0 (0x0010) [0x0000000000000000]              
	class AEmitterPool*                                MyEmitterPool;                                    		// 0x0800 (0x0008) [0x0000000000000000]              
	struct FString                                     DecalManagerClassPath;                            		// 0x0808 (0x0010) [0x0000000000000000]              
	class ADecalManager*                               MyDecalManager;                                   		// 0x0818 (0x0008) [0x0000000000000000]              
	struct FString                                     FractureManagerClassPath;                         		// 0x0820 (0x0010) [0x0000000000000000]              
	class AFractureManager*                            MyFractureManager;                                		// 0x0830 (0x0008) [0x0000000000000000]              
	struct FString                                     ParticleEventManagerClassPath;                    		// 0x0838 (0x0010) [0x0000000000000000]              
	class AParticleEventManager*                       MyParticleEventManager;                           		// 0x0848 (0x0008) [0x0000000000000000]              
	class UProcBuildingRuleset*                        ProcBuildingRulesetOverride;                      		// 0x0850 (0x0008) [0x0000000000000000]              
	int                                                SkelMeshCompTickTagCount;                         		// 0x0858 (0x0004) [0x0000000000000000]              
	float                                              MaxPhysicsDeltaTime;                              		// 0x085C (0x0004) [0x0000000000000000]              
	int                                                MaxPhysicsSubsteps;                               		// 0x0860 (0x0004) [0x0000000000000000]              
	struct FPhysXSceneProperties                       PhysicsProperties;                                		// 0x0864 (0x003C) [0x0000000000000000]              
	TArray< struct FCompartmentRunList >               CompartmentRunFrames;                             		// 0x08A0 (0x0010) [0x0000000000000000]              
	float                                              DefaultSkinWidth;                                 		// 0x08B0 (0x0004) [0x0000000000000000]              
	float                                              ApexLODResourceBudget;                            		// 0x08B4 (0x0004) [0x0000000000000000]              
	float                                              ApexDestructionLODResourceValue;                  		// 0x08B8 (0x0004) [0x0000000000000000]              
	float                                              ApexClothingLODResourceValue;                     		// 0x08BC (0x0004) [0x0000000000000000]              
	struct FApexModuleDestructibleSettings             DestructibleSettings;                             		// 0x08C0 (0x0014) [0x0000000000000000]              
	class UPhysicsLODVerticalEmitter*                  EmitterVertical;                                  		// 0x08D4 (0x0008) [0x0000000000000000]              
	struct FPhysXVerticalProperties                    VerticalProperties;                               		// 0x08DC (0x0018) [0x0000000000000000]              
	TArray< struct FPointer >                          WorldAttractors;                                  		// 0x08F4 (0x0010) [0x0000000000000000]              
	float                                              ChanceOfPhysicsChunkOverride;                     		// 0x0904 (0x0004) [0x0000000000000000]              
	float                                              MaxExplosionChunkSize;                            		// 0x0908 (0x0004) [0x0000000000000000]              
	float                                              MaxDamageChunkSize;                               		// 0x090C (0x0004) [0x0000000000000000]              
	float                                              FractureExplosionVelScale;                        		// 0x0910 (0x0004) [0x0000000000000000]              
	int                                                MaxNumFacturedChunksToSpawnInAFrame;              		// 0x0914 (0x0004) [0x0000000000000000]              
	int                                                NumFacturedChunksSpawnedThisFrame;                		// 0x0918 (0x0004) [0x0000000000000000]              
	float                                              FracturedMeshWeaponDamage;                        		// 0x091C (0x0004) [0x0000000000000000]              
	int                                                VisibilityCellSize;                               		// 0x0920 (0x0004) [0x0000000000000000]              
	int                                                VisibilitySpreadingIterations;                    		// 0x0924 (0x0004) [0x0000000000000000]              
	float                                              MeshBoundsScale;                                  		// 0x0928 (0x0004) [0x0000000000000000]              
	float                                              PlayAreaHeight;                                   		// 0x092C (0x0004) [0x0000000000000000]              
	int                                                MinMeshSamples;                                   		// 0x0930 (0x0004) [0x0000000000000000]              
	int                                                MaxMeshSamples;                                   		// 0x0934 (0x0004) [0x0000000000000000]              
	int                                                NumCellSamples;                                   		// 0x0938 (0x0004) [0x0000000000000000]              
	int                                                NumImportanceSamples;                             		// 0x093C (0x0004) [0x0000000000000000]              
	int                                                CellRenderingBucketSize;                          		// 0x0940 (0x0004) [0x0000000000000000]              
	int                                                NumCellRenderingBuckets;                          		// 0x0944 (0x0004) [0x0000000000000000]              
	int                                                NumCellDistributionBuckets;                       		// 0x0948 (0x0004) [0x0000000000000000]              
	float                                              CharacterLitIndirectBrightness;                   		// 0x094C (0x0004) [0x0000000000000000]              
	float                                              CharacterLitIndirectContrastFactor;               		// 0x0950 (0x0004) [0x0000000000000000]              
	float                                              CharacterShadowedIndirectBrightness;              		// 0x0954 (0x0004) [0x0000000000000000]              
	float                                              CharacterShadowedIndirectContrastFactor;          		// 0x0958 (0x0004) [0x0000000000000000]              
	float                                              CharacterLightingContrastFactor;                  		// 0x095C (0x0004) [0x0000000000000000]              
	class UTexture2D*                                  ImageReflectionEnvironmentTexture;                		// 0x0960 (0x0008) [0x0000000000000000]              
	struct FLinearColor                                ImageReflectionEnvironmentColor;                  		// 0x0968 (0x0010) [0x0000000000000000]              
	float                                              ImageReflectionEnvironmentRotation;               		// 0x0978 (0x0004) [0x0000000000000000]              
	struct FMap_Mirror                                 ScreenMessages;                                   		// 0x097C (0x0048) [0x0000000000000000]              
	TArray< struct FScreenMessageString >              PriorityScreenMessages;                           		// 0x09C4 (0x0010) [0x0000000000000000]              
	int                                                MaxTrianglesPerLeaf;                              		// 0x09D4 (0x0004) [0x0000000000000000]              
	class ULightmassLevelSettings*                     LMLevelSettings;                                  		// 0x09D8 (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x09E0 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.WorldInfo.LandscapeInfoMap
	struct FLightmassWorldInfoSettings                 LightmassSettings;                                		// 0x0A28 (0x0058) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x48 ];                            		// 0x0A80 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.WorldInfo.NavMeshPathConstraintCache
	unsigned char                                      UnknownData02[ 0x48 ];                            		// 0x0AC8 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.WorldInfo.NavMeshPathGoalEvaluatorCache
	class ACrowdPopulationManagerBase*                 PopulationManager;                                		// 0x0B10 (0x0008) [0x0000000000000000]              
	struct FHostMigrationState                         PeerHostMigration;                                		// 0x0B18 (0x0020) [0x0000000000000000]              
	float                                              HostMigrationTimeout;                             		// 0x0B38 (0x0004) [0x0000000000000000]              
	class APhysicsVolume*                              FirstPhysicsVolume;                               		// 0x0B3C (0x0008) [0x0000000000000000]              
	class AFileWriter*                                 GameBalanceLog;                                   		// 0x0B44 (0x0008) [0x0000000000000000]              
	struct FInterpCurveFloat                           FlickerCurve;                                     		// 0x0B4C (0x0014) [0x0000000000000000]              
	struct FInterpCurveFloat                           PulseCurve;                                       		// 0x0B60 (0x0014) [0x0000000000000000]              
	struct FInterpCurveFloat                           StrobeCurve;                                      		// 0x0B74 (0x0014) [0x0000000000000000]              
	struct FInterpCurveFloat                           ChaoticFlickerCurve;                              		// 0x0B88 (0x0014) [0x0000000000000000]              
	struct FInterpCurveFloat                           InverseChaoticFlickerCurve;                       		// 0x0B9C (0x0014) [0x0000000000000000]              
	float                                              FlickerBrightnessLowerBoundClamp;                 		// 0x0BB0 (0x0004) [0x0000000000000000]              
	float                                              PulseBrightnessLowerBoundClamp;                   		// 0x0BB4 (0x0004) [0x0000000000000000]              
	float                                              StrobeBrightnessLowerBoundClamp;                  		// 0x0BB8 (0x0004) [0x0000000000000000]              
	float                                              ChaoticFlickerBrightnessLowerBoundClamp;          		// 0x0BBC (0x0004) [0x0000000000000000]              
	float                                              InverseChaoticFlickerBrightnessLowerBoundClamp;   		// 0x0BC0 (0x0004) [0x0000000000000000]              
	TArray< class UMaterialInstanceConstant* >         ZedTimeMICs;                                      		// 0x0BC4 (0x0010) [0x0000000000000000]              
	float                                              EmitterPoolScale;                                 		// 0x0BD4 (0x0004) [0x0000000000000000]              
	float                                              DestructionLifetimeScale;                         		// 0x0BD8 (0x0004) [0x0000000000000000]              
	struct FString                                     GameplayPoolManagerClassPath;                     		// 0x0BDC (0x0010) [0x0000000000000000]              
	class AActor*                                      MyGameplayPoolManager;                            		// 0x0BEC (0x0008) [0x0000000000000000]              
	struct FString                                     ImpactEffectManagerClassPath;                     		// 0x0BF4 (0x0010) [0x0000000000000000]              
	class AActor*                                      MyImpactEffectManager;                            		// 0x0C04 (0x0008) [0x0000000000000000]              
	struct FString                                     GoreEffectManagerClassPath;                       		// 0x0C0C (0x0010) [0x0000000000000000]              
	class AActor*                                      MyGoreEffectManager;                              		// 0x0C1C (0x0008) [0x0000000000000000]              
	struct FString                                     LightPoolClassPath;                               		// 0x0C24 (0x0010) [0x0000000000000000]              
	class AActor*                                      MyLightPool;                                      		// 0x0C34 (0x0008) [0x0000000000000000]              
	struct FString                                     TWDeferredWorkManagerClassPath;                   		// 0x0C3C (0x0010) [0x0000000000000000]              
	class AActor*                                      DeferredWorkManager;                              		// 0x0C4C (0x0008) [0x0000000000000000]              
	struct FString                                     TurbEffectPoolClassPath;                          		// 0x0C54 (0x0010) [0x0000000000000000]              
	class AActor*                                      MyTurbEffectPool;                                 		// 0x0C64 (0x0008) [0x0000000000000000]              
	struct FString                                     GroundFireEmitterPoolClassPath;                   		// 0x0C6C (0x0010) [0x0000000000000000]              
	class AEmitterPool*                                GroundFireEmitterPool;                            		// 0x0C7C (0x0008) [0x0000000000000000]              
	struct FString                                     ImpactFXEmitterPoolClassPath;                     		// 0x0C84 (0x0010) [0x0000000000000000]              
	class AEmitterPool*                                ImpactFXEmitterPool;                              		// 0x0C94 (0x0008) [0x0000000000000000]              
	int                                                MaxExplosionDecals;                               		// 0x0C9C (0x0004) [0x0000000000000000]              
	class ADecalManager*                               ExplosionDecalManager;                            		// 0x0CA0 (0x0008) [0x0000000000000000]              
	struct FString                                     TimerHelperClassPath;                             		// 0x0CA8 (0x0010) [0x0000000000000000]              
	class AActor*                                      TimerHelper;                                      		// 0x0CB8 (0x0008) [0x0000000000000000]              
	struct FString                                     LastSuccessfulPathBuildTime;                      		// 0x0CC0 (0x0010) [0x0000000000000000]              
	TArray< struct FFlexMeshContactInfo >              FlexMeshContacts;                                 		// 0x0CD0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.WorldInfo" );

		return pClassPointer;
	};

	void TWPushLogs ( );
	void TWLogEvent ( );
	void TWLogsInit ( );
	void LogGameBalance ( );
	void GetAkEnvironmentName ( );
	void GetReverbVolume ( );
	void ClearObjectPools ( );
	void ToggleHostMigration ( );
	void eventNotifyHostMigrationStateChanged ( );
	void BeginHostMigration ( );
	void eventCanBeginHostMigration ( );
	void FindEnvironmentVolume ( );
	void GetWorldInfo ( );
	void GetWorldFractureSettings ( );
	void DoMemoryTracking ( );
	void GetDemoRewindPoints ( );
	void GetDemoFrameInfo ( );
	void IsPlayingDemo ( );
	void IsRecordingDemo ( );
	void GetDetailMode ( );
	void GetMapName ( );
	void SetMapInfo ( );
	void GetMapInfo ( );
	void SetSeamlessTravelMidpointPause ( );
	void IsInSeamlessTravel ( );
	void SeamlessTravel ( );
	void CommitMapChange ( );
	void CancelPendingMapChange ( );
	void IsMapChangeReady ( );
	void IsPreparingMapChange ( );
	void PrepareMapChange ( );
	void NotifyMatchStarted ( );
	void AllClientConnections ( );
	void AllPawns ( );
	void AllControllers ( );
	void NavigationPointCheck ( );
	void RadiusNavigationPoints ( );
	void AllNavigationPoints ( );
	void Reset ( );
	void PostBeginPlay ( );
	void PreBeginPlay ( );
	void ThisIsNeverExecuted ( );
	void eventServerTravel ( );
	void GetGameClass ( );
	void GetAddressURL ( );
	void VerifyNavList ( );
	void ForceGarbageCollection ( );
	void IsPlayInMobilePreview ( );
	void IsPlayInPreview ( );
	void IsPlayInEditor ( );
	void IsWithGFx ( );
	void GetResolutionBasedHUDScale ( );
	void IsConsoleBuild ( );
	void IsNeoCheckerboardRendering ( );
	void IsE3Build ( );
	void IsConsoleDedicatedServer ( );
	void IsDemoBuild ( );
	void GetLocalURL ( );
	void SetLevelRBGravity ( );
	void GetAllRootSequences ( );
	void GetGameSequence ( );
	void GetGravityZ ( );
	void UpdateMusicTrack ( );
	void SetMusicVolume ( );
	void IsMenuLevel ( );
	void AddOnScreenDebugMessage ( );
	void eventReplicatedEvent ( );
	void GetNavMeshPathGoalEvaluatorFromCache ( );
	void GetNavMeshPathConstraintFromCache ( );
	void ReleaseCachedConstraintsAndEvaluators ( );
};

UClass* AWorldInfo::pClassPointer = NULL;

// Class Engine.DownloadableContentEnumerator
// 0x0040 (0x00A0 - 0x0060)
class UDownloadableContentEnumerator : public UObject
{
public:
	TArray< struct FOnlineContent >                    DLCBundles;                                       		// 0x0060 (0x0010) [0x0000000000000000]              
	struct FString                                     DLCRootDir;                                       		// 0x0070 (0x0010) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   FindDLCDelegates;                                 		// 0x0080 (0x0010) [0x0000000000000000]              
	struct FScriptDelegate                             __OnFindDLCComplete__Delegate;                    		// 0x0090 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0094 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DownloadableContentEnumerator" );

		return pClassPointer;
	};

	void TriggerFindDLCDelegates ( );
	void InstallDLC ( );
	void InstallAllDLC ( );
	void DeleteDLC ( );
	void ClearFindDLCDelegate ( );
	void AddFindDLCDelegate ( );
	void OnFindDLCComplete ( );
	void FindDLC ( );
};

UClass* UDownloadableContentEnumerator::pClassPointer = NULL;

// Class Engine.DownloadableContentManager
// 0x00B0 (0x0110 - 0x0060)
class UDownloadableContentManager : public UObject
{
public:
	TArray< struct FPointer >                          DLCConfigCacheChanges;                            		// 0x0060 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           InstalledDLC;                                     		// 0x0070 (0x0010) [0x0000000000000000]              
	struct FMap_Mirror                                 NonPackageFilePathMap;                            		// 0x0080 (0x0048) [0x0000000000000000]              
	TArray< class UClass* >                            ClassesToReload;                                  		// 0x00C8 (0x0010) [0x0000000000000000]              
	TArray< class UObject* >                           ObjectsToReload;                                  		// 0x00D8 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           QueuedFullyLoadPackageInis;                       		// 0x00E8 (0x0010) [0x0000000000000000]              
	class UGameEngine*                                 GameEngine;                                       		// 0x00F8 (0x0008) [0x0000000000000000]              
	struct FScriptDelegate                             __OnRefreshComplete__Delegate;                    		// 0x0100 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0104 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DownloadableContentManager" );

		return pClassPointer;
	};

	void OnRefreshComplete ( );
	void AddPackagesToFullyLoad ( );
	void RefreshDLCEnumComplete ( );
	void RefreshDLC ( );
	void OnContentChange ( );
	void OnStorageDeviceChange ( );
	void OnLoginChange ( );
	void eventInit ( );
	void InstallNonPackageFiles ( );
	void InstallPackages ( );
	void UpdateObjectLists ( );
	void MarkPerObjectConfigPendingKill ( );
	void AddSectionToObjectList ( );
	void GetDLCNonPackageFilePath ( );
	void ClearDLC ( );
	void InstallDLCs ( );
	void InstallDLC ( );
};

UClass* UDownloadableContentManager::pClassPointer = NULL;

// Class Engine.Engine
// 0x089C (0x0904 - 0x0068)
class UEngine : public USubsystem
{
public:
	class UFont*                                       TinyFont;                                         		// 0x0068 (0x0008) [0x0000000000000000]              
	struct FString                                     TinyFontName;                                     		// 0x0070 (0x0010) [0x0000000000000000]              
	class UFont*                                       SmallFont;                                        		// 0x0080 (0x0008) [0x0000000000000000]              
	struct FString                                     SmallFontName;                                    		// 0x0088 (0x0010) [0x0000000000000000]              
	class UFont*                                       MediumFont;                                       		// 0x0098 (0x0008) [0x0000000000000000]              
	struct FString                                     MediumFontName;                                   		// 0x00A0 (0x0010) [0x0000000000000000]              
	class UFont*                                       LargeFont;                                        		// 0x00B0 (0x0008) [0x0000000000000000]              
	struct FString                                     LargeFontName;                                    		// 0x00B8 (0x0010) [0x0000000000000000]              
	class UFont*                                       SubtitleFont;                                     		// 0x00C8 (0x0008) [0x0000000000000000]              
	struct FString                                     SubtitleFontName;                                 		// 0x00D0 (0x0010) [0x0000000000000000]              
	TArray< class UFont* >                             AdditionalFonts;                                  		// 0x00E0 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           AdditionalFontNames;                              		// 0x00F0 (0x0010) [0x0000000000000000]              
	class UClass*                                      ConsoleClass;                                     		// 0x0100 (0x0008) [0x0000000000000000]              
	struct FString                                     ConsoleClassName;                                 		// 0x0108 (0x0010) [0x0000000000000000]              
	class UClass*                                      GameViewportClientClass;                          		// 0x0118 (0x0008) [0x0000000000000000]              
	struct FString                                     GameViewportClientClassName;                      		// 0x0120 (0x0010) [0x0000000000000000]              
	class UClass*                                      DataStoreClientClass;                             		// 0x0130 (0x0008) [0x0000000000000000]              
	struct FString                                     DataStoreClientClassName;                         		// 0x0138 (0x0010) [0x0000000000000000]              
	class UClass*                                      LocalPlayerClass;                                 		// 0x0148 (0x0008) [0x0000000000000000]              
	struct FString                                     LocalPlayerClassName;                             		// 0x0150 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   DefaultMaterial;                                  		// 0x0160 (0x0008) [0x0000000000000000]              
	struct FString                                     DefaultMaterialName;                              		// 0x0168 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   DefaultDecalMaterial;                             		// 0x0178 (0x0008) [0x0000000000000000]              
	struct FString                                     DefaultDecalMaterialName;                         		// 0x0180 (0x0010) [0x0000000000000000]              
	class UTexture*                                    DefaultTexture;                                   		// 0x0190 (0x0008) [0x0000000000000000]              
	struct FString                                     DefaultTextureName;                               		// 0x0198 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   WireframeMaterial;                                		// 0x01A8 (0x0008) [0x0000000000000000]              
	struct FString                                     WireframeMaterialName;                            		// 0x01B0 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   EmissiveTexturedMaterial;                         		// 0x01C0 (0x0008) [0x0000000000000000]              
	struct FString                                     EmissiveTexturedMaterialName;                     		// 0x01C8 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   GeomMaterial;                                     		// 0x01D8 (0x0008) [0x0000000000000000]              
	struct FString                                     GeomMaterialName;                                 		// 0x01E0 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   DefaultFogVolumeMaterial;                         		// 0x01F0 (0x0008) [0x0000000000000000]              
	struct FString                                     DefaultFogVolumeMaterialName;                     		// 0x01F8 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   TickMaterial;                                     		// 0x0208 (0x0008) [0x0000000000000000]              
	struct FString                                     TickMaterialName;                                 		// 0x0210 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   CrossMaterial;                                    		// 0x0220 (0x0008) [0x0000000000000000]              
	struct FString                                     CrossMaterialName;                                		// 0x0228 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   LevelColorationLitMaterial;                       		// 0x0238 (0x0008) [0x0000000000000000]              
	struct FString                                     LevelColorationLitMaterialName;                   		// 0x0240 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   LevelColorationUnlitMaterial;                     		// 0x0250 (0x0008) [0x0000000000000000]              
	struct FString                                     LevelColorationUnlitMaterialName;                 		// 0x0258 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   LightingTexelDensityMaterial;                     		// 0x0268 (0x0008) [0x0000000000000000]              
	struct FString                                     LightingTexelDensityName;                         		// 0x0270 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   ShadedLevelColorationLitMaterial;                 		// 0x0280 (0x0008) [0x0000000000000000]              
	struct FString                                     ShadedLevelColorationLitMaterialName;             		// 0x0288 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   ShadedLevelColorationUnlitMaterial;               		// 0x0298 (0x0008) [0x0000000000000000]              
	struct FString                                     ShadedLevelColorationUnlitMaterialName;           		// 0x02A0 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   RemoveSurfaceMaterial;                            		// 0x02B0 (0x0008) [0x0000000000000000]              
	struct FString                                     RemoveSurfaceMaterialName;                        		// 0x02B8 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   VertexColorMaterial;                              		// 0x02C8 (0x0008) [0x0000000000000000]              
	struct FString                                     VertexColorMaterialName;                          		// 0x02D0 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   VertexColorViewModeMaterial_ColorOnly;            		// 0x02E0 (0x0008) [0x0000000000000000]              
	struct FString                                     VertexColorViewModeMaterialName_ColorOnly;        		// 0x02E8 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   VertexColorViewModeMaterial_AlphaAsColor;         		// 0x02F8 (0x0008) [0x0000000000000000]              
	struct FString                                     VertexColorViewModeMaterialName_AlphaAsColor;     		// 0x0300 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   VertexColorViewModeMaterial_RedOnly;              		// 0x0310 (0x0008) [0x0000000000000000]              
	struct FString                                     VertexColorViewModeMaterialName_RedOnly;          		// 0x0318 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   VertexColorViewModeMaterial_GreenOnly;            		// 0x0328 (0x0008) [0x0000000000000000]              
	struct FString                                     VertexColorViewModeMaterialName_GreenOnly;        		// 0x0330 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   VertexColorViewModeMaterial_BlueOnly;             		// 0x0340 (0x0008) [0x0000000000000000]              
	struct FString                                     VertexColorViewModeMaterialName_BlueOnly;         		// 0x0348 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   HeatmapMaterial;                                  		// 0x0358 (0x0008) [0x0000000000000000]              
	struct FString                                     HeatmapMaterialName;                              		// 0x0360 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   BoneWeightMaterial;                               		// 0x0370 (0x0008) [0x0000000000000000]              
	struct FString                                     BoneWeightMaterialName;                           		// 0x0378 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   TangentColorMaterial;                             		// 0x0388 (0x0008) [0x0000000000000000]              
	struct FString                                     TangentColorMaterialName;                         		// 0x0390 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   MobileEmulationMasterMaterial;                    		// 0x03A0 (0x0008) [0x0000000000000000]              
	struct FString                                     MobileEmulationMasterMaterialName;                		// 0x03A8 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   ProcBuildingSimpleMaterial;                       		// 0x03B8 (0x0008) [0x0000000000000000]              
	struct FString                                     ProcBuildingSimpleMaterialName;                   		// 0x03C0 (0x0010) [0x0000000000000000]              
	class UStaticMesh*                                 BuildingQuadStaticMesh;                           		// 0x03D0 (0x0008) [0x0000000000000000]              
	struct FString                                     BuildingQuadStaticMeshName;                       		// 0x03D8 (0x0010) [0x0000000000000000]              
	float                                              ProcBuildingLODColorTexelsPerWorldUnit;           		// 0x03E8 (0x0004) [0x0000000000000000]              
	float                                              ProcBuildingLODLightingTexelsPerWorldUnit;        		// 0x03EC (0x0004) [0x0000000000000000]              
	int                                                MaxProcBuildingLODColorTextureSize;               		// 0x03F0 (0x0004) [0x0000000000000000]              
	int                                                MaxProcBuildingLODLightingTextureSize;            		// 0x03F4 (0x0004) [0x0000000000000000]              
	DWORD                                              UseProcBuildingLODTextureCropping : 1;            		// 0x03F8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              ForcePowerOfTwoProcBuildingLODTextures : 1;       		// 0x03F8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCombineSimilarMappings : 1;                      		// 0x03F8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bRenderLightMapDensityGrayscale : 1;              		// 0x03F8 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bScreenshotRequested : 1;                         		// 0x03F8 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bUseSound : 1;                                    		// 0x03F8 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bUseBackgroundLevelStreaming : 1;                 		// 0x03F8 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bSubtitlesEnabled : 1;                            		// 0x03F8 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bSubtitlesForcedOff : 1;                          		// 0x03F8 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bSmoothFrameRate : 1;                             		// 0x03F8 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bCheckForMultiplePawnsSpawnedInAFrame : 1;        		// 0x03F8 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bShouldGenerateSimpleLightmaps : 1;               		// 0x03F8 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bForceStaticTerrain : 1;                          		// 0x03F8 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bForceCPUSkinning : 1;                            		// 0x03F8 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bUsePostProcessEffects : 1;                       		// 0x03F8 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bOnScreenKismetWarnings : 1;                      		// 0x03F8 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bEnableKismetLogging : 1;                         		// 0x03F8 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bAllowMatureLanguage : 1;                         		// 0x03F8 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bDisablePhysXHardwareSupport : 1;                 		// 0x03F8 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bPauseOnLossOfFocus : 1;                          		// 0x03F8 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bCheckParticleRenderSize : 1;                     		// 0x03F8 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bEnableColorClear : 1;                            		// 0x03F8 (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bAreConstraintsDirty : 1;                         		// 0x03F8 (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bHasPendingGlobalReattach : 1;                    		// 0x03F8 (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bEnableOnScreenDebugMessages : 1;                 		// 0x03F8 (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bEnableOnScreenDebugMessagesDisplay : 1;          		// 0x03F8 (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bSuppressMapWarnings : 1;                         		// 0x03F8 (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bCookSeparateSharedMPGameContent : 1;             		// 0x03F8 (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bUseRecastNavMesh : 1;                            		// 0x03F8 (0x0004) [0x0000000000000000] [0x10000000] 
	DWORD                                              bDisableAILogging : 1;                            		// 0x03F8 (0x0004) [0x0000000000000000] [0x20000000] 
	DWORD                                              bUseNormalMapsForSimpleLightMaps : 1;             		// 0x03F8 (0x0004) [0x0000000000000000] [0x40000000] 
	DWORD                                              bStartWithMatineeCapture : 1;                     		// 0x03F8 (0x0004) [0x0000000000000000] [0x80000000] 
	DWORD                                              bCompressMatineeCapture : 1;                      		// 0x03FC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLockReadOnlyLevels : 1;                          		// 0x03FC (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              MaxRMSDForCombiningMappings;                      		// 0x0400 (0x0004) [0x0000000000000000]              
	int                                                ImageReflectionTextureSize;                       		// 0x0404 (0x0004) [0x0000000000000000]              
	struct FLinearColor                                LightingOnlyBrightness;                           		// 0x0408 (0x0010) [0x0000000000000000]              
	TArray< struct FColor >                            LightComplexityColors;                            		// 0x0418 (0x0010) [0x0000000000000000]              
	TArray< struct FLinearColor >                      ShaderComplexityColors;                           		// 0x0428 (0x0010) [0x0000000000000000]              
	float                                              MaxPixelShaderAdditiveComplexityCount;            		// 0x0438 (0x0004) [0x0000000000000000]              
	float                                              MinTextureDensity;                                		// 0x043C (0x0004) [0x0000000000000000]              
	float                                              IdealTextureDensity;                              		// 0x0440 (0x0004) [0x0000000000000000]              
	float                                              MaxTextureDensity;                                		// 0x0444 (0x0004) [0x0000000000000000]              
	float                                              MinLightMapDensity;                               		// 0x0448 (0x0004) [0x0000000000000000]              
	float                                              IdealLightMapDensity;                             		// 0x044C (0x0004) [0x0000000000000000]              
	float                                              MaxLightMapDensity;                               		// 0x0450 (0x0004) [0x0000000000000000]              
	float                                              RenderLightMapDensityGrayscaleScale;              		// 0x0454 (0x0004) [0x0000000000000000]              
	float                                              RenderLightMapDensityColorScale;                  		// 0x0458 (0x0004) [0x0000000000000000]              
	struct FLinearColor                                LightMapDensityVertexMappedColor;                 		// 0x045C (0x0010) [0x0000000000000000]              
	struct FLinearColor                                LightMapDensitySelectedColor;                     		// 0x046C (0x0010) [0x0000000000000000]              
	TArray< struct FStatColorMapping >                 StatColorMappings;                                		// 0x047C (0x0010) [0x0000000000000000]              
	class UMaterial*                                   EditorBrushMaterial;                              		// 0x048C (0x0008) [0x0000000000000000]              
	struct FString                                     EditorBrushMaterialName;                          		// 0x0494 (0x0010) [0x0000000000000000]              
	class UPhysicalMaterial*                           DefaultPhysMaterial;                              		// 0x04A4 (0x0008) [0x0000000000000000]              
	struct FString                                     DefaultPhysMaterialName;                          		// 0x04AC (0x0010) [0x0000000000000000]              
	class UPhysicalMaterial*                           LandscapeHolePhysMaterial;                        		// 0x04BC (0x0008) [0x0000000000000000]              
	struct FString                                     LandscapeHolePhysMaterialName;                    		// 0x04C4 (0x0010) [0x0000000000000000]              
	class UApexDestructibleDamageParameters*           ApexDamageParams;                                 		// 0x04D4 (0x0008) [0x0000000000000000]              
	struct FString                                     ApexDamageParamsName;                             		// 0x04DC (0x0010) [0x0000000000000000]              
	class UMaterial*                                   TerrainErrorMaterial;                             		// 0x04EC (0x0008) [0x0000000000000000]              
	struct FString                                     TerrainErrorMaterialName;                         		// 0x04F4 (0x0010) [0x0000000000000000]              
	int                                                TerrainMaterialMaxTextureCount;                   		// 0x0504 (0x0004) [0x0000000000000000]              
	int                                                TerrainTessellationCheckCount;                    		// 0x0508 (0x0004) [0x0000000000000000]              
	float                                              TerrainTessellationCheckDistance;                 		// 0x050C (0x0004) [0x0000000000000000]              
	class UClass*                                      OnlineSubsystemClass;                             		// 0x0510 (0x0008) [0x0000000000000000]              
	struct FString                                     DefaultOnlineSubsystemName;                       		// 0x0518 (0x0010) [0x0000000000000000]              
	class UPostProcessChain*                           DefaultPostProcess;                               		// 0x0528 (0x0008) [0x0000000000000000]              
	struct FString                                     DefaultPostProcessName;                           		// 0x0530 (0x0010) [0x0000000000000000]              
	class UPostProcessChain*                           ThumbnailSkeletalMeshPostProcess;                 		// 0x0540 (0x0008) [0x0000000000000000]              
	struct FString                                     ThumbnailSkeletalMeshPostProcessName;             		// 0x0548 (0x0010) [0x0000000000000000]              
	class UPostProcessChain*                           ThumbnailParticleSystemPostProcess;               		// 0x0558 (0x0008) [0x0000000000000000]              
	struct FString                                     ThumbnailParticleSystemPostProcessName;           		// 0x0560 (0x0010) [0x0000000000000000]              
	class UPostProcessChain*                           ThumbnailMaterialPostProcess;                     		// 0x0570 (0x0008) [0x0000000000000000]              
	struct FString                                     ThumbnailMaterialPostProcessName;                 		// 0x0578 (0x0010) [0x0000000000000000]              
	class UPostProcessChain*                           DefaultUIScenePostProcess;                        		// 0x0588 (0x0008) [0x0000000000000000]              
	struct FString                                     DefaultUIScenePostProcessName;                    		// 0x0590 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   DefaultUICaretMaterial;                           		// 0x05A0 (0x0008) [0x0000000000000000]              
	struct FString                                     DefaultUICaretMaterialName;                       		// 0x05A8 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   SceneCaptureReflectActorMaterial;                 		// 0x05B8 (0x0008) [0x0000000000000000]              
	struct FString                                     SceneCaptureReflectActorMaterialName;             		// 0x05C0 (0x0010) [0x0000000000000000]              
	class UMaterial*                                   SceneCaptureCubeActorMaterial;                    		// 0x05D0 (0x0008) [0x0000000000000000]              
	struct FString                                     SceneCaptureCubeActorMaterialName;                		// 0x05D8 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  ScreenDoorNoiseTexture;                           		// 0x05E8 (0x0008) [0x0000000000000000]              
	struct FString                                     ScreenDoorNoiseTextureName;                       		// 0x05F0 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  ImageGrainNoiseTexture;                           		// 0x0600 (0x0008) [0x0000000000000000]              
	struct FString                                     ImageGrainNoiseTextureName;                       		// 0x0608 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  RandomAngleTexture;                               		// 0x0618 (0x0008) [0x0000000000000000]              
	struct FString                                     RandomAngleTextureName;                           		// 0x0620 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  RandomNormalTexture;                              		// 0x0630 (0x0008) [0x0000000000000000]              
	struct FString                                     RandomNormalTextureName;                          		// 0x0638 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  RandomMirrorDiscTexture;                          		// 0x0648 (0x0008) [0x0000000000000000]              
	struct FString                                     RandomMirrorDiscTextureName;                      		// 0x0650 (0x0010) [0x0000000000000000]              
	class UTexture*                                    WeightMapPlaceholderTexture;                      		// 0x0660 (0x0008) [0x0000000000000000]              
	struct FString                                     WeightMapPlaceholderTextureName;                  		// 0x0668 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  LightMapDensityTexture;                           		// 0x0678 (0x0008) [0x0000000000000000]              
	struct FString                                     LightMapDensityTextureName;                       		// 0x0680 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  LightMapDensityNormal;                            		// 0x0690 (0x0008) [0x0000000000000000]              
	struct FString                                     LightMapDensityNormalName;                        		// 0x0698 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  SplatterMapDensityTexture;                        		// 0x06A8 (0x0008) [0x0000000000000000]              
	struct FString                                     SplatterMapDensityTextureName;                    		// 0x06B0 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  PersistentBloodMasterTexture;                     		// 0x06C0 (0x0008) [0x0000000000000000]              
	struct FString                                     PersistentBloodMasterTextureName;                 		// 0x06C8 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  DitherTexture;                                    		// 0x06D8 (0x0008) [0x0000000000000000]              
	struct FString                                     DitherTextureName;                                		// 0x06E0 (0x0010) [0x0000000000000000]              
	class USoundNodeWave*                              DefaultSound;                                     		// 0x06F0 (0x0008) [0x0000000000000000]              
	struct FString                                     DefaultSoundName;                                 		// 0x06F8 (0x0010) [0x0000000000000000]              
	float                                              TimeBetweenPurgingPendingKillObjects;             		// 0x0708 (0x0004) [0x0000000000000000]              
	class UClient*                                     Client;                                           		// 0x070C (0x0008) [0x0000000000000000]              
	TArray< class ULocalPlayer* >                      GamePlayers;                                      		// 0x0714 (0x0010) [0x0000000000000000]              
	class UGameViewportClient*                         GameViewport;                                     		// 0x0724 (0x0008) [0x0000000000000000]              
	TArray< struct FString >                           DeferredCommands;                                 		// 0x072C (0x0010) [0x0000000000000000]              
	int                                                TickCycles;                                       		// 0x073C (0x0004) [0x0000000000000000]              
	int                                                GameCycles;                                       		// 0x0740 (0x0004) [0x0000000000000000]              
	int                                                ClientCycles;                                     		// 0x0744 (0x0004) [0x0000000000000000]              
	float                                              MaxSmoothedFrameRate;                             		// 0x0748 (0x0004) [0x0000000000000000]              
	float                                              MinSmoothedFrameRate;                             		// 0x074C (0x0004) [0x0000000000000000]              
	int                                                NumPawnsAllowedToBeSpawnedInAFrame;               		// 0x0750 (0x0004) [0x0000000000000000]              
	struct FPointer                                    RemoteControlExec;                                		// 0x0754 (0x0008) [0x0000000000000000]              
	struct FPointer                                    MobileMaterialEmulator;                           		// 0x075C (0x0008) [0x0000000000000000]              
	struct FColor                                      C_WorldBox;                                       		// 0x0764 (0x0004) [0x0000000000000000]              
	struct FColor                                      C_BrushWire;                                      		// 0x0768 (0x0004) [0x0000000000000000]              
	struct FColor                                      C_AddWire;                                        		// 0x076C (0x0004) [0x0000000000000000]              
	struct FColor                                      C_SubtractWire;                                   		// 0x0770 (0x0004) [0x0000000000000000]              
	struct FColor                                      C_SemiSolidWire;                                  		// 0x0774 (0x0004) [0x0000000000000000]              
	struct FColor                                      C_NonSolidWire;                                   		// 0x0778 (0x0004) [0x0000000000000000]              
	struct FColor                                      C_WireBackground;                                 		// 0x077C (0x0004) [0x0000000000000000]              
	struct FColor                                      C_ScaleBoxHi;                                     		// 0x0780 (0x0004) [0x0000000000000000]              
	struct FColor                                      C_VolumeCollision;                                		// 0x0784 (0x0004) [0x0000000000000000]              
	struct FColor                                      C_BSPCollision;                                   		// 0x0788 (0x0004) [0x0000000000000000]              
	struct FColor                                      C_OrthoBackground;                                		// 0x078C (0x0004) [0x0000000000000000]              
	struct FColor                                      C_Volume;                                         		// 0x0790 (0x0004) [0x0000000000000000]              
	struct FColor                                      C_BrushShape;                                     		// 0x0794 (0x0004) [0x0000000000000000]              
	float                                              StreamingDistanceFactor;                          		// 0x0798 (0x0004) [0x0000000000000000]              
	struct FString                                     ScoutClassName;                                   		// 0x079C (0x0010) [0x0000000000000000]              
	unsigned char                                      TransitionType;                                   		// 0x07AC (0x0001) [0x0000000000000000]              
	struct FString                                     TransitionDescription;                            		// 0x07B0 (0x0010) [0x0000000000000000]              
	struct FString                                     TransitionGameType;                               		// 0x07C0 (0x0010) [0x0000000000000000]              
	float                                              MeshLODRange;                                     		// 0x07D0 (0x0004) [0x0000000000000000]              
	float                                              CameraRotationThreshold;                          		// 0x07D4 (0x0004) [0x0000000000000000]              
	float                                              CameraTranslationThreshold;                       		// 0x07D8 (0x0004) [0x0000000000000000]              
	float                                              PrimitiveProbablyVisibleTime;                     		// 0x07DC (0x0004) [0x0000000000000000]              
	float                                              LightProbablyVisibleTime;                         		// 0x07E0 (0x0004) [0x0000000000000000]              
	float                                              PercentUnoccludedRequeries;                       		// 0x07E4 (0x0004) [0x0000000000000000]              
	float                                              MaxOcclusionPixelsFraction;                       		// 0x07E8 (0x0004) [0x0000000000000000]              
	int                                                PhysXLevel;                                       		// 0x07EC (0x0004) [0x0000000000000000]              
	int                                                MaxFluidNumVerts;                                 		// 0x07F0 (0x0004) [0x0000000000000000]              
	float                                              FluidSimulationTimeLimit;                         		// 0x07F4 (0x0004) [0x0000000000000000]              
	int                                                MaxParticleResize;                                		// 0x07F8 (0x0004) [0x0000000000000000]              
	int                                                MaxParticleResizeWarn;                            		// 0x07FC (0x0004) [0x0000000000000000]              
	int                                                MaxParticleVertexMemory;                          		// 0x0800 (0x0004) [0x0000000000000000]              
	int                                                MaxParticleSpriteCount;                           		// 0x0804 (0x0004) [0x0000000000000000]              
	int                                                MaxParticleSubUVCount;                            		// 0x0808 (0x0004) [0x0000000000000000]              
	int                                                BeginUPTryCount;                                  		// 0x080C (0x0004) [0x0000000000000000]              
	TArray< struct FDropNoteInfo >                     PendingDroppedNotes;                              		// 0x0810 (0x0010) [0x0000000000000000]              
	struct FString                                     DynamicCoverMeshComponentName;                    		// 0x0820 (0x0010) [0x0000000000000000]              
	float                                              NetClientTicksPerSecond;                          		// 0x0830 (0x0004) [0x0000000000000000]              
	float                                              MaxTrackedOcclusionIncrement;                     		// 0x0834 (0x0004) [0x0000000000000000]              
	float                                              TrackedOcclusionStepSize;                         		// 0x0838 (0x0004) [0x0000000000000000]              
	struct FLinearColor                                DefaultSelectedMaterialColor;                     		// 0x083C (0x0010) [0x0000000000000000]              
	struct FLinearColor                                DefaultHoveredMaterialColor;                      		// 0x084C (0x0010) [0x0000000000000000]              
	struct FLinearColor                                SelectedMaterialColor;                            		// 0x085C (0x0010) [0x0000000000000000]              
	struct FLinearColor                                UnselectedMaterialColor;                          		// 0x086C (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             IgnoreSimulatedFuncWarnings;                      		// 0x087C (0x0010) [0x0000000000000000]              
	struct FString                                     AISubsystemClassName;                             		// 0x088C (0x0010) [0x0000000000000000]              
	class UAISubsystem*                                AISys;                                            		// 0x089C (0x0008) [0x0000000000000000]              
	int                                                ScreenSaverInhibitorSemaphore;                    		// 0x08A4 (0x0004) [0x0000000000000000]              
	struct FPointer                                    ScreenSaverInhibitor;                             		// 0x08A8 (0x0008) [0x0000000000000000]              
	class UTranslationContext*                         GlobalTranslationContext;                         		// 0x08B0 (0x0008) [0x0000000000000000]              
	struct FDouble                                     LoadingMovieStartTime;                            		// 0x08B8 (0x0008) [0x0000000000000000]              
	struct FString                                     MatineeCaptureName;                               		// 0x08C0 (0x0010) [0x0000000000000000]              
	struct FString                                     MatineePackageCaptureName;                        		// 0x08D0 (0x0010) [0x0000000000000000]              
	struct FString                                     VisibleLevelsForMatineeCapture;                   		// 0x08E0 (0x0010) [0x0000000000000000]              
	int                                                MatineeCaptureFPS;                                		// 0x08F0 (0x0004) [0x0000000000000000]              
	int                                                MatineeCaptureType;                               		// 0x08F4 (0x0004) [0x0000000000000000]              
	class UNetDriver*                                  QueryNetDriver;                                   		// 0x08F8 (0x0008) [0x0000000000000000]              
	float                                              SafeFrameScale;                                   		// 0x0900 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Engine" );

		return pClassPointer;
	};

	void GetSystemSettingFloat ( );
	void GetSystemSettingInt ( );
	void GetSystemSettingBool ( );
	void GetPhysXLevel ( );
	void LaunchURL ( );
	void BasicLoadObject ( );
	void BasicSaveObject ( );
	void AddTextureStreamingSlaveLoc ( );
	void GetWorldPostProcessChain ( );
	void GetDefaultPostProcessChain ( );
	void GetEngine ( );
	void IsRealDStereoEnabled ( );
	void AddOverlayWrapped ( );
	void AddOverlay ( );
	void RemoveAllOverlays ( );
	void StopMovie ( );
	void PlayLoadMapMovie ( );
	void GetLastMovieName ( );
	void GetAISubsystem ( );
	void GetAudioDevice ( );
	void IsUsingES2Renderer ( );
	void IsStereoscopic3D ( );
	void IsSplitScreen ( );
	void GetAdditionalFont ( );
	void GetSubtitleFont ( );
	void GetLargeFont ( );
	void GetMediumFont ( );
	void GetSmallFont ( );
	void GetTinyFont ( );
	void HasNetworkConnection ( );
	void BuildBugSubmissionString ( );
	void GetDevicePushNotificationToken ( );
	void GetTitleSafeArea ( );
	void GetOSVersion ( );
	void GetDeviceUUID ( );
	void GetBuildDate ( );
	void GetCurrentWorldInfo ( );
	void IsGame ( );
	void IsEditor ( );
};

UClass* UEngine::pClassPointer = NULL;

// Class Engine.GameEngine
// 0x024C (0x0B50 - 0x0904)
class UGameEngine : public UEngine
{
public:
	class UPendingLevel*                               GPendingLevel;                                    		// 0x0904 (0x0008) [0x0000000000000000]              
	struct FString                                     PendingLevelPlayerControllerClassName;            		// 0x090C (0x0010) [0x0000000000000000]              
	struct FURL                                        LastURL;                                          		// 0x091C (0x0068) [0x0000000000000000]              
	struct FURL                                        LastRemoteURL;                                    		// 0x0984 (0x0068) [0x0000000000000000]              
	TArray< struct FString >                           ServerActors;                                     		// 0x09EC (0x0010) [0x0000000000000000]              
	struct FString                                     TravelURL;                                        		// 0x09FC (0x0010) [0x0000000000000000]              
	unsigned char                                      TravelType;                                       		// 0x0A0C (0x0001) [0x0000000000000000]              
	struct FString                                     ClientOptionsForTakeoverURL;                      		// 0x0A10 (0x0010) [0x0000000000000000]              
	struct FString                                     TakeoverURL;                                      		// 0x0A20 (0x0010) [0x0000000000000000]              
	DWORD                                              bUsedForTakeover : 1;                             		// 0x0A30 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAvailableForTakeover : 1;                        		// 0x0A30 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bPrivateServer : 1;                               		// 0x0A30 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bWorldWasLoadedThisTick : 1;                      		// 0x0A30 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bCheckForMovieCapture : 1;                        		// 0x0A30 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bTriggerPostLoadMap : 1;                          		// 0x0A30 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bStartedLoadMapMovie : 1;                         		// 0x0A30 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bSaveBenchmarkGraphs : 1;                         		// 0x0A30 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bShouldCommitPendingMapChange : 1;                		// 0x0A30 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bClearAnimSetLinkupCachesOnLoadMap : 1;           		// 0x0A30 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bEnableSecondaryDisplay : 1;                      		// 0x0A30 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bEnableSecondaryViewport : 1;                     		// 0x0A30 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bPartialInstallLaunch : 1;                        		// 0x0A30 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bTrialActive : 1;                                 		// 0x0A30 (0x0004) [0x0000000000000000] [0x00002000] 
	class UOnlineSubsystem*                            OnlineSubsystem;                                  		// 0x0A34 (0x0008) [0x0000000000000000]              
	class UPlayfabInterface*                           PlayfabInterfaceInst;                             		// 0x0A3C (0x0008) [0x0000000000000000]              
	class UGamePadLightbarSubsystem*                   GamePadLightbarSubsystem;                         		// 0x0A44 (0x0008) [0x0000000000000000]              
	class UDownloadableContentEnumerator*              DLCEnumerator;                                    		// 0x0A4C (0x0008) [0x0000000000000000]              
	struct FString                                     DownloadableContentEnumeratorClassName;           		// 0x0A54 (0x0010) [0x0000000000000000]              
	class UDownloadableContentManager*                 DLCManager;                                       		// 0x0A64 (0x0008) [0x0000000000000000]              
	TArray< struct FBenchmarkSample >                  BenchmarkSamples;                                 		// 0x0A6C (0x0010) [0x0000000000000000]              
	struct FString                                     DownloadableContentManagerClassName;              		// 0x0A7C (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             LevelsToLoadForPendingMapChange;                  		// 0x0A8C (0x0010) [0x0000000000000000]              
	TArray< class ULevel* >                            LoadedLevelsForPendingMapChange;                  		// 0x0A9C (0x0010) [0x0000000000000000]              
	struct FString                                     PendingMapChangeFailureDescription;               		// 0x0AAC (0x0010) [0x0000000000000000]              
	float                                              MaxDeltaTime;                                     		// 0x0ABC (0x0004) [0x0000000000000000]              
	struct FString                                     SecondaryViewportClientClassName;                 		// 0x0AC0 (0x0010) [0x0000000000000000]              
	TArray< class UScriptViewportClient* >             SecondaryViewportClients;                         		// 0x0AD0 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          SecondaryViewportFrames;                          		// 0x0AE0 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           IgnoredUsesGUIDPackages;                          		// 0x0AF0 (0x0010) [0x0000000000000000]              
	TArray< struct FLevelStreamingStatus >             PendingLevelStreamingStatusUpdates;               		// 0x0B00 (0x0010) [0x0000000000000000]              
	TArray< class UObjectReferencer* >                 ObjectReferencers;                                		// 0x0B10 (0x0010) [0x0000000000000000]              
	TArray< struct FFullyLoadedPackagesInfo >          PackagesToFullyLoad;                              		// 0x0B20 (0x0010) [0x0000000000000000]              
	TArray< struct FNamedNetDriver >                   NamedNetDrivers;                                  		// 0x0B30 (0x0010) [0x0000000000000000]              
	TArray< struct FAnimTag >                          AnimTags;                                         		// 0x0B40 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GameEngine" );

		return pClassPointer;
	};

	void WasLaunchedOnPartialInstall ( );
	void GetChunkInstallProgress ( );
	void GetChunksInstallProgress ( );
	void AreChunksInstalled ( );
	void IsGameFullyInstalled ( );
	void GetPercentageOfStreamingInstallComplete ( );
	void DecodeURLString ( );
	void EncodeURLString ( );
	void DisableServerTakeover ( );
	void GetWebAdminPort ( );
	void TakeoverServer ( );
	void HasSecondaryScreenActive ( );
	void GetDLCManager ( );
	void GetDLCEnumerator ( );
	void GetPlayfabInterface ( );
	void GetOnlineSubsystem ( );
	void DestroyNamedNetDriver ( );
	void CreateNamedNetDriver ( );
};

UClass* UGameEngine::pClassPointer = NULL;

// Class Engine.EngineBaseTypes
// 0x0000 (0x0060 - 0x0060)
class UEngineBaseTypes : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.EngineBaseTypes" );

		return pClassPointer;
	};

};

UClass* UEngineBaseTypes::pClassPointer = NULL;

// Class Engine.Brush
// 0x0030 (0x0274 - 0x0244)
class ABrush : public AActor
{
public:
	unsigned char                                      CsgOper;                                          		// 0x0244 (0x0001) [0x0000000000000000]              
	struct FColor                                      BrushColor;                                       		// 0x0248 (0x0004) [0x0000000000000000]              
	int                                                PolyFlags;                                        		// 0x024C (0x0004) [0x0000000000000000]              
	DWORD                                              bColored : 1;                                     		// 0x0250 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSolidWhenSelected : 1;                           		// 0x0250 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bPlaceableFromClassBrowser : 1;                   		// 0x0250 (0x0004) [0x0000000000000000] [0x00000004] 
	class UModel*                                      Brush;                                            		// 0x0254 (0x0008) [0x0000000000000000]              
	class UBrushComponent*                             BrushComponent;                                   		// 0x025C (0x0008) [0x0000000000000000]              
	TArray< struct FGeomSelection >                    SavedSelections;                                  		// 0x0264 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Brush" );

		return pClassPointer;
	};

};

UClass* ABrush::pClassPointer = NULL;

// Class Engine.BrushShape
// 0x0000 (0x0274 - 0x0274)
class ABrushShape : public ABrush
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.BrushShape" );

		return pClassPointer;
	};

};

UClass* ABrushShape::pClassPointer = NULL;

// Class Engine.Volume
// 0x000C (0x0280 - 0x0274)
class AVolume : public ABrush
{
public:
	class AActor*                                      AssociatedActor;                                  		// 0x0274 (0x0008) [0x0000000000000000]              
	DWORD                                              bForcePawnWalk : 1;                               		// 0x027C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bProcessAllActors : 1;                            		// 0x027C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bPawnsOnly : 1;                                   		// 0x027C (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Volume" );

		return pClassPointer;
	};

	void eventProcessActorSetVolume ( );
	void eventCollisionChanged ( );
	void OnToggle ( );
	void DisplayDebug ( );
	void eventPostBeginPlay ( );
	void EncompassesPoint ( );
	void Encompasses ( );
};

UClass* AVolume::pClassPointer = NULL;

// Class Engine.BlockingVolume
// 0x0004 (0x0284 - 0x0280)
class ABlockingVolume : public AVolume
{
public:
	DWORD                                              bBlockCamera : 1;                                 		// 0x0280 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.BlockingVolume" );

		return pClassPointer;
	};

	void OnToggle ( );
};

UClass* ABlockingVolume::pClassPointer = NULL;

// Class Engine.DynamicBlockingVolume
// 0x0004 (0x0288 - 0x0284)
class ADynamicBlockingVolume : public ABlockingVolume
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x0284 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DynamicBlockingVolume" );

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void eventPostBeginPlay ( );
};

UClass* ADynamicBlockingVolume::pClassPointer = NULL;

// Class Engine.CullDistanceVolume
// 0x0014 (0x0294 - 0x0280)
class ACullDistanceVolume : public AVolume
{
public:
	TArray< struct FCullDistanceSizePair >             CullDistances;                                    		// 0x0280 (0x0010) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x0290 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CullDistanceVolume" );

		return pClassPointer;
	};

};

UClass* ACullDistanceVolume::pClassPointer = NULL;

// Class Engine.LevelGridVolume
// 0x00A4 (0x0324 - 0x0280)
class ALevelGridVolume : public AVolume
{
public:
	struct FString                                     LevelGridVolumeName;                              		// 0x0280 (0x0010) [0x0000000000000000]              
	unsigned char                                      CellShape;                                        		// 0x0290 (0x0001) [0x0000000000000000]              
	int                                                Subdivisions[ 0x3 ];                              		// 0x0294 (0x000C) [0x0000000000000000]              
	float                                              LoadingDistance;                                  		// 0x02A0 (0x0004) [0x0000000000000000]              
	float                                              KeepLoadedRange;                                  		// 0x02A4 (0x0004) [0x0000000000000000]              
	struct FKConvexElem                                CellConvexElem;                                   		// 0x02A8 (0x007C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LevelGridVolume" );

		return pClassPointer;
	};

};

UClass* ALevelGridVolume::pClassPointer = NULL;

// Class Engine.LevelStreamingVolume
// 0x001C (0x029C - 0x0280)
class ALevelStreamingVolume : public AVolume
{
public:
	TArray< class ULevelStreaming* >                   StreamingLevels;                                  		// 0x0280 (0x0010) [0x0000000000000000]              
	DWORD                                              bEditorPreVisOnly : 1;                            		// 0x0290 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDisabled : 1;                                    		// 0x0290 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bTestDistanceToVolume : 1;                        		// 0x0290 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned char                                      StreamingUsage;                                   		// 0x0294 (0x0001) [0x0000000000000000]              
	unsigned char                                      Usage;                                            		// 0x0295 (0x0001) [0x0000000000000000]              
	float                                              TestVolumeDistance;                               		// 0x0298 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LevelStreamingVolume" );

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void OnToggle ( );
};

UClass* ALevelStreamingVolume::pClassPointer = NULL;

// Class Engine.LightmassCharacterIndirectDetailVolume
// 0x0000 (0x0280 - 0x0280)
class ALightmassCharacterIndirectDetailVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LightmassCharacterIndirectDetailVolume" );

		return pClassPointer;
	};

};

UClass* ALightmassCharacterIndirectDetailVolume::pClassPointer = NULL;

// Class Engine.LightmassImportanceVolume
// 0x0000 (0x0280 - 0x0280)
class ALightmassImportanceVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LightmassImportanceVolume" );

		return pClassPointer;
	};

};

UClass* ALightmassImportanceVolume::pClassPointer = NULL;

// Class Engine.MassiveLODOverrideVolume
// 0x0000 (0x0280 - 0x0280)
class AMassiveLODOverrideVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MassiveLODOverrideVolume" );

		return pClassPointer;
	};

};

UClass* AMassiveLODOverrideVolume::pClassPointer = NULL;

// Class Engine.PathBlockingVolume
// 0x0000 (0x0280 - 0x0280)
class APathBlockingVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PathBlockingVolume" );

		return pClassPointer;
	};

};

UClass* APathBlockingVolume::pClassPointer = NULL;

// Class Engine.PhysicsVolume
// 0x0050 (0x02D0 - 0x0280)
class APhysicsVolume : public AVolume
{
public:
	struct FVector                                     ZoneVelocity;                                     		// 0x0280 (0x000C) [0x0000000000000000]              
	DWORD                                              bVelocityAffectsWalking : 1;                      		// 0x028C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPainCausing : 1;                                 		// 0x028C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAIShouldIgnorePain : 1;                          		// 0x028C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bEntryPain : 1;                                   		// 0x028C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              BACKUP_bPainCausing : 1;                          		// 0x028C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bDestructive : 1;                                 		// 0x028C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bNoInventory : 1;                                 		// 0x028C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bMoveProjectiles : 1;                             		// 0x028C (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bBounceVelocity : 1;                              		// 0x028C (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bNeutralZone : 1;                                 		// 0x028C (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bCrowdAgentsPlayDeathAnim : 1;                    		// 0x028C (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bPhysicsOnContact : 1;                            		// 0x028C (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bWaterVolume : 1;                                 		// 0x028C (0x0004) [0x0000000000000000] [0x00001000] 
	float                                              GroundFriction;                                   		// 0x0290 (0x0004) [0x0000000000000000]              
	float                                              TerminalVelocity;                                 		// 0x0294 (0x0004) [0x0000000000000000]              
	float                                              DamagePerSec;                                     		// 0x0298 (0x0004) [0x0000000000000000]              
	class UClass*                                      DamageType;                                       		// 0x029C (0x0008) [0x0000000000000000]              
	int                                                Priority;                                         		// 0x02A4 (0x0004) [0x0000000000000000]              
	float                                              FluidFriction;                                    		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              PainInterval;                                     		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              RigidBodyDamping;                                 		// 0x02B0 (0x0004) [0x0000000000000000]              
	float                                              MaxDampingForce;                                  		// 0x02B4 (0x0004) [0x0000000000000000]              
	class AInfo*                                       PainTimer;                                        		// 0x02B8 (0x0008) [0x0000000000000000]              
	class AController*                                 DamageInstigator;                                 		// 0x02C0 (0x0008) [0x0000000000000000]              
	class APhysicsVolume*                              NextPhysicsVolume;                                		// 0x02C8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PhysicsVolume" );

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void ShouldSaveForCheckpoint ( );
	void OnSetDamageInstigator ( );
	void NotifyPawnBecameViewTarget ( );
	void ModifyPlayer ( );
	void CausePainTo ( );
	void eventTouch ( );
	void TimerPop ( );
	void eventCollisionChanged ( );
	void OnToggle ( );
	void eventPawnLeavingVolume ( );
	void eventPawnEnteredVolume ( );
	void eventActorLeavingVolume ( );
	void eventActorEnteredVolume ( );
	void eventPhysicsChangedFor ( );
	void Reset ( );
	void eventPostBeginPlay ( );
	void GetZoneVelocityForActor ( );
	void GetGravityZ ( );
};

UClass* APhysicsVolume::pClassPointer = NULL;

// Class Engine.DefaultPhysicsVolume
// 0x0000 (0x02D0 - 0x02D0)
class ADefaultPhysicsVolume : public APhysicsVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DefaultPhysicsVolume" );

		return pClassPointer;
	};

	void eventDestroyed ( );
};

UClass* ADefaultPhysicsVolume::pClassPointer = NULL;

// Class Engine.GravityVolume
// 0x0004 (0x02D4 - 0x02D0)
class AGravityVolume : public APhysicsVolume
{
public:
	float                                              GravityZ;                                         		// 0x02D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GravityVolume" );

		return pClassPointer;
	};

};

UClass* AGravityVolume::pClassPointer = NULL;

// Class Engine.LadderVolume
// 0x0040 (0x0310 - 0x02D0)
class ALadderVolume : public APhysicsVolume
{
public:
	struct FRotator                                    WallDir;                                          		// 0x02D0 (0x000C) [0x0000000000000000]              
	struct FVector                                     LookDir;                                          		// 0x02DC (0x000C) [0x0000000000000000]              
	struct FVector                                     ClimbDir;                                         		// 0x02E8 (0x000C) [0x0000000000000000]              
	class ALadder*                                     LadderList;                                       		// 0x02F4 (0x0008) [0x0000000000000000]              
	DWORD                                              bNoPhysicalLadder : 1;                            		// 0x02FC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAutoPath : 1;                                    		// 0x02FC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAllowLadderStrafing : 1;                         		// 0x02FC (0x0004) [0x0000000000000000] [0x00000004] 
	class APawn*                                       PendingClimber;                                   		// 0x0300 (0x0008) [0x0000000000000000]              
	class UArrowComponent*                             WallDirArrow;                                     		// 0x0308 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LadderVolume" );

		return pClassPointer;
	};

	void eventPhysicsChangedFor ( );
	void eventPawnLeavingVolume ( );
	void eventPawnEnteredVolume ( );
	void InUse ( );
	void eventPostBeginPlay ( );
};

UClass* ALadderVolume::pClassPointer = NULL;

// Class Engine.PortalVolume
// 0x0010 (0x0290 - 0x0280)
class APortalVolume : public AVolume
{
public:
	TArray< class APortalTeleporter* >                 Portals;                                          		// 0x0280 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PortalVolume" );

		return pClassPointer;
	};

};

UClass* APortalVolume::pClassPointer = NULL;

// Class Engine.PostProcessVolume
// 0x0230 (0x04B0 - 0x0280)
class APostProcessVolume : public AVolume
{
public:
	float                                              Priority;                                         		// 0x0280 (0x0004) [0x0000000000000000]              
	DWORD                                              bOverrideWorldPostProcessChain : 1;               		// 0x0284 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnabled : 1;                                     		// 0x0284 (0x0004) [0x0000000000150000] [0x00000002] ( CPF_Travel | CPF_GlobalConfig )
	struct FPostProcessSettings                        Settings;                                         		// 0x0288 (0x0220) [0x0000000000000000]              
	class APostProcessVolume*                          NextLowerPriorityVolume;                          		// 0x04A8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PostProcessVolume" );

		return pClassPointer;
	};

	void OnToggle ( );
};

UClass* APostProcessVolume::pClassPointer = NULL;

// Class Engine.PrecomputedVisibilityOverrideVolume
// 0x0020 (0x02A0 - 0x0280)
class APrecomputedVisibilityOverrideVolume : public AVolume
{
public:
	TArray< class AActor* >                            OverrideVisibleActors;                            		// 0x0280 (0x0010) [0x0000000000000000]              
	TArray< class AActor* >                            OverrideInvisibleActors;                          		// 0x0290 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PrecomputedVisibilityOverrideVolume" );

		return pClassPointer;
	};

};

UClass* APrecomputedVisibilityOverrideVolume::pClassPointer = NULL;

// Class Engine.PrecomputedVisibilityVolume
// 0x0000 (0x0280 - 0x0280)
class APrecomputedVisibilityVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PrecomputedVisibilityVolume" );

		return pClassPointer;
	};

};

UClass* APrecomputedVisibilityVolume::pClassPointer = NULL;

// Class Engine.ReverbVolume
// 0x0044 (0x02C4 - 0x0280)
class AReverbVolume : public AVolume
{
public:
	float                                              Priority;                                         		// 0x0280 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x0284 (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )
	struct FReverbSettings                             Settings;                                         		// 0x0288 (0x0010) [0x0000000000000000]              
	struct FInteriorSettings                           AmbientZoneSettings;                              		// 0x0298 (0x0024) [0x0000000000000000]              
	class AReverbVolume*                               NextLowerPriorityVolume;                          		// 0x02BC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ReverbVolume" );

		return pClassPointer;
	};

	void GetEnvironmentEchoDistance ( );
};

UClass* AReverbVolume::pClassPointer = NULL;

// Class Engine.TriggerVolume
// 0x0000 (0x0280 - 0x0280)
class ATriggerVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TriggerVolume" );

		return pClassPointer;
	};

	void StopsProjectile ( );
	void eventPostBeginPlay ( );
};

UClass* ATriggerVolume::pClassPointer = NULL;

// Class Engine.DroppedPickup
// 0x001C (0x0260 - 0x0244)
class ADroppedPickup : public AActor
{
public:
	class AInventory*                                  Inventory;                                        		// 0x0244 (0x0008) [0x0000000000000000]              
	class UClass*                                      InventoryClass;                                   		// 0x024C (0x0008) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )
	class ANavigationPoint*                            PickupCache;                                      		// 0x0254 (0x0008) [0x0000000000000000]              
	DWORD                                              bFadeOut : 1;                                     		// 0x025C (0x0004) [0x0000000000160000] [0x00000001] ( CPF_EditConst | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DroppedPickup" );

		return pClassPointer;
	};

	void RecheckValidTouch ( );
	void PickedUpBy ( );
	void GiveTo ( );
	void eventLanded ( );
	void DetourWeight ( );
	void eventEncroachedBy ( );
	void eventSetPickupParticles ( );
	void eventSetPickupMesh ( );
	void Reset ( );
	void eventReplicatedEvent ( );
	void eventDestroyed ( );
	void RemoveFromNavigation ( );
	void AddToNavigation ( );
};

UClass* ADroppedPickup::pClassPointer = NULL;

// Class Engine.DynamicSMActor
// 0x0050 (0x0294 - 0x0244)
class ADynamicSMActor : public AActor
{
public:
	class UStaticMeshComponent*                        StaticMeshComponent;                              		// 0x0244 (0x0008) [0x0000000000000000]              
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                 		// 0x024C (0x0008) [0x0000000000000000]              
	class UStaticMesh*                                 ReplicatedMesh;                                   		// 0x0254 (0x0008) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )
	class UMaterialInterface*                          ReplicatedMaterial0;                              		// 0x025C (0x0008) [0x0000000000160000]              ( CPF_EditConst | CPF_GlobalConfig )
	class UMaterialInterface*                          ReplicatedMaterial1;                              		// 0x0264 (0x0008) [0x0000000000170000]              ( CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
	DWORD                                              bForceStaticDecals : 1;                           		// 0x026C (0x0004) [0x0000000000180000] [0x00000001] ( CPF_Component )
	DWORD                                              bPawnCanBaseOn : 1;                               		// 0x026C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bSafeBaseIfAsleep : 1;                            		// 0x026C (0x0004) [0x0000000000000000] [0x00000004] 
	struct FVector                                     ReplicatedMeshTranslation;                        		// 0x0270 (0x000C) [0x0000000000190000]              ( CPF_Travel | CPF_Component )
	struct FRotator                                    ReplicatedMeshRotation;                           		// 0x027C (0x000C) [0x00000000001A0000]              ( CPF_EditConst | CPF_Component )
	struct FVector                                     ReplicatedMeshScale3D;                            		// 0x0288 (0x000C) [0x00000000001B0000]              ( CPF_Travel | CPF_EditConst | CPF_Component )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DynamicSMActor" );

		return pClassPointer;
	};

	void SetLightEnvironmentToNotBeDynamic ( );
	void eventDetach ( );
	void eventAttach ( );
	void CanBasePawn ( );
	void SetStaticMesh ( );
	void OnSetMaterial ( );
	void OnSetMesh ( );
	void eventReplicatedEvent ( );
	void eventPostBeginPlay ( );
};

UClass* ADynamicSMActor::pClassPointer = NULL;

// Class Engine.InterpActor
// 0x004C (0x02E0 - 0x0294)
class AInterpActor : public ADynamicSMActor
{
public:
	DWORD                                              bShouldSaveForCheckpoint : 1;                     		// 0x0294 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bMonitorMover : 1;                                		// 0x0294 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bMonitorZVelocity : 1;                            		// 0x0294 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bDestroyProjectilesOnEncroach : 1;                		// 0x0294 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bContinueOnEncroachPhysicsObject : 1;             		// 0x0294 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bStopOnEncroach : 1;                              		// 0x0294 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bShouldShadowParentAllAttachedActors : 1;         		// 0x0294 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bIsLift : 1;                                      		// 0x0294 (0x0004) [0x0000000000000000] [0x00000080] 
	class ANavigationPoint*                            MyMarker;                                         		// 0x0298 (0x0008) [0x0000000000000000]              
	float                                              MaxZVelocity;                                     		// 0x02A0 (0x0004) [0x0000000000000000]              
	float                                              StayOpenTime;                                     		// 0x02A4 (0x0004) [0x0000000000000000]              
	class UAkBaseSoundObject*                          OpenSound;                                        		// 0x02A8 (0x0008) [0x0000000000000000]              
	class USoundCue*                                   OpeningAmbientSound;                              		// 0x02B0 (0x0008) [0x0000000000000000]              
	class UAkBaseSoundObject*                          OpenedSound;                                      		// 0x02B8 (0x0008) [0x0000000000000000]              
	class UAkBaseSoundObject*                          CloseSound;                                       		// 0x02C0 (0x0008) [0x0000000000000000]              
	class USoundCue*                                   ClosingAmbientSound;                              		// 0x02C8 (0x0008) [0x0000000000000000]              
	class UAkBaseSoundObject*                          ClosedSound;                                      		// 0x02D0 (0x0008) [0x0000000000000000]              
	class UAudioComponent*                             AmbientSoundComponent;                            		// 0x02D8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpActor" );

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void ShouldSaveForCheckpoint ( );
	void ShutDown ( );
	void eventInterpolationChanged ( );
	void eventInterpolationFinished ( );
	void eventInterpolationStarted ( );
	void PlayMovingSound ( );
	void FinishedOpen ( );
	void Restart ( );
	void eventDetach ( );
	void eventAttach ( );
	void eventRanInto ( );
	void eventEncroachingOn ( );
	void eventPostBeginPlay ( );
};

UClass* AInterpActor::pClassPointer = NULL;

// Class Engine.FlexActor
// 0x0000 (0x02E0 - 0x02E0)
class AFlexActor : public AInterpActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FlexActor" );

		return pClassPointer;
	};

};

UClass* AFlexActor::pClassPointer = NULL;

// Class Engine.Emitter
// 0x0014 (0x0258 - 0x0244)
class AEmitter : public AActor
{
public:
	class UParticleSystemComponent*                    ParticleSystemComponent;                          		// 0x0244 (0x0008) [0x0000000000000000]              
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                 		// 0x024C (0x0008) [0x0000000000000000]              
	DWORD                                              bDestroyOnSystemFinish : 1;                       		// 0x0254 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPostUpdateTickGroup : 1;                         		// 0x0254 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCurrentlyActive : 1;                             		// 0x0254 (0x0004) [0x0000000000150000] [0x00000004] ( CPF_Travel | CPF_GlobalConfig )
	DWORD                                              bDepthTestEnabled : 1;                            		// 0x0254 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bUseAsOccluder : 1;                               		// 0x0254 (0x0004) [0x0000000000000000] [0x00000010] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Emitter" );

		return pClassPointer;
	};

	void HideSelf ( );
	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void ShouldSaveForCheckpoint ( );
	void OnSetParticleSysParam ( );
	void SetActorParameter ( );
	void SetExtColorParameter ( );
	void SetColorParameter ( );
	void SetVectorParameter ( );
	void SetFloatParameter ( );
	void ShutDown ( );
	void OnParticleEventGenerator ( );
	void OnToggle ( );
	void OnParticleSystemFinished ( );
	void eventReplicatedEvent ( );
	void eventPostBeginPlay ( );
	void eventSetTemplate ( );
};

UClass* AEmitter::pClassPointer = NULL;

// Class Engine.EmitterPool
// 0x0078 (0x02BC - 0x0244)
class AEmitterPool : public AActor
{
public:
	class UParticleSystemComponent*                    PSCTemplate;                                      		// 0x0244 (0x0008) [0x0000000000000000]              
	TArray< class UParticleSystemComponent* >          PoolComponents;                                   		// 0x024C (0x0010) [0x0000000000000000]              
	TArray< class UParticleSystemComponent* >          ActiveComponents;                                 		// 0x025C (0x0010) [0x0000000000000000]              
	class UParticleSystemComponent*                    FlexSurrogateComponent;                           		// 0x026C (0x0008) [0x0000000000000000]              
	int                                                MaxActiveEffects;                                 		// 0x0274 (0x0004) [0x0000000000000000]              
	DWORD                                              bLogPoolOverflow : 1;                             		// 0x0278 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLogPoolOverflowList : 1;                         		// 0x0278 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< struct FEmitterBaseInfo >                  RelativePSCs;                                     		// 0x027C (0x0010) [0x0000000000000000]              
	float                                              SMC_MIC_ReductionTime;                            		// 0x028C (0x0004) [0x0000000000000000]              
	float                                              SMC_MIC_CurrentReductionTime;                     		// 0x0290 (0x0004) [0x0000000000000000]              
	int                                                IdealStaticMeshComponents;                        		// 0x0294 (0x0004) [0x0000000000000000]              
	int                                                IdealMaterialInstanceConstants;                   		// 0x0298 (0x0004) [0x0000000000000000]              
	TArray< class UStaticMeshComponent* >              FreeSMComponents;                                 		// 0x029C (0x0010) [0x0000000000000000]              
	TArray< class UMaterialInstanceConstant* >         FreeMatInstConsts;                                		// 0x02AC (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.EmitterPool" );

		return pClassPointer;
	};

	void PostBeginPlay ( );
	void SpawnEmitterCustomLifetime ( );
	void SpawnEmitterMeshAttachment ( );
	void SpawnEmitter ( );
	void GetPooledComponent ( );
	void GetFreeMatInstConsts ( );
	void FreeMaterialInstanceConstants ( );
	void GetFreeStaticMeshComponent ( );
	void FreeStaticMeshComponents ( );
	void ReturnToPool ( );
	void ClearPoolComponents ( );
	void OnParticleSystemFinished ( );
};

UClass* AEmitterPool::pClassPointer = NULL;

// Class Engine.HUD
// 0x0320 (0x0564 - 0x0244)
class AHUD : public AActor
{
public:
	struct FColor                                      WhiteColor;                                       		// 0x0244 (0x0004) [0x0000000000000000]              
	struct FColor                                      GreenColor;                                       		// 0x0248 (0x0004) [0x0000000000000000]              
	struct FColor                                      RedColor;                                         		// 0x024C (0x0004) [0x0000000000000000]              
	class APlayerController*                           PlayerOwner;                                      		// 0x0250 (0x0008) [0x0000000000000000]              
	DWORD                                              bLostFocusPaused : 1;                             		// 0x0258 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bShowHUD : 1;                                     		// 0x0258 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bShowScores : 1;                                  		// 0x0258 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bShowDebugInfo : 1;                               		// 0x0258 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bShowBadConnectionAlert : 1;                      		// 0x0258 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bShowDirectorInfoDebug : 1;                       		// 0x0258 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bShowDirectorInfoHUD : 1;                         		// 0x0258 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bMessageBeep : 1;                                 		// 0x0258 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bRenderFullScreen : 1;                            		// 0x0258 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bScaleCanvasForCinematicMode : 1;                 		// 0x0258 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bShowOverlays : 1;                                		// 0x0258 (0x0004) [0x0000000000000000] [0x00000400] 
	float                                              HudCanvasScale;                                   		// 0x025C (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            PostRenderedActors;                               		// 0x0260 (0x0010) [0x0000000000000000]              
	TArray< struct FConsoleMessage >                   ConsoleMessages;                                  		// 0x0270 (0x0010) [0x0000000000000000]              
	struct FColor                                      ConsoleColor;                                     		// 0x0280 (0x0004) [0x0000000000000000]              
	int                                                ConsoleMessageCount;                              		// 0x0284 (0x0004) [0x0000000000000000]              
	int                                                ConsoleFontSize;                                  		// 0x0288 (0x0004) [0x0000000000000000]              
	int                                                MessageFontOffset;                                		// 0x028C (0x0004) [0x0000000000000000]              
	int                                                MaxHUDAreaMessageCount;                           		// 0x0290 (0x0004) [0x0000000000000000]              
	struct FHudLocalizedMessage                        LocalMessages[ 0x8 ];                             		// 0x0294 (0x0280) [0x0000000000000000]              
	float                                              ConsoleMessagePosX;                               		// 0x0514 (0x0004) [0x0000000000000000]              
	float                                              ConsoleMessagePosY;                               		// 0x0518 (0x0004) [0x0000000000000000]              
	class UCanvas*                                     Canvas;                                           		// 0x051C (0x0008) [0x0000000000000000]              
	float                                              LastHUDRenderTime;                                		// 0x0524 (0x0004) [0x0000000000000000]              
	float                                              RenderDelta;                                      		// 0x0528 (0x0004) [0x0000000000000000]              
	float                                              SizeX;                                            		// 0x052C (0x0004) [0x0000000000000000]              
	float                                              SizeY;                                            		// 0x0530 (0x0004) [0x0000000000000000]              
	float                                              CenterX;                                          		// 0x0534 (0x0004) [0x0000000000000000]              
	float                                              CenterY;                                          		// 0x0538 (0x0004) [0x0000000000000000]              
	float                                              RatioX;                                           		// 0x053C (0x0004) [0x0000000000000000]              
	float                                              RatioY;                                           		// 0x0540 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             DebugDisplay;                                     		// 0x0544 (0x0010) [0x0000000000000000]              
	TArray< struct FKismetDrawTextInfo >               KismetTextInfo;                                   		// 0x0554 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.HUD" );

		return pClassPointer;
	};

	void eventOnLostFocusPause ( );
	void NotifyBindPostProcessEffects ( );
	void PlayerOwnerDied ( );
	void GetFontSizeIndex ( );
	void DrawText ( );
	void DisplayKismetMessages ( );
	void DisplayLocalMessages ( );
	void DrawMessageText ( );
	void DrawMessage ( );
	void GetScreenCoords ( );
	void AddLocalizedMessage ( );
	void LocalizedMessage ( );
	void AddConsoleMessage ( );
	void ShouldShowConsoleMessage ( );
	void DisplayConsoleMessages ( );
	void Message ( );
	void ClearMessage ( );
	void DisplayBadConnectionAlert ( );
	void DrawHUD ( );
	void eventPostRender ( );
	void PreCalcValues ( );
	void DrawRoute ( );
	void ShowDebugInfo ( );
	void ToggleDirectorInfoDebug ( );
	void ToggleDirectorInfoHUD ( );
	void ShouldDisplayDebug ( );
	void ShowDebug ( );
	void SetShowScores ( );
	void ShowScores ( );
	void ShowHUD ( );
	void ToggleHUD ( );
	void AddPostRenderedActor ( );
	void RemovePostRenderedActor ( );
	void DrawActorOverlays ( );
	void eventPostBeginPlay ( );
	void Draw2DLine ( );
	void Draw3DLine ( );
};

UClass* AHUD::pClassPointer = NULL;

// Class Engine.AutoTestManager
// 0x00C4 (0x0308 - 0x0244)
class AAutoTestManager : public AInfo
{
public:
	DWORD                                              bAutomatedPerfTesting : 1;                        		// 0x0244 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAutoContinueToNextRound : 1;                     		// 0x0244 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUsingAutomatedTestingMapList : 1;                		// 0x0244 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bAutomatedTestingWithOpen : 1;                    		// 0x0244 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bExitOnCyclesComplete : 1;                        		// 0x0244 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bCheckingForFragmentation : 1;                    		// 0x0244 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bCheckingForMemLeaks : 1;                         		// 0x0244 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bDoingASentinelRun : 1;                           		// 0x0244 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bSentinelStreamingLevelStillLoading : 1;          		// 0x0244 (0x0004) [0x0000000000000000] [0x00000100] 
	int                                                AutomatedPerfRemainingTime;                       		// 0x0248 (0x0004) [0x0000000000000000]              
	int                                                AutomatedTestingMapIndex;                         		// 0x024C (0x0004) [0x0000000000000000]              
	TArray< struct FString >                           AutomatedMapTestingList;                          		// 0x0250 (0x0010) [0x0000000000000000]              
	int                                                NumAutomatedMapTestingCycles;                     		// 0x0260 (0x0004) [0x0000000000000000]              
	int                                                NumberOfMatchesPlayed;                            		// 0x0264 (0x0004) [0x0000000000000000]              
	int                                                NumMapListCyclesDone;                             		// 0x0268 (0x0004) [0x0000000000000000]              
	struct FString                                     AutomatedTestingExecCommandToRunAtStartMatch;     		// 0x026C (0x0010) [0x0000000000000000]              
	struct FString                                     AutomatedMapTestingTransitionMap;                 		// 0x027C (0x0010) [0x0000000000000000]              
	struct FString                                     SentinelTaskDescription;                          		// 0x028C (0x0010) [0x0000000000000000]              
	struct FString                                     SentinelTaskParameter;                            		// 0x029C (0x0010) [0x0000000000000000]              
	struct FString                                     SentinelTagDesc;                                  		// 0x02AC (0x0010) [0x0000000000000000]              
	class APlayerController*                           SentinelPC;                                       		// 0x02BC (0x0008) [0x0000000000000000]              
	TArray< struct FVector >                           SentinelTravelArray;                              		// 0x02C4 (0x0010) [0x0000000000000000]              
	int                                                SentinelNavigationIdx;                            		// 0x02D4 (0x0004) [0x0000000000000000]              
	int                                                SentinelIdx;                                      		// 0x02D8 (0x0004) [0x0000000000000000]              
	int                                                NumRotationsIncrement;                            		// 0x02DC (0x0004) [0x0000000000000000]              
	int                                                TravelPointsIncrement;                            		// 0x02E0 (0x0004) [0x0000000000000000]              
	int                                                NumMinutesPerMap;                                 		// 0x02E4 (0x0004) [0x0000000000000000]              
	TArray< struct FString >                           CommandsToRunAtEachTravelTheWorldNode;            		// 0x02E8 (0x0010) [0x0000000000000000]              
	struct FString                                     CommandStringToExec;                              		// 0x02F8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AutoTestManager" );

		return pClassPointer;
	};

	void CheckForSentinelRun ( );
	void StartMatch ( );
	void GetNextAutomatedTestingMap ( );
	void IncrementNumberOfMatchesPlayed ( );
	void IncrementAutomatedTestingMapIndex ( );
	void CloseAutomatedMapTestTimer ( );
	void StartAutomatedMapTestTimerWorker ( );
	void eventStartAutomatedMapTestTimer ( );
	void DoMemoryTracking ( );
	void DoTimeBasedSentinelStatGathering ( );
	void DoSentinel_ViewDependentMemoryAtSpecificLocation ( );
	void DoSentinel_PerfAtSpecificLocation ( );
	void DoSentinel_MemoryAtSpecificLocation ( );
	void GetTravelLocations ( );
	void HandlePerLoadedMapAudioStats ( );
	void DoSentinelActionPerLoadedMap ( );
	void DoTravelTheWorld ( );
	void EndSentinelRun ( );
	void AddSentinelPerTimePeriodStats ( );
	void BeginSentinelRun ( );
	void InitializeOptions ( );
	void eventTimer ( );
	void eventPostBeginPlay ( );
};

UClass* AAutoTestManager::pClassPointer = NULL;

// Class Engine.CoverGroup
// 0x0018 (0x025C - 0x0244)
class ACoverGroup : public AInfo
{
public:
	TArray< struct FActorReference >                   CoverLinkRefs;                                    		// 0x0244 (0x0010) [0x0000000000000000]              
	float                                              AutoSelectRadius;                                 		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              AutoSelectHeight;                                 		// 0x0258 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CoverGroup" );

		return pClassPointer;
	};

	void OnToggle ( );
	void ToggleGroup ( );
	void DisableGroup ( );
	void EnableGroup ( );
};

UClass* ACoverGroup::pClassPointer = NULL;

// Class Engine.FileWriter
// 0x0020 (0x0264 - 0x0244)
class AFileWriter : public AInfo
{
public:
	struct FPointer                                    ArchivePtr;                                       		// 0x0244 (0x0008) [0x0000000000000000]              
	struct FString                                     Filename;                                         		// 0x024C (0x0010) [0x0000000000000000]              
	unsigned char                                      FileType;                                         		// 0x025C (0x0001) [0x0000000000000000]              
	DWORD                                              bFlushEachWrite : 1;                              		// 0x0260 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bWantsAsyncWrites : 1;                            		// 0x0260 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FileWriter" );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void Logf ( );
	void CloseFile ( );
	void OpenFile ( );
};

UClass* AFileWriter::pClassPointer = NULL;

// Class Engine.FileLog
// 0x0000 (0x0264 - 0x0264)
class AFileLog : public AFileWriter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FileLog" );

		return pClassPointer;
	};

	void CloseLog ( );
	void OpenLog ( );
};

UClass* AFileLog::pClassPointer = NULL;

// Class Engine.GameInfo
// 0x0258 (0x049C - 0x0244)
class AGameInfo : public AInfo
{
public:
	DWORD                                              bRestartLevel : 1;                                		// 0x0244 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPauseable : 1;                                   		// 0x0244 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bTeamGame : 1;                                    		// 0x0244 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bGameEnded : 1;                                   		// 0x0244 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bOverTime : 1;                                    		// 0x0244 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bDelayedStart : 1;                                		// 0x0244 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bWaitingToStartMatch : 1;                         		// 0x0244 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bChangeLevels : 1;                                		// 0x0244 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bAlreadyChanged : 1;                              		// 0x0244 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bAdminCanPause : 1;                               		// 0x0244 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bGameRestarted : 1;                               		// 0x0244 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bLevelChange : 1;                                 		// 0x0244 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bKickLiveIdlers : 1;                              		// 0x0244 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bUsingArbitration : 1;                            		// 0x0244 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bHasArbitratedHandshakeBegun : 1;                 		// 0x0244 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bNeedsEndGameHandshake : 1;                       		// 0x0244 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bIsEndGameHandshakeComplete : 1;                  		// 0x0244 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bHasEndGameHandshakeBegun : 1;                    		// 0x0244 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bFixedPlayerStart : 1;                            		// 0x0244 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bDoFearCostFallOff : 1;                           		// 0x0244 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bUseSeamlessTravel : 1;                           		// 0x0244 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bHasNetworkError : 1;                             		// 0x0244 (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bRequiresPushToTalk : 1;                          		// 0x0244 (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bIsStandbyCheckingEnabled : 1;                    		// 0x0244 (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bIsStandbyCheckingOn : 1;                         		// 0x0244 (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bHasStandbyCheatTriggered : 1;                    		// 0x0244 (0x0004) [0x0000000000000000] [0x02000000] 
	struct FString                                     CauseEventCommand;                                		// 0x0248 (0x0010) [0x0000000000000000]              
	struct FString                                     BugLocString;                                     		// 0x0258 (0x0010) [0x0000000000000000]              
	struct FString                                     BugRotString;                                     		// 0x0268 (0x0010) [0x0000000000000000]              
	TArray< class APlayerController* >                 PendingArbitrationPCs;                            		// 0x0278 (0x0010) [0x0000000000000000]              
	TArray< class APlayerController* >                 ArbitrationPCs;                                   		// 0x0288 (0x0010) [0x0000000000000000]              
	float                                              ArbitrationHandshakeTimeout;                      		// 0x0298 (0x0004) [0x0000000000000000]              
	float                                              GameDifficulty;                                   		// 0x029C (0x0004) [0x0000000000000000]              
	float                                              GameDifficultyModifier;                           		// 0x02A0 (0x0004) [0x0000000000000000]              
	int                                                GoreLevel;                                        		// 0x02A4 (0x0004) [0x0000000000000000]              
	float                                              GameSpeed;                                        		// 0x02A8 (0x0004) [0x0000000000000000]              
	class UClass*                                      DefaultPawnClass;                                 		// 0x02AC (0x0008) [0x0000000000000000]              
	class UClass*                                      HUDType;                                          		// 0x02B4 (0x0008) [0x0000000000000000]              
	class UClass*                                      SecondaryHUDType;                                 		// 0x02BC (0x0008) [0x0000000000000000]              
	int                                                MaxSpectators;                                    		// 0x02C4 (0x0004) [0x0000000000000000]              
	int                                                MaxSpectatorsAllowed;                             		// 0x02C8 (0x0004) [0x0000000000000000]              
	int                                                NumSpectators;                                    		// 0x02CC (0x0004) [0x0000000000000000]              
	int                                                MaxPlayers;                                       		// 0x02D0 (0x0004) [0x0000000000000000]              
	int                                                MaxPlayersAllowed;                                		// 0x02D4 (0x0004) [0x0000000000000000]              
	int                                                NumPlayers;                                       		// 0x02D8 (0x0004) [0x0000000000000000]              
	int                                                NumBots;                                          		// 0x02DC (0x0004) [0x0000000000000000]              
	int                                                NumTravellingPlayers;                             		// 0x02E0 (0x0004) [0x0000000000000000]              
	int                                                CurrentID;                                        		// 0x02E4 (0x0004) [0x0000000000000000]              
	struct FString                                     DefaultPlayerName;                                		// 0x02E8 (0x0010) [0x0000000000000000]              
	struct FString                                     GameName;                                         		// 0x02F8 (0x0010) [0x0000000000000000]              
	float                                              FearCostFallOff;                                  		// 0x0308 (0x0004) [0x0000000000000000]              
	int                                                GoalScore;                                        		// 0x030C (0x0004) [0x0000000000000000]              
	int                                                MaxLives;                                         		// 0x0310 (0x0004) [0x0000000000000000]              
	int                                                TimeLimit;                                        		// 0x0314 (0x0004) [0x0000000000000000]              
	class UClass*                                      DeathMessageClass;                                		// 0x0318 (0x0008) [0x0000000000000000]              
	class UClass*                                      GameMessageClass;                                 		// 0x0320 (0x0008) [0x0000000000000000]              
	class AMutator*                                    BaseMutator;                                      		// 0x0328 (0x0008) [0x0000000000000000]              
	class UClass*                                      AccessControlClass;                               		// 0x0330 (0x0008) [0x0000000000000000]              
	class AAccessControl*                              AccessControl;                                    		// 0x0338 (0x0008) [0x0000000000000000]              
	class UClass*                                      BroadcastHandlerClass;                            		// 0x0340 (0x0008) [0x0000000000000000]              
	class ABroadcastHandler*                           BroadcastHandler;                                 		// 0x0348 (0x0008) [0x0000000000000000]              
	class UClass*                                      AutoTestManagerClass;                             		// 0x0350 (0x0008) [0x0000000000000000]              
	class AAutoTestManager*                            MyAutoTestManager;                                		// 0x0358 (0x0008) [0x0000000000000000]              
	class UClass*                                      PlayerControllerClass;                            		// 0x0360 (0x0008) [0x0000000000000000]              
	class UClass*                                      PlayerReplicationInfoClass;                       		// 0x0368 (0x0008) [0x0000000000000000]              
	class UClass*                                      GameReplicationInfoClass;                         		// 0x0370 (0x0008) [0x0000000000000000]              
	class AGameReplicationInfo*                        GameReplicationInfo;                              		// 0x0378 (0x0008) [0x0000000000000000]              
	class ACrowdPopulationManagerBase*                 PopulationManager;                                		// 0x0380 (0x0008) [0x0000000000000000]              
	class UClass*                                      PopulationManagerClass;                           		// 0x0388 (0x0008) [0x0000000000000000]              
	float                                              MaxIdleTime;                                      		// 0x0390 (0x0004) [0x0000000000000000]              
	float                                              MaxTimeMargin;                                    		// 0x0394 (0x0004) [0x0000000000000000]              
	float                                              TimeMarginSlack;                                  		// 0x0398 (0x0004) [0x0000000000000000]              
	float                                              MinTimeMargin;                                    		// 0x039C (0x0004) [0x0000000000000000]              
	TArray< class APlayerReplicationInfo* >            InactivePRIArray;                                 		// 0x03A0 (0x0010) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   Pausers;                                          		// 0x03B0 (0x0010) [0x0000000000000000]              
	class UOnlineSubsystem*                            OnlineSub;                                        		// 0x03C0 (0x0008) [0x0000000000000000]              
	class UPlayfabInterface*                           PlayfabInter;                                     		// 0x03C8 (0x0008) [0x0000000000000000]              
	class UOnlineGameInterface*                        GameInterface;                                    		// 0x03D0 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x03D8 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UClass*                                      OnlineStatsWriteClass;                            		// 0x03E0 (0x0008) [0x0000000000000000]              
	int                                                LeaderboardId;                                    		// 0x03E8 (0x0004) [0x0000000000000000]              
	int                                                ArbitratedLeaderboardId;                          		// 0x03EC (0x0004) [0x0000000000000000]              
	class ACoverReplicator*                            CoverReplicatorBase;                              		// 0x03F0 (0x0008) [0x0000000000000000]              
	class UClass*                                      OnlineGameSettingsClass;                          		// 0x03F8 (0x0008) [0x0000000000000000]              
	struct FString                                     ServerOptions;                                    		// 0x0400 (0x0010) [0x0000000000000000]              
	int                                                AdjustedNetSpeed;                                 		// 0x0410 (0x0004) [0x0000000000000000]              
	float                                              LastNetSpeedUpdateTime;                           		// 0x0414 (0x0004) [0x0000000000000000]              
	int                                                TotalNetBandwidth;                                		// 0x0418 (0x0004) [0x0000000000000000]              
	int                                                MinDynamicBandwidth;                              		// 0x041C (0x0004) [0x0000000000000000]              
	int                                                MaxDynamicBandwidth;                              		// 0x0420 (0x0004) [0x0000000000000000]              
	float                                              StandbyRxCheatTime;                               		// 0x0424 (0x0004) [0x0000000000000000]              
	float                                              StandbyTxCheatTime;                               		// 0x0428 (0x0004) [0x0000000000000000]              
	int                                                BadPingThreshold;                                 		// 0x042C (0x0004) [0x0000000000000000]              
	float                                              PercentMissingForRxStandby;                       		// 0x0430 (0x0004) [0x0000000000000000]              
	float                                              PercentMissingForTxStandby;                       		// 0x0434 (0x0004) [0x0000000000000000]              
	float                                              PercentForBadPing;                                		// 0x0438 (0x0004) [0x0000000000000000]              
	float                                              JoinInProgressStandbyWaitTime;                    		// 0x043C (0x0004) [0x0000000000000000]              
	class UMaterial*                                   StreamingPauseIcon;                               		// 0x0440 (0x0008) [0x0000000000000000]              
	TArray< struct FGameClassShortName >               GameInfoClassAliases;                             		// 0x0448 (0x0010) [0x0000000000000000]              
	struct FString                                     DefaultGameType;                                  		// 0x0458 (0x0010) [0x0000000000000000]              
	TArray< struct FGameTypePrefix >                   DefaultMapPrefixes;                               		// 0x0468 (0x0010) [0x0000000000000000]              
	TArray< struct FGameTypePrefix >                   CustomMapPrefixes;                                		// 0x0478 (0x0010) [0x0000000000000000]              
	int                                                AnimTreePoolSize;                                 		// 0x0488 (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __CanUnpause__Delegate;                           		// 0x048C (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x4 ];                             		// 0x0490 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GameInfo" );

		return pClassPointer;
	};

	void eventGetRequiresPassword ( );
	void NotifyControllerReconnected ( );
	void NotifyControllerDisconnected ( );
	void eventGetFriendlyNameForCurrentGameMode ( );
	void WasLaunchedByPlayfab ( );
	void eventOnRetreivedPFInternalUserData ( );
	void ClearOnlineDelegates ( );
	void InitCrowdPopulationManager ( );
	void eventOnEngineHasLoaded ( );
	void OnDestroyOnlineGameComplete ( );
	void eventStandbyCheatDetected ( );
	void EnableStandbyCheatDetection ( );
	void BeginBVT ( );
	void CheckForSentinelRun ( );
	void ShouldAutoContinueToNextRound ( );
	void IsDoingASentinelRun ( );
	void IsCheckingForMemLeaks ( );
	void IsCheckingForFragmentation ( );
	void IsAutomatedPerfTesting ( );
	void SetBandwidthLimit ( );
	void DoTravelTheWorld ( );
	void TellClientsToTravelToSession ( );
	void TellClientsPartyHostIsLeaving ( );
	void TellClientsToReturnToPartyHost ( );
	void OnServerCreateComplete ( );
	void RegisterServer ( );
	void OnLoginChange ( );
	void OnLoginFailed ( );
	void ClearAutoLoginDelegates ( );
	void ProcessServerLogin ( );
	void eventMatineeCancelled ( );
	void RecalculateSkillRating ( );
	void UpdateGameplayMuteList ( );
	void NotifyArbitratedMatchEnd ( );
	void MatchIsInProgress ( );
	void ArbitrationRegistrationComplete ( );
	void RegisterServerForArbitration ( );
	void StartArbitratedMatch ( );
	void StartArbitrationRegistration ( );
	void ProcessClientRegistrationCompletion ( );
	void UpdateGameSettingsCounts ( );
	void SetSeamlessTravelViewTarget ( );
	void eventHandleSeamlessTravelPlayer ( );
	void UpdateGameSettings ( );
	void eventPostSeamlessTravel ( );
	void SwapPlayerControllers ( );
	void eventGetSeamlessTravelActorList ( );
	void OverridePRI ( );
	void FindInactivePRI ( );
	void AddInactivePRI ( );
	void eventPostCommitMapChange ( );
	void eventPreCommitMapChange ( );
	void AllowPausing ( );
	void AllowCheats ( );
	void AllowMutator ( );
	void PlayerCanRestart ( );
	void PlayerCanRestartGame ( );
	void DriverLeftVehicle ( );
	void CanLeaveVehicle ( );
	void DriverEnteredVehicle ( );
	void ModifyScoreKill ( );
	void ScoreKill ( );
	void CheckScore ( );
	void ScoreObjective ( );
	void AddObjectiveScore ( );
	void RatePlayerStart ( );
	void ChoosePlayerStart ( );
	void FindPlayerStart ( );
	void ShouldSpawnAtStartSpot ( );
	void EndLogging ( );
	void GameEventsPoll ( );
	void EndOnlineGame ( );
	void PerformEndGameHandling ( );
	void EndGame ( );
	void WriteOnlinePlayerScores ( );
	void WriteOnlineStats ( );
	void CheckEndGame ( );
	void CheckModifiedEndGame ( );
	void eventBroadcastLocalizedTeam ( );
	void eventBroadcastLocalized ( );
	void BroadcastTeam ( );
	void eventBroadcast ( );
	void RestartGame ( );
	void GetTravelType ( );
	void GetNextMap ( );
	void SendPlayer ( );
	void PickTeam ( );
	void ChangeTeam ( );
	void ChangeName ( );
	void DiscardInventory ( );
	void PickupQuery ( );
	void ShouldRespawn ( );
	void CheckRelevance ( );
	void ReduceDamage ( );
	void CanSpectate ( );
	void KickBan ( );
	void Kick ( );
	void BroadcastDeathMessage ( );
	void PreventDeath ( );
	void Killed ( );
	void NotifyKilled ( );
	void SetPlayerDefaults ( );
	void Mutate ( );
	void eventAddDefaultInventory ( );
	void eventAcceptInventory ( );
	void UnregisterPlayer ( );
	void Logout ( );
	void eventPreExit ( );
	void CalculatedNetSpeed ( );
	void UpdateNetSpeeds ( );
	void eventPostLogin ( );
	void UpdateBestNextHosts ( );
	void BestNextHostSort ( );
	void GenericPlayerInitialization ( );
	void ReplicateStreamingStatus ( );
	void GetDefaultPlayerClass ( );
	void SpawnDefaultPawnFor ( );
	void RestartPlayer ( );
	void StartBots ( );
	void StartHumans ( );
	void OnStartOnlineGameComplete ( );
	void StartOnlineGame ( );
	void StartMatch ( );
	void SetNeedsReload ( );
	void SetNeedsRestart ( );
	void eventConfirmReservation ( );
	void eventMakeReservations ( );
	void eventSeatPlayer ( );
	void ScoreHeal ( );
	void ScoreDamage ( );
	void AllowAnalyticsLogging ( );
	void eventLogin ( );
	void SpawnPlayerController ( );
	void GetNextPlayerID ( );
	void AtCapacity ( );
	void RejectLogin ( );
	void ResumeLogin ( );
	void PauseLogin ( );
	void eventPreLogin ( );
	void RequiresPassword ( );
	void GetModifiedGameDifficulty ( );
	void ProcessClientTravel ( );
	void ProcessServerTravel ( );
	void GetShouldShowLength ( );
	void CheckNextMap ( );
	void RemoveMutator ( );
	void AddMutator ( );
	void eventNotifyPendingConnectionLost ( );
	void eventInitGame ( );
	void eventSetGameType ( );
	void eventGetDefaultGameClassPath ( );
	void GetIntOption ( );
	void HasOption ( );
	void ParseOption ( );
	void GetKeyValue ( );
	void GrabOption ( );
	void SetGameSpeed ( );
	void DebugPause ( );
	void ForceClearUnpauseDelegates ( );
	void eventClearPause ( );
	void SetPause ( );
	void CanUnpause ( );
	void GetNumPlayers ( );
	void GetNetworkNumber ( );
	void InitGameReplicationInfo ( );
	void eventForceKickPlayer ( );
	void eventKickIdler ( );
	void eventGameEnding ( );
	void NotifyNavigationChanged ( );
	void DoNavFearCostFallOff ( );
	void ShouldStartInCinematicMode ( );
	void eventTimer ( );
	void ResetLevel ( );
	void ShouldReset ( );
	void Reset ( );
	void DisplayDebug ( );
	void OnServerTitleDataRead ( );
	void eventPostBeginPlay ( );
	void GetCoverReplicator ( );
	void eventPreBeginPlay ( );
	void GetMapCommonPackageName ( );
	void GetSupportedGameTypes ( );
};

UClass* AGameInfo::pClassPointer = NULL;

// Class Engine.Mutator
// 0x001C (0x0260 - 0x0244)
class AMutator : public AInfo
{
public:
	class AMutator*                                    NextMutator;                                      		// 0x0244 (0x0008) [0x0000000000000000]              
	TArray< struct FString >                           GroupNames;                                       		// 0x024C (0x0010) [0x0000000000000000]              
	DWORD                                              bUserAdded : 1;                                   		// 0x025C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Mutator" );

		return pClassPointer;
	};

	void ModifyZedTime ( );
	void ModifyActivatedPickupFactory ( );
	void ModifyPickupFactories ( );
	void ModifyAIEnemy ( );
	void ModifyAI ( );
	void ModifyNextTraderIndex ( );
	void NetDamage ( );
	void ScoreKill ( );
	void ScoreObjective ( );
	void PreventDeath ( );
	void OverridePickupQuery ( );
	void CheckEndGame ( );
	void HandleRestartGame ( );
	void FindPlayerStart ( );
	void GetSeamlessTravelActorList ( );
	void InitMutator ( );
	void DriverLeftVehicle ( );
	void CanLeaveVehicle ( );
	void DriverEnteredVehicle ( );
	void NotifyLogin ( );
	void NotifyLogout ( );
	void CheckReplacement ( );
	void CheckRelevance ( );
	void IsRelevant ( );
	void AlwaysKeep ( );
	void AddMutator ( );
	void ModifyPlayer ( );
	void ModifyLogin ( );
	void Mutate ( );
	void eventDestroyed ( );
	void MutatorIsAllowed ( );
	void eventPreBeginPlay ( );
};

UClass* AMutator::pClassPointer = NULL;

// Class Engine.PotentialClimbWatcher
// 0x0000 (0x0244 - 0x0244)
class APotentialClimbWatcher : public AInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PotentialClimbWatcher" );

		return pClassPointer;
	};

	void eventTick ( );
};

UClass* APotentialClimbWatcher::pClassPointer = NULL;

// Class Engine.Route
// 0x0024 (0x0268 - 0x0244)
class ARoute : public AInfo
{
public:
	struct FPointer                                    VfTable_IEditorLinkSelectionInterface;            		// 0x0244 (0x0008) [0x0000000000000000]              
	unsigned char                                      RouteType;                                        		// 0x024C (0x0001) [0x0000000000000000]              
	TArray< struct FActorReference >                   RouteList;                                        		// 0x0250 (0x0010) [0x0000000000000000]              
	float                                              FudgeFactor;                                      		// 0x0260 (0x0004) [0x0000000000000000]              
	int                                                RouteIndexOffset;                                 		// 0x0264 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Route" );

		return pClassPointer;
	};

	void MoveOntoRoutePath ( );
	void ResolveRouteIndex ( );
};

UClass* ARoute::pClassPointer = NULL;

// Class Engine.WindPointSource
// 0x0008 (0x024C - 0x0244)
class AWindPointSource : public AInfo
{
public:
	class UWindPointSourceComponent*                   Component;                                        		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.WindPointSource" );

		return pClassPointer;
	};

};

UClass* AWindPointSource::pClassPointer = NULL;

// Class Engine.Inventory
// 0x0074 (0x02B8 - 0x0244)
class AInventory : public AActor
{
public:
	class AInventory*                                  Inventory;                                        		// 0x0244 (0x0008) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )
	class AInventoryManager*                           InvManager;                                       		// 0x024C (0x0008) [0x0000000000160000]              ( CPF_EditConst | CPF_GlobalConfig )
	struct FString                                     ItemName;                                         		// 0x0254 (0x0010) [0x0000000000000000]              
	DWORD                                              bDropOnDeath : 1;                                 		// 0x0264 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDelayedSpawn : 1;                                		// 0x0264 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bPredictRespawns : 1;                             		// 0x0264 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              RespawnTime;                                      		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              MaxDesireability;                                 		// 0x026C (0x0004) [0x0000000000000000]              
	struct FString                                     PickupMessage;                                    		// 0x0270 (0x0010) [0x0000000000000000]              
	class USoundCue*                                   PickupSound;                                      		// 0x0280 (0x0008) [0x0000000000000000]              
	struct FString                                     PickupForce;                                      		// 0x0288 (0x0010) [0x0000000000000000]              
	class UClass*                                      DroppedPickupClass;                               		// 0x0298 (0x0008) [0x0000000000000000]              
	class UPrimitiveComponent*                         DroppedPickupMesh;                                		// 0x02A0 (0x0008) [0x0000000000000000]              
	class UPrimitiveComponent*                         PickupFactoryMesh;                                		// 0x02A8 (0x0008) [0x0000000000000000]              
	class UParticleSystemComponent*                    DroppedPickupParticles;                           		// 0x02B0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Inventory" );

		return pClassPointer;
	};

	void GetLocalString ( );
	void DropFrom ( );
	void DenyPickupQuery ( );
	void ItemRemovedFromInvManager ( );
	void ClientGivenTo ( );
	void GivenTo ( );
	void AnnouncePickup ( );
	void GiveTo ( );
	void DetourWeight ( );
	void BotDesireability ( );
	void eventDestroyed ( );
	void GetHumanReadableName ( );
};

UClass* AInventory::pClassPointer = NULL;

// Class Engine.Weapon
// 0x00D0 (0x0388 - 0x02B8)
class AWeapon : public AInventory
{
public:
	unsigned char                                      CurrentFireMode;                                  		// 0x02B8 (0x0001) [0x0000000000000000]              
	TArray< struct FName >                             FiringStatesArray;                                		// 0x02BC (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            WeaponFireTypes;                                  		// 0x02CC (0x0010) [0x0000000000000000]              
	TArray< class UClass* >                            WeaponProjectiles;                                		// 0x02DC (0x0010) [0x0000000000000000]              
	TArray< float >                                    FireInterval;                                     		// 0x02EC (0x0010) [0x0000000000000000]              
	TArray< float >                                    Spread;                                           		// 0x02FC (0x0010) [0x0000000000000000]              
	TArray< float >                                    InstantHitDamage;                                 		// 0x030C (0x0010) [0x0000000000000000]              
	TArray< float >                                    InstantHitMomentum;                               		// 0x031C (0x0010) [0x0000000000000000]              
	TArray< class UClass* >                            InstantHitDamageTypes;                            		// 0x032C (0x0010) [0x0000000000000000]              
	float                                              EquipTime;                                        		// 0x033C (0x0004) [0x0000000000000000]              
	float                                              PutDownTime;                                      		// 0x0340 (0x0004) [0x0000000000000000]              
	struct FVector                                     FireOffset;                                       		// 0x0344 (0x000C) [0x0000000000000000]              
	DWORD                                              bWeaponPutDown : 1;                               		// 0x0350 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bCanThrow : 1;                                    		// 0x0350 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bWasOptionalSet : 1;                              		// 0x0350 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bWasDoNotActivate : 1;                            		// 0x0350 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bInstantHit : 1;                                  		// 0x0350 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bMeleeWeapon : 1;                                 		// 0x0350 (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              WeaponRange;                                      		// 0x0354 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              Mesh;                                             		// 0x0358 (0x0008) [0x0000000000000000]              
	float                                              DefaultAnimSpeed;                                 		// 0x0360 (0x0004) [0x0000000000000000]              
	float                                              Priority;                                         		// 0x0364 (0x0004) [0x0000000000000000]              
	class AAIController*                               AIController;                                     		// 0x0368 (0x0008) [0x0000000000000000]              
	TArray< unsigned char >                            ShouldFireOnRelease;                              		// 0x0370 (0x0010) [0x0000000000000000]              
	float                                              AIRating;                                         		// 0x0380 (0x0004) [0x0000000000000000]              
	float                                              CachedMaxRange;                                   		// 0x0384 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Weapon" );

		return pClassPointer;
	};

	void SetMeshLightingChannels ( );
	void GetTargetDistance ( );
	void CacheAIController ( );
	void WeaponIsDown ( );
	void StillFiring ( );
	void ShouldRefire ( );
	void NotifyWeaponFinishedFiring ( );
	void NotifyWeaponFired ( );
	void HandleFinishedFiring ( );
	void TryPutDown ( );
	void eventGetPhysicalFireStartLoc ( );
	void eventGetMuzzleLoc ( );
	void CustomFire ( );
	void ProjectileFire ( );
	void ProcessInstantHit ( );
	void InstantFire ( );
	void PassThroughDamage ( );
	void CalcWeaponFire ( );
	void GetTraceOwner ( );
	void eventGetTraceRange ( );
	void GetAdjustedAim ( );
	void FireAmmunition ( );
	void FireModeUpdated ( );
	void SetCurrentFireMode ( );
	void SendToFiringState ( );
	void ForceEndFire ( );
	void EndFire ( );
	void ServerStopFire ( );
	void StopFire ( );
	void BeginFire ( );
	void ServerStartFire ( );
	void StartFire ( );
	void ClientWeaponSet ( );
	void ClientGivenTo ( );
	void DetachWeapon ( );
	void AttachWeaponTo ( );
	void ClearFlashLocation ( );
	void SetFlashLocation ( );
	void ClearFlashCount ( );
	void IncrementFlashCount ( );
	void WeaponEmpty ( );
	void DenyPickupQuery ( );
	void PutDownWeapon ( );
	void Activate ( );
	void TimeWeaponEquipping ( );
	void TimeWeaponPutDown ( );
	void RefireCheckTimer ( );
	void TimeWeaponFiring ( );
	void GetFireInterval ( );
	void StopFireEffects ( );
	void PlayFireEffects ( );
	void StopWeaponAnimation ( );
	void PlayWeaponAnimation ( );
	void GetWeaponAnimNodeSeq ( );
	void FireOnRelease ( );
	void CanAttack ( );
	void GetWeaponRating ( );
	void GetAIRating ( );
	void MaxRange ( );
	void AddSpread ( );
	void GetProjectileClass ( );
	void ClearPendingFire ( );
	void SetPendingFire ( );
	void PendingFire ( );
	void GetPendingFireLength ( );
	void HasAnyAmmo ( );
	void HasAmmo ( );
	void AddAmmo ( );
	void ConsumeAmmo ( );
	void GetWeaponDebug ( );
	void DisplayDebug ( );
	void DrawHUD ( );
	void DenyClientWeaponSet ( );
	void eventIsFiring ( );
	void ClientWeaponThrown ( );
	void CanThrow ( );
	void DropFrom ( );
	void DoOverridePrevWeapon ( );
	void DoOverrideNextWeapon ( );
	void HolderDied ( );
	void ItemRemovedFromInvManager ( );
	void eventDestroyed ( );
	void ShouldWeaponIgnoreStartFire ( );
	void GetModifiedFOVAngle ( );
	void ShouldOwnerWalk ( );
};

UClass* AWeapon::pClassPointer = NULL;

// Class Engine.InventoryManager
// 0x002C (0x0270 - 0x0244)
class AInventoryManager : public AActor
{
public:
	class AInventory*                                  InventoryChain;                                   		// 0x0244 (0x0008) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )
	class AWeapon*                                     PendingWeapon;                                    		// 0x024C (0x0008) [0x0000000000000000]              
	class AWeapon*                                     LastAttemptedSwitchToWeapon;                      		// 0x0254 (0x0008) [0x0000000000000000]              
	DWORD                                              bMustHoldWeapon : 1;                              		// 0x025C (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< int >                                      PendingFire;                                      		// 0x0260 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InventoryManager" );

		return pClassPointer;
	};

	void UpdateController ( );
	void ClientWeaponSet ( );
	void ChangedWeapon ( );
	void ClearPendingWeapon ( );
	void CancelWeaponChange ( );
	void SetPendingWeapon ( );
	void InternalSetCurrentWeapon ( );
	void ServerSetCurrentWeapon ( );
	void SetCurrentWeapon ( );
	void NextWeapon ( );
	void PrevWeapon ( );
	void SwitchToBestWeapon ( );
	void GetBestWeapon ( );
	void GetWeaponRatingFor ( );
	void DrawHUD ( );
	void OwnerDied ( );
	void eventDiscardInventory ( );
	void RemoveFromInventory ( );
	void AddInventory ( );
	void CreateInventory ( );
	void eventFindInventoryType ( );
	void HandlePickupQuery ( );
	void eventDestroyed ( );
	void SetupFor ( );
	void InventoryActors ( );
	void ClearAllPendingFire ( );
	void IsPendingFire ( );
	void ClearPendingFire ( );
	void SetPendingFire ( );
	void GetPendingFireLength ( );
	void eventPostBeginPlay ( );
};

UClass* AInventoryManager::pClassPointer = NULL;

// Class Engine.Keypoint
// 0x0008 (0x024C - 0x0244)
class AKeypoint : public AActor
{
public:
	class USpriteComponent*                            SpriteComp;                                       		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Keypoint" );

		return pClassPointer;
	};

};

UClass* AKeypoint::pClassPointer = NULL;

// Class Engine.TargetPoint
// 0x000C (0x0258 - 0x024C)
class ATargetPoint : public AKeypoint
{
public:
	class UTexture2D*                                  SpawnSpriteTexture;                               		// 0x024C (0x0008) [0x0000000000000000]              
	int                                                SpawnRefCount;                                    		// 0x0254 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TargetPoint" );

		return pClassPointer;
	};

};

UClass* ATargetPoint::pClassPointer = NULL;

// Class Engine.MaterialInstanceActor
// 0x0008 (0x024C - 0x0244)
class AMaterialInstanceActor : public AActor
{
public:
	class UMaterialInstanceConstant*                   MatInst;                                          		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialInstanceActor" );

		return pClassPointer;
	};

};

UClass* AMaterialInstanceActor::pClassPointer = NULL;

// Class Engine.MatineeActor
// 0x00E0 (0x0324 - 0x0244)
class AMatineeActor : public AActor
{
public:
	class USeqAct_Interp*                              InterpAction;                                     		// 0x0244 (0x0008) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )
	DWORD                                              bIsPlaying : 1;                                   		// 0x024C (0x0004) [0x0000000000160020] [0x00000001] ( CPF_Net | CPF_EditConst | CPF_GlobalConfig )
	DWORD                                              bReversePlayback : 1;                             		// 0x024C (0x0004) [0x0000000000170020] [0x00000002] ( CPF_Net | CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
	DWORD                                              bPaused : 1;                                      		// 0x024C (0x0004) [0x0000000000180020] [0x00000004] ( CPF_Net | CPF_Component )
	DWORD                                              AllAIGroupsInitialized : 1;                       		// 0x024C (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              PlayRate;                                         		// 0x0250 (0x0004) [0x0000000000190020]              ( CPF_Net | CPF_Travel | CPF_Component )
	float                                              Position;                                         		// 0x0254 (0x0004) [0x00000000001A0020]              ( CPF_Net | CPF_EditConst | CPF_Component )
	struct FName                                       AIGroupNames[ 0xA ];                              		// 0x0258 (0x0050) [0x00000000001B0020]              ( CPF_Net | CPF_Travel | CPF_EditConst | CPF_Component )
	class APawn*                                       AIGroupPawns[ 0xA ];                              		// 0x02A8 (0x0050) [0x0000000000250020]              ( CPF_Net | CPF_Travel | CPF_GlobalConfig )
	int                                                AIGroupInitStage[ 0xA ];                          		// 0x02F8 (0x0028) [0x0000000000000000]              
	float                                              ClientSidePositionErrorTolerance;                 		// 0x0320 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MatineeActor" );

		return pClassPointer;
	};

	void CheckPriorityRefresh ( );
	void eventUpdate ( );
	void AddAIGroupActor ( );
};

UClass* AMatineeActor::pClassPointer = NULL;

// Class Engine.NavigationPoint
// 0x0138 (0x037C - 0x0244)
class ANavigationPoint : public AActor
{
public:
	DWORD                                              bEndPoint : 1;                                    		// 0x0244 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bTransientEndPoint : 1;                           		// 0x0244 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bHideEditorPaths : 1;                             		// 0x0244 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bCanReach : 1;                                    		// 0x0244 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bBlocked : 1;                                     		// 0x0244 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bOneWayPath : 1;                                  		// 0x0244 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bNeverUseStrafing : 1;                            		// 0x0244 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bAlwaysUseStrafing : 1;                           		// 0x0244 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bForceNoStrafing : 1;                             		// 0x0244 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bAutoBuilt : 1;                                   		// 0x0244 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bSpecialMove : 1;                                 		// 0x0244 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bAllowPathConnections : 1;                        		// 0x0244 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bWallNode : 1;                                    		// 0x0244 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bNoAutoConnect : 1;                               		// 0x0244 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bNotifyOnAddToRouteCache : 1;                     		// 0x0244 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bNotBased : 1;                                    		// 0x0244 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bPathsChanged : 1;                                		// 0x0244 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bDestinationOnly : 1;                             		// 0x0244 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bSourceOnly : 1;                                  		// 0x0244 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bSpecialForced : 1;                               		// 0x0244 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bMustBeReachable : 1;                             		// 0x0244 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bBlockable : 1;                                   		// 0x0244 (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bFlyingPreferred : 1;                             		// 0x0244 (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bMayCausePain : 1;                                		// 0x0244 (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bAlreadyVisited : 1;                              		// 0x0244 (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bVehicleDestination : 1;                          		// 0x0244 (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bMakeSourceOnly : 1;                              		// 0x0244 (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bMustTouchToReach : 1;                            		// 0x0244 (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bCanWalkOnToReach : 1;                            		// 0x0244 (0x0004) [0x0000000000000000] [0x10000000] 
	DWORD                                              bBuildLongPaths : 1;                              		// 0x0244 (0x0004) [0x0000000000000000] [0x20000000] 
	DWORD                                              bBlockedForVehicles : 1;                          		// 0x0244 (0x0004) [0x0000000000000000] [0x40000000] 
	DWORD                                              bPreferredVehiclePath : 1;                        		// 0x0244 (0x0004) [0x0000000000000000] [0x80000000] 
	DWORD                                              bHasCrossLevelPaths : 1;                          		// 0x0248 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bShouldSaveForCheckpoint : 1;                     		// 0x0248 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bConnectToSameFloorOnly : 1;                      		// 0x0248 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bNoAutoConnectBiDirectional : 1;                  		// 0x0248 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bBadPlacement : 1;                                		// 0x0248 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bUnnecessaryNavPoint : 1;                         		// 0x0248 (0x0004) [0x0000000000000000] [0x00000020] 
	struct FNavigationOctreeObject                     NavOctreeObject;                                  		// 0x024C (0x003C) [0x0000000000000000]              
	float                                              Luminance;                                        		// 0x0288 (0x0004) [0x0000000000000000]              
	struct FLinearColor                                Intensity;                                        		// 0x028C (0x0010) [0x0000000000000000]              
	struct FName                                       DebugTag;                                         		// 0x029C (0x0008) [0x0000000000000000]              
	TArray< class UReachSpec* >                        PathList;                                         		// 0x02A4 (0x0010) [0x0000000000000000]              
	TArray< struct FActorReference >                   EditorProscribedPaths;                            		// 0x02B4 (0x0010) [0x0000000000000000]              
	TArray< struct FActorReference >                   EditorForcedPaths;                                		// 0x02C4 (0x0010) [0x0000000000000000]              
	TArray< struct FActorReference >                   Volumes;                                          		// 0x02D4 (0x0010) [0x0000000000000000]              
	int                                                visitedWeight;                                    		// 0x02E4 (0x0004) [0x0000000000000000]              
	int                                                bestPathWeight;                                   		// 0x02E8 (0x0004) [0x0000000000000000]              
	class ANavigationPoint*                            nextNavigationPoint;                              		// 0x02EC (0x0008) [0x0000000000000000]              
	class ANavigationPoint*                            nextOrdered;                                      		// 0x02F4 (0x0008) [0x0000000000000000]              
	class ANavigationPoint*                            prevOrdered;                                      		// 0x02FC (0x0008) [0x0000000000000000]              
	class ANavigationPoint*                            previousPath;                                     		// 0x0304 (0x0008) [0x0000000000000000]              
	int                                                Cost;                                             		// 0x030C (0x0004) [0x0000000000000000]              
	int                                                ExtraCost;                                        		// 0x0310 (0x0004) [0x0000000000000000]              
	int                                                TransientCost;                                    		// 0x0314 (0x0004) [0x0000000000000000]              
	int                                                FearCost;                                         		// 0x0318 (0x0004) [0x0000000000000000]              
	TArray< struct FDebugNavCost >                     CostArray;                                        		// 0x031C (0x0010) [0x0000000000000000]              
	class ADroppedPickup*                              InventoryCache;                                   		// 0x032C (0x0008) [0x0000000000000000]              
	float                                              InventoryDist;                                    		// 0x0334 (0x0004) [0x0000000000000000]              
	float                                              LastDetourWeight;                                 		// 0x0338 (0x0004) [0x0000000000000000]              
	class UCylinderComponent*                          CylinderComponent;                                		// 0x033C (0x0008) [0x0000000000000000]              
	struct FCylinder                                   MaxPathSize;                                      		// 0x0344 (0x0008) [0x0000000000000000]              
	struct FGuid                                       NavGuid;                                          		// 0x034C (0x0010) [0x0000000000000000]              
	class USpriteComponent*                            GoodSprite;                                       		// 0x035C (0x0008) [0x0000000000000000]              
	class USpriteComponent*                            BadSprite;                                        		// 0x0364 (0x0008) [0x0000000000000000]              
	int                                                NetworkID;                                        		// 0x036C (0x0004) [0x0000000000000000]              
	class APawn*                                       AnchoredPawn;                                     		// 0x0370 (0x0008) [0x0000000000000000]              
	float                                              LastAnchoredPawnTime;                             		// 0x0378 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavigationPoint" );

		return pClassPointer;
	};

	void eventGetDebugAbbrev ( );
	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void ShouldSaveForCheckpoint ( );
	void eventShutDown ( );
	void OnToggle ( );
	void IsOnDifferentNetwork ( );
	void GetAllNavInRadius ( );
	void GetNearestNavToPoint ( );
	void GetNearestNavToActor ( );
	void ProceedWithMove ( );
	void eventSuggestMovePreparation ( );
	void eventDetourWeight ( );
	void eventAccept ( );
	void eventSpecialCost ( );
	void CanTeleport ( );
	void IsUsableAnchorFor ( );
	void GetReachSpecTo ( );
	void GetBoundingCylinder ( );
};

UClass* ANavigationPoint::pClassPointer = NULL;

// Class Engine.CoverLink
// 0x0099 (0x0415 - 0x037C)
class ACoverLink : public ANavigationPoint
{
public:
	DWORD                                              GLOBAL_bUseSlotMarkers : 1;                       		// 0x037C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDisabled : 1;                                    		// 0x037C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bClaimAllSlots : 1;                               		// 0x037C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bAutoSort : 1;                                    		// 0x037C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bAutoAdjust : 1;                                  		// 0x037C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bCircular : 1;                                    		// 0x037C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bLooped : 1;                                      		// 0x037C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bPlayerOnly : 1;                                  		// 0x037C (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bDynamicCover : 1;                                		// 0x037C (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bFractureOnTouch : 1;                             		// 0x037C (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bDebug_FireLinks : 1;                             		// 0x037C (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bDebug_ExposedLinks : 1;                          		// 0x037C (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bDebug_CoverGen : 1;                              		// 0x037C (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bDoAutoSlotDensityFixup : 1;                      		// 0x037C (0x0004) [0x0000000000000000] [0x00002000] 
	float                                              LeanTraceDist;                                    		// 0x0380 (0x0004) [0x0000000000000000]              
	TArray< struct FCoverSlot >                        Slots;                                            		// 0x0384 (0x0010) [0x0000000000000000]              
	TArray< struct FDynamicLinkInfo >                  DynamicLinkInfos;                                 		// 0x0394 (0x0010) [0x0000000000000000]              
	TArray< class APawn* >                             Claims;                                           		// 0x03A4 (0x0010) [0x0000000000000000]              
	float                                              InvalidateDistance;                               		// 0x03B4 (0x0004) [0x0000000000000000]              
	float                                              MaxFireLinkDist;                                  		// 0x03B8 (0x0004) [0x0000000000000000]              
	struct FVector                                     CircularOrigin;                                   		// 0x03BC (0x000C) [0x0000000000000000]              
	float                                              CircularRadius;                                   		// 0x03C8 (0x0004) [0x0000000000000000]              
	float                                              AlignDist;                                        		// 0x03CC (0x0004) [0x0000000000000000]              
	float                                              AutoCoverSlotInterval;                            		// 0x03D0 (0x0004) [0x0000000000000000]              
	float                                              StandHeight;                                      		// 0x03D4 (0x0004) [0x0000000000000000]              
	float                                              MidHeight;                                        		// 0x03D8 (0x0004) [0x0000000000000000]              
	struct FVector                                     StandingLeanOffset;                               		// 0x03DC (0x000C) [0x0000000000000000]              
	struct FVector                                     CrouchLeanOffset;                                 		// 0x03E8 (0x000C) [0x0000000000000000]              
	struct FVector                                     PopupOffset;                                      		// 0x03F4 (0x000C) [0x0000000000000000]              
	float                                              SlipDist;                                         		// 0x0400 (0x0004) [0x0000000000000000]              
	float                                              TurnDist;                                         		// 0x0404 (0x0004) [0x0000000000000000]              
	float                                              DangerScale;                                      		// 0x0408 (0x0004) [0x0000000000000000]              
	class ACoverLink*                                  NextCoverLink;                                    		// 0x040C (0x0008) [0x0000000000000000]              
	unsigned char                                      LocationDescription;                              		// 0x0414 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CoverLink" );

		return pClassPointer;
	};

	void eventGetDebugAbbrev ( );
	void GetLocationDescription ( );
	void eventGetDebugString ( );
	void AddCoverSlot ( );
	void eventTick ( );
	void BreakFracturedMeshes ( );
	void GetSwatTurnTarget ( );
	void eventShutDown ( );
	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void OnToggle ( );
	void IsEnabled ( );
	void AutoAdjustSlot ( );
	void OnModifyCover ( );
	void eventSetSlotPlayerOnly ( );
	void NotifySlotOwnerCoverDisabled ( );
	void eventSetSlotEnabled ( );
	void eventSetDisabled ( );
	void GetSlotActions ( );
	void HasFireLinkTo ( );
	void GetFireLinkTo ( );
	void AllowLeftTransition ( );
	void AllowRightTransition ( );
	void GetSlotIdxToRight ( );
	void GetSlotIdxToLeft ( );
	void IsRightEdgeSlot ( );
	void IsLeftEdgeSlot ( );
	void IsEdgeSlot ( );
	void FindSlots ( );
	void IsStationarySlot ( );
	void IsValidClaimBetween ( );
	void IsValidClaim ( );
	void eventUnClaim ( );
	void eventClaim ( );
	void eventSetInvalidUntil ( );
	void IsExposedTo ( );
	void GetSlotViewPoint ( );
	void GetSlotRotation ( );
	void GetSlotLocation ( );
	void UnPackFireLinkInteractionInfo ( );
	void PackFireLinkInteractionInfo ( );
	void GetFireLinkTargetCoverInfo ( );
};

UClass* ACoverLink::pClassPointer = NULL;

// Class Engine.DoorMarker
// 0x0018 (0x0394 - 0x037C)
class ADoorMarker : public ANavigationPoint
{
public:
	class AInterpActor*                                MyDoor;                                           		// 0x037C (0x0008) [0x0000000000000000]              
	unsigned char                                      DoorType;                                         		// 0x0384 (0x0001) [0x0000000000000000]              
	class AActor*                                      DoorTrigger;                                      		// 0x0388 (0x0008) [0x0000000000000000]              
	DWORD                                              bWaitUntilCompletelyOpened : 1;                   		// 0x0390 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bInitiallyClosed : 1;                             		// 0x0390 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bBlockedWhenClosed : 1;                           		// 0x0390 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bDoorOpen : 1;                                    		// 0x0390 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bTempDisabledCollision : 1;                       		// 0x0390 (0x0004) [0x0000000000000000] [0x00000010] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DoorMarker" );

		return pClassPointer;
	};

	void eventSuggestMovePreparation ( );
	void ProceedWithMove ( );
	void eventSpecialHandling ( );
	void MoverClosed ( );
	void MoverOpened ( );
	void eventPostBeginPlay ( );
};

UClass* ADoorMarker::pClassPointer = NULL;

// Class Engine.DynamicAnchor
// 0x0008 (0x0384 - 0x037C)
class ADynamicAnchor : public ANavigationPoint
{
public:
	class AController*                                 CurrentUser;                                      		// 0x037C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DynamicAnchor" );

		return pClassPointer;
	};

};

UClass* ADynamicAnchor::pClassPointer = NULL;

// Class Engine.Ladder
// 0x0010 (0x038C - 0x037C)
class ALadder : public ANavigationPoint
{
public:
	class ALadderVolume*                               MyLadder;                                         		// 0x037C (0x0008) [0x0000000000000000]              
	class ALadder*                                     LadderList;                                       		// 0x0384 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Ladder" );

		return pClassPointer;
	};

	void eventSuggestMovePreparation ( );
};

UClass* ALadder::pClassPointer = NULL;

// Class Engine.AutoLadder
// 0x0000 (0x038C - 0x038C)
class AAutoLadder : public ALadder
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AutoLadder" );

		return pClassPointer;
	};

};

UClass* AAutoLadder::pClassPointer = NULL;

// Class Engine.LiftCenter
// 0x0028 (0x03A4 - 0x037C)
class ALiftCenter : public ANavigationPoint
{
public:
	class AInterpActor*                                MyLift;                                           		// 0x037C (0x0008) [0x0000000000000000]              
	float                                              MaxDist2D;                                        		// 0x0384 (0x0004) [0x0000000000000000]              
	struct FVector                                     LiftOffset;                                       		// 0x0388 (0x000C) [0x0000000000000000]              
	DWORD                                              bJumpLift : 1;                                    		// 0x0394 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              CollisionHeight;                                  		// 0x0398 (0x0004) [0x0000000000000000]              
	class ATrigger*                                    LiftTrigger;                                      		// 0x039C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LiftCenter" );

		return pClassPointer;
	};

	void ProceedWithMove ( );
	void eventSuggestMovePreparation ( );
	void eventSpecialHandling ( );
	void eventPostBeginPlay ( );
};

UClass* ALiftCenter::pClassPointer = NULL;

// Class Engine.LiftExit
// 0x000C (0x0388 - 0x037C)
class ALiftExit : public ANavigationPoint
{
public:
	class ALiftCenter*                                 MyLiftCenter;                                     		// 0x037C (0x0008) [0x0000000000000000]              
	DWORD                                              bExitOnly : 1;                                    		// 0x0384 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LiftExit" );

		return pClassPointer;
	};

	void eventSuggestMovePreparation ( );
	void WaitForLift ( );
	void CanBeReachedFromLiftBy ( );
};

UClass* ALiftExit::pClassPointer = NULL;

// Class Engine.PathNode
// 0x0000 (0x037C - 0x037C)
class APathNode : public ANavigationPoint
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PathNode" );

		return pClassPointer;
	};

	void eventGetDebugAbbrev ( );
};

UClass* APathNode::pClassPointer = NULL;

// Class Engine.VolumePathNode
// 0x0008 (0x0384 - 0x037C)
class AVolumePathNode : public APathNode
{
public:
	float                                              StartingRadius;                                   		// 0x037C (0x0004) [0x0000000000000000]              
	float                                              StartingHeight;                                   		// 0x0380 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.VolumePathNode" );

		return pClassPointer;
	};

};

UClass* AVolumePathNode::pClassPointer = NULL;

// Class Engine.PickupFactory
// 0x002C (0x03A8 - 0x037C)
class APickupFactory : public ANavigationPoint
{
public:
	DWORD                                              bOnlyReplicateHidden : 1;                         		// 0x037C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPickupHidden : 1;                                		// 0x037C (0x0004) [0x0000000000150000] [0x00000002] ( CPF_Travel | CPF_GlobalConfig )
	DWORD                                              bPredictRespawns : 1;                             		// 0x037C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bIsSuperItem : 1;                                 		// 0x037C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bRespawnPaused : 1;                               		// 0x037C (0x0004) [0x0000000000000000] [0x00000010] 
	class UClass*                                      InventoryType;                                    		// 0x0380 (0x0008) [0x0000000000160020]              ( CPF_Net | CPF_EditConst | CPF_GlobalConfig )
	float                                              RespawnEffectTime;                                		// 0x0388 (0x0004) [0x0000000000000000]              
	float                                              MaxDesireability;                                 		// 0x038C (0x0004) [0x0000000000000000]              
	class UPrimitiveComponent*                         PickupMesh;                                       		// 0x0390 (0x0008) [0x0000000000000000]              
	class APickupFactory*                              ReplacementFactory;                               		// 0x0398 (0x0008) [0x0000000000000000]              
	class APickupFactory*                              OriginalFactory;                                  		// 0x03A0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PickupFactory" );

		return pClassPointer;
	};

	void DelayRespawn ( );
	void eventDestroyed ( );
	void SetPickupVisible ( );
	void SetPickupHidden ( );
	void RespawnEffect ( );
	void GetRespawnTime ( );
	void RecheckValidTouch ( );
	void PickedUpBy ( );
	void GiveTo ( );
	void ReadyToPickup ( );
	void SpawnCopyFor ( );
	void eventDetourWeight ( );
	void StartSleeping ( );
	void SetRespawn ( );
	void CheckForErrors ( );
	void Reset ( );
	void SetPickupMesh ( );
	void ShutDown ( );
	void eventSetInitialState ( );
	void InitializePickup ( );
	void eventPreBeginPlay ( );
	void eventReplicatedEvent ( );
};

UClass* APickupFactory::pClassPointer = NULL;

// Class Engine.PlayerStart
// 0x0010 (0x038C - 0x037C)
class APlayerStart : public ANavigationPoint
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x037C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPrimaryStart : 1;                                		// 0x037C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bBestStart : 1;                                   		// 0x037C (0x0004) [0x0000000000000000] [0x00000004] 
	int                                                TeamIndex;                                        		// 0x0380 (0x0004) [0x0000000000000000]              
	int                                                Score;                                            		// 0x0384 (0x0004) [0x0000000000000000]              
	int                                                SelectionIndex;                                   		// 0x0388 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PlayerStart" );

		return pClassPointer;
	};

	void eventPostRenderFor ( );
	void OnToggle ( );
};

UClass* APlayerStart::pClassPointer = NULL;

// Class Engine.PortalMarker
// 0x0008 (0x0384 - 0x037C)
class APortalMarker : public ANavigationPoint
{
public:
	class APortalTeleporter*                           MyPortal;                                         		// 0x037C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PortalMarker" );

		return pClassPointer;
	};

	void CanTeleport ( );
};

UClass* APortalMarker::pClassPointer = NULL;

// Class Engine.Pylon
// 0x0130 (0x04AC - 0x037C)
class APylon : public ANavigationPoint
{
public:
	struct FPointer                                    VfTable_IEditorLinkSelectionInterface;            		// 0x037C (0x0008) [0x0000000000000000]              
	struct FPointer                                    VfTable_IInterface_NavigationHandle;              		// 0x0384 (0x0008) [0x0000000000000000]              
	struct FPointer                                    NavMeshPtr;                                       		// 0x038C (0x0008) [0x0000000000000000]              
	struct FPointer                                    ObstacleMesh;                                     		// 0x0394 (0x0008) [0x0000000000000000]              
	struct FPointer                                    DynamicObstacleMesh;                              		// 0x039C (0x0008) [0x0000000000000000]              
	struct FPointer                                    WorkingSetPtr;                                    		// 0x03A4 (0x0008) [0x0000000000000000]              
	struct FPointer                                    PathObjectsThatAffectThisPylon;                   		// 0x03AC (0x0008) [0x0000000000000000]              
	TArray< struct FVector >                           NextPassSeedList;                                 		// 0x03B4 (0x0010) [0x0000000000000000]              
	struct FOctreeElementId                            OctreeId;                                         		// 0x03C4 (0x000C) [0x0000000000000000]              
	struct FPointer                                    OctreeIWasAddedTo;                                		// 0x03D0 (0x0008) [0x0000000000000000]              
	class APylon*                                      NextPylon;                                        		// 0x03D8 (0x0008) [0x0000000000000000]              
	TArray< class AVolume* >                           ExpansionVolumes;                                 		// 0x03E0 (0x0010) [0x0000000000000000]              
	float                                              ExpansionRadius;                                  		// 0x03F0 (0x0004) [0x0000000000000000]              
	float                                              MaxExpansionRadius;                               		// 0x03F4 (0x0004) [0x0000000000000000]              
	class UDrawPylonRadiusComponent*                   PylonRadiusPreview;                               		// 0x03F8 (0x0008) [0x0000000000000000]              
	DWORD                                              bImportedMesh : 1;                                		// 0x0400 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseExpansionSphereOverride : 1;                  		// 0x0400 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bNeedsCostCheck : 1;                              		// 0x0400 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bPylonInHighLevelPath : 1;                        		// 0x0400 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bUseRecast : 1;                                   		// 0x0400 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bAllowRecastGenerator : 1;                        		// 0x0400 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bAllowNavMeshOverLoads : 1;                       		// 0x0400 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bHightlightOneWayReachSpecs : 1;                  		// 0x0400 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bDrawEdgePolys : 1;                               		// 0x0400 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bDrawPolyBounds : 1;                              		// 0x0400 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bRenderInShowPaths : 1;                           		// 0x0400 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bDrawWalkableSurface : 1;                         		// 0x0400 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bDrawObstacleSurface : 1;                         		// 0x0400 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bSolidObstaclesInGame : 1;                        		// 0x0400 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bBuildThisPylon : 1;                              		// 0x0400 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bDisabled : 1;                                    		// 0x0400 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bForceObstacleMeshCollision : 1;                  		// 0x0400 (0x0004) [0x0000000000000000] [0x00010000] 
	struct FVector                                     ExpansionSphereCenter;                            		// 0x0404 (0x000C) [0x0000000000000000]              
	class UNavMeshRenderingComponent*                  RenderingComp;                                    		// 0x0410 (0x0008) [0x0000000000000000]              
	class USpriteComponent*                            BrokenSprite;                                     		// 0x0418 (0x0008) [0x0000000000000000]              
	TArray< class APylon* >                            ImposterPylons;                                   		// 0x0420 (0x0010) [0x0000000000000000]              
	TArray< class AActor* >                            OnBuild_DisableCollisionForThese;                 		// 0x0430 (0x0010) [0x0000000000000000]              
	TArray< class AActor* >                            OnBuild_EnableCollisionForThese;                  		// 0x0440 (0x0010) [0x0000000000000000]              
	float                                              MaxPolyHeight_Optional;                           		// 0x0450 (0x0004) [0x0000000000000000]              
	unsigned char                                      NavMeshGenerator;                                 		// 0x0454 (0x0001) [0x0000000000000000]              
	float                                              Recast_CellSize;                                  		// 0x0458 (0x0004) [0x0000000000000000]              
	float                                              Recast_CellHeight;                                		// 0x045C (0x0004) [0x0000000000000000]              
	float                                              Recast_AgentMaxSlope;                             		// 0x0460 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_MaxStepHeight;                         		// 0x0464 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_MinPolyArea;                           		// 0x0468 (0x0004) [0x0000000000000000]              
	TArray< struct FKAggregateGeom >                   VoxelFilterBounds;                                		// 0x046C (0x0010) [0x0000000000000000]              
	TArray< struct FMatrix >                           VoxelFilterTM;                                    		// 0x047C (0x0010) [0x0000000000000000]              
	float                                              BufferEpsilonToAddedToBoundsBoxForDropEdgeCheck;  		// 0x048C (0x0004) [0x0000000000000000]              
	int                                                DebugEdgeCount;                                   		// 0x0490 (0x0004) [0x0000000000000000]              
	struct FVector                                     DebugPathExtent;                                  		// 0x0494 (0x000C) [0x0000000000000000]              
	struct FVector                                     DebugPathStartLocation;                           		// 0x04A0 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Pylon" );

		return pClassPointer;
	};

	void CanReachPylon ( );
	void OnToggle ( );
	void eventIsEnabled ( );
	void eventSetEnabled ( );
	void PostBeginPlay ( );
	void eventNotifyPathChanged ( );
	void VerifyTopLevelConnections ( );
	void GetTestPathExtent ( );
	void FlushDynamicEdges ( );
	void UpdateMeshForPreExistingNavMeshObstacles ( );
	void OnPylonStatusChange ( );
};

UClass* APylon::pClassPointer = NULL;

// Class Engine.AISwitchablePylon
// 0x0004 (0x04B0 - 0x04AC)
class AAISwitchablePylon : public APylon
{
public:
	DWORD                                              bOpen : 1;                                        		// 0x04AC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AISwitchablePylon" );

		return pClassPointer;
	};

	void eventIsEnabled ( );
	void eventSetEnabled ( );
	void PostBeginPlay ( );
};

UClass* AAISwitchablePylon::pClassPointer = NULL;

// Class Engine.DynamicPylon
// 0x0004 (0x04B0 - 0x04AC)
class ADynamicPylon : public APylon
{
public:
	DWORD                                              bMoving : 1;                                      		// 0x04AC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DynamicPylon" );

		return pClassPointer;
	};

	void eventStoppedMoving ( );
	void eventStartedMoving ( );
	void FlushDynamicEdges ( );
	void RebuildDynamicEdges ( );
	void PostBeginPlay ( );
};

UClass* ADynamicPylon::pClassPointer = NULL;

// Class Engine.Teleporter
// 0x002C (0x03A8 - 0x037C)
class ATeleporter : public ANavigationPoint
{
public:
	struct FString                                     URL;                                              		// 0x037C (0x0010) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )
	struct FName                                       ProductRequired;                                  		// 0x038C (0x0008) [0x0000000000000000]              
	DWORD                                              bChangesVelocity : 1;                             		// 0x0394 (0x0004) [0x0000000000160011] [0x00000001] ( CPF_Edit | CPF_OptionalParm | CPF_EditConst | CPF_GlobalConfig )
	DWORD                                              bChangesYaw : 1;                                  		// 0x0394 (0x0004) [0x0000000000170011] [0x00000002] ( CPF_Edit | CPF_OptionalParm | CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
	DWORD                                              bReversesX : 1;                                   		// 0x0394 (0x0004) [0x0000000000180011] [0x00000004] ( CPF_Edit | CPF_OptionalParm | CPF_Component )
	DWORD                                              bReversesY : 1;                                   		// 0x0394 (0x0004) [0x0000000000190011] [0x00000008] ( CPF_Edit | CPF_OptionalParm | CPF_Travel | CPF_Component )
	DWORD                                              bReversesZ : 1;                                   		// 0x0394 (0x0004) [0x00000000001A0011] [0x00000010] ( CPF_Edit | CPF_OptionalParm | CPF_EditConst | CPF_Component )
	DWORD                                              bEnabled : 1;                                     		// 0x0394 (0x0004) [0x00000000001B0000] [0x00000020] ( CPF_Travel | CPF_EditConst | CPF_Component )
	DWORD                                              bCanTeleportVehicles : 1;                         		// 0x0394 (0x0004) [0x0000000000000000] [0x00000040] 
	struct FVector                                     TargetVelocity;                                   		// 0x0398 (0x000C) [0x00000000001C0011]              ( CPF_Edit | CPF_OptionalParm | CPF_GlobalConfig | CPF_Component )
	float                                              LastFired;                                        		// 0x03A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Teleporter" );

		return pClassPointer;
	};

	void eventSpecialHandling ( );
	void eventPostTouch ( );
	void eventTouch ( );
	void eventAccept ( );
	void eventPostBeginPlay ( );
	void CanTeleport ( );
};

UClass* ATeleporter::pClassPointer = NULL;

// Class Engine.Note
// 0x0010 (0x0254 - 0x0244)
class ANote : public AActor
{
public:
	struct FString                                     Text;                                             		// 0x0244 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Note" );

		return pClassPointer;
	};

};

UClass* ANote::pClassPointer = NULL;

// Class Engine.Projectile
// 0x005C (0x02A0 - 0x0244)
class AProjectile : public AActor
{
public:
	float                                              Speed;                                            		// 0x0244 (0x0004) [0x0000000000000000]              
	float                                              MaxSpeed;                                         		// 0x0248 (0x0004) [0x0000000000000000]              
	DWORD                                              bSwitchToZeroCollision : 1;                       		// 0x024C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bBlockedByInstigator : 1;                         		// 0x024C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bBegunPlay : 1;                                   		// 0x024C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bRotationFollowsVelocity : 1;                     		// 0x024C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bIgnoreFoliageTouch : 1;                          		// 0x024C (0x0004) [0x0000000000000000] [0x00000010] 
	class AActor*                                      ZeroCollider;                                     		// 0x0250 (0x0008) [0x0000000000000000]              
	class UPrimitiveComponent*                         ZeroColliderComponent;                            		// 0x0258 (0x0008) [0x0000000000000000]              
	float                                              Damage;                                           		// 0x0260 (0x0004) [0x0000000000000000]              
	float                                              DamageRadius;                                     		// 0x0264 (0x0004) [0x0000000000000000]              
	float                                              MomentumTransfer;                                 		// 0x0268 (0x0004) [0x0000000000000000]              
	class UClass*                                      MyDamageType;                                     		// 0x026C (0x0008) [0x0000000000000000]              
	class USoundCue*                                   SpawnSound;                                       		// 0x0274 (0x0008) [0x0000000000000000]              
	class USoundCue*                                   ImpactSound;                                      		// 0x027C (0x0008) [0x0000000000000000]              
	class AController*                                 InstigatorController;                             		// 0x0284 (0x0008) [0x0000000000000000]              
	class AActor*                                      ImpactedActor;                                    		// 0x028C (0x0008) [0x0000000000000000]              
	float                                              NetCullDistanceSquared;                           		// 0x0294 (0x0004) [0x0000000000000000]              
	class UCylinderComponent*                          CylinderComponent;                                		// 0x0298 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Projectile" );

		return pClassPointer;
	};

	void ApplyFluidSurfaceImpact ( );
	void GetRange ( );
	void StaticGetTimeToLocation ( );
	void GetTimeToLocation ( );
	void eventFellOutOfWorld ( );
	void IsStationary ( );
	void RandSpin ( );
	void Explode ( );
	void eventEncroachedBy ( );
	void eventHitWall ( );
	void ProcessTouch ( );
	void eventTouch ( );
	void HurtRadius ( );
	void ProjectileHurtRadius ( );
	void Reset ( );
	void CanSplash ( );
	void GetTeamNum ( );
	void Init ( );
	void eventPostBeginPlay ( );
	void eventPreBeginPlay ( );
	void eventEncroachingOn ( );
};

UClass* AProjectile::pClassPointer = NULL;

// Class Engine.RigidBodyBase
// 0x0000 (0x0244 - 0x0244)
class ARigidBodyBase : public AActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RigidBodyBase" );

		return pClassPointer;
	};

};

UClass* ARigidBodyBase::pClassPointer = NULL;

// Class Engine.SceneCaptureActor
// 0x0008 (0x024C - 0x0244)
class ASceneCaptureActor : public AActor
{
public:
	class USceneCaptureComponent*                      SceneCapture;                                     		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SceneCaptureActor" );

		return pClassPointer;
	};

	void OnToggle ( );
};

UClass* ASceneCaptureActor::pClassPointer = NULL;

// Class Engine.SceneCapture2DActor
// 0x0008 (0x0254 - 0x024C)
class ASceneCapture2DActor : public ASceneCaptureActor
{
public:
	class UDrawFrustumComponent*                       DrawFrustum;                                      		// 0x024C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SceneCapture2DActor" );

		return pClassPointer;
	};

};

UClass* ASceneCapture2DActor::pClassPointer = NULL;

// Class Engine.SceneCaptureCubeMapActor
// 0x0010 (0x025C - 0x024C)
class ASceneCaptureCubeMapActor : public ASceneCaptureActor
{
public:
	class UStaticMeshComponent*                        StaticMesh;                                       		// 0x024C (0x0008) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   CubeMaterialInst;                                 		// 0x0254 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SceneCaptureCubeMapActor" );

		return pClassPointer;
	};

};

UClass* ASceneCaptureCubeMapActor::pClassPointer = NULL;

// Class Engine.SceneCaptureReflectActor
// 0x0010 (0x025C - 0x024C)
class ASceneCaptureReflectActor : public ASceneCaptureActor
{
public:
	class UStaticMeshComponent*                        StaticMesh;                                       		// 0x024C (0x0008) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   ReflectMaterialInst;                              		// 0x0254 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SceneCaptureReflectActor" );

		return pClassPointer;
	};

};

UClass* ASceneCaptureReflectActor::pClassPointer = NULL;

// Class Engine.SceneCapturePortalActor
// 0x0000 (0x025C - 0x025C)
class ASceneCapturePortalActor : public ASceneCaptureReflectActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SceneCapturePortalActor" );

		return pClassPointer;
	};

};

UClass* ASceneCapturePortalActor::pClassPointer = NULL;

// Class Engine.PortalTeleporter
// 0x001C (0x0278 - 0x025C)
class APortalTeleporter : public ASceneCapturePortalActor
{
public:
	class APortalTeleporter*                           SisterPortal;                                     		// 0x025C (0x0008) [0x0000000000000000]              
	int                                                TextureResolutionX;                               		// 0x0264 (0x0004) [0x0000000000000000]              
	int                                                TextureResolutionY;                               		// 0x0268 (0x0004) [0x0000000000000000]              
	class APortalMarker*                               MyMarker;                                         		// 0x026C (0x0008) [0x0000000000000000]              
	DWORD                                              bMovablePortal : 1;                               		// 0x0274 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAlwaysTeleportNonPawns : 1;                      		// 0x0274 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCanTeleportVehicles : 1;                         		// 0x0274 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PortalTeleporter" );

		return pClassPointer;
	};

	void StopsProjectile ( );
	void CreatePortalTexture ( );
	void TransformHitLocation ( );
	void TransformVectorDir ( );
	void TransformActor ( );
};

UClass* APortalTeleporter::pClassPointer = NULL;

// Class Engine.StaticMeshActorBase
// 0x0000 (0x0244 - 0x0244)
class AStaticMeshActorBase : public AActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.StaticMeshActorBase" );

		return pClassPointer;
	};

};

UClass* AStaticMeshActorBase::pClassPointer = NULL;

// Class Engine.StaticMeshActor
// 0x006C (0x02B0 - 0x0244)
class AStaticMeshActor : public AStaticMeshActorBase
{
public:
	class UStaticMeshComponent*                        StaticMeshComponent;                              		// 0x0244 (0x0008) [0x0000000000000000]              
	DWORD                                              bDisableAutoBaseOnProcBuilding : 1;               		// 0x024C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bProxy : 1;                                       		// 0x024C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bHiddenByProxy : 1;                               		// 0x024C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              OldCastShadow : 1;                                		// 0x024C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              OldAcceptsLights : 1;                             		// 0x024C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bResetCapable : 1;                                		// 0x024C (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned char                                      OldCollisionType;                                 		// 0x0250 (0x0001) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0xF ];                             		// 0x0251 (0x000F) MISSED OFFSET
	struct FMatrix                                     DefaultLocalToWorld;                              		// 0x0260 (0x0040) [0x0000000000000000]              
	TArray< struct FPreCombinedStaticMeshActor >       PreCombinedStaticMeshActors;                      		// 0x02A0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.StaticMeshActor" );

		return pClassPointer;
	};

	void eventReset ( );
	void ResetToDefaults ( );
	void eventPreBeginPlay ( );
};

UClass* AStaticMeshActor::pClassPointer = NULL;

// Class Engine.StaticMeshCollectionActor
// 0x0014 (0x0258 - 0x0244)
class AStaticMeshCollectionActor : public AStaticMeshActorBase
{
public:
	TArray< class UStaticMeshComponent* >              StaticMeshComponents;                             		// 0x0244 (0x0010) [0x0000000000000000]              
	int                                                MaxStaticMeshComponents;                          		// 0x0254 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.StaticMeshCollectionActor" );

		return pClassPointer;
	};

};

UClass* AStaticMeshCollectionActor::pClassPointer = NULL;

// Class Engine.StaticMeshActorBasedOnExtremeContent
// 0x0028 (0x026C - 0x0244)
class AStaticMeshActorBasedOnExtremeContent : public AActor
{
public:
	class UStaticMeshComponent*                        StaticMeshComponent;                              		// 0x0244 (0x0008) [0x0000000000000000]              
	TArray< struct FSMMaterialSetterDatum >            ExtremeContent;                                   		// 0x024C (0x0010) [0x0000000000000000]              
	TArray< struct FSMMaterialSetterDatum >            NonExtremeContent;                                		// 0x025C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.StaticMeshActorBasedOnExtremeContent" );

		return pClassPointer;
	};

	void SetMaterialBasedOnExtremeContent ( );
	void eventPostBeginPlay ( );
};

UClass* AStaticMeshActorBasedOnExtremeContent::pClassPointer = NULL;

// Class Engine.Trigger
// 0x0010 (0x0254 - 0x0244)
class ATrigger : public AActor
{
public:
	class UCylinderComponent*                          CylinderComponent;                                		// 0x0244 (0x0008) [0x0000000000000000]              
	DWORD                                              bRecentlyTriggered : 1;                           		// 0x024C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              AITriggerDelay;                                   		// 0x0250 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Trigger" );

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void ShouldSaveForCheckpoint ( );
	void StopsProjectile ( );
	void UnTrigger ( );
	void NotifyTriggered ( );
	void eventTouch ( );
	void eventPostBeginPlay ( );
};

UClass* ATrigger::pClassPointer = NULL;

// Class Engine.Trigger_PawnsOnly
// 0x0000 (0x0254 - 0x0254)
class ATrigger_PawnsOnly : public ATrigger
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Trigger_PawnsOnly" );

		return pClassPointer;
	};

};

UClass* ATrigger_PawnsOnly::pClassPointer = NULL;

// Class Engine.ActorComponent
// 0x0015 (0x0085 - 0x0070)
class UActorComponent : public UComponent
{
public:
	struct FPointer                                    Scene;                                            		// 0x0070 (0x0008) [0x0000000000000000]              
	class AActor*                                      Owner;                                            		// 0x0078 (0x0008) [0x0000000000000000]              
	DWORD                                              bAttached : 1;                                    		// 0x0080 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bTickInEditor : 1;                                		// 0x0080 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bNeedsReattach : 1;                               		// 0x0080 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bNeedsUpdateTransform : 1;                        		// 0x0080 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned char                                      TickGroup;                                        		// 0x0084 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorComponent" );

		return pClassPointer;
	};

	void DetachFromAny ( );
	void ForceUpdate ( );
	void SetComponentRBFixed ( );
	void SetTickGroup ( );
};

UClass* UActorComponent::pClassPointer = NULL;

// Class Engine.AudioComponent
// 0x022B (0x02B0 - 0x0085)
class UAudioComponent : public UActorComponent
{
public:
	class USoundCue*                                   SoundCue;                                         		// 0x0088 (0x0008) [0x0000000000000000]              
	class USoundNode*                                  CueFirstNode;                                     		// 0x0090 (0x0008) [0x0000000000000000]              
	TArray< struct FAudioComponentParam >              InstanceParameters;                               		// 0x0098 (0x0010) [0x0000000000000000]              
	DWORD                                              bUseOwnerLocation : 1;                            		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAutoPlay : 1;                                    		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAutoDestroy : 1;                                 		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bStopWhenOwnerDestroyed : 1;                      		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bShouldRemainActiveIfDropped : 1;                 		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bWasOccluded : 1;                                 		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bSuppressSubtitles : 1;                           		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bWasPlaying : 1;                                  		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bAllowSpatialization : 1;                         		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bFinished : 1;                                    		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bApplyRadioFilter : 1;                            		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bRadioFilterSelected : 1;                         		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bPreviewComponent : 1;                            		// 0x00A8 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bIgnoreForFlushing : 1;                           		// 0x00A8 (0x0004) [0x0000000000000000] [0x00002000] 
	float                                              StereoBleed;                                      		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              LFEBleed;                                         		// 0x00B0 (0x0004) [0x0000000000000000]              
	DWORD                                              bEQFilterApplied : 1;                             		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAlwaysPlay : 1;                                  		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIsUISound : 1;                                   		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bIsMusic : 1;                                     		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bReverb : 1;                                      		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bCenterChannelOnly : 1;                           		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000020] 
	TArray< struct FPointer >                          WaveInstances;                                    		// 0x00B8 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            SoundNodeData;                                    		// 0x00C8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x00D8 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.AudioComponent.SoundNodeOffsetMap
	struct FMultiMap_Mirror                            SoundNodeResetWaveMap;                            		// 0x0120 (0x0048) [0x0000000000000000]              
	struct FPointer                                    Listener;                                         		// 0x0168 (0x0008) [0x0000000000000000]              
	float                                              PlaybackTime;                                     		// 0x0170 (0x0004) [0x0000000000000000]              
	class APortalVolume*                               PortalVolume;                                     		// 0x0174 (0x0008) [0x0000000000000000]              
	struct FVector                                     Location;                                         		// 0x017C (0x000C) [0x0000000000000000]              
	struct FVector                                     ComponentLocation;                                		// 0x0188 (0x000C) [0x0000000000000000]              
	class AActor*                                      LastOwner;                                        		// 0x0194 (0x0008) [0x0000000000000000]              
	float                                              SubtitlePriority;                                 		// 0x019C (0x0004) [0x0000000000000000]              
	float                                              FadeInStartTime;                                  		// 0x01A0 (0x0004) [0x0000000000000000]              
	float                                              FadeInStopTime;                                   		// 0x01A4 (0x0004) [0x0000000000000000]              
	float                                              FadeInTargetVolume;                               		// 0x01A8 (0x0004) [0x0000000000000000]              
	float                                              FadeOutStartTime;                                 		// 0x01AC (0x0004) [0x0000000000000000]              
	float                                              FadeOutStopTime;                                  		// 0x01B0 (0x0004) [0x0000000000000000]              
	float                                              FadeOutTargetVolume;                              		// 0x01B4 (0x0004) [0x0000000000000000]              
	float                                              AdjustVolumeStartTime;                            		// 0x01B8 (0x0004) [0x0000000000000000]              
	float                                              AdjustVolumeStopTime;                             		// 0x01BC (0x0004) [0x0000000000000000]              
	float                                              AdjustVolumeTargetVolume;                         		// 0x01C0 (0x0004) [0x0000000000000000]              
	float                                              CurrAdjustVolumeTargetVolume;                     		// 0x01C4 (0x0004) [0x0000000000000000]              
	class USoundNode*                                  CurrentNotifyBufferFinishedHook;                  		// 0x01C8 (0x0008) [0x0000000000000000]              
	struct FVector                                     CurrentLocation;                                  		// 0x01D0 (0x000C) [0x0000000000000000]              
	struct FVector                                     CurrentVelocity;                                  		// 0x01DC (0x000C) [0x0000000000000000]              
	float                                              CurrentVolume;                                    		// 0x01E8 (0x0004) [0x0000000000000000]              
	float                                              CurrentPitch;                                     		// 0x01EC (0x0004) [0x0000000000000000]              
	float                                              CurrentHighFrequencyGain;                         		// 0x01F0 (0x0004) [0x0000000000000000]              
	int                                                CurrentUseSpatialization;                         		// 0x01F4 (0x0004) [0x0000000000000000]              
	int                                                CurrentNotifyOnLoop;                              		// 0x01F8 (0x0004) [0x0000000000000000]              
	float                                              OmniRadius;                                       		// 0x01FC (0x0004) [0x0000000000000000]              
	float                                              CurrentVolumeMultiplier;                          		// 0x0200 (0x0004) [0x0000000000000000]              
	float                                              CurrentPitchMultiplier;                           		// 0x0204 (0x0004) [0x0000000000000000]              
	float                                              CurrentHighFrequencyGainMultiplier;               		// 0x0208 (0x0004) [0x0000000000000000]              
	float                                              CurrentVoiceCenterChannelVolume;                  		// 0x020C (0x0004) [0x0000000000000000]              
	float                                              CurrentRadioFilterVolume;                         		// 0x0210 (0x0004) [0x0000000000000000]              
	float                                              CurrentRadioFilterVolumeThreshold;                		// 0x0214 (0x0004) [0x0000000000000000]              
	struct FDouble                                     LastUpdateTime;                                   		// 0x0218 (0x0008) [0x0000000000000000]              
	float                                              SourceInteriorVolume;                             		// 0x0220 (0x0004) [0x0000000000000000]              
	float                                              SourceInteriorLPF;                                		// 0x0224 (0x0004) [0x0000000000000000]              
	float                                              CurrentInteriorVolume;                            		// 0x0228 (0x0004) [0x0000000000000000]              
	float                                              CurrentInteriorLPF;                               		// 0x022C (0x0004) [0x0000000000000000]              
	struct FVector                                     LastLocation;                                     		// 0x0230 (0x000C) [0x0000000000000000]              
	struct FInteriorSettings                           LastInteriorSettings;                             		// 0x023C (0x0024) [0x0000000000000000]              
	int                                                LastReverbVolumeIndex;                            		// 0x0260 (0x0004) [0x0000000000000000]              
	float                                              VolumeMultiplier;                                 		// 0x0264 (0x0004) [0x0000000000000000]              
	float                                              PitchMultiplier;                                  		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              HighFrequencyGainMultiplier;                      		// 0x026C (0x0004) [0x0000000000000000]              
	float                                              OcclusionCheckInterval;                           		// 0x0270 (0x0004) [0x0000000000000000]              
	float                                              LastOcclusionCheckTime;                           		// 0x0274 (0x0004) [0x0000000000000000]              
	class UDrawSoundRadiusComponent*                   PreviewSoundRadius;                               		// 0x0278 (0x0008) [0x0000000000000000]              
	class USkeletalMeshComponent*                      SkelMeshBase;                                     		// 0x0280 (0x0008) [0x0000000000000000]              
	struct FName                                       SkelMeshBaseBoneName;                             		// 0x0288 (0x0008) [0x0000000000000000]              
	struct FScriptDelegate                             __OnAudioFinished__Delegate;                      		// 0x0290 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x4 ];                             		// 0x0294 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnQueueSubtitles__Delegate;                     		// 0x02A0 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x4 ];                             		// 0x02A4 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AudioComponent" );

		return pClassPointer;
	};

	void eventOcclusionChanged ( );
	void OnQueueSubtitles ( );
	void OnAudioFinished ( );
	void ResetToDefaults ( );
	void SetWaveParameter ( );
	void SetFloatParameter ( );
	void AdjustVolume ( );
	void FadeOut ( );
	void FadeIn ( );
	void IsFadingOut ( );
	void IsFadingIn ( );
	void IsPlaying ( );
	void Stop ( );
	void Play ( );
};

UClass* UAudioComponent::pClassPointer = NULL;

// Class Engine.SplineAudioComponent
// 0x0018 (0x02C8 - 0x02B0)
class USplineAudioComponent : public UAudioComponent
{
public:
	float                                              ListenerScopeRadius;                              		// 0x02B0 (0x0004) [0x0000000000000000]              
	int                                                ClosestPointOnSplineIndex;                        		// 0x02B4 (0x0004) [0x0000000000000000]              
	TArray< struct FInterpPointOnSpline >              Points;                                           		// 0x02B8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SplineAudioComponent" );

		return pClassPointer;
	};

};

UClass* USplineAudioComponent::pClassPointer = NULL;

// Class Engine.MultiCueSplineAudioComponent
// 0x0014 (0x02DC - 0x02C8)
class UMultiCueSplineAudioComponent : public USplineAudioComponent
{
public:
	TArray< struct FMultiCueSplineSoundSlot >          SoundSlots;                                       		// 0x02C8 (0x0010) [0x0000000000000000]              
	int                                                CurrentSlotIndex;                                 		// 0x02D8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MultiCueSplineAudioComponent" );

		return pClassPointer;
	};

};

UClass* UMultiCueSplineAudioComponent::pClassPointer = NULL;

// Class Engine.SimpleSplineAudioComponent
// 0x0038 (0x0300 - 0x02C8)
class USimpleSplineAudioComponent : public USplineAudioComponent
{
public:
	DWORD                                              bAttenuateWithLPF : 1;                            		// 0x02C8 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              LPFRadiusMin;                                     		// 0x02CC (0x0004) [0x0000000000000000]              
	float                                              LPFRadiusMax;                                     		// 0x02D0 (0x0004) [0x0000000000000000]              
	float                                              dBAttenuationAtMax;                               		// 0x02D4 (0x0004) [0x0000000000000000]              
	float                                              FlattenAttenuationRadius;                         		// 0x02D8 (0x0004) [0x0000000000000000]              
	unsigned char                                      DistanceAlgorithm;                                		// 0x02DC (0x0001) [0x0000000000000000]              
	float                                              RadiusMin;                                        		// 0x02E0 (0x0004) [0x0000000000000000]              
	float                                              RadiusMax;                                        		// 0x02E4 (0x0004) [0x0000000000000000]              
	TArray< struct FSplineSoundSlot >                  SoundSlots;                                       		// 0x02E8 (0x0010) [0x0000000000000000]              
	class USoundNode*                                  NotifyBufferFinishedHook;                         		// 0x02F8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SimpleSplineAudioComponent" );

		return pClassPointer;
	};

};

UClass* USimpleSplineAudioComponent::pClassPointer = NULL;

// Class Engine.SimpleSplineNonLoopAudioComponent
// 0x0028 (0x0328 - 0x0300)
class USimpleSplineNonLoopAudioComponent : public USimpleSplineAudioComponent
{
public:
	float                                              DelayMin;                                         		// 0x0300 (0x0004) [0x0000000000000000]              
	float                                              DelayMax;                                         		// 0x0304 (0x0004) [0x0000000000000000]              
	float                                              PitchMin;                                         		// 0x0308 (0x0004) [0x0000000000000000]              
	float                                              PitchMax;                                         		// 0x030C (0x0004) [0x0000000000000000]              
	float                                              VolumeMin;                                        		// 0x0310 (0x0004) [0x0000000000000000]              
	float                                              VolumeMax;                                        		// 0x0314 (0x0004) [0x0000000000000000]              
	int                                                CurrentSlotIndex;                                 		// 0x0318 (0x0004) [0x0000000000000000]              
	float                                              UsedVolumeModulation;                             		// 0x031C (0x0004) [0x0000000000000000]              
	float                                              UsedPitchModulation;                              		// 0x0320 (0x0004) [0x0000000000000000]              
	float                                              NextSoundTime;                                    		// 0x0324 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SimpleSplineNonLoopAudioComponent" );

		return pClassPointer;
	};

};

UClass* USimpleSplineNonLoopAudioComponent::pClassPointer = NULL;

// Class Engine.HeightFogComponent
// 0x001F (0x00A4 - 0x0085)
class UHeightFogComponent : public UActorComponent
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              Height;                                           		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              Density;                                          		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              LightBrightness;                                  		// 0x0094 (0x0004) [0x0000000000000000]              
	struct FColor                                      LightColor;                                       		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              ExtinctionDistance;                               		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              StartDistance;                                    		// 0x00A0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.HeightFogComponent" );

		return pClassPointer;
	};

	void SetEnabled ( );
};

UClass* UHeightFogComponent::pClassPointer = NULL;

// Class Engine.PrimitiveComponent
// 0x01B3 (0x0238 - 0x0085)
class UPrimitiveComponent : public UActorComponent
{
public:
	int                                                Tag;                                              		// 0x0088 (0x0004) [0x0000000000000000]              
	struct FBoxSphereBounds                            Bounds;                                           		// 0x008C (0x001C) [0x0000000000000000]              
	struct FPointer                                    SceneInfo;                                        		// 0x00A8 (0x0008) [0x0000000000000000]              
	int                                                DetachFence;                                      		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              LocalToWorldDeterminant;                          		// 0x00B4 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x00B8 (0x0008) MISSED OFFSET
	struct FMatrix                                     LocalToWorld;                                     		// 0x00C0 (0x0040) [0x0000000000000000]              
	int                                                MotionBlurInfoIndex;                              		// 0x0100 (0x0004) [0x0000000000000000]              
	TArray< struct FPointer >                          DecalList;                                        		// 0x0104 (0x0010) [0x0000000000000000]              
	TArray< class UDecalComponent* >                   DecalsToReattach;                                 		// 0x0114 (0x0010) [0x0000000000000000]              
	class UPrimitiveComponent*                         ShadowParent;                                     		// 0x0124 (0x0008) [0x0000000000000000]              
	class UPrimitiveComponent*                         ReplacementPrimitive;                             		// 0x012C (0x0008) [0x0000000000000000]              
	class UFogVolumeDensityComponent*                  FogVolumeComponent;                               		// 0x0134 (0x0008) [0x0000000000000000]              
	class ULightComponent*                             OverrideLightComponent;                           		// 0x013C (0x0008) [0x0000000000000000]              
	class ULightEnvironmentComponent*                  LightEnvironment;                                 		// 0x0144 (0x0008) [0x0000000000000000]              
	class ULightEnvironmentComponent*                  PreviousLightEnvironment;                         		// 0x014C (0x0008) [0x0000000000000000]              
	float                                              MinDrawDistance;                                  		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              MassiveLODDistance;                               		// 0x0158 (0x0004) [0x0000000000000000]              
	float                                              MaxDrawDistance;                                  		// 0x015C (0x0004) [0x0000000000000000]              
	float                                              CachedMaxDrawDistance;                            		// 0x0160 (0x0004) [0x0000000000000000]              
	float                                              MotionBlurInstanceScale;                          		// 0x0164 (0x0004) [0x0000000000000000]              
	float                                              CullDistance;                                     		// 0x0168 (0x0004) [0x0000000000000000]              
	float                                              CachedCullDistance;                               		// 0x016C (0x0004) [0x0000000000000000]              
	unsigned char                                      DepthPriorityGroup;                               		// 0x0170 (0x0001) [0x0000000000000000]              
	unsigned char                                      ViewOwnerDepthPriorityGroup;                      		// 0x0171 (0x0001) [0x0000000000000000]              
	unsigned char                                      DetailMode;                                       		// 0x0172 (0x0001) [0x0000000000000000]              
	unsigned char                                      RBChannel;                                        		// 0x0173 (0x0001) [0x0000000000000000]              
	unsigned char                                      RBDominanceGroup;                                 		// 0x0174 (0x0001) [0x0000000000000000]              
	unsigned char                                      PreviewEnvironmentShadowing;                      		// 0x0175 (0x0001) [0x0000000000000000]              
	DWORD                                              bUseViewOwnerDepthPriorityGroup : 1;              		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAllowCullDistanceVolume : 1;                     		// 0x0178 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              HiddenGame : 1;                                   		// 0x0178 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              HiddenEditor : 1;                                 		// 0x0178 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bOwnerNoSee : 1;                                  		// 0x0178 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bOnlyOwnerSee : 1;                                		// 0x0178 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bIgnoreOwnerHidden : 1;                           		// 0x0178 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bUseAsOccluder : 1;                               		// 0x0178 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bAllowApproximateOcclusion : 1;                   		// 0x0178 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bFirstFrameOcclusion : 1;                         		// 0x0178 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bIgnoreNearPlaneIntersection : 1;                 		// 0x0178 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bSelectable : 1;                                  		// 0x0178 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bForceMipStreaming : 1;                           		// 0x0178 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bAcceptsDecals : 1;                               		// 0x0178 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bAcceptsDecalsDuringGameplay : 1;                 		// 0x0178 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bAcceptsStaticDecals : 1;                         		// 0x0178 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bAcceptsDynamicDecals : 1;                        		// 0x0178 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bIsRefreshingDecals : 1;                          		// 0x0178 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bAllowDecalAutomaticReAttach : 1;                 		// 0x0178 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bUsePerInstanceHitProxies : 1;                    		// 0x0178 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              CastShadow : 1;                                   		// 0x0178 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bForceDirectLightMap : 1;                         		// 0x0178 (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bCastDynamicShadow : 1;                           		// 0x0178 (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bCastStaticShadow : 1;                            		// 0x0178 (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bSelfShadowOnly : 1;                              		// 0x0178 (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bNoModSelfShadow : 1;                             		// 0x0178 (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bAcceptsDynamicDominantLightShadows : 1;          		// 0x0178 (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bCastHiddenShadow : 1;                            		// 0x0178 (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bCastShadowAsTwoSided : 1;                        		// 0x0178 (0x0004) [0x0000000000000000] [0x10000000] 
	DWORD                                              bAcceptsLights : 1;                               		// 0x0178 (0x0004) [0x0000000000000000] [0x20000000] 
	DWORD                                              bAcceptsDynamicLights : 1;                        		// 0x0178 (0x0004) [0x0000000000000000] [0x40000000] 
	DWORD                                              bUseOnePassLightingOnTranslucency : 1;            		// 0x0178 (0x0004) [0x0000000000000000] [0x80000000] 
	DWORD                                              bUsePrecomputedShadows : 1;                       		// 0x017C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bHasExplicitShadowParent : 1;                     		// 0x017C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAllowAmbientOcclusion : 1;                       		// 0x017C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              CollideActors : 1;                                		// 0x017C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              AlwaysCheckCollision : 1;                         		// 0x017C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              BlockActors : 1;                                  		// 0x017C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              BlockZeroExtent : 1;                              		// 0x017C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              BlockNonZeroExtent : 1;                           		// 0x017C (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              CanBlockCamera : 1;                               		// 0x017C (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              BlockRigidBody : 1;                               		// 0x017C (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bBlockFootPlacement : 1;                          		// 0x017C (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bDisableAllRigidBody : 1;                         		// 0x017C (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bSkipRBGeomCreation : 1;                          		// 0x017C (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bNotifyRigidBodyCollision : 1;                    		// 0x017C (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bFluidDrain : 1;                                  		// 0x017C (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bFluidTwoWay : 1;                                 		// 0x017C (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bIgnoreRadialImpulse : 1;                         		// 0x017C (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bIgnoreRadialForce : 1;                           		// 0x017C (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bIgnoreForceField : 1;                            		// 0x017C (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bUseCompartment : 1;                              		// 0x017C (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              AlwaysLoadOnClient : 1;                           		// 0x017C (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              AlwaysLoadOnServer : 1;                           		// 0x017C (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bIgnoreHiddenActorsMembership : 1;                		// 0x017C (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              AbsoluteTranslation : 1;                          		// 0x017C (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              AbsoluteRotation : 1;                             		// 0x017C (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              AbsoluteScale : 1;                                		// 0x017C (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bAllowShadowFade : 1;                             		// 0x017C (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bSupportedOnMobile : 1;                           		// 0x017C (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bWasSNFiltered : 1;                               		// 0x017C (0x0004) [0x0000000000000000] [0x10000000] 
	TArray< int >                                      OctreeNodes;                                      		// 0x0180 (0x0010) [0x0000000000000000]              
	int                                                TranslucencySortPriority;                         		// 0x0190 (0x0004) [0x0000000000000000]              
	int                                                VisibilityId;                                     		// 0x0194 (0x0004) [0x0000000000000000]              
	struct FLightingChannelContainer                   LightingChannels;                                 		// 0x0198 (0x0004) [0x0000000000000000]              
	struct FRBCollisionChannelContainer                RBCollideWithChannels;                            		// 0x019C (0x0004) [0x0000000000000000]              
	class UPhysicalMaterial*                           PhysMaterialOverride;                             		// 0x01A0 (0x0008) [0x0000000000000000]              
	class URB_BodyInstance*                            BodyInstance;                                     		// 0x01A8 (0x0008) [0x0000000000000000]              
	struct FMatrix                                     CachedParentToWorld;                              		// 0x01B0 (0x0040) [0x0000000000000000]              
	struct FVector                                     Translation;                                      		// 0x01F0 (0x000C) [0x0000000000000000]              
	struct FRotator                                    Rotation;                                         		// 0x01FC (0x000C) [0x0000000000000000]              
	float                                              Scale;                                            		// 0x0208 (0x0004) [0x0000000000000000]              
	struct FVector                                     Scale3D;                                          		// 0x020C (0x000C) [0x0000000000000000]              
	float                                              BoundsScale;                                      		// 0x0218 (0x0004) [0x0000000000000000]              
	float                                              LastSubmitTime;                                   		// 0x021C (0x0004) [0x0000000000000000]              
	float                                              LastRenderTime;                                   		// 0x0220 (0x0004) [0x0000000000000000]              
	float                                              LastShadowRenderTime;                             		// 0x0224 (0x0004) [0x0000000000000000]              
	float                                              ScriptRigidBodyCollisionThreshold;                		// 0x0228 (0x0004) [0x0000000000000000]              
	float                                              FootPlacementZOffset;                             		// 0x022C (0x0004) [0x0000000000000000]              
	float                                              PerObjectShadowCullDistance;                      		// 0x0230 (0x0004) [0x0000000000000000]              
	DWORD                                              bAllowPerObjectShadows : 1;                       		// 0x0234 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAllowPreshadows : 1;                             		// 0x0234 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAllowPerObjectShadowBatching : 1;                		// 0x0234 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bOverrideAutoLightingChannels : 1;                		// 0x0234 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bOverridePrecomputedShadowOcclusion : 1;          		// 0x0234 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bAcceptReflections : 1;                           		// 0x0234 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bAllowPersistentSplatters : 1;                    		// 0x0234 (0x0004) [0x0000000000000000] [0x00000040] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PrimitiveComponent" );

		return pClassPointer;
	};

	void ClosestPointOnComponentToComponent ( );
	void ClosestPointOnComponentToPoint ( );
	void GetRotation ( );
	void GetPosition ( );
	void SetAbsolute ( );
	void SetScale3D ( );
	void SetScale ( );
	void SetRotation ( );
	void SetTranslation ( );
	void SetActorCollision ( );
	void SetTraceBlocking ( );
	void SetViewOwnerDepthPriorityGroup ( );
	void SetDepthPriorityGroup ( );
	void SetPerObjectShadows ( );
	void SetLightingChannels ( );
	void SetCullDistance ( );
	void SetLightEnvironment ( );
	void SetShadowParent ( );
	void SetIgnoreOwnerHidden ( );
	void SetOnlyOwnerSee ( );
	void SetOwnerNoSee ( );
	void SetHidden ( );
	void ShouldComponentAddToScene ( );
	void SetRBDominanceGroup ( );
	void GetRootBodyInstance ( );
	void SetPhysMaterialOverride ( );
	void InitRBPhys ( );
	void SetNotifyRigidBodyCollision ( );
	void SetRBChannel ( );
	void SetRBCollisionChannels ( );
	void SetRBCollidesWithChannel ( );
	void SetBlockRigidBody ( );
	void RigidBodyIsAwake ( );
	void PutRigidBodyToSleep ( );
	void WakeRigidBody ( );
	void SetRBRotation ( );
	void SetRBPosition ( );
	void RetardRBLinearVelocity ( );
	void SetRBAngularVelocity ( );
	void SetRBLinearVelocity ( );
	void AddTorque ( );
	void AddRadialForce ( );
	void AddForce ( );
	void AddRadialImpulse ( );
	void AddImpulse ( );
};

UClass* UPrimitiveComponent::pClassPointer = NULL;

// Class Engine.ArrowComponent
// 0x0014 (0x024C - 0x0238)
class UArrowComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      ArrowColor;                                       		// 0x0238 (0x0004) [0x0000000000000000]              
	float                                              ArrowSize;                                        		// 0x023C (0x0004) [0x0000000000000000]              
	DWORD                                              bTreatAsASprite : 1;                              		// 0x0240 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FName                                       SpriteCategoryName;                               		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ArrowComponent" );

		return pClassPointer;
	};

};

UClass* UArrowComponent::pClassPointer = NULL;

// Class Engine.BrushComponent
// 0x007C (0x02B4 - 0x0238)
class UBrushComponent : public UPrimitiveComponent
{
public:
	class UModel*                                      Brush;                                            		// 0x0238 (0x0008) [0x0000000000000000]              
	struct FKAggregateGeom                             BrushAggGeom;                                     		// 0x0240 (0x005C) [0x0000000000000000]              
	struct FKCachedConvexData                          CachedPhysBrushData;                              		// 0x029C (0x0010) [0x0000000000000000]              
	int                                                CachedPhysBrushDataVersion;                       		// 0x02AC (0x0004) [0x0000000000000000]              
	DWORD                                              bBlockComplexCollisionTrace : 1;                  		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.BrushComponent" );

		return pClassPointer;
	};

};

UClass* UBrushComponent::pClassPointer = NULL;

// Class Engine.CameraConeComponent
// 0x0000 (0x0238 - 0x0238)
class UCameraConeComponent : public UPrimitiveComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CameraConeComponent" );

		return pClassPointer;
	};

};

UClass* UCameraConeComponent::pClassPointer = NULL;

// Class Engine.CylinderComponent
// 0x0010 (0x0248 - 0x0238)
class UCylinderComponent : public UPrimitiveComponent
{
public:
	float                                              CollisionHeight;                                  		// 0x0238 (0x0004) [0x0000000000000000]              
	float                                              CollisionRadius;                                  		// 0x023C (0x0004) [0x0000000000000000]              
	struct FColor                                      CylinderColor;                                    		// 0x0240 (0x0004) [0x0000000000000000]              
	DWORD                                              bDrawBoundingBox : 1;                             		// 0x0244 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDrawNonColliding : 1;                            		// 0x0244 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAlwaysRenderIfSelected : 1;                      		// 0x0244 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CylinderComponent" );

		return pClassPointer;
	};

	void SetCylinderSize ( );
};

UClass* UCylinderComponent::pClassPointer = NULL;

// Class Engine.DrawBoxComponent
// 0x001C (0x0254 - 0x0238)
class UDrawBoxComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      BoxColor;                                         		// 0x0238 (0x0004) [0x0000000000000000]              
	class UMaterial*                                   BoxMaterial;                                      		// 0x023C (0x0008) [0x0000000000000000]              
	struct FVector                                     BoxExtent;                                        		// 0x0244 (0x000C) [0x0000000000000000]              
	DWORD                                              bDrawWireBox : 1;                                 		// 0x0250 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDrawLitBox : 1;                                  		// 0x0250 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDrawOnlyIfSelected : 1;                          		// 0x0250 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DrawBoxComponent" );

		return pClassPointer;
	};

};

UClass* UDrawBoxComponent::pClassPointer = NULL;

// Class Engine.DrawCapsuleComponent
// 0x0018 (0x0250 - 0x0238)
class UDrawCapsuleComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      CapsuleColor;                                     		// 0x0238 (0x0004) [0x0000000000000000]              
	class UMaterial*                                   CapsuleMaterial;                                  		// 0x023C (0x0008) [0x0000000000000000]              
	float                                              CapsuleHeight;                                    		// 0x0244 (0x0004) [0x0000000000000000]              
	float                                              CapsuleRadius;                                    		// 0x0248 (0x0004) [0x0000000000000000]              
	DWORD                                              bDrawWireCapsule : 1;                             		// 0x024C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDrawLitCapsule : 1;                              		// 0x024C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDrawOnlyIfSelected : 1;                          		// 0x024C (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DrawCapsuleComponent" );

		return pClassPointer;
	};

};

UClass* UDrawCapsuleComponent::pClassPointer = NULL;

// Class Engine.DrawConeComponent
// 0x0010 (0x0248 - 0x0238)
class UDrawConeComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      ConeColor;                                        		// 0x0238 (0x0004) [0x0000000000000000]              
	float                                              ConeRadius;                                       		// 0x023C (0x0004) [0x0000000000000000]              
	float                                              ConeAngle;                                        		// 0x0240 (0x0004) [0x0000000000000000]              
	int                                                ConeSides;                                        		// 0x0244 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DrawConeComponent" );

		return pClassPointer;
	};

};

UClass* UDrawConeComponent::pClassPointer = NULL;

// Class Engine.DrawCylinderComponent
// 0x0024 (0x025C - 0x0238)
class UDrawCylinderComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      CylinderColor;                                    		// 0x0238 (0x0004) [0x0000000000000000]              
	class UMaterial*                                   CylinderMaterial;                                 		// 0x023C (0x0008) [0x0000000000000000]              
	float                                              CylinderRadius;                                   		// 0x0244 (0x0004) [0x0000000000000000]              
	float                                              CylinderTopRadius;                                		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              CylinderHeight;                                   		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              CylinderHeightOffset;                             		// 0x0250 (0x0004) [0x0000000000000000]              
	int                                                CylinderSides;                                    		// 0x0254 (0x0004) [0x0000000000000000]              
	DWORD                                              bDrawWireCylinder : 1;                            		// 0x0258 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDrawLitCylinder : 1;                             		// 0x0258 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDrawOnlyIfSelected : 1;                          		// 0x0258 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DrawCylinderComponent" );

		return pClassPointer;
	};

};

UClass* UDrawCylinderComponent::pClassPointer = NULL;

// Class Engine.DrawFrustumComponent
// 0x001C (0x0254 - 0x0238)
class UDrawFrustumComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      FrustumColor;                                     		// 0x0238 (0x0004) [0x0000000000000000]              
	float                                              FrustumAngle;                                     		// 0x023C (0x0004) [0x0000000000000000]              
	float                                              FrustumAspectRatio;                               		// 0x0240 (0x0004) [0x0000000000000000]              
	float                                              FrustumStartDist;                                 		// 0x0244 (0x0004) [0x0000000000000000]              
	float                                              FrustumEndDist;                                   		// 0x0248 (0x0004) [0x0000000000000000]              
	class UTexture*                                    Texture;                                          		// 0x024C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DrawFrustumComponent" );

		return pClassPointer;
	};

};

UClass* UDrawFrustumComponent::pClassPointer = NULL;

// Class Engine.DrawQuadComponent
// 0x0010 (0x0248 - 0x0238)
class UDrawQuadComponent : public UPrimitiveComponent
{
public:
	class UTexture*                                    Texture;                                          		// 0x0238 (0x0008) [0x0000000000000000]              
	float                                              Width;                                            		// 0x0240 (0x0004) [0x0000000000000000]              
	float                                              Height;                                           		// 0x0244 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DrawQuadComponent" );

		return pClassPointer;
	};

};

UClass* UDrawQuadComponent::pClassPointer = NULL;

// Class Engine.DrawSphereComponent
// 0x0018 (0x0250 - 0x0238)
class UDrawSphereComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      SphereColor;                                      		// 0x0238 (0x0004) [0x0000000000000000]              
	class UMaterial*                                   SphereMaterial;                                   		// 0x023C (0x0008) [0x0000000000000000]              
	float                                              SphereRadius;                                     		// 0x0244 (0x0004) [0x0000000000000000]              
	int                                                SphereSides;                                      		// 0x0248 (0x0004) [0x0000000000000000]              
	DWORD                                              bDrawWireSphere : 1;                              		// 0x024C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDrawLitSphere : 1;                               		// 0x024C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDrawOnlyIfSelected : 1;                          		// 0x024C (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DrawSphereComponent" );

		return pClassPointer;
	};

};

UClass* UDrawSphereComponent::pClassPointer = NULL;

// Class Engine.DrawPylonRadiusComponent
// 0x0000 (0x0250 - 0x0250)
class UDrawPylonRadiusComponent : public UDrawSphereComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DrawPylonRadiusComponent" );

		return pClassPointer;
	};

};

UClass* UDrawPylonRadiusComponent::pClassPointer = NULL;

// Class Engine.DrawSoundRadiusComponent
// 0x0000 (0x0250 - 0x0250)
class UDrawSoundRadiusComponent : public UDrawSphereComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DrawSoundRadiusComponent" );

		return pClassPointer;
	};

};

UClass* UDrawSoundRadiusComponent::pClassPointer = NULL;

// Class Engine.DrawTaperedCapsuleComponent
// 0x001C (0x0254 - 0x0238)
class UDrawTaperedCapsuleComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      CapsuleColor;                                     		// 0x0238 (0x0004) [0x0000000000000000]              
	class UMaterial*                                   CapsuleMaterial;                                  		// 0x023C (0x0008) [0x0000000000000000]              
	float                                              CapsuleHeight;                                    		// 0x0244 (0x0004) [0x0000000000000000]              
	float                                              CapsuleRadius;                                    		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              CapsuleTopRadius;                                 		// 0x024C (0x0004) [0x0000000000000000]              
	DWORD                                              bDrawWireCapsule : 1;                             		// 0x0250 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDrawLitCapsule : 1;                              		// 0x0250 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDrawOnlyIfSelected : 1;                          		// 0x0250 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DrawTaperedCapsuleComponent" );

		return pClassPointer;
	};

};

UClass* UDrawTaperedCapsuleComponent::pClassPointer = NULL;

// Class Engine.LevelGridVolumeRenderingComponent
// 0x0000 (0x0238 - 0x0238)
class ULevelGridVolumeRenderingComponent : public UPrimitiveComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LevelGridVolumeRenderingComponent" );

		return pClassPointer;
	};

};

UClass* ULevelGridVolumeRenderingComponent::pClassPointer = NULL;

// Class Engine.LineBatchComponent
// 0x0034 (0x026C - 0x0238)
class ULineBatchComponent : public UPrimitiveComponent
{
public:
	struct FPointer                                    FPrimitiveDrawInterfaceVfTable;                   		// 0x0238 (0x0008) [0x0000000000000000]              
	struct FPointer                                    FPrimitiveDrawInterfaceView;                      		// 0x0240 (0x0008) [0x0000000000000000]              
	TArray< struct FPointer >                          BatchedLines;                                     		// 0x0248 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          BatchedPoints;                                    		// 0x0258 (0x0010) [0x0000000000000000]              
	float                                              DefaultLifeTime;                                  		// 0x0268 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LineBatchComponent" );

		return pClassPointer;
	};

};

UClass* ULineBatchComponent::pClassPointer = NULL;

// Class Engine.ModelComponent
// 0x0030 (0x0268 - 0x0238)
class UModelComponent : public UPrimitiveComponent
{
public:
	class UObject*                                     Model;                                            		// 0x0238 (0x0008) [0x0000000000000000]              
	int                                                ZoneIndex;                                        		// 0x0240 (0x0004) [0x0000000000000000]              
	int                                                ComponentIndex;                                   		// 0x0244 (0x0004) [0x0000000000000000]              
	TArray< struct FPointer >                          Nodes;                                            		// 0x0248 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          Elements;                                         		// 0x0258 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ModelComponent" );

		return pClassPointer;
	};

};

UClass* UModelComponent::pClassPointer = NULL;

// Class Engine.SpriteComponent
// 0x0028 (0x0260 - 0x0238)
class USpriteComponent : public UPrimitiveComponent
{
public:
	class UTexture2D*                                  Sprite;                                           		// 0x0238 (0x0008) [0x0000000000000000]              
	DWORD                                              bIsScreenSizeScaled : 1;                          		// 0x0240 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              ScreenSize;                                       		// 0x0244 (0x0004) [0x0000000000000000]              
	float                                              U;                                                		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              UL;                                               		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              V;                                                		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              VL;                                               		// 0x0254 (0x0004) [0x0000000000000000]              
	struct FName                                       SpriteCategoryName;                               		// 0x0258 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SpriteComponent" );

		return pClassPointer;
	};

	void SetSpriteAndUV ( );
	void SetUV ( );
	void SetSprite ( );
};

UClass* USpriteComponent::pClassPointer = NULL;

// Class Engine.RadialBlurComponent
// 0x006B (0x00F0 - 0x0085)
class URadialBlurComponent : public UActorComponent
{
public:
	class UMaterialInterface*                          Material;                                         		// 0x0088 (0x0008) [0x0000000000000000]              
	unsigned char                                      DepthPriorityGroup;                               		// 0x0090 (0x0001) [0x0000000000000000]              
	float                                              BlurScale;                                        		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              BlurFalloffExponent;                              		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              BlurOpacity;                                      		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              MaxCullDistance;                                  		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              DistanceFalloffExponent;                          		// 0x00A4 (0x0004) [0x0000000000000000]              
	DWORD                                              bRenderAsVelocity : 1;                            		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnabled : 1;                                     		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x00AC (0x0004) MISSED OFFSET
	struct FMatrix                                     LocalToWorld;                                     		// 0x00B0 (0x0040) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RadialBlurComponent" );

		return pClassPointer;
	};

	void OnUpdatePropertyBlurOpacity ( );
	void OnUpdatePropertyBlurFalloffExponent ( );
	void OnUpdatePropertyBlurScale ( );
	void SetEnabled ( );
	void SetBlurOpacity ( );
	void SetBlurFalloffExponent ( );
	void SetBlurScale ( );
	void SetMaterial ( );
};

UClass* URadialBlurComponent::pClassPointer = NULL;

// Class Engine.SceneCaptureComponent
// 0x004B (0x00D0 - 0x0085)
class USceneCaptureComponent : public UActorComponent
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnablePostProcess : 1;                           		// 0x0088 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bEnableFog : 1;                                   		// 0x0088 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUseMainScenePostProcessSettings : 1;             		// 0x0088 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bSkipUpdateIfTextureUsersOccluded : 1;            		// 0x0088 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bSkipUpdateIfOwnerOccluded : 1;                   		// 0x0088 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bSkipRenderingDepthPrepass : 1;                   		// 0x0088 (0x0004) [0x0000000000000000] [0x00000040] 
	struct FColor                                      ClearColor;                                       		// 0x008C (0x0004) [0x0000000000000000]              
	unsigned char                                      ViewMode;                                         		// 0x0090 (0x0001) [0x0000000000000000]              
	int                                                SceneLOD;                                         		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              FrameRate;                                        		// 0x0098 (0x0004) [0x0000000000000000]              
	class UPostProcessChain*                           PostProcess;                                      		// 0x009C (0x0008) [0x0000000000000000]              
	float                                              MaxUpdateDist;                                    		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              MaxViewDistanceOverride;                          		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              MaxStreamingUpdateDist;                           		// 0x00AC (0x0004) [0x0000000000000000]              
	struct FPointer                                    CaptureInfo;                                      		// 0x00B0 (0x0008) [0x0000000000000000]              
	struct FPointer                                    ViewState;                                        		// 0x00B8 (0x0008) [0x0000000000000000]              
	TArray< struct FPointer >                          PostProcessProxies;                               		// 0x00C0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SceneCaptureComponent" );

		return pClassPointer;
	};

	void SetEnabled ( );
	void SetFrameRate ( );
};

UClass* USceneCaptureComponent::pClassPointer = NULL;

// Class Engine.SceneCapture2DComponent
// 0x00A0 (0x0170 - 0x00D0)
class USceneCapture2DComponent : public USceneCaptureComponent
{
public:
	class UTextureRenderTarget2D*                      TextureTarget;                                    		// 0x00D0 (0x0008) [0x0000000000000000]              
	float                                              FieldOfView;                                      		// 0x00D8 (0x0004) [0x0000000000000000]              
	float                                              NearPlane;                                        		// 0x00DC (0x0004) [0x0000000000000000]              
	float                                              FarPlane;                                         		// 0x00E0 (0x0004) [0x0000000000000000]              
	DWORD                                              bUpdateMatrices : 1;                              		// 0x00E4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x00E8 (0x0008) MISSED OFFSET
	struct FMatrix                                     ViewMatrix;                                       		// 0x00F0 (0x0040) [0x0000000000000000]              
	struct FMatrix                                     ProjMatrix;                                       		// 0x0130 (0x0040) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SceneCapture2DComponent" );

		return pClassPointer;
	};

	void SetView ( );
	void SetCaptureParameters ( );
};

UClass* USceneCapture2DComponent::pClassPointer = NULL;

// Class Engine.SceneCapture2DHitMaskComponent
// 0x002C (0x00FC - 0x00D0)
class USceneCapture2DHitMaskComponent : public USceneCaptureComponent
{
public:
	class UTextureRenderTarget2D*                      TextureTarget;                                    		// 0x00D0 (0x0008) [0x0000000000000000]              
	class USkeletalMeshComponent*                      SkeletalMeshComp;                                 		// 0x00D8 (0x0008) [0x0000000000000000]              
	int                                                MaterialIndex;                                    		// 0x00E0 (0x0004) [0x0000000000000000]              
	int                                                ForceLOD;                                         		// 0x00E4 (0x0004) [0x0000000000000000]              
	int                                                HitMaskCullDistance;                              		// 0x00E8 (0x0004) [0x0000000000000000]              
	float                                              FadingStartTimeSinceHit;                          		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              FadingPercentage;                                 		// 0x00F0 (0x0004) [0x0000000000000000]              
	float                                              FadingDurationTime;                               		// 0x00F4 (0x0004) [0x0000000000000000]              
	float                                              FadingIntervalTime;                               		// 0x00F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SceneCapture2DHitMaskComponent" );

		return pClassPointer;
	};

	void SetFadingStartTimeSinceHit ( );
	void SetCaptureParameters ( );
	void SetCaptureTargetTexture ( );
};

UClass* USceneCapture2DHitMaskComponent::pClassPointer = NULL;

// Class Engine.SceneCaptureCubeMapComponent
// 0x001C (0x00EC - 0x00D0)
class USceneCaptureCubeMapComponent : public USceneCaptureComponent
{
public:
	class UTextureRenderTargetCube*                    TextureTarget;                                    		// 0x00D0 (0x0008) [0x0000000000000000]              
	float                                              NearPlane;                                        		// 0x00D8 (0x0004) [0x0000000000000000]              
	float                                              FarPlane;                                         		// 0x00DC (0x0004) [0x0000000000000000]              
	struct FVector                                     WorldLocation;                                    		// 0x00E0 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SceneCaptureCubeMapComponent" );

		return pClassPointer;
	};

};

UClass* USceneCaptureCubeMapComponent::pClassPointer = NULL;

// Class Engine.SceneCapturePortalComponent
// 0x0014 (0x00E4 - 0x00D0)
class USceneCapturePortalComponent : public USceneCaptureComponent
{
public:
	class UTextureRenderTarget2D*                      TextureTarget;                                    		// 0x00D0 (0x0008) [0x0000000000000000]              
	float                                              ScaleFOV;                                         		// 0x00D8 (0x0004) [0x0000000000000000]              
	class AActor*                                      ViewDestination;                                  		// 0x00DC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SceneCapturePortalComponent" );

		return pClassPointer;
	};

	void SetCaptureParameters ( );
};

UClass* USceneCapturePortalComponent::pClassPointer = NULL;

// Class Engine.SceneCaptureReflectComponent
// 0x000C (0x00DC - 0x00D0)
class USceneCaptureReflectComponent : public USceneCaptureComponent
{
public:
	class UTextureRenderTarget2D*                      TextureTarget;                                    		// 0x00D0 (0x0008) [0x0000000000000000]              
	float                                              ScaleFOV;                                         		// 0x00D8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SceneCaptureReflectComponent" );

		return pClassPointer;
	};

};

UClass* USceneCaptureReflectComponent::pClassPointer = NULL;

// Class Engine.WindDirectionalSourceComponent
// 0x001B (0x00A0 - 0x0085)
class UWindDirectionalSourceComponent : public UActorComponent
{
public:
	struct FPointer                                    SceneProxy;                                       		// 0x0088 (0x0008) [0x0000000000000000]              
	float                                              Strength;                                         		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              Phase;                                            		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              Frequency;                                        		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              Speed;                                            		// 0x009C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.WindDirectionalSourceComponent" );

		return pClassPointer;
	};

};

UClass* UWindDirectionalSourceComponent::pClassPointer = NULL;

// Class Engine.WindPointSourceComponent
// 0x000C (0x00AC - 0x00A0)
class UWindPointSourceComponent : public UWindDirectionalSourceComponent
{
public:
	class UDrawSphereComponent*                        PreviewRadiusComponent;                           		// 0x00A0 (0x0008) [0x0000000000000000]              
	float                                              Radius;                                           		// 0x00A8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.WindPointSourceComponent" );

		return pClassPointer;
	};

};

UClass* UWindPointSourceComponent::pClassPointer = NULL;

// Class Engine.ActorFactory
// 0x003C (0x009C - 0x0060)
class UActorFactory : public UObject
{
public:
	class UClass*                                      GameplayActorClass;                               		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FString                                     MenuName;                                         		// 0x0068 (0x0010) [0x0000000000000000]              
	int                                                MenuPriority;                                     		// 0x0078 (0x0004) [0x0000000000000000]              
	int                                                AlternateMenuPriority;                            		// 0x007C (0x0004) [0x0000000000000000]              
	struct FString                                     NewActorClassName;                                		// 0x0080 (0x0010) [0x0000000000000000]              
	class UClass*                                      NewActorClass;                                    		// 0x0090 (0x0008) [0x0000000000000000]              
	DWORD                                              bPlaceable : 1;                                   		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bShowInEditorQuickMenu : 1;                       		// 0x0098 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactory" );

		return pClassPointer;
	};

	void eventPostCreateActor ( );
};

UClass* UActorFactory::pClassPointer = NULL;

// Class Engine.ActorFactoryActor
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryActor : public UActorFactory
{
public:
	class UClass*                                      ActorClass;                                       		// 0x009C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryActor" );

		return pClassPointer;
	};

};

UClass* UActorFactoryActor::pClassPointer = NULL;

// Class Engine.ActorFactoryAI
// 0x0038 (0x00D4 - 0x009C)
class UActorFactoryAI : public UActorFactory
{
public:
	class UClass*                                      ControllerClass;                                  		// 0x009C (0x0008) [0x0000000000000000]              
	class UClass*                                      PawnClass;                                        		// 0x00A4 (0x0008) [0x0000000000000000]              
	struct FString                                     PawnName;                                         		// 0x00AC (0x0010) [0x0000000000000000]              
	DWORD                                              bGiveDefaultInventory : 1;                        		// 0x00BC (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class UClass* >                            InventoryList;                                    		// 0x00C0 (0x0010) [0x0000000000000000]              
	int                                                TeamIndex;                                        		// 0x00D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryAI" );

		return pClassPointer;
	};

};

UClass* UActorFactoryAI::pClassPointer = NULL;

// Class Engine.ActorFactoryAmbientSound
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryAmbientSound : public UActorFactory
{
public:
	class USoundCue*                                   AmbientSoundCue;                                  		// 0x009C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryAmbientSound" );

		return pClassPointer;
	};

};

UClass* UActorFactoryAmbientSound::pClassPointer = NULL;

// Class Engine.ActorFactoryAmbientSoundMovable
// 0x0000 (0x00A4 - 0x00A4)
class UActorFactoryAmbientSoundMovable : public UActorFactoryAmbientSound
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryAmbientSoundMovable" );

		return pClassPointer;
	};

};

UClass* UActorFactoryAmbientSoundMovable::pClassPointer = NULL;

// Class Engine.ActorFactoryAmbientSoundSimple
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryAmbientSoundSimple : public UActorFactory
{
public:
	class USoundNodeWave*                              SoundNodeWave;                                    		// 0x009C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryAmbientSoundSimple" );

		return pClassPointer;
	};

};

UClass* UActorFactoryAmbientSoundSimple::pClassPointer = NULL;

// Class Engine.ActorFactoryAmbientSoundNonLoop
// 0x0000 (0x00A4 - 0x00A4)
class UActorFactoryAmbientSoundNonLoop : public UActorFactoryAmbientSoundSimple
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryAmbientSoundNonLoop" );

		return pClassPointer;
	};

};

UClass* UActorFactoryAmbientSoundNonLoop::pClassPointer = NULL;

// Class Engine.ActorFactoryAmbientSoundSimpleToggleable
// 0x0000 (0x00A4 - 0x00A4)
class UActorFactoryAmbientSoundSimpleToggleable : public UActorFactoryAmbientSoundSimple
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryAmbientSoundSimpleToggleable" );

		return pClassPointer;
	};

};

UClass* UActorFactoryAmbientSoundSimpleToggleable::pClassPointer = NULL;

// Class Engine.ActorFactoryAmbientSoundNonLoopingToggleable
// 0x0000 (0x00A4 - 0x00A4)
class UActorFactoryAmbientSoundNonLoopingToggleable : public UActorFactoryAmbientSoundSimpleToggleable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryAmbientSoundNonLoopingToggleable" );

		return pClassPointer;
	};

};

UClass* UActorFactoryAmbientSoundNonLoopingToggleable::pClassPointer = NULL;

// Class Engine.ActorFactoryApexDestructible
// 0x0014 (0x00B0 - 0x009C)
class UActorFactoryApexDestructible : public UActorFactory
{
public:
	DWORD                                              bStartAwake : 1;                                  		// 0x009C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      RBChannel;                                        		// 0x00A0 (0x0001) [0x0000000000000000]              
	struct FRBCollisionChannelContainer                CollideWithChannels;                              		// 0x00A4 (0x0004) [0x0000000000000000]              
	class UApexDestructibleAsset*                      DestructibleAsset;                                		// 0x00A8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryApexDestructible" );

		return pClassPointer;
	};

};

UClass* UActorFactoryApexDestructible::pClassPointer = NULL;

// Class Engine.ActorFactoryArchetype
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryArchetype : public UActorFactory
{
public:
	class AActor*                                      ArchetypeActor;                                   		// 0x009C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryArchetype" );

		return pClassPointer;
	};

};

UClass* UActorFactoryArchetype::pClassPointer = NULL;

// Class Engine.ActorFactoryCoverLink
// 0x0000 (0x009C - 0x009C)
class UActorFactoryCoverLink : public UActorFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryCoverLink" );

		return pClassPointer;
	};

};

UClass* UActorFactoryCoverLink::pClassPointer = NULL;

// Class Engine.ActorFactoryDominantDirectionalLight
// 0x0000 (0x009C - 0x009C)
class UActorFactoryDominantDirectionalLight : public UActorFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryDominantDirectionalLight" );

		return pClassPointer;
	};

};

UClass* UActorFactoryDominantDirectionalLight::pClassPointer = NULL;

// Class Engine.ActorFactoryDominantDirectionalLightMovable
// 0x0000 (0x009C - 0x009C)
class UActorFactoryDominantDirectionalLightMovable : public UActorFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryDominantDirectionalLightMovable" );

		return pClassPointer;
	};

};

UClass* UActorFactoryDominantDirectionalLightMovable::pClassPointer = NULL;

// Class Engine.ActorFactoryDynamicSM
// 0x0019 (0x00B5 - 0x009C)
class UActorFactoryDynamicSM : public UActorFactory
{
public:
	class UStaticMesh*                                 StaticMesh;                                       		// 0x009C (0x0008) [0x0000000000000000]              
	struct FVector                                     DrawScale3D;                                      		// 0x00A4 (0x000C) [0x0000000000000000]              
	DWORD                                              bNoEncroachCheck : 1;                             		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bNotifyRigidBodyCollision : 1;                    		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bBlockRigidBody : 1;                              		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUseCompartment : 1;                              		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bCastDynamicShadow : 1;                           		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned char                                      CollisionType;                                    		// 0x00B4 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryDynamicSM" );

		return pClassPointer;
	};

};

UClass* UActorFactoryDynamicSM::pClassPointer = NULL;

// Class Engine.ActorFactoryMover
// 0x0003 (0x00B8 - 0x00B5)
class UActorFactoryMover : public UActorFactoryDynamicSM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryMover" );

		return pClassPointer;
	};

};

UClass* UActorFactoryMover::pClassPointer = NULL;

// Class Engine.ActorFactoryRigidBody
// 0x002F (0x00E4 - 0x00B5)
class UActorFactoryRigidBody : public UActorFactoryDynamicSM
{
public:
	DWORD                                              bStartAwake : 1;                                  		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDamageAppliesImpulse : 1;                        		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bLocalSpaceInitialVelocity : 1;                   		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bEnableStayUprightSpring : 1;                     		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000008] 
	struct FVector                                     InitialVelocity;                                  		// 0x00BC (0x000C) [0x0000000000000000]              
	class UDistributionVector*                         AdditionalVelocity;                               		// 0x00C8 (0x0008) [0x0000000000000000]              
	class UDistributionVector*                         InitialAngularVelocity;                           		// 0x00D0 (0x0008) [0x0000000000000000]              
	unsigned char                                      RBChannel;                                        		// 0x00D8 (0x0001) [0x0000000000000000]              
	float                                              StayUprightTorqueFactor;                          		// 0x00DC (0x0004) [0x0000000000000000]              
	float                                              StayUprightMaxTorque;                             		// 0x00E0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryRigidBody" );

		return pClassPointer;
	};

};

UClass* UActorFactoryRigidBody::pClassPointer = NULL;

// Class Engine.ActorFactoryEmitter
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryEmitter : public UActorFactory
{
public:
	class UParticleSystem*                             ParticleSystem;                                   		// 0x009C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryEmitter" );

		return pClassPointer;
	};

};

UClass* UActorFactoryEmitter::pClassPointer = NULL;

// Class Engine.ActorFactoryFlex
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryFlex : public UActorFactory
{
public:
	class UStaticMesh*                                 StaticMesh;                                       		// 0x009C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryFlex" );

		return pClassPointer;
	};

};

UClass* UActorFactoryFlex::pClassPointer = NULL;

// Class Engine.ActorFactoryFracturedStaticMesh
// 0x0014 (0x00B0 - 0x009C)
class UActorFactoryFracturedStaticMesh : public UActorFactory
{
public:
	class UFracturedStaticMesh*                        FracturedStaticMesh;                              		// 0x009C (0x0008) [0x0000000000000000]              
	struct FVector                                     DrawScale3D;                                      		// 0x00A4 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryFracturedStaticMesh" );

		return pClassPointer;
	};

};

UClass* UActorFactoryFracturedStaticMesh::pClassPointer = NULL;

// Class Engine.ActorFactoryLensFlare
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryLensFlare : public UActorFactory
{
public:
	class ULensFlare*                                  LensFlareObject;                                  		// 0x009C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryLensFlare" );

		return pClassPointer;
	};

};

UClass* UActorFactoryLensFlare::pClassPointer = NULL;

// Class Engine.ActorFactoryLight
// 0x0000 (0x009C - 0x009C)
class UActorFactoryLight : public UActorFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryLight" );

		return pClassPointer;
	};

};

UClass* UActorFactoryLight::pClassPointer = NULL;

// Class Engine.ActorFactoryPathNode
// 0x0000 (0x009C - 0x009C)
class UActorFactoryPathNode : public UActorFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryPathNode" );

		return pClassPointer;
	};

};

UClass* UActorFactoryPathNode::pClassPointer = NULL;

// Class Engine.ActorFactoryPhysicsAsset
// 0x002C (0x00C8 - 0x009C)
class UActorFactoryPhysicsAsset : public UActorFactory
{
public:
	class UPhysicsAsset*                               PhysicsAsset;                                     		// 0x009C (0x0008) [0x0000000000000000]              
	class USkeletalMesh*                               SkeletalMesh;                                     		// 0x00A4 (0x0008) [0x0000000000000000]              
	DWORD                                              bStartAwake : 1;                                  		// 0x00AC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDamageAppliesImpulse : 1;                        		// 0x00AC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bNotifyRigidBodyCollision : 1;                    		// 0x00AC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUseCompartment : 1;                              		// 0x00AC (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bCastDynamicShadow : 1;                           		// 0x00AC (0x0004) [0x0000000000000000] [0x00000010] 
	struct FVector                                     InitialVelocity;                                  		// 0x00B0 (0x000C) [0x0000000000000000]              
	struct FVector                                     DrawScale3D;                                      		// 0x00BC (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryPhysicsAsset" );

		return pClassPointer;
	};

};

UClass* UActorFactoryPhysicsAsset::pClassPointer = NULL;

// Class Engine.ActorFactoryPlayerStart
// 0x0000 (0x009C - 0x009C)
class UActorFactoryPlayerStart : public UActorFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryPlayerStart" );

		return pClassPointer;
	};

};

UClass* UActorFactoryPlayerStart::pClassPointer = NULL;

// Class Engine.ActorFactoryPylon
// 0x0000 (0x009C - 0x009C)
class UActorFactoryPylon : public UActorFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryPylon" );

		return pClassPointer;
	};

};

UClass* UActorFactoryPylon::pClassPointer = NULL;

// Class Engine.ActorFactorySkeletalMesh
// 0x0018 (0x00B4 - 0x009C)
class UActorFactorySkeletalMesh : public UActorFactory
{
public:
	class USkeletalMesh*                               SkeletalMesh;                                     		// 0x009C (0x0008) [0x0000000000000000]              
	class UAnimSet*                                    AnimSet;                                          		// 0x00A4 (0x0008) [0x0000000000000000]              
	struct FName                                       AnimSequenceName;                                 		// 0x00AC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactorySkeletalMesh" );

		return pClassPointer;
	};

};

UClass* UActorFactorySkeletalMesh::pClassPointer = NULL;

// Class Engine.ActorFactoryStaticMesh
// 0x0014 (0x00B0 - 0x009C)
class UActorFactoryStaticMesh : public UActorFactory
{
public:
	class UStaticMesh*                                 StaticMesh;                                       		// 0x009C (0x0008) [0x0000000000000000]              
	struct FVector                                     DrawScale3D;                                      		// 0x00A4 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryStaticMesh" );

		return pClassPointer;
	};

};

UClass* UActorFactoryStaticMesh::pClassPointer = NULL;

// Class Engine.ActorFactoryTrigger
// 0x0000 (0x009C - 0x009C)
class UActorFactoryTrigger : public UActorFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryTrigger" );

		return pClassPointer;
	};

};

UClass* UActorFactoryTrigger::pClassPointer = NULL;

// Class Engine.ActorFactoryVehicle
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryVehicle : public UActorFactory
{
public:
	class UClass*                                      VehicleClass;                                     		// 0x009C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryVehicle" );

		return pClassPointer;
	};

};

UClass* UActorFactoryVehicle::pClassPointer = NULL;

// Class Engine.AISubsystem
// 0x0004 (0x006C - 0x0068)
class UAISubsystem : public USubsystem
{
public:
	DWORD                                              bImplementsNavMeshGeneration : 1;                 		// 0x0068 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AISubsystem" );

		return pClassPointer;
	};

	void eventGetDifficultyValue ( );
	void ToggleNavByCover ( );
	void ToggleNavByComponent ( );
	void ToggleNavByActor ( );
};

UClass* UAISubsystem::pClassPointer = NULL;

// Class Engine.AkBank
// 0x0004 (0x0064 - 0x0060)
class UAkBank : public UObject
{
public:
	DWORD                                              AutoLoad : 1;                                     		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              GenerateDefinition : 1;                           		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AkBank" );

		return pClassPointer;
	};

};

UClass* UAkBank::pClassPointer = NULL;

// Class Engine.AkBaseSoundObject
// 0x0000 (0x0060 - 0x0060)
class UAkBaseSoundObject : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AkBaseSoundObject" );

		return pClassPointer;
	};

};

UClass* UAkBaseSoundObject::pClassPointer = NULL;

// Class Engine.AkEvent
// 0x0070 (0x00D0 - 0x0060)
class UAkEvent : public UAkBaseSoundObject
{
public:
	class UAkBank*                                     RequiredBank;                                     		// 0x0060 (0x0008) [0x0000000000000000]              
	float                                              MaxAudibleDistance;                               		// 0x0068 (0x0004) [0x0000000000000000]              
	DWORD                                              bOverrideMaxAudibleDistance : 1;                  		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseListenerDistance : 1;                         		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUseEnvironmentReverbSwitchGroup : 1;             		// 0x006C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUseDoppler : 1;                                  		// 0x006C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bForceHearSoundLocational : 1;                    		// 0x006C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bNeedsOcclusionUpdates : 1;                       		// 0x006C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bNeverOcclude : 1;                                		// 0x006C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bIsMusicTrack : 1;                                		// 0x006C (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bUseAdvancedSoundFunctionality : 1;               		// 0x006C (0x0004) [0x0000000000000000] [0x00000100] 
	float                                              Duration;                                         		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              OcclusionUpdateInterval;                          		// 0x0074 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             CustomTags;                                       		// 0x0078 (0x0010) [0x0000000000000000]              
	TArray< struct FEventSwitchInfo >                  CustomSwitches;                                   		// 0x0088 (0x0010) [0x0000000000000000]              
	TArray< struct FEventRTPCInfo >                    CustomRTPCs;                                      		// 0x0098 (0x0010) [0x0000000000000000]              
	class UAkEvent*                                    EchoFront;                                        		// 0x00A8 (0x0008) [0x0000000000000000]              
	class UAkEvent*                                    EchoLeft;                                         		// 0x00B0 (0x0008) [0x0000000000000000]              
	class UAkEvent*                                    EchoRight;                                        		// 0x00B8 (0x0008) [0x0000000000000000]              
	class UAkEvent*                                    EchoRear;                                         		// 0x00C0 (0x0008) [0x0000000000000000]              
	class UAkEvent*                                    EchoMono;                                         		// 0x00C8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AkEvent" );

		return pClassPointer;
	};

	void SetCustomRTPC ( );
};

UClass* UAkEvent::pClassPointer = NULL;

// Class Engine.SoundCue
// 0x00A8 (0x0108 - 0x0060)
class USoundCue : public UAkBaseSoundObject
{
public:
	struct FName                                       SoundClass;                                       		// 0x0060 (0x0008) [0x0000000000000000]              
	unsigned char                                      SoundClassName;                                   		// 0x0068 (0x0001) [0x0000000000000000]              
	DWORD                                              bDebug : 1;                                       		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPitchShiftWithTimeDilation : 1;                  		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 
	class USoundNode*                                  FirstNode;                                        		// 0x0070 (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x0078 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.SoundCue.EditorData
	float                                              MaxAudibleDistance;                               		// 0x00C0 (0x0004) [0x0000000000000000]              
	float                                              VolumeMultiplier;                                 		// 0x00C4 (0x0004) [0x0000000000000000]              
	float                                              PitchMultiplier;                                  		// 0x00C8 (0x0004) [0x0000000000000000]              
	float                                              Duration;                                         		// 0x00CC (0x0004) [0x0000000000000000]              
	class UFaceFXAnimSet*                              FaceFXAnimSetRef;                                 		// 0x00D0 (0x0008) [0x0000000000000000]              
	struct FString                                     FaceFXGroupName;                                  		// 0x00D8 (0x0010) [0x0000000000000000]              
	struct FString                                     FaceFXAnimName;                                   		// 0x00E8 (0x0010) [0x0000000000000000]              
	int                                                MaxConcurrentPlayCount;                           		// 0x00F8 (0x0004) [0x0000000000000000]              
	int                                                CurrentPlayCount;                                 		// 0x00FC (0x0004) [0x0000000000000000]              
	struct FName                                       SoundGroup;                                       		// 0x0100 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundCue" );

		return pClassPointer;
	};

	void GetCueDuration ( );
};

UClass* USoundCue::pClassPointer = NULL;

// Class Engine.BookMark
// 0x0028 (0x0088 - 0x0060)
class UBookMark : public UObject
{
public:
	struct FVector                                     Location;                                         		// 0x0060 (0x000C) [0x0000000000000000]              
	struct FRotator                                    Rotation;                                         		// 0x006C (0x000C) [0x0000000000000000]              
	TArray< struct FString >                           HiddenLevels;                                     		// 0x0078 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.BookMark" );

		return pClassPointer;
	};

};

UClass* UBookMark::pClassPointer = NULL;

// Class Engine.BookMark2D
// 0x000C (0x006C - 0x0060)
class UBookMark2D : public UObject
{
public:
	float                                              Zoom2D;                                           		// 0x0060 (0x0004) [0x0000000000000000]              
	struct FIntPoint                                   Location;                                         		// 0x0064 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.BookMark2D" );

		return pClassPointer;
	};

};

UClass* UBookMark2D::pClassPointer = NULL;

// Class Engine.KismetBookMark
// 0x0010 (0x007C - 0x006C)
class UKismetBookMark : public UBookMark2D
{
public:
	struct FString                                     BookMarkSequencePathName;                         		// 0x006C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.KismetBookMark" );

		return pClassPointer;
	};

};

UClass* UKismetBookMark::pClassPointer = NULL;

// Class Engine.Canvas
// 0x0068 (0x00C8 - 0x0060)
class UCanvas : public UObject
{
public:
	class UFont*                                       Font;                                             		// 0x0060 (0x0008) [0x0000000000000000]              
	float                                              OrgX;                                             		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              OrgY;                                             		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              ClipX;                                            		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              ClipY;                                            		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              CurX;                                             		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              CurY;                                             		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              CurZ;                                             		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              CurYL;                                            		// 0x0084 (0x0004) [0x0000000000000000]              
	struct FColor                                      DrawColor;                                        		// 0x0088 (0x0004) [0x0000000000000000]              
	DWORD                                              bCenter : 1;                                      		// 0x008C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bNoSmooth : 1;                                    		// 0x008C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bStencilEnabled : 1;                              		// 0x008C (0x0004) [0x0000000000000000] [0x00000004] 
	int                                                SizeX;                                            		// 0x0090 (0x0004) [0x0000000000000000]              
	int                                                SizeY;                                            		// 0x0094 (0x0004) [0x0000000000000000]              
	struct FPointer                                    Canvas;                                           		// 0x0098 (0x0008) [0x0000000000000000]              
	struct FPointer                                    SceneView;                                        		// 0x00A0 (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x00A8 (0x0008) MISSED OFFSET
	struct FPlane                                      ColorModulate;                                    		// 0x00B0 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  DefaultTexture;                                   		// 0x00C0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Canvas" );

		return pClassPointer;
	};

	void DrawDebugGraphElement ( );
	void DrawDebugGraphBackground ( );
	void DrawDebugGraph ( );
	void DrawTextureDoubleLine ( );
	void DrawTextureLine ( );
	void Draw2DLine ( );
	void SetDrawColorStruct ( );
	void EnableStencilTest ( );
	void SetDrawColor ( );
	void DrawBox ( );
	void DrawRect ( );
	void DrawIcon ( );
	void DrawScaledIcon ( );
	void MakeIcon ( );
	void DrawBlendedTile ( );
	void DrawTexture ( );
	void PopMaskRegion ( );
	void PushMaskRegion ( );
	void SetClip ( );
	void SetOrigin ( );
	void SetPos ( );
	void GetDefaultCanvasFont ( );
	void eventReset ( );
	void PopTransform ( );
	void PushTranslationMatrix ( );
	void DeProject ( );
	void Project(FVector In, FVector &Out);
	void DrawText(struct FString Text, float ScaleX, float ScaleY);
	void TextSize ( );
	void StrLen ( );
	void CreateFontRenderInfo ( );
	void DrawTris ( );
	void DrawTileStretched ( );
	void DrawTimer ( );
	void DrawRotatedMaterialTile ( );
	void DrawRotatedTile ( );
	void DrawMaterialTile ( );
	void PreOptimizeDrawTiles ( );
	void DrawTile ( );
};

UClass* UCanvas::pClassPointer = NULL;

// Class Engine.Channel
// 0x0040 (0x00A0 - 0x0060)
class UChannel : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0x40 ];                            		// 0x0060 (0x0040) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Channel" );

		return pClassPointer;
	};

};

UClass* UChannel::pClassPointer = NULL;

// Class Engine.ActorChannel
// 0x0080 (0x0120 - 0x00A0)
class UActorChannel : public UChannel
{
public:
	unsigned char                                      UnknownData00[ 0x80 ];                            		// 0x00A0 (0x0080) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorChannel" );

		return pClassPointer;
	};

};

UClass* UActorChannel::pClassPointer = NULL;

// Class Engine.ControlChannel
// 0x0014 (0x00B4 - 0x00A0)
class UControlChannel : public UChannel
{
public:
	unsigned char                                      UnknownData00[ 0x14 ];                            		// 0x00A0 (0x0014) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ControlChannel" );

		return pClassPointer;
	};

};

UClass* UControlChannel::pClassPointer = NULL;

// Class Engine.FileChannel
// 0x0224 (0x02C4 - 0x00A0)
class UFileChannel : public UChannel
{
public:
	unsigned char                                      UnknownData00[ 0x224 ];                           		// 0x00A0 (0x0224) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FileChannel" );

		return pClassPointer;
	};

};

UClass* UFileChannel::pClassPointer = NULL;

// Class Engine.VoiceChannel
// 0x0010 (0x00B0 - 0x00A0)
class UVoiceChannel : public UChannel
{
public:
	unsigned char                                      UnknownData00[ 0x10 ];                            		// 0x00A0 (0x0010) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.VoiceChannel" );

		return pClassPointer;
	};

};

UClass* UVoiceChannel::pClassPointer = NULL;

// Class Engine.Controller
// 0x01F4 (0x0438 - 0x0244)
class AController : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;              		// 0x0244 (0x0008) [0x0000000000000000]              
	class APawn*                                       Pawn;                                             		// 0x024C (0x0008) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )
	class APlayerReplicationInfo*                      PlayerReplicationInfo;                            		// 0x0254 (0x0008) [0x0000000000160000]              ( CPF_EditConst | CPF_GlobalConfig )
	int                                                PlayerNum;                                        		// 0x025C (0x0004) [0x0000000000000000]              
	class AController*                                 NextController;                                   		// 0x0260 (0x0008) [0x0000000000000000]              
	DWORD                                              bIsPlayer : 1;                                    		// 0x0268 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bGodMode : 1;                                     		// 0x0268 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDemiGodMode : 1;                                 		// 0x0268 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bSoaking : 1;                                     		// 0x0268 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bSlowerZAcquire : 1;                              		// 0x0268 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bNotifyPostLanded : 1;                            		// 0x0268 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bNotifyApex : 1;                                  		// 0x0268 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bOverrideSearchStart : 1;                         		// 0x0268 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bAdvancedTactics : 1;                             		// 0x0268 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bCanDoSpecial : 1;                                		// 0x0268 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bAdjusting : 1;                                   		// 0x0268 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bPreparingMove : 1;                               		// 0x0268 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bForceStrafe : 1;                                 		// 0x0268 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bLOSflag : 1;                                     		// 0x0268 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bSkipExtraLOSChecks : 1;                          		// 0x0268 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bNotifyFallingHitWall : 1;                        		// 0x0268 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bEarlyOutOfSighTestsForSameType : 1;              		// 0x0268 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bReachedLatentMoveGoal : 1;                       		// 0x0268 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bAdjustFromWalls : 1;                             		// 0x0268 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bPreciseDestination : 1;                          		// 0x0268 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bSeeFriendly : 1;                                 		// 0x0268 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bUsingPathLanes : 1;                              		// 0x0268 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned char                                      bFire;                                            		// 0x026C (0x0001) [0x0000000000000000]              
	unsigned char                                      bAltFire;                                         		// 0x026D (0x0001) [0x0000000000000000]              
	float                                              MinHitWall;                                       		// 0x0270 (0x0004) [0x0000000000000000]              
	class UClass*                                      NavigationHandleClass;                            		// 0x0274 (0x0008) [0x0000000000000000]              
	class UNavigationHandle*                           NavigationHandle;                                 		// 0x027C (0x0008) [0x0000000000000000]              
	struct FVector                                     OverrideSearchStart;                              		// 0x0284 (0x000C) [0x0000000000000000]              
	float                                              MoveTimer;                                        		// 0x0290 (0x0004) [0x0000000000000000]              
	class AActor*                                      MoveTarget;                                       		// 0x0294 (0x0008) [0x0000000000000000]              
	struct FBasedPosition                              DestinationPosition;                              		// 0x029C (0x0038) [0x0000000000000000]              
	struct FBasedPosition                              FocalPosition;                                    		// 0x02D4 (0x0038) [0x0000000000000000]              
	class AActor*                                      Focus;                                            		// 0x030C (0x0008) [0x0000000000000000]              
	class AActor*                                      GoalList[ 0x4 ];                                  		// 0x0314 (0x0020) [0x0000000000000000]              
	struct FBasedPosition                              AdjustPosition;                                   		// 0x0334 (0x0038) [0x0000000000000000]              
	class ANavigationPoint*                            StartSpot;                                        		// 0x036C (0x0008) [0x0000000000000000]              
	TArray< class ANavigationPoint* >                  RouteCache;                                       		// 0x0374 (0x0010) [0x0000000000000000]              
	class UReachSpec*                                  CurrentPath;                                      		// 0x0384 (0x0008) [0x0000000000000000]              
	class UReachSpec*                                  NextRoutePath;                                    		// 0x038C (0x0008) [0x0000000000000000]              
	struct FVector                                     CurrentPathDir;                                   		// 0x0394 (0x000C) [0x0000000000000000]              
	class AActor*                                      RouteGoal;                                        		// 0x03A0 (0x0008) [0x0000000000000000]              
	float                                              RouteDist;                                        		// 0x03A8 (0x0004) [0x0000000000000000]              
	float                                              LastRouteFind;                                    		// 0x03AC (0x0004) [0x0000000000000000]              
	class AInterpActor*                                PendingMover;                                     		// 0x03B0 (0x0008) [0x0000000000000000]              
	class AActor*                                      FailedMoveTarget;                                 		// 0x03B8 (0x0008) [0x0000000000000000]              
	int                                                MoveFailureCount;                                 		// 0x03C0 (0x0004) [0x0000000000000000]              
	float                                              GroundPitchTime;                                  		// 0x03C4 (0x0004) [0x0000000000000000]              
	class APawn*                                       ShotTarget;                                       		// 0x03C8 (0x0008) [0x0000000000000000]              
	class AActor*                                      LastFailedReach;                                  		// 0x03D0 (0x0008) [0x0000000000000000]              
	float                                              FailedReachTime;                                  		// 0x03D8 (0x0004) [0x0000000000000000]              
	struct FVector                                     FailedReachLocation;                              		// 0x03DC (0x000C) [0x0000000000000000]              
	float                                              SightCounter;                                     		// 0x03E8 (0x0004) [0x0000000000000000]              
	float                                              SightCounterInterval;                             		// 0x03EC (0x0004) [0x0000000000000000]              
	class ANavigationPoint*                            LastNavGoalReached;                               		// 0x03F0 (0x0008) [0x0000000000000000]              
	float                                              InUseNodeCostMultiplier;                          		// 0x03F8 (0x0004) [0x0000000000000000]              
	int                                                HighJumpNodeCostModifier;                         		// 0x03FC (0x0004) [0x0000000000000000]              
	float                                              MaxMoveTowardPawnTargetTime;                      		// 0x0400 (0x0004) [0x0000000000000000]              
	class APawn*                                       Enemy;                                            		// 0x0404 (0x0008) [0x0000000000000000]              
	TArray< struct FVisiblePortalInfo >                VisiblePortals;                                   		// 0x040C (0x0010) [0x0000000000000000]              
	float                                              LaneOffset;                                       		// 0x041C (0x0004) [0x0000000000000000]              
	struct FRotator                                    OldBasedRotation;                                 		// 0x0420 (0x000C) [0x0000000000000000]              
	struct FVector                                     NavMeshPath_SearchExtent_Modifier;                		// 0x042C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Controller" );

		return pClassPointer;
	};

	void eventGeneratePathToLocation ( );
	void eventGeneratePathToActor ( );
	void eventInterpolationFinished ( );
	void eventInterpolationStarted ( );
	void InitNavigationHandle ( );
	void ReadyForLift ( );
	void SendMessage ( );
	void eventCurrentLevelUnloaded ( );
	void eventIsInCombat ( );
	void eventIsSpectating ( );
	void OnToggleHidden ( );
	void NotifyAddInventory ( );
	void OnModifyHealth ( );
	void NotifyCoverClaimViolation ( );
	void eventNotifyCoverAdjusted ( );
	void NotifyCoverDisabled ( );
	void OnSetVelocity ( );
	void OnSetPhysics ( );
	void OnToggleGodMode ( );
	void OnAttachToActor ( );
	void OnTeleport ( );
	void IsDead ( );
	void GetHumanReadableName ( );
	void DisplayDebug ( );
	void StopLatentExecution ( );
	void InLatentExecution ( );
	void eventReachedPreciseDestination ( );
	void eventNotifyMissedJump ( );
	void eventNotifyJumpApex ( );
	void eventNotifyBump ( );
	void eventNotifyFallingHitWall ( );
	void eventNotifyHitWall ( );
	void eventNotifyLanded ( );
	void eventNotifyHeadVolumeChange ( );
	void eventNotifyPhysicsVolumeChange ( );
	void LandingShake ( );
	void IsAimingAt ( );
	void eventGetActorEyesViewPoint ( );
	void eventGetPlayerViewPoint ( );
	void eventHandlePathObstruction ( );
	void UnderLift ( );
	void eventMoverFinished ( );
	void WaitForMover ( );
	void eventAllowDetourTo ( );
	void eventMayFall ( );
	void EndClimbLadder ( );
	void eventLongFall ( );
	void WaitForLanding ( );
	void PickWallAdjust ( );
	void eventMoveUnreachable ( );
	void ActorReachable ( );
	void PointReachable ( );
	void FindPathToIntercept ( );
	void FindRandomDest ( );
	void FindPathTowardNearest ( );
	void FindPathToward ( );
	void FindPathTo ( );
	void FinishRotation ( );
	void eventSetupSpecialPathAbilities ( );
	void MoveToward ( );
	void MoveToDirectNonPathPos ( );
	void MoveTo ( );
	void eventEnemyNotVisible ( );
	void eventSeeMonster ( );
	void eventSeePlayer ( );
	void eventHearNoise ( );
	void PickTarget ( );
	void CanSeeByPoints ( );
	void CanSee ( );
	void LineOfSightTo ( );
	void NotifyChangedWeapon ( );
	void ClientSwitchToBestWeapon ( );
	void SwitchToBestWeapon ( );
	void ReceiveProjectileWarning ( );
	void ReceiveWarning ( );
	void InstantWarnTarget ( );
	void GetAdjustedAimFor ( );
	void HandlePickup ( );
	void RoundHasEnded ( );
	void eventStopFiring ( );
	void FireWeaponAt ( );
	void eventRatePickup ( );
	void WarnProjExplode ( );
	void NotifyProjLanded ( );
	void NotifyKilled ( );
	void GameHasEnded ( );
	void SetCharacter ( );
	void ServerGivePawn ( );
	void ServerRestartPlayer ( );
	void GetTeamNum ( );
	void InitPlayerReplicationInfo ( );
	void NotifyTakeHit ( );
	void EnemyJustTeleported ( );
	void BeyondFogDistance ( );
	void Restart ( );
	void CleanupPRI ( );
	void eventDestroyed ( );
	void eventNotifyPostLanded ( );
	void GamePlayEndedState ( );
	void PawnDied ( );
	void eventUnPossess ( );
	void eventPossess ( );
	void OnPossess ( );
	void eventReplicatedEvent ( );
	void ClientSetRotation ( );
	void ClientSetLocation ( );
	void Reset ( );
	void eventPostBeginPlay ( );
	void eventSetSkelControlScale ( );
	void eventSetMorphWeight ( );
	void eventStopActorFaceFXAnim ( );
	void eventPlayActorFaceFXAnim ( );
	void eventFinishAnimControl ( );
	void eventSetAnimPosition ( );
	void eventBeginAnimControl ( );
	void eventPauseAndShowMsg ( );
	void eventAILog_Internal ( );
	void eventNotifyFailMove ( );
	void eventJumpedOverWall ( );
	void eventFailedToFindAnchor ( );
	void eventNotifyPathChanged ( );
	void GetAdjustLocation ( );
	void SetAdjustLocation ( );
	void GetDestinationPosition ( );
	void SetDestinationPosition ( );
	void GetFocalPoint ( );
	void SetFocalPoint ( );
	void RouteCache_RemoveIndex ( );
	void RouteCache_RemoveItem ( );
	void RouteCache_InsertItem ( );
	void RouteCache_AddItem ( );
	void RouteCache_Empty ( );
	void IsLocalController ( );
	void IsLocalPlayerController ( );
};

UClass* AController::pClassPointer = NULL;

// Class Engine.PlayerController
// 0x0338 (0x0770 - 0x0438)
class APlayerController : public AController
{
public:
	class UPlayer*                                     Player;                                           		// 0x0438 (0x0008) [0x0000000000000000]              
	class ACamera*                                     PlayerCamera;                                     		// 0x0440 (0x0008) [0x0000000000000000]              
	class UClass*                                      CameraClass;                                      		// 0x0448 (0x0008) [0x0000000000000000]              
	DWORD                                              bFrozen : 1;                                      		// 0x0450 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPressedJump : 1;                                 		// 0x0450 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDoubleJump : 1;                                  		// 0x0450 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUpdatePosition : 1;                              		// 0x0450 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bUpdating : 1;                                    		// 0x0450 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bNeverSwitchOnPickup : 1;                         		// 0x0450 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bCheatFlying : 1;                                 		// 0x0450 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bCameraPositionLocked : 1;                        		// 0x0450 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bShortConnectTimeOut : 1;                         		// 0x0450 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bPendingDestroy : 1;                              		// 0x0450 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bWasSpeedHack : 1;                                		// 0x0450 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bWasSaturated : 1;                                		// 0x0450 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bAimingHelp : 1;                                  		// 0x0450 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bCameraCut : 1;                                   		// 0x0450 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bClientSimulatingViewTarget : 1;                  		// 0x0450 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bHasVoiceHandshakeCompleted : 1;                  		// 0x0450 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bCanPlayOnline : 1;                               		// 0x0450 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bCanShareUserCreatedContent : 1;                  		// 0x0450 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bCanCommunicateVoice : 1;                         		// 0x0450 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bPrivilegesInitialized : 1;                       		// 0x0450 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bCinematicMode : 1;                               		// 0x0450 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bInteractiveMode : 1;                             		// 0x0450 (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bCinemaDisableInputMove : 1;                      		// 0x0450 (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bCinemaDisableInputLook : 1;                      		// 0x0450 (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bRenderHUDFullScreen : 1;                         		// 0x0450 (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bIgnoreNetworkMessages : 1;                       		// 0x0450 (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bShowKismetDrawText : 1;                          		// 0x0450 (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bReplicateAllPawns : 1;                           		// 0x0450 (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bIsUsingStreamingVolumes : 1;                     		// 0x0450 (0x0004) [0x0000000000000000] [0x10000000] 
	DWORD                                              bIsExternalUIOpen : 1;                            		// 0x0450 (0x0004) [0x0000000000000000] [0x20000000] 
	DWORD                                              bIsControllerConnected : 1;                       		// 0x0450 (0x0004) [0x0000000000000000] [0x40000000] 
	DWORD                                              bCheckSoundOcclusion : 1;                         		// 0x0450 (0x0004) [0x0000000000000000] [0x80000000] 
	DWORD                                              bDebugCameraAnims : 1;                            		// 0x0454 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bBlockCameraAnimsFromOverridingPostProcess : 1;   		// 0x0454 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bLogHearSoundOverflow : 1;                        		// 0x0454 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bCheckRelevancyThroughPortals : 1;                		// 0x0454 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bDebugClientAdjustPosition : 1;                   		// 0x0454 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bDrawRelevancyChecks : 1;                         		// 0x0454 (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              MaxResponseTime;                                  		// 0x0458 (0x0004) [0x0000000000000000]              
	float                                              WaitDelay;                                        		// 0x045C (0x0004) [0x0000000000000000]              
	class APawn*                                       AcknowledgedPawn;                                 		// 0x0460 (0x0008) [0x0000000000000000]              
	unsigned char                                      DoubleClickDir;                                   		// 0x0468 (0x0001) [0x0000000000000000]              
	unsigned char                                      bIgnoreMoveInput;                                 		// 0x0469 (0x0001) [0x0000000000000000]              
	unsigned char                                      bIgnoreLookInput;                                 		// 0x046A (0x0001) [0x0000000000000000]              
	unsigned char                                      bRun;                                             		// 0x046B (0x0001) [0x0000000000000000]              
	unsigned char                                      bDuck;                                            		// 0x046C (0x0001) [0x0000000000000000]              
	unsigned char                                      NetPlayerIndex;                                   		// 0x046D (0x0001) [0x0000000000000000]              
	unsigned char                                      RelevancyCounter;                                 		// 0x046E (0x0001) [0x0000000000000000]              
	class AActor*                                      ViewTarget;                                       		// 0x0470 (0x0008) [0x0000000000000000]              
	class APlayerReplicationInfo*                      RealViewTarget;                                   		// 0x0478 (0x0008) [0x0000000000000000]              
	class UInterpTrackInstDirector*                    ControllingDirTrackInst;                          		// 0x0480 (0x0008) [0x0000000000000000]              
	float                                              FOVAngle;                                         		// 0x0488 (0x0004) [0x0000000000000000]              
	float                                              DesiredFOV;                                       		// 0x048C (0x0004) [0x0000000000000000]              
	float                                              DefaultFOV;                                       		// 0x0490 (0x0004) [0x0000000000000000]              
	float                                              LODDistanceFactor;                                		// 0x0494 (0x0004) [0x0000000000000000]              
	struct FRotator                                    TargetViewRotation;                               		// 0x0498 (0x000C) [0x0000000000170000]              ( CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
	float                                              TargetEyeHeight;                                  		// 0x04A4 (0x0004) [0x0000000000180000]              ( CPF_Component )
	struct FRotator                                    BlendedTargetViewRotation;                        		// 0x04A8 (0x000C) [0x0000000000000000]              
	class AHUD*                                        myHUD;                                            		// 0x04B4 (0x0008) [0x0000000000000000]              
	class AHUD*                                        mySecondaryHUD;                                   		// 0x04BC (0x0008) [0x0000000000000000]              
	class UClass*                                      SavedMoveClass;                                   		// 0x04C4 (0x0008) [0x0000000000000000]              
	class USavedMove*                                  SavedMoves;                                       		// 0x04CC (0x0008) [0x0000000000000000]              
	class USavedMove*                                  FreeMoves;                                        		// 0x04D4 (0x0008) [0x0000000000000000]              
	class USavedMove*                                  PendingMove;                                      		// 0x04DC (0x0008) [0x0000000000000000]              
	struct FVector                                     LastAckedAccel;                                   		// 0x04E4 (0x000C) [0x0000000000000000]              
	float                                              CurrentTimeStamp;                                 		// 0x04F0 (0x0004) [0x0000000000000000]              
	float                                              LastUpdateTime;                                   		// 0x04F4 (0x0004) [0x0000000000000000]              
	float                                              ServerTimeStamp;                                  		// 0x04F8 (0x0004) [0x0000000000000000]              
	float                                              TimeMargin;                                       		// 0x04FC (0x0004) [0x0000000000000000]              
	float                                              ClientUpdateTime;                                 		// 0x0500 (0x0004) [0x0000000000000000]              
	float                                              MaxTimeMargin;                                    		// 0x0504 (0x0004) [0x0000000000000000]              
	float                                              LastActiveTime;                                   		// 0x0508 (0x0004) [0x0000000000000000]              
	int                                                ClientCap;                                        		// 0x050C (0x0004) [0x0000000000000000]              
	float                                              DynamicPingThreshold;                             		// 0x0510 (0x0004) [0x0000000000000000]              
	float                                              LastPingUpdate;                                   		// 0x0514 (0x0004) [0x0000000000000000]              
	float                                              LastSpeedHackLog;                                 		// 0x0518 (0x0004) [0x0000000000000000]              
	struct FClientAdjustment                           PendingAdjustment;                                		// 0x051C (0x0038) [0x0000000000000000]              
	int                                                GroundPitch;                                      		// 0x0554 (0x0004) [0x0000000000000000]              
	class UCheatManager*                               CheatManager;                                     		// 0x0558 (0x0008) [0x0000000000000000]              
	class UClass*                                      CheatClass;                                       		// 0x0560 (0x0008) [0x0000000000000000]              
	class UPlayerInput*                                PlayerInput;                                      		// 0x0568 (0x0008) [0x0000000000000000]              
	class UClass*                                      InputClass;                                       		// 0x0570 (0x0008) [0x0000000000000000]              
	struct FVector                                     FailedPathStart;                                  		// 0x0578 (0x000C) [0x0000000000000000]              
	class UCylinderComponent*                          CylinderComponent;                                		// 0x0584 (0x0008) [0x0000000000000000]              
	struct FString                                     ForceFeedbackManagerClassName;                    		// 0x058C (0x0010) [0x0000000000000000]              
	class UForceFeedbackManager*                       ForceFeedbackManager;                             		// 0x059C (0x0008) [0x0000000000000000]              
	TArray< class UInteraction* >                      Interactions;                                     		// 0x05A4 (0x0010) [0x0000000000000000]              
	TArray< struct FUniqueNetId >                      VoiceMuteList;                                    		// 0x05B4 (0x0010) [0x0000000000000000]              
	TArray< struct FUniqueNetId >                      GameplayVoiceMuteList;                            		// 0x05C4 (0x0010) [0x0000000000000000]              
	TArray< struct FUniqueNetId >                      VoicePacketFilter;                                		// 0x05D4 (0x0010) [0x0000000000000000]              
	TArray< struct FConnectedPeerInfo >                ConnectedPeers;                                   		// 0x05E4 (0x0010) [0x0000000000000000]              
	TArray< struct FUniqueNetId >                      BestNextHostPeers;                                		// 0x05F4 (0x0010) [0x0000000000000000]              
	class UOnlineGameSearch*                           MigratedSearchToJoin;                             		// 0x0604 (0x0008) [0x0000000000000000]              
	class UOnlineSubsystem*                            OnlineSub;                                        		// 0x060C (0x0008) [0x0000000000000000]              
	class UPlayfabInterface*                           PlayfabInter;                                     		// 0x0614 (0x0008) [0x0000000000000000]              
	class UOnlineVoiceInterface*                       VoiceInterface;                                   		// 0x061C (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0624 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UUIDataStore_OnlinePlayerData*               OnlinePlayerData;                                 		// 0x062C (0x0008) [0x0000000000000000]              
	struct FOnlineGameSearchResult                     CachedInviteResult;                               		// 0x0634 (0x0010) [0x0000000000000000]              
	float                                              InteractDistance;                                 		// 0x0644 (0x0004) [0x0000000000000000]              
	struct FName                                       DelayedJoinSessionName;                           		// 0x0648 (0x0008) [0x0000000000000000]              
	TArray< struct FInputMatchRequest >                InputRequests;                                    		// 0x0650 (0x0010) [0x0000000000000000]              
	float                                              LastBroadcastTime;                                		// 0x0660 (0x0004) [0x0000000000000000]              
	struct FString                                     LastBroadcastString[ 0x4 ];                       		// 0x0664 (0x0040) [0x0000000000000000]              
	TArray< struct FName >                             PendingMapChangeLevelNames;                       		// 0x06A4 (0x0010) [0x0000000000000000]              
	class ACoverReplicator*                            MyCoverReplicator;                                		// 0x06B4 (0x0008) [0x0000000000000000]              
	TArray< struct FDebugTextInfo >                    DebugTextList;                                    		// 0x06BC (0x0010) [0x0000000000000000]              
	float                                              SpectatorCameraSpeed;                             		// 0x06CC (0x0004) [0x0000000000000000]              
	class UNetConnection*                              PendingSwapConnection;                            		// 0x06D0 (0x0008) [0x0000000000000000]              
	float                                              MinRespawnDelay;                                  		// 0x06D8 (0x0004) [0x0000000000000000]              
	int                                                MaxConcurrentHearSounds;                          		// 0x06DC (0x0004) [0x0000000000000000]              
	TArray< class UAudioComponent* >                   HearSoundActiveComponents;                        		// 0x06E0 (0x0010) [0x0000000000000000]              
	TArray< class UAudioComponent* >                   HearSoundPoolComponents;                          		// 0x06F0 (0x0010) [0x0000000000000000]              
	TArray< class AActor* >                            HiddenActors;                                     		// 0x0700 (0x0010) [0x0000000000000000]              
	float                                              LastSpectatorStateSynchTime;                      		// 0x0710 (0x0004) [0x0000000000000000]              
	TArray< struct FUniqueNetId >                      VoiceSenders;                                     		// 0x0714 (0x0010) [0x0000000000000000]              
	TArray< struct FUniqueNetId >                      VoiceReceivers;                                   		// 0x0724 (0x0010) [0x0000000000000000]              
	struct FRotator                                    WeaponBufferRotation;                             		// 0x0734 (0x000C) [0x0000000000000000]              
	struct FScriptDelegate                             __OnMissingPeersUnregistered__Delegate;           		// 0x0740 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x4 ];                             		// 0x0744 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __CanUnpause__Delegate;                           		// 0x0750 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x4 ];                             		// 0x0754 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __InputMatchDelegate__Delegate;                   		// 0x0760 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData03[ 0x4 ];                             		// 0x0764 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PlayerController" );

		return pClassPointer;
	};

	void ClientReceiveReliableVoicePacket ( );
	void ServerReceiveReliableVoicePacket ( );
	void eventSendReliableVoicePacketToServer ( );
	void eventClientReplicationDebug ( );
	void OnLobbyStatusChanged ( );
	void NotifyUnsuccessfulSearch ( );
	void eventSetUIScale ( );
	void eventSetMatineeConstantCameraAnim ( );
	void eventNotifyDisconnect ( );
	void ReceivedGameClass ( );
	void LogOutBugItAIGoToLogFile ( );
	void LogOutBugItGoToLogFile ( );
	void DisableDebugAI ( );
	void ReadFriendsList ( );
	void OnFriendsReadComplete ( );
	void SetCallback ( );
	void DumpPeers ( );
	void DumpVoiceMutingState ( );
	void DumpOnlineSessionState ( );
	void DebugLogPRIs ( );
	void eventOnEngineInitialTick ( );
	void BugItStringCreator ( );
	void BugItAI ( );
	void LogLoc ( );
	void BugIt ( );
	void BugItWorker ( );
	void BugItGoString ( );
	void BugItGo ( );
	void HasPeerConnection ( );
	void OnSetSoundMode ( );
	void eventClientSpawnCameraLensEffect ( );
	void DebugCameraAnims ( );
	void eventClientStopCameraAnim ( );
	void eventClientPlayCameraAnim ( );
	void OnCameraShake ( );
	void ClientStopCameraShake ( );
	void ClientPlayCameraShake ( );
	void DoForceFeedbackForScreenShake ( );
	void InputMatchDelegate ( );
	void Sentinel_PostAcquireTravelTheWorldPoints ( );
	void Sentinel_PreAcquireTravelTheWorldPoints ( );
	void Sentinel_SetupForGamebasedTravelTheWorld ( );
	void OnFlyThroughHasEnded ( );
	void eventGetAchievementProgression ( );
	void GetPartyGameTypeName ( );
	void GetPartyMapName ( );
	void IsPartyLeader ( );
	void eventClientAddTextureStreamingLoc ( );
	void eventClientPrestreamTextures ( );
	void eventClientSetForceMipLevelsToBeResident ( );
	void ClientControlMovieTexture ( );
	void GetSplitscreenPlayerCount ( );
	void GetSplitscreenPlayerByIndex ( );
	void IsSplitscreenPlayer ( );
	void IsPrimaryPlayer ( );
	void ServerNotifyPartyHostLeaving ( );
	void ClientNotifyPartyHostLeaving ( );
	void ClientReturnToParty ( );
	void OnJoinTravelToSessionComplete ( );
	void PreJoinUpdateGameSettings ( );
	void ClientTravelToSession ( );
	void PathClear ( );
	void PathChild ( );
	void PathStep ( );
	void eventSoakPause ( );
	void IncrementNumberOfMatchesPlayed ( );
	void CanViewUserCreatedContent ( );
	void ClientEndOnlineGame ( );
	void ClientStartOnlineGame ( );
	void ServerRegisterClientStatGuid ( );
	void OnRegisterHostStatGuidComplete ( );
	void ClientRegisterHostStatGuid ( );
	void eventRemoveAllDebugStrings ( );
	void eventRemoveDebugText ( );
	void eventAddDebugText ( );
	void DrawDebugTextList ( );
	void OnDestroy ( );
	void ClientStartNetworkedVoice ( );
	void ClientStopNetworkedVoice ( );
	void ClientSetHostUniqueId ( );
	void ClientWriteLeaderboardStats ( );
	void ClientWriteOnlinePlayerScores ( );
	void ClientArbitratedMatchEnded ( );
	void NotifyNotEnoughSpaceInInvite ( );
	void NotifyNotAllPlayersCanJoinInvite ( );
	void NotifyInviteFailed ( );
	void OnInviteJoinComplete ( );
	void ModifyClientURL ( );
	void OnDestroyForInviteComplete ( );
	void OnEndForInviteComplete ( );
	void ClearInviteDelegates ( );
	void CanAllPlayersPlayOnline ( );
	void InviteHasEnoughSpace ( );
	void JoinPlayfabServer ( );
	void OnPlayTogetherStarted ( );
	void OnConnectionStatusChange ( );
	void OnGameInviteAccepted ( );
	void ServerRegisteredForArbitration ( );
	void OnArbitrationRegisterComplete ( );
	void ClientRegisterForArbitration ( );
	void eventClientWasKicked ( );
	void IsShowingSubtitles ( );
	void SetShowSubtitles ( );
	void eventNotifyDirectorControl ( );
	void eventServerUnmutePlayer ( );
	void eventServerMutePlayer ( );
	void GameplayUnmutePlayer ( );
	void GameplayMutePlayer ( );
	void eventClientUnmutePlayer ( );
	void eventClientMutePlayer ( );
	void ClientVoiceHandshakeComplete ( );
	void GetPlayerControllerFromNetId ( );
	void ClientSetOnlineStatus ( );
	void SeamlessTravelFrom ( );
	void SeamlessTravelTo ( );
	void eventGetSeamlessTravelActorList ( );
	void ForceDisconnect ( );
	void ShouldReplicateVoicePacketTo ( );
	void ShouldReplicateVoicePacketFrom ( );
	void IsPlayerMuted ( );
	void GetUIController ( );
	void SaveActorConfig ( );
	void SaveClassConfig ( );
	void ClientWaitForLevelsVisible ( );
	void eventClientSetBlockOnAsyncLoading ( );
	void eventClientFlushLevelStreaming ( );
	void eventClientCancelPendingMapChange ( );
	void eventClientCommitMapChange ( );
	void DelayedPrepareMapChange ( );
	void eventClientPrepareMapChange ( );
	void eventServerUpdateLevelVisibility ( );
	void ClientUpdateLevelStreamingStatus ( );
	void eventLevelStreamingStatusChanged ( );
	void eventClientForceGarbageCollection ( );
	void OnConsoleCommand ( );
	void ResetPlayerMovementInput ( );
	void eventIsLookInputIgnored ( );
	void IgnoreLookInput ( );
	void eventIsMoveInputIgnored ( );
	void IgnoreMoveInput ( );
	void ClientSetCinematicMode ( );
	void SetCinematicMode ( );
	void OnToggleCinematicMode ( );
	void IsForceFeedbackAllowed ( );
	void eventClientStopForceFeedbackWaveform ( );
	void eventClientPlayForceFeedbackWaveform ( );
	void eventPlayRumble ( );
	void OnForceFeedback ( );
	void NotifyTakeHit ( );
	void ShowGameState ( );
	void ShowPlayerState ( );
	void ServerRemoteEvent ( );
	void RE ( );
	void RemoteEvent ( );
	void ListCE ( );
	void ListConsoleEvents ( );
	void CE ( );
	void CauseEvent ( );
	void ServerCauseEvent ( );
	void OnToggleHUD ( );
	void OnSetCameraTarget ( );
	void ClientClearKismetText ( );
	void ClientDrawKismetText ( );
	void OnDrawText ( );
	void DisplayDebug ( );
	void ClientIgnoreLookInput ( );
	void ClientIgnoreMoveInput ( );
	void OnToggleInput ( );
	void eventAdjustHUDRenderSize ( );
	void DrawHUD ( );
	void CanRestartPlayer ( );
	void ServerViewSelf ( );
	void ViewAPlayer ( );
	void GetNextViewablePlayer ( );
	void ServerViewPrevPlayer ( );
	void ServerViewNextPlayer ( );
	void ServerSetSpectatorLocation ( );
	void IsSpectating ( );
	void AdjustPlayerWalkingMoveAccel ( );
	void CheckJumpOrDuck ( );
	void eventLimitViewRotation ( );
	void ProcessViewRotation ( );
	void ModifyUpdateRotation ( );
	void UpdateRotation ( );
	void ViewShake ( );
	void eventGetPlayerViewPoint ( );
	void eventSpawnPlayerCamera ( );
	void ServerVerifyViewTarget ( );
	void GetViewTarget ( );
	void eventClientSetViewTarget ( );
	void SetViewTargetWithBlend ( );
	void SetViewTarget ( );
	void IsLocalController ( );
	void IsLocalPlayerController ( );
	void eventGetFOVAngle ( );
	void AdjustFOV ( );
	void eventNotifyLanded ( );
	void AimHelpDot ( );
	void GetAdjustedAimFor ( );
	void eventCameraLookAtFinished ( );
	void AimingHelp ( );
	void PlayerMove ( );
	void eventPlayerTick ( );
	void NotifyChangedWeapon ( );
	void ClientGameEnded ( );
	void GameHasEnded ( );
	void ClientRestart ( );
	void EnterStartState ( );
	void ForceSingleNetUpdateFor ( );
	void HasClientLoadedCurrentWorld ( );
	void eventNotifyLoadedWorld ( );
	void eventServerNotifyLoadedWorld ( );
	void Restart ( );
	void eventClientSetProgressMessage ( );
	void SwitchLevel ( );
	void ServerChangeTeam ( );
	void ChangeTeam ( );
	void SwitchTeam ( );
	void ServerChangeName ( );
	void SetName ( );
	void ServerSuicide ( );
	void Suicide ( );
	void TriggerInteracted ( );
	void FindVehicleToDrive ( );
	void PerformedUseAction ( );
	void ServerUse ( );
	void Use ( );
	void GetTriggerUseList ( );
	void StopAltFire ( );
	void StartAltFire ( );
	void StopFire ( );
	void StartFire ( );
	void NextWeapon ( );
	void PrevWeapon ( );
	void ServerThrowWeapon ( );
	void ThrowWeapon ( );
	void UTrace ( );
	void ServerUTrace ( );
	void eventConditionalPause ( );
	void ServerPause ( );
	void Pause ( );
	void IsPaused ( );
	void SetPause ( );
	void CanUnpause ( );
	void ClientPauseRumble ( );
	void PauseRumbleForAllPlayers ( );
	void LocalTravel ( );
	void RestartLevel ( );
	void ServerSpeech ( );
	void Speech ( );
	void ServerRestartGame ( );
	void HandleWalking ( );
	void ServerUpdateCamera ( );
	void CallServerMove ( );
	void ReplicateMove ( );
	void CompressAccel ( );
	void GetFreeMove ( );
	void ClientUpdatePosition ( );
	void ClearAckedMoves ( );
	void ServerUpdatePing ( );
	void UpdateStateFromAdjustment ( );
	void LongClientAdjustPosition ( );
	void SkipPositionUpdateForRM ( );
	void UpdatePing ( );
	void ClientAdjustPosition ( );
	void ClientAckGoodMove ( );
	void ClientCapBandwidth ( );
	void ShortClientAdjustPosition ( );
	void VeryShortClientAdjustPosition ( );
	void MoveAutonomous ( );
	void ProcessMove ( );
	void ProcessDrive ( );
	void ServerDrive ( );
	void eventSendClientAdjustment ( );
	void ServerMove ( );
	void ServerMoveHandleClientError ( );
	void GetServerMoveDeltaTime ( );
	void OldServerMove ( );
	void DualServerMove ( );
	void ForceDeathUpdate ( );
	void UsingFirstPersonCamera ( );
	void eventClientSetCameraFade ( );
	void eventResetCameraMode ( );
	void SetCameraMode ( );
	void ClientSetCameraMode ( );
	void ServerCamera ( );
	void Camera ( );
	void eventPreClientTravel ( );
	void ServerTeamSay ( );
	void TeamSay ( );
	void ClientAdminMessage ( );
	void ServerSay ( );
	void Say ( );
	void AllowTextMessage ( );
	void ServerMutate ( );
	void Mutate ( );
	void FOV ( );
	void ResetFOV ( );
	void SetFOV ( );
	void FixFOV ( );
	void eventDestroyed ( );
	void eventExit ( );
	void CleanupPawn ( );
	void eventClearOnlineDelegates ( );
	void OnPartyMembersInfoChanged ( );
	void OnPartyMemberListChanged ( );
	void RegisterOnlineDelegates ( );
	void PlayBeepSound ( );
	void eventTeamMessage ( );
	void SpeakTTS ( );
	void TeamTalk ( );
	void Talk ( );
	void CreateTTSSoundCue ( );
	void AllowTTSMessageFrom ( );
	void CanCommunicate ( );
	void eventClientMessage ( );
	void ClientPlayActorFaceFXAnim ( );
	void eventKismet_ClientStopSound ( );
	void eventKismet_ClientPlaySound ( );
	void IsClosestLocalPlayerToActor ( );
	void eventWwiseClientHearSound ( );
	void eventClientHearSoundAdvancedRelevant ( );
	void eventClientHearSoundAdvanced ( );
	void eventClientHearSound ( );
	void GetPooledAudioComponent ( );
	void HearSoundFinished ( );
	void eventClientPlaySound ( );
	void eventReceiveLocalizedMessage ( );
	void CleanupPRI ( );
	void HandlePickup ( );
	void ClientSetSecondaryHUD ( );
	void ClientSetHUD ( );
	void PawnDied ( );
	void eventUnPossess ( );
	void ServerAcknowledgePossession ( );
	void AcknowledgePossession ( );
	void eventPossess ( );
	void GivePawn ( );
	void AskForPawn ( );
	void ClientGotoState ( );
	void SetTiltActive ( );
	void IsMouseAvailable ( );
	void IsKeyboardAvailable ( );
	void SetUseTiltForwardAndBack ( );
	void SetOnlyUseControllerTiltInput ( );
	void SetControllerTiltActive ( );
	void IsControllerTiltActive ( );
	void SetRumbleScale ( );
	void ReloadProfileSettings ( );
	void UnregisterStandardPlayerDataStores ( );
	void UnregisterPlayerDataStores ( );
	void RegisterStandardPlayerDataStores ( );
	void RegisterCustomPlayerDataStores ( );
	void RegisterPlayerDataStores ( );
	void ClientInitializeDataStores ( );
	void eventInitInputSystem ( );
	void GetOnlineSubsystem ( );
	void PostControllerIdChange ( );
	void PreControllerIdChange ( );
	void CleanOutSavedMoves ( );
	void ClientReset ( );
	void Reset ( );
	void SpawnDefaultHUD ( );
	void EnableCheats ( );
	void AddCheats ( );
	void eventKickWarning ( );
	void ServerGivePawn ( );
	void ServerShortTimeout ( );
	void ResetTimeMargin ( );
	void eventPreRender ( );
	void OnJoinMigratedGame ( );
	void PeerDesignatedAsClient ( );
	void OnUnregisterPlayerCompleteForJoinMigrate ( );
	void eventPeerReceivedMigratedSession ( );
	void TellPeerToTravelToSession ( );
	void TellPeerToTravel ( );
	void PeerTravelAsHost ( );
	void GetNewPeerHostURL ( );
	void PeerDesignatedAsHost ( );
	void GetCurrentSearchClass ( );
	void OnHostMigratedOnlineGame ( );
	void OnUnregisterPlayerCompleteForHostMigrate ( );
	void RemoveMissingPeersFromSession ( );
	void GetPRIFromNetId ( );
	void OnMissingPeersUnregistered ( );
	void GetRegisteredPlayersInSession ( );
	void NotifyHostMigrationStarted ( );
	void eventMigrateNewHost ( );
	void IsBestHostPeer ( );
	void eventNotifyPeerDisconnectHost ( );
	void ClientUpdateBestNextHosts ( );
	void ServerRemovePeer ( );
	void ServerAddPeer ( );
	void eventRemovePeer ( );
	void eventAddPeer ( );
	void BestNextHostSort ( );
	void FindConnectedPeerIndex ( );
	void eventReceivedPlayer ( );
	void eventPostBeginPlay ( );
	void SpawnCoverReplicator ( );
	void CanUnpauseControllerConnected ( );
	void ControllerChangedUnpause ( );
	void ControllerChangedPause ( );
	void OnControllerChanged ( );
	void CanUnpauseExternalUI ( );
	void OnExternalUIChanged ( );
	void OnPrivilegeLevelChecked ( );
	void eventCheckPrivileges ( );
	void ForceClearUnpauseDelegates ( );
	void DisableActorHeadTracking ( );
	void EnableActorHeadTracking ( );
	void eventFellOutOfWorld ( );
	void CleanUpAudioComponents ( );
	void FindStairRotation ( );
	void CheckSpeedHack ( );
	void eventServerProcessConvolve ( );
	void eventClientConvolve ( );
	void SetAudioGroupVolume ( );
	void SetAllowMatureLanguage ( );
	void PasteFromClipboard ( );
	void CopyToClipboard ( );
	void GetDefaultURL ( );
	void UpdateURL ( );
	void eventClientTravel ( );
	void ConsoleCommand ( );
	void GetServerNetworkAddress ( );
	void GetPlayerNetworkAddress ( );
	void SetNetSpeed ( );
};

UClass* APlayerController::pClassPointer = NULL;

// Class Engine.CheatManager
// 0x0020 (0x0080 - 0x0060)
class UCheatManager : public UObject
{
public:
	struct FString                                     ViewingFrom;                                      		// 0x0060 (0x0010) [0x0000000000000000]              
	struct FString                                     OwnCamera;                                        		// 0x0070 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CheatManager" );

		return pClassPointer;
	};

	void AnalyticsEndSession ( );
	void AnalyticsStartSession ( );
	void GetAnalyticsUserId ( );
	void SetAnalyticsUserId ( );
	void SendAnalyticsCachedEvents ( );
	void SendAnalyticsCurrencyGivenEvent ( );
	void SendAnalyticsCurrencyPurchaseEvent ( );
	void SendAnalyticsItemPurchaseEvent ( );
	void SendAnalyticsUserAttributeEvent ( );
	void SendAnalyticsEvent ( );
	void OnRequestComplete ( );
	void TestHttp ( );
	void OnDeleteUserFileComplete ( );
	void DebugDeleteUserFile ( );
	void OnReadUserFileComplete ( );
	void DebugReadUserFile ( );
	void OnWriteUserFileComplete ( );
	void DebugWriteUserFile ( );
	void OnEnumerateUserFilesComplete ( );
	void DebugQueryUserFiles ( );
	void OnReceivedLocalNotificationDebug ( );
	void DebugNotification ( );
	void DrawLocationXYZ ( );
	void DrawLocation ( );
	void DumpCoverStats ( );
	void DebugEmsDownload ( );
	void DebugDeleteTitleFiles ( );
	void OnSaveComplete ( );
	void DebugSaveTitleFile ( );
	void OnLoadComplete ( );
	void OnDownloadComplete ( );
	void DebugDownloadTitleFile ( );
	void DebugIniLocPatcher ( );
	void ToggleAILogging ( );
	void VerifyNavMeshCoverRefs ( );
	void PrintNavMeshObstacles ( );
	void PrintAllPathObjectEdges ( );
	void NavMeshVerification ( );
	void DrawUnsupportingEdges ( );
	void VerifyNavMeshObjects ( );
	void LogParticleActivateSystemCalls ( );
	void LogPlaySoundCalls ( );
	void InitCheatManager ( );
	void VerbosePathDebug ( );
	void TestPylonConnectivity ( );
	void TestNavMeshPath ( );
	void SetOnlineDebugLevel ( );
	void DumpOnlineSessionState ( );
	void TestLevel ( );
	void StreamLevelOut ( );
	void OnlyLoadLevel ( );
	void StreamLevelIn ( );
	void SetLevelStreamingStatus ( );
	void AllWeapons ( );
	void Loaded ( );
	void ViewClass ( );
	void ViewBot ( );
	void ViewActor ( );
	void ViewPlayer ( );
	void ViewSelf ( );
	void RememberSpot ( );
	void FractureAllMeshesToMaximizeMemoryUsage ( );
	void FractureAllMeshes ( );
	void DestroyFractures ( );
	void SuspendAI ( );
	void PlayersOnly ( );
	void GiveWeapon ( );
	void Summon ( );
	void Avatar ( );
	void KillPawns ( );
	void KillAllPawns ( );
	void KillAll ( );
	void SetSpeed ( );
	void SetGravity ( );
	void SetJumpZ ( );
	void Slomo ( );
	void God ( );
	void AllAmmo ( );
	void Ghost ( );
	void Walk ( );
	void Fly ( );
	void Amphibious ( );
	void EndPath ( );
	void ChangeSize ( );
	void Teleport ( );
	void KillViewedActor ( );
	void WriteToLog ( );
	void FreezeFrame ( );
	void ListDynamicActors ( );
	void DebugPause ( );
	void EditAIByTrace ( );
	void DebugAI ( );
	void FXStop ( );
	void FXPlay ( );
};

UClass* UCheatManager::pClassPointer = NULL;

// Class Engine.Client
// 0x0018 (0x0078 - 0x0060)
class UClient : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0060 (0x0008) MISSED OFFSET
	float                                              MinDesiredFrameRate;                              		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              DisplayGamma;                                     		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              InitialButtonRepeatDelay;                         		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              ButtonRepeatDelay;                                		// 0x0074 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Client" );

		return pClassPointer;
	};

};

UClass* UClient::pClassPointer = NULL;

// Class Engine.ClipPadEntry
// 0x0020 (0x0080 - 0x0060)
class UClipPadEntry : public UObject
{
public:
	struct FString                                     Title;                                            		// 0x0060 (0x0010) [0x0000000000000000]              
	struct FString                                     Text;                                             		// 0x0070 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ClipPadEntry" );

		return pClassPointer;
	};

};

UClass* UClipPadEntry::pClassPointer = NULL;

// Class Engine.CloudSaveSystem
// 0x0084 (0x00E4 - 0x0060)
class UCloudSaveSystem : public UObject
{
public:
	class UCloudSaveSystemKVSInterface*                KeyValueStore;                                    		// 0x0060 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0068 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UCloudSaveSystemDataBlobStoreInterface*      DataBlobStore;                                    		// 0x0070 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x8 ];                             		// 0x0078 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	TArray< struct FGetSaveDataCallbackStruct >        OnGetSaveDataCallbacks;                           		// 0x0080 (0x0010) [0x0000000000000000]              
	TArray< struct FSetSaveDataCallbackStruct >        OnSetSaveDataCallbacks;                           		// 0x0090 (0x0010) [0x0000000000000000]              
	struct FScriptDelegate                             DeleteSaveDataCallback;                           		// 0x00A0 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x4 ];                             		// 0x00A4 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	int                                                ActiveSlotForDelete;                              		// 0x00B0 (0x0004) [0x0000000000000000]              
	TArray< struct FSaveSlotOperation >                ActiveSaveSlotOperations;                         		// 0x00B4 (0x0010) [0x0000000000000000]              
	struct FScriptDelegate                             __OnGetSaveDataCallback__Delegate;                		// 0x00C4 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData03[ 0x4 ];                             		// 0x00C8 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __SaveSystemCallback__Delegate;                   		// 0x00D4 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData04[ 0x4 ];                             		// 0x00D8 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CloudSaveSystem" );

		return pClassPointer;
	};

	void GetKeyValue ( );
	void GetDataStoreIDAndBlobNameForSaveSlot ( );
	void SetKeyValue ( );
	void InternalSetSaveSlotKeyValues ( );
	void SetSaveSlotKeyValues ( );
	void OnDeleteSaveDataComplete ( );
	void DeleteSaveData ( );
	void OnSetSaveDataComplete ( );
	void SetSaveData ( );
	void OnGetSaveDataComplete ( );
	void GetSaveData ( );
	void Init ( );
	void DeserializeObject ( );
	void SerializeObject ( );
	void AreAnySlotOperationsActive ( );
	void IsDeleteOperationActive ( );
	void IsOperationActiveForSlot ( );
	void WriteNumSaveSlots ( );
	void DoesSaveSlotKeyValueDataAlreadyExist ( );
	void GetNumberOfSaveSlots ( );
	void SaveSystemCallback ( );
	void OnGetSaveDataCallback ( );
};

UClass* UCloudSaveSystem::pClassPointer = NULL;

// Class Engine.CodecMovie
// 0x0004 (0x0064 - 0x0060)
class UCodecMovie : public UObject
{
public:
	float                                              PlaybackDuration;                                 		// 0x0060 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CodecMovie" );

		return pClassPointer;
	};

};

UClass* UCodecMovie::pClassPointer = NULL;

// Class Engine.CodecMovieBink
// 0x0038 (0x009C - 0x0064)
class UCodecMovieBink : public UCodecMovie
{
public:
	unsigned char                                      UnknownData00[ 0x38 ];                            		// 0x0064 (0x0038) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CodecMovieBink" );

		return pClassPointer;
	};

};

UClass* UCodecMovieBink::pClassPointer = NULL;

// Class Engine.CodecMovieFallback
// 0x0004 (0x0068 - 0x0064)
class UCodecMovieFallback : public UCodecMovie
{
public:
	float                                              CurrentTime;                                      		// 0x0064 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CodecMovieFallback" );

		return pClassPointer;
	};

};

UClass* UCodecMovieFallback::pClassPointer = NULL;

// Class Engine.CurveEdPresetCurve
// 0x0020 (0x0080 - 0x0060)
class UCurveEdPresetCurve : public UObject
{
public:
	struct FString                                     CurveName;                                        		// 0x0060 (0x0010) [0x0000000000000000]              
	TArray< struct FPresetGeneratedPoint >             Points;                                           		// 0x0070 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CurveEdPresetCurve" );

		return pClassPointer;
	};

};

UClass* UCurveEdPresetCurve::pClassPointer = NULL;

// Class Engine.CustomPropertyItemHandler
// 0x0000 (0x0060 - 0x0060)
class UCustomPropertyItemHandler : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CustomPropertyItemHandler" );

		return pClassPointer;
	};

};

UClass* UCustomPropertyItemHandler::pClassPointer = NULL;

// Class Engine.DamageType
// 0x0030 (0x0090 - 0x0060)
class UDamageType : public UObject
{
public:
	DWORD                                              bArmorStops : 1;                                  		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bCausedByWorld : 1;                               		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bExtraMomentumZ : 1;                              		// 0x0060 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bCausesFracture : 1;                              		// 0x0060 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bRadialDamageVelChange : 1;                       		// 0x0060 (0x0004) [0x0000000000000000] [0x00000010] 
	float                                              KDamageImpulse;                                   		// 0x0064 (0x0004) [0x0000000000000000]              
	float                                              KDeathVel;                                        		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              KDeathUpKick;                                     		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              RadialDamageImpulse;                              		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              VehicleDamageScaling;                             		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              VehicleMomentumScaling;                           		// 0x0078 (0x0004) [0x0000000000000000]              
	class UForceFeedbackWaveform*                      DamagedFFWaveform;                                		// 0x007C (0x0008) [0x0000000000000000]              
	class UForceFeedbackWaveform*                      KilledFFWaveform;                                 		// 0x0084 (0x0008) [0x0000000000000000]              
	float                                              FracturedMeshDamage;                              		// 0x008C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DamageType" );

		return pClassPointer;
	};

	void VehicleDamageScalingFor ( );
};

UClass* UDamageType::pClassPointer = NULL;

// Class Engine.KillZDamageType
// 0x0000 (0x0090 - 0x0090)
class UKillZDamageType : public UDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.KillZDamageType" );

		return pClassPointer;
	};

};

UClass* UKillZDamageType::pClassPointer = NULL;

// Class Engine.DistributionFloatConstant
// 0x0004 (0x0080 - 0x007C)
class UDistributionFloatConstant : public UDistributionFloat
{
public:
	float                                              Constant;                                         		// 0x007C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionFloatConstant" );

		return pClassPointer;
	};

};

UClass* UDistributionFloatConstant::pClassPointer = NULL;

// Class Engine.DistributionFloatParameterBase
// 0x0019 (0x0099 - 0x0080)
class UDistributionFloatParameterBase : public UDistributionFloatConstant
{
public:
	struct FName                                       ParameterName;                                    		// 0x0080 (0x0008) [0x0000000000000000]              
	float                                              MinInput;                                         		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              MaxInput;                                         		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              MinOutput;                                        		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              MaxOutput;                                        		// 0x0094 (0x0004) [0x0000000000000000]              
	unsigned char                                      ParamMode;                                        		// 0x0098 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionFloatParameterBase" );

		return pClassPointer;
	};

};

UClass* UDistributionFloatParameterBase::pClassPointer = NULL;

// Class Engine.DistributionFloatConstantCurve
// 0x0014 (0x0090 - 0x007C)
class UDistributionFloatConstantCurve : public UDistributionFloat
{
public:
	struct FInterpCurveFloat                           ConstantCurve;                                    		// 0x007C (0x0014) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionFloatConstantCurve" );

		return pClassPointer;
	};

};

UClass* UDistributionFloatConstantCurve::pClassPointer = NULL;

// Class Engine.DistributionFloatUniform
// 0x0008 (0x0084 - 0x007C)
class UDistributionFloatUniform : public UDistributionFloat
{
public:
	float                                              Min;                                              		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              Max;                                              		// 0x0080 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionFloatUniform" );

		return pClassPointer;
	};

};

UClass* UDistributionFloatUniform::pClassPointer = NULL;

// Class Engine.DistributionFloatUniformCurve
// 0x0014 (0x0090 - 0x007C)
class UDistributionFloatUniformCurve : public UDistributionFloat
{
public:
	struct FInterpCurveVector2D                        ConstantCurve;                                    		// 0x007C (0x0014) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionFloatUniformCurve" );

		return pClassPointer;
	};

};

UClass* UDistributionFloatUniformCurve::pClassPointer = NULL;

// Class Engine.DistributionFloatUniformRange
// 0x0014 (0x0090 - 0x007C)
class UDistributionFloatUniformRange : public UDistributionFloat
{
public:
	float                                              MaxHigh;                                          		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              MaxLow;                                           		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              MinHigh;                                          		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              MinLow;                                           		// 0x0088 (0x0004) [0x0000000000000000]              
	DWORD                                              bMirrorMaxMin : 1;                                		// 0x008C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionFloatUniformRange" );

		return pClassPointer;
	};

};

UClass* UDistributionFloatUniformRange::pClassPointer = NULL;

// Class Engine.DistributionVectorConstant
// 0x0011 (0x008D - 0x007C)
class UDistributionVectorConstant : public UDistributionVector
{
public:
	struct FVector                                     Constant;                                         		// 0x007C (0x000C) [0x0000000000000000]              
	DWORD                                              bLockAxes : 1;                                    		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      LockedAxes;                                       		// 0x008C (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionVectorConstant" );

		return pClassPointer;
	};

};

UClass* UDistributionVectorConstant::pClassPointer = NULL;

// Class Engine.DistributionVectorParameterBase
// 0x003E (0x00CB - 0x008D)
class UDistributionVectorParameterBase : public UDistributionVectorConstant
{
public:
	struct FName                                       ParameterName;                                    		// 0x0090 (0x0008) [0x0000000000000000]              
	struct FVector                                     MinInput;                                         		// 0x0098 (0x000C) [0x0000000000000000]              
	struct FVector                                     MaxInput;                                         		// 0x00A4 (0x000C) [0x0000000000000000]              
	struct FVector                                     MinOutput;                                        		// 0x00B0 (0x000C) [0x0000000000000000]              
	struct FVector                                     MaxOutput;                                        		// 0x00BC (0x000C) [0x0000000000000000]              
	unsigned char                                      ParamModes[ 0x3 ];                                		// 0x00C8 (0x0003) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionVectorParameterBase" );

		return pClassPointer;
	};

};

UClass* UDistributionVectorParameterBase::pClassPointer = NULL;

// Class Engine.DistributionVectorConstantCurve
// 0x0019 (0x0095 - 0x007C)
class UDistributionVectorConstantCurve : public UDistributionVector
{
public:
	struct FInterpCurveVector                          ConstantCurve;                                    		// 0x007C (0x0014) [0x0000000000000000]              
	DWORD                                              bLockAxes : 1;                                    		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      LockedAxes;                                       		// 0x0094 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionVectorConstantCurve" );

		return pClassPointer;
	};

};

UClass* UDistributionVectorConstantCurve::pClassPointer = NULL;

// Class Engine.DistributionVectorUniform
// 0x0020 (0x009C - 0x007C)
class UDistributionVectorUniform : public UDistributionVector
{
public:
	struct FVector                                     Max;                                              		// 0x007C (0x000C) [0x0000000000000000]              
	struct FVector                                     Min;                                              		// 0x0088 (0x000C) [0x0000000000000000]              
	DWORD                                              bLockAxes : 1;                                    		// 0x0094 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseExtremes : 1;                                 		// 0x0094 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned char                                      LockedAxes;                                       		// 0x0098 (0x0001) [0x0000000000000000]              
	unsigned char                                      MirrorFlags[ 0x3 ];                               		// 0x0099 (0x0003) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionVectorUniform" );

		return pClassPointer;
	};

};

UClass* UDistributionVectorUniform::pClassPointer = NULL;

// Class Engine.DistributionVectorUniformCurve
// 0x001D (0x0099 - 0x007C)
class UDistributionVectorUniformCurve : public UDistributionVector
{
public:
	struct FInterpCurveTwoVectors                      ConstantCurve;                                    		// 0x007C (0x0014) [0x0000000000000000]              
	DWORD                                              bLockAxes1 : 1;                                   		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLockAxes2 : 1;                                   		// 0x0090 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUseExtremes : 1;                                 		// 0x0090 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned char                                      LockedAxes[ 0x2 ];                                		// 0x0094 (0x0002) [0x0000000000000000]              
	unsigned char                                      MirrorFlags[ 0x3 ];                               		// 0x0096 (0x0003) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionVectorUniformCurve" );

		return pClassPointer;
	};

};

UClass* UDistributionVectorUniformCurve::pClassPointer = NULL;

// Class Engine.DistributionVectorUniformRange
// 0x0030 (0x00AC - 0x007C)
class UDistributionVectorUniformRange : public UDistributionVector
{
public:
	struct FVector                                     MaxHigh;                                          		// 0x007C (0x000C) [0x0000000000000000]              
	struct FVector                                     MaxLow;                                           		// 0x0088 (0x000C) [0x0000000000000000]              
	struct FVector                                     MinHigh;                                          		// 0x0094 (0x000C) [0x0000000000000000]              
	struct FVector                                     MinLow;                                           		// 0x00A0 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionVectorUniformRange" );

		return pClassPointer;
	};

};

UClass* UDistributionVectorUniformRange::pClassPointer = NULL;

// Class Engine.Download
// 0x0A44 (0x0AA4 - 0x0060)
class UDownload : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0xA44 ];                           		// 0x0060 (0x0A44) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Download" );

		return pClassPointer;
	};

};

UClass* UDownload::pClassPointer = NULL;

// Class Engine.ChannelDownload
// 0x0008 (0x0AAC - 0x0AA4)
class UChannelDownload : public UDownload
{
public:
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0AA4 (0x0008) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ChannelDownload" );

		return pClassPointer;
	};

};

UClass* UChannelDownload::pClassPointer = NULL;

// Class Engine.EdCoordSystem
// 0x0050 (0x00B0 - 0x0060)
class UEdCoordSystem : public UObject
{
public:
	struct FMatrix                                     M;                                                		// 0x0060 (0x0040) [0x0000000000000000]              
	struct FString                                     Desc;                                             		// 0x00A0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.EdCoordSystem" );

		return pClassPointer;
	};

};

UClass* UEdCoordSystem::pClassPointer = NULL;

// Class Engine.EditorLinkSelectionInterface
// 0x0000 (0x0060 - 0x0060)
class UEditorLinkSelectionInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.EditorLinkSelectionInterface" );

		return pClassPointer;
	};

};

UClass* UEditorLinkSelectionInterface::pClassPointer = NULL;

// Class Engine.EngineTypes
// 0x0000 (0x0060 - 0x0060)
class UEngineTypes : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.EngineTypes" );

		return pClassPointer;
	};

};

UClass* UEngineTypes::pClassPointer = NULL;

// Class Engine.FaceFXAnimSet
// 0x0054 (0x00B4 - 0x0060)
class UFaceFXAnimSet : public UObject
{
public:
	class UFaceFXAsset*                                DefaultFaceFXAsset;                               		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FPointer                                    InternalFaceFXAnimSet;                            		// 0x0068 (0x0008) [0x0000000000000000]              
	TArray< unsigned char >                            RawFaceFXAnimSetBytes;                            		// 0x0070 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            RawFaceFXMiniSessionBytes;                        		// 0x0080 (0x0010) [0x0000000000000000]              
	TArray< class USoundCue* >                         ReferencedSoundCues;                              		// 0x0090 (0x0010) [0x0000000000000000]              
	TArray< class UAkEvent* >                          ReferencedAkEvents;                               		// 0x00A0 (0x0010) [0x0000000000000000]              
	int                                                NumLoadErrors;                                    		// 0x00B0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FaceFXAnimSet" );

		return pClassPointer;
	};

};

UClass* UFaceFXAnimSet::pClassPointer = NULL;

// Class Engine.FaceFXAsset
// 0x0074 (0x00D4 - 0x0060)
class UFaceFXAsset : public UObject
{
public:
	class USkeletalMesh*                               DefaultSkelMesh;                                  		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FPointer                                    FaceFXActor;                                      		// 0x0068 (0x0008) [0x0000000000000000]              
	TArray< unsigned char >                            RawFaceFXActorBytes;                              		// 0x0070 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            RawFaceFXSessionBytes;                            		// 0x0080 (0x0010) [0x0000000000000000]              
	TArray< class UMorphTargetSet* >                   PreviewMorphSets;                                 		// 0x0090 (0x0010) [0x0000000000000000]              
	TArray< class UFaceFXAnimSet* >                    MountedFaceFXAnimSets;                            		// 0x00A0 (0x0010) [0x0000000000000000]              
	TArray< class USoundCue* >                         ReferencedSoundCues;                              		// 0x00B0 (0x0010) [0x0000000000000000]              
	TArray< class UAkEvent* >                          ReferencedAkEvents;                               		// 0x00C0 (0x0010) [0x0000000000000000]              
	int                                                NumLoadErrors;                                    		// 0x00D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FaceFXAsset" );

		return pClassPointer;
	};

	void UnmountFaceFXAnimSet ( );
	void MountFaceFXAnimSet ( );
};

UClass* UFaceFXAsset::pClassPointer = NULL;

// Class Engine.Font
// 0x0140 (0x01A0 - 0x0060)
class UFont : public UObject
{
public:
	TArray< struct FFontCharacter >                    Characters;                                       		// 0x0060 (0x0010) [0x0000000000000000]              
	TArray< class UTexture2D* >                        Textures;                                         		// 0x0070 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x0080 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.Font.CharRemap
	int                                                IsRemapped;                                       		// 0x00C8 (0x0004) [0x0000000000000000]              
	float                                              EmScale;                                          		// 0x00CC (0x0004) [0x0000000000000000]              
	float                                              Ascent;                                           		// 0x00D0 (0x0004) [0x0000000000000000]              
	float                                              Descent;                                          		// 0x00D4 (0x0004) [0x0000000000000000]              
	float                                              Leading;                                          		// 0x00D8 (0x0004) [0x0000000000000000]              
	int                                                Kerning;                                          		// 0x00DC (0x0004) [0x0000000000000000]              
	struct FFontImportOptionsData                      ImportOptions;                                    		// 0x00E0 (0x00A8) [0x0000000000000000]              
	int                                                NumCharacters;                                    		// 0x0188 (0x0004) [0x0000000000000000]              
	TArray< int >                                      MaxCharHeight;                                    		// 0x018C (0x0010) [0x0000000000000000]              
	float                                              ScalingFactor;                                    		// 0x019C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Font" );

		return pClassPointer;
	};

	void GetStringHeightAndWidth ( );
	void GetMaxCharHeight ( );
	void GetAuthoredViewportHeight ( );
	void GetScalingFactor ( );
	void GetResolutionPageIndex ( );
};

UClass* UFont::pClassPointer = NULL;

// Class Engine.MultiFont
// 0x0010 (0x01B0 - 0x01A0)
class UMultiFont : public UFont
{
public:
	TArray< float >                                    ResolutionTestTable;                              		// 0x01A0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MultiFont" );

		return pClassPointer;
	};

	void GetResolutionTestTableIndex ( );
};

UClass* UMultiFont::pClassPointer = NULL;

// Class Engine.FontImportOptions
// 0x00A8 (0x0108 - 0x0060)
class UFontImportOptions : public UObject
{
public:
	struct FFontImportOptionsData                      Data;                                             		// 0x0060 (0x00A8) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FontImportOptions" );

		return pClassPointer;
	};

};

UClass* UFontImportOptions::pClassPointer = NULL;

// Class Engine.ForceFeedbackManager
// 0x0028 (0x0088 - 0x0060)
class UForceFeedbackManager : public UObject
{
public:
	DWORD                                              bAllowsForceFeedback : 1;                         		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIsPaused : 1;                                    		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 
	class UForceFeedbackWaveform*                      FFWaveform;                                       		// 0x0064 (0x0008) [0x0000000000000000]              
	int                                                CurrentSample;                                    		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              ElapsedTime;                                      		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                NextSample;                                       		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              NextElapsedTime;                                  		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              ScaleAllWaveformsBy;                              		// 0x007C (0x0004) [0x0000000000000000]              
	class AActor*                                      WaveformInstigator;                               		// 0x0080 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ForceFeedbackManager" );

		return pClassPointer;
	};

	void PauseWaveform ( );
	void StopForceFeedbackWaveform ( );
	void PlayForceFeedbackWaveform ( );
};

UClass* UForceFeedbackManager::pClassPointer = NULL;

// Class Engine.ForceFeedbackWaveform
// 0x001C (0x007C - 0x0060)
class UForceFeedbackWaveform : public UObject
{
public:
	DWORD                                              bIsLooping : 1;                                   		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< struct FWaveformSample >                   Samples;                                          		// 0x0064 (0x0010) [0x0000000000000000]              
	float                                              WaveformFalloffStartDistance;                     		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              MaxWaveformDistance;                              		// 0x0078 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ForceFeedbackWaveform" );

		return pClassPointer;
	};

};

UClass* UForceFeedbackWaveform::pClassPointer = NULL;

// Class Engine.GamePadLightbarSubsystem
// 0x0080 (0x00E0 - 0x0060)
class UGamePadLightbarSubsystem : public UObject
{
public:
	unsigned char                                      CurrentLightBarState;                             		// 0x0060 (0x0001) [0x0000000000000000]              
	struct FLinearColor                                CurrentColor;                                     		// 0x0064 (0x0010) [0x0000000000000000]              
	struct FLinearColor                                OriginalColor;                                    		// 0x0074 (0x0010) [0x0000000000000000]              
	struct FLinearColor                                TargetColor;                                      		// 0x0084 (0x0010) [0x0000000000000000]              
	float                                              LerpTimeRemaining;                                		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              TotalLerpTime;                                    		// 0x0098 (0x0004) [0x0000000000000000]              
	struct FColor                                      DefaultColor;                                     		// 0x009C (0x0004) [0x0000000000000000]              
	TArray< struct FColorDefinition >                  ColorDefinitions;                                 		// 0x00A0 (0x0010) [0x0000000000000000]              
	TArray< struct FLerpToInstruction >                LerpToInstructions;                               		// 0x00B0 (0x0010) [0x0000000000000000]              
	TArray< struct FSetAndLerpInstruction >            SetAndLerpInstructions;                           		// 0x00C0 (0x0010) [0x0000000000000000]              
	TArray< struct FPulseInstruction >                 PulseInstructions;                                		// 0x00D0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GamePadLightbarSubsystem" );

		return pClassPointer;
	};

	void ResetState ( );
	void SetPulsingFromDef ( );
	void SetPulsing ( );
	void SetPadColorAndLerpFromDef ( );
	void SetPadColorAndLerp ( );
	void BeginLerpFromDef ( );
	void BeginLerp ( );
	void SetPadColorFromDef ( );
	void SetPadColor ( );
};

UClass* UGamePadLightbarSubsystem::pClassPointer = NULL;

// Class Engine.GameplayEvents
// 0x0160 (0x01C0 - 0x0060)
class UGameplayEvents : public UObject
{
public:
	struct FPointer                                    Archive;                                          		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FString                                     StatsFileName;                                    		// 0x0068 (0x0010) [0x0000000000000000]              
	struct FGameplayEventsHeader                       Header;                                           		// 0x0078 (0x0030) [0x0000000000000000]              
	struct FGameSessionInformation                     CurrentSessionInfo;                               		// 0x00A8 (0x0088) [0x0000000000000000]              
	TArray< struct FPlayerInformation >                PlayerList;                                       		// 0x0130 (0x0010) [0x0000000000000000]              
	TArray< struct FTeamInformation >                  TeamList;                                         		// 0x0140 (0x0010) [0x0000000000000000]              
	TArray< struct FGameplayEventMetaData >            SupportedEvents;                                  		// 0x0150 (0x0010) [0x0000000000000000]              
	TArray< struct FWeaponClassEventData >             WeaponClassArray;                                 		// 0x0160 (0x0010) [0x0000000000000000]              
	TArray< struct FDamageClassEventData >             DamageClassArray;                                 		// 0x0170 (0x0010) [0x0000000000000000]              
	TArray< struct FProjectileClassEventData >         ProjectileClassArray;                             		// 0x0180 (0x0010) [0x0000000000000000]              
	TArray< struct FPawnClassEventData >               PawnClassArray;                                   		// 0x0190 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           ActorArray;                                       		// 0x01A0 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           SoundCueArray;                                    		// 0x01B0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GameplayEvents" );

		return pClassPointer;
	};

	void eventGetFilename ( );
	void CloseStatsFile ( );
	void OpenStatsFile ( );
};

UClass* UGameplayEvents::pClassPointer = NULL;

// Class Engine.GameplayEventsReader
// 0x0010 (0x01D0 - 0x01C0)
class UGameplayEventsReader : public UGameplayEvents
{
public:
	TArray< class UGameplayEventsHandler* >            RegisteredHandlers;                               		// 0x01C0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GameplayEventsReader" );

		return pClassPointer;
	};

	void GetSessionDuration ( );
	void GetSessionEnd ( );
	void GetSessionStart ( );
	void GetSessionTimestamp ( );
	void GetPlatform ( );
	void GetTitleID ( );
	void GetSessionID ( );
	void ProcessStreamEnd ( );
	void ProcessStream ( );
	void ProcessStreamStart ( );
	void eventUnregisterHandler ( );
	void eventRegisterHandler ( );
	void SerializeHeader ( );
	void CloseStatsFile ( );
	void OpenStatsFile ( );
};

UClass* UGameplayEventsReader::pClassPointer = NULL;

// Class Engine.GameplayEventsWriterBase
// 0x0008 (0x01C8 - 0x01C0)
class UGameplayEventsWriterBase : public UGameplayEvents
{
public:
	class AGameInfo*                                   Game;                                             		// 0x01C0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GameplayEventsWriterBase" );

		return pClassPointer;
	};

	void RecordCoverLinkFireLinks ( );
	void RecordAIPathFail ( );
	void LogSystemPollEvents ( );
	void LogProjectileIntEvent ( );
	void LogDamageEvent ( );
	void LogWeaponIntEvent ( );
	void LogPlayerPlayerEvent ( );
	void LogPlayerKillDeath ( );
	void LogAllPlayerPositionsEvent ( );
	void LogPlayerLoginChange ( );
	void LogPlayerSpawnEvent ( );
	void LogPlayerStringEvent ( );
	void LogPlayerFloatEvent ( );
	void LogPlayerIntEvent ( );
	void LogTeamStringEvent ( );
	void LogTeamFloatEvent ( );
	void LogTeamIntEvent ( );
	void LogGamePositionEvent ( );
	void LogGameFloatEvent ( );
	void LogGameStringEvent ( );
	void LogGameIntEvent ( );
	void EndLogging ( );
	void ResetLogging ( );
	void StartLogging ( );
	void eventGetPlaylistId ( );
	void eventGetGameTypeId ( );
	void Poll ( );
	void eventStopPolling ( );
	void eventStartPolling ( );
	void IsSessionInProgress ( );
};

UClass* UGameplayEventsWriterBase::pClassPointer = NULL;

// Class Engine.GameplayEventsUploadAnalytics
// 0x0000 (0x01C8 - 0x01C8)
class UGameplayEventsUploadAnalytics : public UGameplayEventsWriterBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GameplayEventsUploadAnalytics" );

		return pClassPointer;
	};

	void RecordCoverLinkFireLinks ( );
	void RecordAIPathFail ( );
	void GetGenericParamListEntry ( );
	void LogProjectileIntEvent ( );
	void LogDamageEvent ( );
	void LogWeaponIntEvent ( );
	void LogPlayerPlayerEvent ( );
	void LogPlayerKillDeath ( );
	void LogAllPlayerPositionsEvent ( );
	void LogPlayerLoginChange ( );
	void LogPlayerSpawnEvent ( );
	void LogPlayerStringEvent ( );
	void LogPlayerFloatEvent ( );
	void LogPlayerIntEvent ( );
	void LogTeamStringEvent ( );
	void LogTeamFloatEvent ( );
	void LogTeamIntEvent ( );
	void LogGamePositionEvent ( );
	void LogGameFloatEvent ( );
	void LogGameStringEvent ( );
	void LogGameIntEvent ( );
	void EndLogging ( );
	void ResetLogging ( );
	void StartLogging ( );
};

UClass* UGameplayEventsUploadAnalytics::pClassPointer = NULL;

// Class Engine.GameplayEventsWriter
// 0x0000 (0x01C8 - 0x01C8)
class UGameplayEventsWriter : public UGameplayEventsWriterBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GameplayEventsWriter" );

		return pClassPointer;
	};

	void RecordCoverLinkFireLinks ( );
	void RecordAIPathFail ( );
	void GetGenericParamListEntry ( );
	void LogSystemPollEvents ( );
	void LogProjectileIntEvent ( );
	void LogDamageEvent ( );
	void LogWeaponIntEvent ( );
	void LogPlayerPlayerEvent ( );
	void LogPlayerKillDeath ( );
	void LogAllPlayerPositionsEvent ( );
	void LogPlayerLoginChange ( );
	void LogPlayerSpawnEvent ( );
	void LogPlayerStringEvent ( );
	void LogPlayerFloatEvent ( );
	void LogPlayerIntEvent ( );
	void LogTeamStringEvent ( );
	void LogTeamFloatEvent ( );
	void LogTeamIntEvent ( );
	void LogGamePositionEvent ( );
	void LogGameFloatEvent ( );
	void LogGameStringEvent ( );
	void LogGameIntEvent ( );
	void EndLogging ( );
	void ResetLogging ( );
	void StartLogging ( );
	void SerializeFooter ( );
	void SerializeHeader ( );
	void CloseStatsFile ( );
	void OpenStatsFile ( );
	void ResolvePlayerIndex ( );
};

UClass* UGameplayEventsWriter::pClassPointer = NULL;

// Class Engine.GameplayEventsHandler
// 0x0028 (0x0088 - 0x0060)
class UGameplayEventsHandler : public UObject
{
public:
	TArray< int >                                      EventIDFilter;                                    		// 0x0060 (0x0010) [0x0000000000000000]              
	TArray< struct FGameStatGroup >                    GroupFilter;                                      		// 0x0070 (0x0010) [0x0000000000000000]              
	class UGameplayEventsReader*                       Reader;                                           		// 0x0080 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GameplayEventsHandler" );

		return pClassPointer;
	};

	void RemoveFilter ( );
	void AddFilter ( );
	void eventResolveGroupFilters ( );
	void eventPostProcessStream ( );
	void eventPreProcessStream ( );
	void SetReader ( );
};

UClass* UGameplayEventsHandler::pClassPointer = NULL;

// Class Engine.GenericParamListStatEntry
// 0x0010 (0x0070 - 0x0060)
class UGenericParamListStatEntry : public UObject
{
public:
	struct FPointer                                    StatEvent;                                        		// 0x0060 (0x0008) [0x0000000000000000]              
	class UGameplayEventsWriter*                       Writer;                                           		// 0x0068 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GenericParamListStatEntry" );

		return pClassPointer;
	};

	void CommitToDisk ( );
	void GetString ( );
	void GetVector ( );
	void GetInt ( );
	void GetFloat ( );
	void AddString ( );
	void AddVector ( );
	void AddInt ( );
	void AddFloat ( );
};

UClass* UGenericParamListStatEntry::pClassPointer = NULL;

// Class Engine.GuidCache
// 0x0058 (0x00B8 - 0x0060)
class UGuidCache : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0x58 ];                            		// 0x0060 (0x0058) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GuidCache" );

		return pClassPointer;
	};

};

UClass* UGuidCache::pClassPointer = NULL;

// Class Engine.HttpBaseInterface
// 0x0000 (0x0060 - 0x0060)
class UHttpBaseInterface : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.HttpBaseInterface" );

		return pClassPointer;
	};

	void GetContent ( );
	void GetURL ( );
	void GetContentLength ( );
	void GetContentType ( );
	void GetURLParameter ( );
	void GetHeaders ( );
	void GetHeader ( );
};

UClass* UHttpBaseInterface::pClassPointer = NULL;

// Class Engine.HttpRequestInterface
// 0x0010 (0x0070 - 0x0060)
class UHttpRequestInterface : public UHttpBaseInterface
{
public:
	struct FScriptDelegate                             __OnProcessRequestComplete__Delegate;             		// 0x0060 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0064 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.HttpRequestInterface" );

		return pClassPointer;
	};

	void SetProcessRequestCompleteDelegate ( );
	void OnProcessRequestComplete ( );
	void ProcessRequest ( );
	void SetHeader ( );
	void SetContentAsString ( );
	void SetContent ( );
	void SetURL ( );
	void SetVerb ( );
	void GetVerb ( );
};

UClass* UHttpRequestInterface::pClassPointer = NULL;

// Class Engine.HttpResponseInterface
// 0x0000 (0x0060 - 0x0060)
class UHttpResponseInterface : public UHttpBaseInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.HttpResponseInterface" );

		return pClassPointer;
	};

	void GetContentAsString ( );
	void GetResponseCode ( );
};

UClass* UHttpResponseInterface::pClassPointer = NULL;

// Class Engine.IniLocPatcher
// 0x0078 (0x00D8 - 0x0060)
class UIniLocPatcher : public UObject
{
public:
	TArray< struct FIniLocFileEntry >                  Files;                                            		// 0x0060 (0x0010) [0x0000000000000000]              
	DWORD                                              bRequestEmsFileList : 1;                          		// 0x0070 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                MaxCachedFileAge;                                 		// 0x0074 (0x0004) [0x0000000000000000]              
	class UOnlineTitleFileInterface*                   TitleFileInterface;                               		// 0x0078 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0080 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineTitleFileCacheInterface*              TitleFileCacheInterface;                          		// 0x0088 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x8 ];                             		// 0x0090 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	TArray< struct FScriptDelegate >                   ReadTitleFileCompleteDelegates;                   		// 0x0098 (0x0010) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   AllTitleFilesCompletedDelegates;                  		// 0x00A8 (0x0010) [0x0000000000000000]              
	struct FScriptDelegate                             __OnReadTitleFileComplete__Delegate;              		// 0x00B8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x4 ];                             		// 0x00BC (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnAllTitleFilesCompleted__Delegate;             		// 0x00C8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData03[ 0x4 ];                             		// 0x00CC (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.IniLocPatcher" );

		return pClassPointer;
	};

	void UpdateLocFileName ( );
	void ClearCachedFiles ( );
	void ClearAllTitleFilesCompletedDelegate ( );
	void AddAllTitleFilesCompletedDelegate ( );
	void ClearReadFileDelegate ( );
	void AddReadFileDelegate ( );
	void AddFileToDownload ( );
	void ProcessIniLocFile ( );
	void CheckForAllFilesComplete ( );
	void TriggerDownloadCompleteDelegates ( );
	void OnFileCacheSaveComplete ( );
	void OnFileCacheLoadComplete ( );
	void OnDownloadFileComplete ( );
	void StartLoadingFiles ( );
	void OnRequestTitleFileListComplete ( );
	void DownloadFiles ( );
	void Init ( );
	void OnAllTitleFilesCompleted ( );
	void OnReadTitleFileComplete ( );
};

UClass* UIniLocPatcher::pClassPointer = NULL;

// Class Engine.Interface_NavigationHandle
// 0x0000 (0x0060 - 0x0060)
class UInterface_NavigationHandle : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Interface_NavigationHandle" );

		return pClassPointer;
	};

	void eventNotifyPathChanged ( );
};

UClass* UInterface_NavigationHandle::pClassPointer = NULL;

// Class Engine.Interface_Speaker
// 0x0000 (0x0060 - 0x0060)
class UInterface_Speaker : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Interface_Speaker" );

		return pClassPointer;
	};

	void eventSpeak ( );
};

UClass* UInterface_Speaker::pClassPointer = NULL;

// Class Engine.InterpCurveEdSetup
// 0x0014 (0x0074 - 0x0060)
class UInterpCurveEdSetup : public UObject
{
public:
	TArray< struct FCurveEdTab >                       Tabs;                                             		// 0x0060 (0x0010) [0x0000000000000000]              
	int                                                ActiveTab;                                        		// 0x0070 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpCurveEdSetup" );

		return pClassPointer;
	};

};

UClass* UInterpCurveEdSetup::pClassPointer = NULL;

// Class Engine.InterpTrack
// 0x0060 (0x00C0 - 0x0060)
class UInterpTrack : public UObject
{
public:
	struct FPointer                                    VfTable_FInterpEdInputInterface;                  		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FPointer                                    CurveEdVTable;                                    		// 0x0068 (0x0008) [0x0000000000000000]              
	TArray< class UInterpTrack* >                      SubTracks;                                        		// 0x0070 (0x0010) [0x0000000000000000]              
	TArray< struct FSubTrackGroup >                    SubTrackGroups;                                   		// 0x0080 (0x0010) [0x0000000000000000]              
	TArray< struct FSupportedSubTrackInfo >            SupportedSubTracks;                               		// 0x0090 (0x0010) [0x0000000000000000]              
	class UClass*                                      TrackInstClass;                                   		// 0x00A0 (0x0008) [0x0000000000000000]              
	unsigned char                                      ActiveCondition;                                  		// 0x00A8 (0x0001) [0x0000000000000000]              
	struct FString                                     TrackTitle;                                       		// 0x00AC (0x0010) [0x0000000000000000]              
	DWORD                                              bOnePerGroup : 1;                                 		// 0x00BC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDirGroupOnly : 1;                                		// 0x00BC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDisableTrack : 1;                                		// 0x00BC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bIsAnimControlTrack : 1;                          		// 0x00BC (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bSubTrackOnly : 1;                                		// 0x00BC (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bVisible : 1;                                     		// 0x00BC (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bIsSelected : 1;                                  		// 0x00BC (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bIsRecording : 1;                                 		// 0x00BC (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bIsCollapsed : 1;                                 		// 0x00BC (0x0004) [0x0000000000000000] [0x00000100] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrack" );

		return pClassPointer;
	};

};

UClass* UInterpTrack::pClassPointer = NULL;

// Class Engine.JsonObject
// 0x00B0 (0x0110 - 0x0060)
class UJsonObject : public UObject
{
public:
	struct FMap_Mirror                                 ValueMap;                                         		// 0x0060 (0x0048) [0x0000000000000000]              
	struct FMap_Mirror                                 ObjectMap;                                        		// 0x00A8 (0x0048) [0x0000000000000000]              
	TArray< struct FString >                           ValueArray;                                       		// 0x00F0 (0x0010) [0x0000000000000000]              
	TArray< class UJsonObject* >                       ObjectArray;                                      		// 0x0100 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.JsonObject" );

		return pClassPointer;
	};

	void DecodeJson ( );
	void EncodeJson ( );
	void eventSetBoolValue ( );
	void eventSetFloatValue ( );
	void eventSetIntValue ( );
	void SetStringValue ( );
	void SetObject ( );
	void eventGetBoolValue ( );
	void eventGetFloatValue ( );
	void eventGetIntValue ( );
	void HasKey ( );
	void GetStringValue ( );
	void GetObject ( );
};

UClass* UJsonObject::pClassPointer = NULL;

// Class Engine.KMeshProps
// 0x0068 (0x00C8 - 0x0060)
class UKMeshProps : public UObject
{
public:
	struct FVector                                     COMNudge;                                         		// 0x0060 (0x000C) [0x0000000000000000]              
	struct FKAggregateGeom                             AggGeom;                                          		// 0x006C (0x005C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.KMeshProps" );

		return pClassPointer;
	};

};

UClass* UKMeshProps::pClassPointer = NULL;

// Class Engine.LevelBase
// 0x0080 (0x00E0 - 0x0060)
class ULevelBase : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0x80 ];                            		// 0x0060 (0x0080) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LevelBase" );

		return pClassPointer;
	};

};

UClass* ULevelBase::pClassPointer = NULL;

// Class Engine.Level
// 0x04E0 (0x05C0 - 0x00E0)
class ULevel : public ULevelBase
{
public:
	unsigned char                                      UnknownData00[ 0x108 ];                           		// 0x00E0 (0x0108) MISSED OFFSET
	float                                              LightmapTotalSize;                                		// 0x01E8 (0x0004) [0x0000000000000000]              
	float                                              ShadowmapTotalSize;                               		// 0x01EC (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x3D0 ];                           		// 0x01F0 (0x03D0) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Level" );

		return pClassPointer;
	};

};

UClass* ULevel::pClassPointer = NULL;

// Class Engine.PendingLevel
// 0x004C (0x012C - 0x00E0)
class UPendingLevel : public ULevelBase
{
public:
	unsigned char                                      UnknownData00[ 0x4C ];                            		// 0x00E0 (0x004C) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PendingLevel" );

		return pClassPointer;
	};

};

UClass* UPendingLevel::pClassPointer = NULL;

// Class Engine.DemoPlayPendingLevel
// 0x0000 (0x012C - 0x012C)
class UDemoPlayPendingLevel : public UPendingLevel
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DemoPlayPendingLevel" );

		return pClassPointer;
	};

};

UClass* UDemoPlayPendingLevel::pClassPointer = NULL;

// Class Engine.NetPendingLevel
// 0x0000 (0x012C - 0x012C)
class UNetPendingLevel : public UPendingLevel
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NetPendingLevel" );

		return pClassPointer;
	};

};

UClass* UNetPendingLevel::pClassPointer = NULL;

// Class Engine.LevelStreaming
// 0x00B0 (0x0110 - 0x0060)
class ULevelStreaming : public UObject
{
public:
	struct FName                                       PackageName;                                      		// 0x0060 (0x0008) [0x0000000000000000]              
	class ULevel*                                      LoadedLevel;                                      		// 0x0068 (0x0008) [0x0000000000000000]              
	struct FVector                                     Offset;                                           		// 0x0070 (0x000C) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x007C (0x0004) MISSED OFFSET
	struct FMatrix                                     LevelTransform;                                   		// 0x0080 (0x0040) [0x0000000000000000]              
	struct FVector                                     OldOffset;                                        		// 0x00C0 (0x000C) [0x0000000000000000]              
	DWORD                                              bIsVisible : 1;                                   		// 0x00CC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bHasLoadRequestPending : 1;                       		// 0x00CC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bHasUnloadRequestPending : 1;                     		// 0x00CC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bShouldBeVisibleInEditor : 1;                     		// 0x00CC (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bBoundingBoxVisible : 1;                          		// 0x00CC (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bLocked : 1;                                      		// 0x00CC (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bIsFullyStatic : 1;                               		// 0x00CC (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bShouldBeLoaded : 1;                              		// 0x00CC (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bShouldBeVisible : 1;                             		// 0x00CC (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bShouldBlockOnLoad : 1;                           		// 0x00CC (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bDrawOnLevelStatusMap : 1;                        		// 0x00CC (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bIsRequestingUnloadAndRemoval : 1;                		// 0x00CC (0x0004) [0x0000000000000000] [0x00000800] 
	struct FColor                                      DrawColor;                                        		// 0x00D0 (0x0004) [0x0000000000000000]              
	TArray< class ALevelStreamingVolume* >             EditorStreamingVolumes;                           		// 0x00D4 (0x0010) [0x0000000000000000]              
	float                                              MinTimeBetweenVolumeUnloadRequests;               		// 0x00E4 (0x0004) [0x0000000000000000]              
	float                                              LastVolumeUnloadRequestTime;                      		// 0x00E8 (0x0004) [0x0000000000000000]              
	TArray< struct FString >                           Keywords;                                         		// 0x00EC (0x0010) [0x0000000000000000]              
	class ALevelGridVolume*                            EditorGridVolume;                                 		// 0x00FC (0x0008) [0x0000000000000000]              
	int                                                GridPosition[ 0x3 ];                              		// 0x0104 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LevelStreaming" );

		return pClassPointer;
	};

};

UClass* ULevelStreaming::pClassPointer = NULL;

// Class Engine.LevelStreamingAlwaysLoaded
// 0x0004 (0x0114 - 0x0110)
class ULevelStreamingAlwaysLoaded : public ULevelStreaming
{
public:
	DWORD                                              bIsProceduralBuildingLODLevel : 1;                		// 0x0110 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LevelStreamingAlwaysLoaded" );

		return pClassPointer;
	};

};

UClass* ULevelStreamingAlwaysLoaded::pClassPointer = NULL;

// Class Engine.LevelStreamingDistance
// 0x0010 (0x0120 - 0x0110)
class ULevelStreamingDistance : public ULevelStreaming
{
public:
	struct FVector                                     Origin;                                           		// 0x0110 (0x000C) [0x0000000000000000]              
	float                                              MaxDistance;                                      		// 0x011C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LevelStreamingDistance" );

		return pClassPointer;
	};

};

UClass* ULevelStreamingDistance::pClassPointer = NULL;

// Class Engine.LevelStreamingKismet
// 0x0000 (0x0110 - 0x0110)
class ULevelStreamingKismet : public ULevelStreaming
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LevelStreamingKismet" );

		return pClassPointer;
	};

};

UClass* ULevelStreamingKismet::pClassPointer = NULL;

// Class Engine.LevelStreamingPersistent
// 0x0000 (0x0110 - 0x0110)
class ULevelStreamingPersistent : public ULevelStreaming
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LevelStreamingPersistent" );

		return pClassPointer;
	};

};

UClass* ULevelStreamingPersistent::pClassPointer = NULL;

// Class Engine.LightmappedSurfaceCollection
// 0x0018 (0x0078 - 0x0060)
class ULightmappedSurfaceCollection : public UObject
{
public:
	class UModel*                                      SourceModel;                                      		// 0x0060 (0x0008) [0x0000000000000000]              
	TArray< int >                                      Surfaces;                                         		// 0x0068 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LightmappedSurfaceCollection" );

		return pClassPointer;
	};

};

UClass* ULightmappedSurfaceCollection::pClassPointer = NULL;

// Class Engine.LightmassLevelSettings
// 0x0030 (0x0090 - 0x0060)
class ULightmassLevelSettings : public UObject
{
public:
	int                                                NumIndirectLightingBounces;                       		// 0x0060 (0x0004) [0x0000000000000000]              
	struct FColor                                      EnvironmentColor;                                 		// 0x0064 (0x0004) [0x0000000000000000]              
	float                                              EnvironmentIntensity;                             		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              EmissiveBoost;                                    		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              DiffuseBoost;                                     		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              SpecularBoost;                                    		// 0x0074 (0x0004) [0x0000000000000000]              
	DWORD                                              bUseAmbientOcclusion : 1;                         		// 0x0078 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bVisualizeAmbientOcclusion : 1;                   		// 0x0078 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              DirectIlluminationOcclusionFraction;              		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              IndirectIlluminationOcclusionFraction;            		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              OcclusionExponent;                                		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              FullyOccludedSamplesFraction;                     		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              MaxOcclusionDistance;                             		// 0x008C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LightmassLevelSettings" );

		return pClassPointer;
	};

};

UClass* ULightmassLevelSettings::pClassPointer = NULL;

// Class Engine.LightmassPrimitiveSettingsObject
// 0x001C (0x007C - 0x0060)
class ULightmassPrimitiveSettingsObject : public UObject
{
public:
	struct FLightmassPrimitiveSettings                 LightmassSettings;                                		// 0x0060 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LightmassPrimitiveSettingsObject" );

		return pClassPointer;
	};

};

UClass* ULightmassPrimitiveSettingsObject::pClassPointer = NULL;

// Class Engine.MapInfo
// 0x0004 (0x0064 - 0x0060)
class UMapInfo : public UObject
{
public:
	DWORD                                              bDefaultPawnsToOutdoor : 1;                       		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseFlexTriangleCollision : 1;                    		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MapInfo" );

		return pClassPointer;
	};

};

UClass* UMapInfo::pClassPointer = NULL;

// Class Engine.Model
// 0x0C28 (0x0C88 - 0x0060)
class UModel : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0xC28 ];                           		// 0x0060 (0x0C28) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Model" );

		return pClassPointer;
	};

};

UClass* UModel::pClassPointer = NULL;

// Class Engine.MusicTrackDataStructures
// 0x0000 (0x0060 - 0x0060)
class UMusicTrackDataStructures : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MusicTrackDataStructures" );

		return pClassPointer;
	};

};

UClass* UMusicTrackDataStructures::pClassPointer = NULL;

// Class Engine.NavigationMeshBase
// 0x0310 (0x0370 - 0x0060)
class UNavigationMeshBase : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0x310 ];                           		// 0x0060 (0x0310) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavigationMeshBase" );

		return pClassPointer;
	};

};

UClass* UNavigationMeshBase::pClassPointer = NULL;

// Class Engine.NetDriver
// 0x0190 (0x01F8 - 0x0068)
class UNetDriver : public USubsystem
{
public:
	unsigned char                                      UnknownData00[ 0x34 ];                            		// 0x0068 (0x0034) MISSED OFFSET
	float                                              ConnectionTimeout;                                		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              InitialConnectTimeout;                            		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              KeepAliveTime;                                    		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              RelevantTimeout;                                  		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              SpawnPrioritySeconds;                             		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              ServerTravelPause;                                		// 0x00B0 (0x0004) [0x0000000000000000]              
	int                                                MaxClientRate;                                    		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                MaxInternetClientRate;                            		// 0x00B8 (0x0004) [0x0000000000000000]              
	int                                                NetServerMaxTickRate;                             		// 0x00BC (0x0004) [0x0000000000000000]              
	int                                                NetServerLobbyTickRate;                           		// 0x00C0 (0x0004) [0x0000000000000000]              
	DWORD                                              bClampListenServerTickRate : 1;                   		// 0x00C4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              AllowDownloads : 1;                               		// 0x00C8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              AllowPeerConnections : 1;                         		// 0x00CC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              AllowPeerVoice : 1;                               		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      UnknownData01[ 0x20 ];                            		// 0x00D4 (0x0020) MISSED OFFSET
	int                                                MaxDownloadSize;                                  		// 0x00F4 (0x0004) [0x0000000000000000]              
	TArray< struct FString >                           DownloadManagers;                                 		// 0x00F8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x9C ];                            		// 0x0108 (0x009C) MISSED OFFSET
	struct FString                                     NetConnectionClassName;                           		// 0x01A4 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData03[ 0x44 ];                            		// 0x01B4 (0x0044) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NetDriver" );

		return pClassPointer;
	};

};

UClass* UNetDriver::pClassPointer = NULL;

// Class Engine.DemoRecDriver
// 0x00F8 (0x02F0 - 0x01F8)
class UDemoRecDriver : public UNetDriver
{
public:
	unsigned char                                      UnknownData00[ 0x2C ];                            		// 0x01F8 (0x002C) MISSED OFFSET
	struct FString                                     DemoSpectatorClass;                               		// 0x0224 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0xA8 ];                            		// 0x0234 (0x00A8) MISSED OFFSET
	int                                                MaxRewindPoints;                                  		// 0x02DC (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x4 ];                             		// 0x02E0 (0x0004) MISSED OFFSET
	float                                              RewindPointInterval;                              		// 0x02E4 (0x0004) [0x0000000000000000]              
	int                                                NumRecentRewindPoints;                            		// 0x02E8 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData03[ 0x4 ];                             		// 0x02EC (0x0004) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DemoRecDriver" );

		return pClassPointer;
	};

};

UClass* UDemoRecDriver::pClassPointer = NULL;

// Class Engine.ObjectReferencer
// 0x0010 (0x0070 - 0x0060)
class UObjectReferencer : public UObject
{
public:
	TArray< class UObject* >                           ReferencedObjects;                                		// 0x0060 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ObjectReferencer" );

		return pClassPointer;
	};

};

UClass* UObjectReferencer::pClassPointer = NULL;

// Class Engine.OnlineAuthInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineAuthInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineAuthInterface" );

		return pClassPointer;
	};

	void GetServerAddr ( );
	void GetServerUniqueId ( );
	void FindLocalServerAuthSession ( );
	void FindServerAuthSession ( );
	void FindLocalClientAuthSession ( );
	void FindClientAuthSession ( );
	void AllLocalServerAuthSessions ( );
	void AllServerAuthSessions ( );
	void AllLocalClientAuthSessions ( );
	void AllClientAuthSessions ( );
	void EndAllRemoteServerAuthSessions ( );
	void EndAllLocalServerAuthSessions ( );
	void EndRemoteServerAuthSession ( );
	void EndLocalServerAuthSession ( );
	void VerifyServerAuthSession ( );
	void CreateServerAuthSession ( );
	void EndAllRemoteClientAuthSessions ( );
	void EndAllLocalClientAuthSessions ( );
	void EndRemoteClientAuthSession ( );
	void EndLocalClientAuthSession ( );
	void VerifyClientAuthSession ( );
	void CreateClientAuthSession ( );
	void SendServerAuthRetryRequest ( );
	void SendClientAuthEndSessionRequest ( );
	void SendServerAuthResponse ( );
	void SendClientAuthResponse ( );
	void SendServerAuthRequest ( );
	void SendClientAuthRequest ( );
	void ClearServerConnectionCloseDelegate ( );
	void AddServerConnectionCloseDelegate ( );
	void OnServerConnectionClose ( );
	void ClearClientConnectionCloseDelegate ( );
	void AddClientConnectionCloseDelegate ( );
	void OnClientConnectionClose ( );
	void ClearServerAuthRetryRequestDelegate ( );
	void AddServerAuthRetryRequestDelegate ( );
	void OnServerAuthRetryRequest ( );
	void ClearClientAuthEndSessionRequestDelegate ( );
	void AddClientAuthEndSessionRequestDelegate ( );
	void OnClientAuthEndSessionRequest ( );
	void ClearServerAuthCompleteDelegate ( );
	void AddServerAuthCompleteDelegate ( );
	void OnServerAuthComplete ( );
	void ClearClientAuthCompleteDelegate ( );
	void AddClientAuthCompleteDelegate ( );
	void OnClientAuthComplete ( );
	void ClearServerAuthResponseDelegate ( );
	void AddServerAuthResponseDelegate ( );
	void OnServerAuthResponse ( );
	void ClearClientAuthResponseDelegate ( );
	void AddClientAuthResponseDelegate ( );
	void OnClientAuthResponse ( );
	void ClearServerAuthRequestDelegate ( );
	void AddServerAuthRequestDelegate ( );
	void OnServerAuthRequest ( );
	void ClearClientAuthRequestDelegate ( );
	void AddClientAuthRequestDelegate ( );
	void OnClientAuthRequest ( );
	void ClearAuthReadyDelegate ( );
	void AddAuthReadyDelegate ( );
	void OnAuthReady ( );
	void IsReady ( );
};

UClass* UOnlineAuthInterface::pClassPointer = NULL;

// Class Engine.OnlineGameInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineGameInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineGameInterface" );

		return pClassPointer;
	};

	void RunBandwidthTest ( );
	void IsAllowedToNetworkHost ( );
	void ClearGetRoomIdFromTitleServiceDelegate ( );
	void AddGetRoomIdFromTitleServiceDelegate ( );
	void GetRoomIdFromSessionId ( );
	void GetRoomIdFromTitleService ( );
	void OnGetRoomIdFromTitleService ( );
	void GetRoomId ( );
	void ClearGetNumberOfCurrentPlayersCompleteDelegate ( );
	void AddGetNumberOfCurrentPlayersCompleteDelegate ( );
	void OnGetNumberOfCurrentPlayersComplete ( );
	void GetNumberOfCurrentPlayersCached ( );
	void SendPlayerList ( );
	void RetrieveGameSettingsForIP ( );
	void ClearOnRetrieveGameSettingsForIPDelegate ( );
	void AddOnRetrieveGameSettingsForIPDelegate ( );
	void OnRetrievedGameSettingsForIP ( );
	void GetNumberOfCurrentPlayers ( );
	void ClearJoinMigratedOnlineGameCompleteDelegate ( );
	void AddJoinMigratedOnlineGameCompleteDelegate ( );
	void OnJoinMigratedOnlineGameComplete ( );
	void JoinMigratedOnlineGame ( );
	void ClearMigrateOnlineGameCompleteDelegate ( );
	void AddMigrateOnlineGameCompleteDelegate ( );
	void OnMigrateOnlineGameComplete ( );
	void MigrateOnlineGame ( );
	void ClearRecalculateSkillRatingCompleteDelegate ( );
	void AddRecalculateSkillRatingCompleteDelegate ( );
	void OnRecalculateSkillRatingComplete ( );
	void RecalculateSkillRating ( );
	void SetPendingMembersToInvite ( );
	void ResetPendingMembersToInvite ( );
	void GetPendingMembersToInvite ( );
	void ClearPlayTogetherStartedDelegate ( );
	void AddPlayTogetherStartedDelegate ( );
	void OnPlayTogetherStarted ( );
	void AcceptGameInvite ( );
	void ClearGameInviteAcceptedDelegate ( );
	void AddGameInviteAcceptedDelegate ( );
	void OnGameInviteAccepted ( );
	void GetArbitratedPlayers ( );
	void ClearArbitrationRegistrationCompleteDelegate ( );
	void AddArbitrationRegistrationCompleteDelegate ( );
	void OnArbitrationRegistrationComplete ( );
	void RegisterForArbitration ( );
	void ClearEndOnlineGameCompleteDelegate ( );
	void AddEndOnlineGameCompleteDelegate ( );
	void OnEndOnlineGameComplete ( );
	void EndOnlineGame ( );
	void ClearStartOnlineGameCompleteDelegate ( );
	void AddStartOnlineGameCompleteDelegate ( );
	void OnStartOnlineGameComplete ( );
	void StartOnlineGame ( );
	void ClearUnregisterPlayerCompleteDelegate ( );
	void AddUnregisterPlayerCompleteDelegate ( );
	void OnUnregisterPlayerComplete ( );
	void UnregisterPlayers ( );
	void UnregisterPlayer ( );
	void ClearRegisterPlayerCompleteDelegate ( );
	void AddRegisterPlayerCompleteDelegate ( );
	void OnRegisterPlayerComplete ( );
	void RegisterPlayers ( );
	void RegisterPlayer ( );
	void GetResolvedConnectString ( );
	void ClearQuerySessionsForUserCompleteDelegate ( );
	void AddQuerySessionsForUserCompleteDelegate ( );
	void OnQuerySessionsForUserComplete ( );
	void QuerySessionsByKeyword ( );
	void QuerySessionsForUser ( );
	void LeaveAllOnlineSessions ( );
	void LeaveOnlineSession ( );
	void ClearMatchStatusChangedDelegate ( );
	void AddMatchStatusChangedDelegate ( );
	void OnMatchStatusChanged ( );
	void ClearGamePlayersChangedDelegate ( );
	void AddGamePlayersChangedDelegate ( );
	void OnGamePlayersChanged ( );
	void ClearUpdateSessionPropertiesCompleteDelegate ( );
	void AddUpdateSessionPropertiesCompleteDelegate ( );
	void OnUpdateSessionPropertiesComplete ( );
	void UpdateSessionProperties ( );
	void DeleteCustomMemberProperty ( );
	void SetCustomMemberProperty ( );
	void DeleteCustomSessionProperty ( );
	void SetCustomSessionProperty ( );
	void ClearDeleteMatchTicketCompleteDelegate ( );
	void AddDeleteMatchTicketCompleteDelegate ( );
	void OnDeleteMatchTicketComplete ( );
	void DeleteMatchTicketWithHopper ( );
	void DeleteMatchTicket ( );
	void ClearQueryMatchmakingForSessionCompleteDelegate ( );
	void AddQueryMatchmakingForSessionCompleteDelegate ( );
	void OnQueryMatchmakingForSessionComplete ( );
	void QueryMatchmakingForSessionWithHopper ( );
	void QueryMatchmakingForSession ( );
	void ClearMultiplayerSessionChangeDelegate ( );
	void AddMultiplayerSessionChangeDelegate ( );
	void OnMultiplayerSessionChange ( );
	void ClearJoinOnlineGameCompleteDelegate ( );
	void AddJoinOnlineGameCompleteDelegate ( );
	void OnJoinOnlineGameComplete ( );
	void IsCurrentRoomOwner ( );
	void SetRankedReadyStatus ( );
	void IsJoinOperationInProgress ( );
	void JoinOnlineGameByMatchingParams ( );
	void JoinOnlineGameBySessionHandle ( );
	void JoinOnlineGame ( );
	void QueryNonAdvertisedData ( );
	void FreeSearchResults ( );
	void GetGameSearch ( );
	void BindSessionGuidToSearch ( );
	void BindPlatformSpecificSessionToSearch ( );
	void ReadSessionGuidBySessionName ( );
	void ReadPlatformSpecificSessionInfoBySessionName ( );
	void ReadPlatformSpecificSessionInfo ( );
	void ClearQosStatusChangedDelegate ( );
	void AddQosStatusChangedDelegate ( );
	void OnQosStatusChanged ( );
	void ClearCancelFindOnlineGamesCompleteDelegate ( );
	void AddCancelFindOnlineGamesCompleteDelegate ( );
	void OnCancelFindOnlineGamesComplete ( );
	void CancelFindOnlineGames ( );
	void ClearFindOnlineGamesCompleteDelegate ( );
	void AddFindOnlineGamesCompleteDelegate ( );
	void OnFindOnlineGamesComplete ( );
	void FindOnlineGames ( );
	void ClearDestroyOnlineGameCompleteDelegate ( );
	void AddDestroyOnlineGameCompleteDelegate ( );
	void OnDestroyOnlineGameComplete ( );
	void DestroyOnlineGame ( );
	void GetGameSettings ( );
	void ClearUpdateOnlineGameCompleteDelegate ( );
	void AddUpdateOnlineGameCompleteDelegate ( );
	void OnUpdateOnlineGameComplete ( );
	void UpdateOnlineGame ( );
	void ClearCreateOnlineGameCompleteDelegate ( );
	void AddCreateOnlineGameCompleteDelegate ( );
	void OnCreateOnlineGameComplete ( );
	void CreateOnlineGame ( );
	void GetGameServerRemoteAddress ( );
	void ClearOnlineDelegates ( );
	void RemoveSearchResultFromFavorites ( );
	void ClearGetPlayerListCompleteDelegate ( );
	void AddGetPlayerListCompleteDelegate ( );
	void OnGetPlayerListComplete ( );
	void IsSearchResultInFavoritesList ( );
	void AddSearchResultToFavorites ( );
	void SetMatchmakingTypeMode ( );
};

UClass* UOnlineGameInterface::pClassPointer = NULL;

// Class Engine.OnlineMatchmakingStats
// 0x0000 (0x0060 - 0x0060)
class UOnlineMatchmakingStats : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineMatchmakingStats" );

		return pClassPointer;
	};

	void StopTimer ( );
	void StartTimer ( );
};

UClass* UOnlineMatchmakingStats::pClassPointer = NULL;

// Class Engine.OnlinePlayerStorage
// 0x0034 (0x0094 - 0x0060)
class UOnlinePlayerStorage : public UObject
{
public:
	int                                                VersionNumber;                                    		// 0x0060 (0x0004) [0x0000000000000000]              
	int                                                VersionSettingsId;                                		// 0x0064 (0x0004) [0x0000000000000000]              
	int                                                SaveCountSettingId;                               		// 0x0068 (0x0004) [0x0000000000000000]              
	TArray< struct FOnlineProfileSetting >             ProfileSettings;                                  		// 0x006C (0x0010) [0x0000000000000000]              
	TArray< struct FSettingsPropertyPropertyMetaData > ProfileMappings;                                  		// 0x007C (0x0010) [0x0000000000000000]              
	unsigned char                                      AsyncState;                                       		// 0x008C (0x0001) [0x0000000000000000]              
	int                                                DeviceID;                                         		// 0x0090 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlinePlayerStorage" );

		return pClassPointer;
	};

	void SetDefaultVersionNumber ( );
	void GetVersionNumber ( );
	void AppendVersionToSettings ( );
	void eventSetToDefaults ( );
	void AddSettingFloat ( );
	void AddSettingInt ( );
	void GetRangedProfileSettingValue ( );
	void SetRangedProfileSettingValue ( );
	void GetProfileSettingRange ( );
	void GetProfileSettingMappingIds ( );
	void GetProfileSettingMappingType ( );
	void SetProfileSettingValueFloat ( );
	void SetProfileSettingValueInt ( );
	void SetProfileSettingValueId ( );
	void GetProfileSettingValueFloat ( );
	void GetProfileSettingValueInt ( );
	void GetProfileSettingValueFromListIndex ( );
	void GetProfileSettingValueId ( );
	void SetProfileSettingValue ( );
	void SetProfileSettingValueByName ( );
	void GetProfileSettingValueByName ( );
	void GetProfileSettingValues ( );
	void GetProfileSettingValueName ( );
	void GetProfileSettingValue ( );
	void IsProfileSettingIdMapped ( );
	void FindDefaultProfileMappingIndexByName ( );
	void FindProfileMappingIndexByName ( );
	void FindProfileMappingIndex ( );
	void FindProfileSettingIndex ( );
	void GetProfileSettingColumnHeader ( );
	void GetProfileSettingName ( );
	void GetProfileSettingId ( );
};

UClass* UOnlinePlayerStorage::pClassPointer = NULL;

// Class Engine.OnlineProfileSettings
// 0x0030 (0x00C4 - 0x0094)
class UOnlineProfileSettings : public UOnlinePlayerStorage
{
public:
	TArray< int >                                      ProfileSettingIds;                                		// 0x0094 (0x0010) [0x0000000000000000]              
	TArray< struct FOnlineProfileSetting >             DefaultSettings;                                  		// 0x00A4 (0x0010) [0x0000000000000000]              
	TArray< struct FIdToStringMapping >                OwnerMappings;                                    		// 0x00B4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineProfileSettings" );

		return pClassPointer;
	};

	void ExpandExtraFromProfileSettings ( );
	void FlattenExtraToProfileSettings ( );
	void eventModifyAvailableProfileSettings ( );
	void AppendVersionToReadIds ( );
	void eventSetToDefaults ( );
	void GetProfileSettingDefaultFloat ( );
	void GetProfileSettingDefaultInt ( );
	void GetProfileSettingDefaultId ( );
};

UClass* UOnlineProfileSettings::pClassPointer = NULL;

// Class Engine.OnlineStats
// 0x0010 (0x0070 - 0x0060)
class UOnlineStats : public UObject
{
public:
	TArray< struct FStringIdToStringMapping >          ViewIdMappings;                                   		// 0x0060 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineStats" );

		return pClassPointer;
	};

	void GetViewName ( );
	void GetViewId ( );
};

UClass* UOnlineStats::pClassPointer = NULL;

// Class Engine.OnlineStatsRead
// 0x0050 (0x00C0 - 0x0070)
class UOnlineStatsRead : public UOnlineStats
{
public:
	int                                                ViewId;                                           		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                SortColumnId;                                     		// 0x0074 (0x0004) [0x0000000000000000]              
	TArray< int >                                      ColumnIds;                                        		// 0x0078 (0x0010) [0x0000000000000000]              
	int                                                TotalRowsInView;                                  		// 0x0088 (0x0004) [0x0000000000000000]              
	TArray< struct FOnlineStatsRow >                   Rows;                                             		// 0x008C (0x0010) [0x0000000000000000]              
	TArray< struct FColumnMetaData >                   ColumnMappings;                                   		// 0x009C (0x0010) [0x0000000000000000]              
	struct FString                                     ViewName;                                         		// 0x00AC (0x0010) [0x0000000000000000]              
	int                                                TitleId;                                          		// 0x00BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineStatsRead" );

		return pClassPointer;
	};

	void GetRankForPlayer ( );
	void AddPlayer ( );
	void IsStatZero ( );
	void GetStatValueForPlayerAsString ( );
	void SetFloatStatValueForPlayer ( );
	void GetFloatStatValueForPlayer ( );
	void SetIntStatValueForPlayer ( );
	void GetIntStatValueForPlayer ( );
	void eventOnReadComplete ( );
};

UClass* UOnlineStatsRead::pClassPointer = NULL;

// Class Engine.OnlineStatsWrite
// 0x0054 (0x00C4 - 0x0070)
class UOnlineStatsWrite : public UOnlineStats
{
public:
	TArray< struct FStringIdToStringMapping >          StatMappings;                                     		// 0x0070 (0x0010) [0x0000000000000000]              
	TArray< struct FSettingsProperty >                 Properties;                                       		// 0x0080 (0x0010) [0x0000000000000000]              
	TArray< int >                                      ViewIds;                                          		// 0x0090 (0x0010) [0x0000000000000000]              
	TArray< int >                                      ArbitratedViewIds;                                		// 0x00A0 (0x0010) [0x0000000000000000]              
	int                                                RatingId;                                         		// 0x00B0 (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __OnStatsWriteComplete__Delegate;                 		// 0x00B4 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x00B8 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineStatsWrite" );

		return pClassPointer;
	};

	void DecrementIntStat ( );
	void DecrementFloatStat ( );
	void IncrementIntStat ( );
	void IncrementFloatStat ( );
	void SetIntStat ( );
	void SetFloatStat ( );
	void GetStatName ( );
	void GetStatId ( );
	void OnStatsWriteComplete ( );
};

UClass* UOnlineStatsWrite::pClassPointer = NULL;

// Class Engine.OnlineSubsystem
// 0x0284 (0x02E4 - 0x0060)
class UOnlineSubsystem : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                          		// 0x0060 (0x0008) [0x0000000000000000]              
	class UOnlineAccountInterface*                     AccountInterface;                                 		// 0x0068 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0070 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlinePlayerInterface*                      PlayerInterface;                                  		// 0x0078 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x8 ];                             		// 0x0080 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlinePlayerInterfaceEx*                    PlayerInterfaceEx;                                		// 0x0088 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x8 ];                             		// 0x0090 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineMarketplaceInterface*                 MarketplaceInterface;                             		// 0x0098 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData03[ 0x8 ];                             		// 0x00A0 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineSystemInterface*                      SystemInterface;                                  		// 0x00A8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData04[ 0x8 ];                             		// 0x00B0 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineGameInterface*                        GameInterface;                                    		// 0x00B8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData05[ 0x8 ];                             		// 0x00C0 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineContentInterface*                     ContentInterface;                                 		// 0x00C8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData06[ 0x8 ];                             		// 0x00D0 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineVoiceInterface*                       VoiceInterface;                                   		// 0x00D8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData07[ 0x8 ];                             		// 0x00E0 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineStatsInterface*                       StatsInterface;                                   		// 0x00E8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData08[ 0x8 ];                             		// 0x00F0 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineNewsInterface*                        NewsInterface;                                    		// 0x00F8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData09[ 0x8 ];                             		// 0x0100 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlinePartyChatInterface*                   PartyChatInterface;                               		// 0x0108 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData10[ 0x8 ];                             		// 0x0110 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlinePartyInterface*                       PartyInterface;                                   		// 0x0118 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData11[ 0x8 ];                             		// 0x0120 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineTitleFileInterface*                   TitleFileInterface;                               		// 0x0128 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData12[ 0x8 ];                             		// 0x0130 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineTitleFileCacheInterface*              TitleFileCacheInterface;                          		// 0x0138 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData13[ 0x8 ];                             		// 0x0140 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UUserCloudFileInterface*                     UserCloudInterface;                               		// 0x0148 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData14[ 0x8 ];                             		// 0x0150 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class USharedCloudFileInterface*                   SharedCloudInterface;                             		// 0x0158 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData15[ 0x8 ];                             		// 0x0160 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineSocialInterface*                      SocialInterface;                                  		// 0x0168 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData16[ 0x8 ];                             		// 0x0170 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineAuthInterface*                        AuthInterface;                                    		// 0x0178 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData17[ 0x8 ];                             		// 0x0180 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	TArray< struct FScriptDelegate >                   ReadInventoryCompleteDelegates;                   		// 0x0188 (0x0010) [0x0000000000000000]              
	DWORD                                              bInventoryReady : 1;                              		// 0x0198 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseBuildIdOverride : 1;                          		// 0x0198 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< struct FScriptDelegate >                   PingRegionsCompleteDelegates;                     		// 0x019C (0x0010) [0x0000000000000000]              
	class UOnlineGameDVRInterface*                     GameDVRInterface;                                 		// 0x01AC (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData18[ 0x8 ];                             		// 0x01B4 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlineCommunityContentInterface*            CommunityContentInterface;                        		// 0x01BC (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData19[ 0x8 ];                             		// 0x01C4 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FUniqueNetId                                LoggedInPlayerNetId;                              		// 0x01CC (0x0008) [0x0000000000000000]              
	TArray< struct FNamedInterface >                   NamedInterfaces;                                  		// 0x01D4 (0x0010) [0x0000000000000000]              
	TArray< struct FNamedInterfaceDef >                NamedInterfaceDefs;                               		// 0x01E4 (0x0010) [0x0000000000000000]              
	TArray< struct FNamedSession >                     Sessions;                                         		// 0x01F4 (0x0010) [0x0000000000000000]              
	TArray< struct FSessionMemberInfo >                PartyMemberList;                                  		// 0x0204 (0x0010) [0x0000000000000000]              
	TArray< struct FSessionMemberInfo >                GameMemberList;                                   		// 0x0214 (0x0010) [0x0000000000000000]              
	int                                                BuildIdOverride;                                  		// 0x0224 (0x0004) [0x0000000000000000]              
	struct FString                                     IniLocPatcherClassName;                           		// 0x0228 (0x0010) [0x0000000000000000]              
	class UIniLocPatcher*                              Patcher;                                          		// 0x0238 (0x0008) [0x0000000000000000]              
	float                                              AsyncMinCompletionTime;                           		// 0x0240 (0x0004) [0x0000000000000000]              
	struct FString                                     DefaultSessionTemplateName;                       		// 0x0244 (0x0010) [0x0000000000000000]              
	struct FString                                     PartySessionTemplateName;                         		// 0x0254 (0x0010) [0x0000000000000000]              
	TArray< struct FCurrentInventoryEntry >            CurrentInventory;                                 		// 0x0264 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           OwnedEntitlementIds;                              		// 0x0274 (0x0010) [0x0000000000000000]              
	TArray< struct FItemProperties >                   ItemPropertiesList;                               		// 0x0284 (0x0010) [0x0000000000000000]              
	TArray< struct FExchangeRuleSets >                 ExchangeRuleSetList;                              		// 0x0294 (0x0010) [0x0000000000000000]              
	struct FScriptDelegate                             __OnInventoryReadComplete__Delegate;              		// 0x02A4 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData20[ 0x4 ];                             		// 0x02A8 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnPingRegionsComplete__Delegate;                		// 0x02B4 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData21[ 0x4 ];                             		// 0x02B8 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnReadOnlineAvatarComplete__Delegate;           		// 0x02C4 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData22[ 0x4 ];                             		// 0x02C8 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnReadOnlineAvatarByNameComplete__Delegate;     		// 0x02D4 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData23[ 0x4 ];                             		// 0x02D8 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineSubsystem" );

		return pClassPointer;
	};

	void SetCachedProfile ( );
	void ActivateGamepad ( );
	void ManuallyActivateUser ( );
	void HasChatRestriction ( );
	void CancelRegionPing ( );
	void StartRegionPingAndSelectDefaultRegion ( );
	void SetSharedPassword ( );
	void CheckPlayerGroup ( );
	void GetPlayerGroups ( );
	void GetUGCInterface ( );
	void GetNATType ( );
	void GetLoginStatus ( );
	void UniqueNetIdToPlayerName ( );
	void UniqueNetIdToInt64 ( );
	void Int64ToUniqueNetId ( );
	void GetUniquePlayerId ( );
	void ShowVoIPConfigUI ( );
	void RemoveFriend ( );
	void AddFriend ( );
	void IsFriend ( );
	void ResetStats ( );
	void ReadOnlineAvatarByName ( );
	void ReadOnlineAvatar ( );
	void OnReadOnlineAvatarByNameComplete ( );
	void OnReadOnlineAvatarComplete ( );
	void RegisterLocalTalker ( );
	void GetLobbyInterface ( );
	void SetDebugSpewLevel ( );
	void DumpVoiceRegistration ( );
	void DumpNetIds ( );
	void DumpSessionState ( );
	void DumpGameSettings ( );
	void IsInSession ( );
	void GetNumSupportedLogins ( );
	void GetBuildUniqueId ( );
	void eventGetPlayerUniqueNetIdFromIndex ( );
	void StringToUniqueNetIdDec ( );
	void StringToUniqueNetId ( );
	void UniqueNetIdToString ( );
	void eventRaiseEvent ( );
	void eventGetNamedInterface ( );
	void eventSetNamedInterface ( );
	void eventSetCommunityContentInterface ( );
	void eventSetGameDVRInterface ( );
	void eventSetSharedCloudInterface ( );
	void eventSetUserCloudInterface ( );
	void eventSetAuthInterface ( );
	void eventSetSocialInterface ( );
	void eventSetTitleFileCacheInterface ( );
	void eventSetTitleFileInterface ( );
	void eventSetPartyInterface ( );
	void eventSetPartyChatInterface ( );
	void eventSetNewsInterface ( );
	void eventSetStatsInterface ( );
	void eventSetVoiceInterface ( );
	void eventSetContentInterface ( );
	void eventSetGameInterface ( );
	void eventSetSystemInterface ( );
	void eventSetMarketplaceInterface ( );
	void eventSetPlayerInterfaceEx ( );
	void eventSetPlayerInterface ( );
	void eventSetAccountInterface ( );
	void eventExit ( );
	void eventPostInit ( );
	void eventInit ( );
	void ClearAllInventoryReadCompleteDelegates ( );
	void ClearOnInventoryReadCompleteDelegate ( );
	void AddOnInventoryReadCompleteDelegate ( );
	void OnPingRegionsComplete ( );
	void OnInventoryReadComplete ( );
	void ExchangeDuplicates ( );
	void Exchange ( );
	void HasKeyForItem ( );
	void ExchangeReady ( );
	void ClearInFlight ( );
	void ClearNewlyAdded ( );
	void IsExchangeable ( );
	void CanCheckFreeTrialState ( );
	void IsFreeTrialPeriodActive ( );
	void IsGameOwned ( );
	void OpenGameStorePage ( );
	void OpenURL ( );
	void OpenItemPurchaseOverlay ( );
	void OpenMarketPlaceSearch ( );
};

UClass* UOnlineSubsystem::pClassPointer = NULL;

// Class Engine.PackageMapLevel
// 0x0008 (0x0108 - 0x0100)
class UPackageMapLevel : public UPackageMap
{
public:
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0100 (0x0008) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PackageMapLevel" );

		return pClassPointer;
	};

};

UClass* UPackageMapLevel::pClassPointer = NULL;

// Class Engine.PackageMapSeekFree
// 0x0000 (0x0108 - 0x0108)
class UPackageMapSeekFree : public UPackageMapLevel
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PackageMapSeekFree" );

		return pClassPointer;
	};

};

UClass* UPackageMapSeekFree::pClassPointer = NULL;

// Class Engine.PatchScriptCommandlet
// 0x0008 (0x00BC - 0x00B4)
class UPatchScriptCommandlet : public UCommandlet
{
public:
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x00B4 (0x0008) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PatchScriptCommandlet" );

		return pClassPointer;
	};

};

UClass* UPatchScriptCommandlet::pClassPointer = NULL;

// Class Engine.PlatformInterfaceBase
// 0x0020 (0x0080 - 0x0060)
class UPlatformInterfaceBase : public UObject
{
public:
	TArray< struct FDelegateArray >                    AllDelegates;                                     		// 0x0060 (0x0010) [0x0000000000000000]              
	struct FScriptDelegate                             __PlatformInterfaceDelegate__Delegate;            		// 0x0070 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0074 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PlatformInterfaceBase" );

		return pClassPointer;
	};

	void ClearDelegate ( );
	void AddDelegate ( );
	void GetDiscordRPCIntegration ( );
	void GetRazerIntegration ( );
	void GetAlienFXIntegration ( );
	void GetLogitechIntegration ( );
	void GetMixerIntegration ( );
	void GetInAppMessageInterface ( );
	void GetAppNotificationsInterface ( );
	void GetTwitterIntegration ( );
	void GetAnalyticEventsInterface ( );
	void GetMicroTransactionInterface ( );
	void GetInGameAdManager ( );
	void GetFacebookIntegration ( );
	void GetLocalStorageInterface ( );
	void GetCloudStorageInterface ( );
	void CallDelegates ( );
	void PlatformInterfaceDelegate ( );
};

UClass* UPlatformInterfaceBase::pClassPointer = NULL;

// Class Engine.MicroTransactionBase
// 0x0030 (0x00B0 - 0x0080)
class UMicroTransactionBase : public UPlatformInterfaceBase
{
public:
	TArray< struct FPurchaseInfo >                     AvailableProducts;                                		// 0x0080 (0x0010) [0x0000000000000000]              
	struct FString                                     LastError;                                        		// 0x0090 (0x0010) [0x0000000000000000]              
	struct FString                                     LastErrorSolution;                                		// 0x00A0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MicroTransactionBase" );

		return pClassPointer;
	};

	void eventGetProductIndex ( );
	void eventBeginPurchase ( );
	void eventIsAllowedToMakePurchases ( );
	void eventQueryForAvailablePurchases ( );
	void eventInit ( );
};

UClass* UMicroTransactionBase::pClassPointer = NULL;

// Class Engine.MicroTransactionProxy
// 0x0000 (0x00B0 - 0x00B0)
class UMicroTransactionProxy : public UMicroTransactionBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MicroTransactionProxy" );

		return pClassPointer;
	};

};

UClass* UMicroTransactionProxy::pClassPointer = NULL;

// Class Engine.Player
// 0x002C (0x008C - 0x0060)
class UPlayer : public UObject
{
public:
	struct FPointer                                    VfTable_FExec;                                    		// 0x0060 (0x0008) [0x0000000000000000]              
	class APlayerController*                           Actor;                                            		// 0x0068 (0x0008) [0x0000000000000000]              
	int                                                CurrentNetSpeed;                                  		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                ConfiguredInternetSpeed;                          		// 0x0074 (0x0004) [0x0000000000000000]              
	int                                                ConfiguredLanSpeed;                               		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              PP_DesaturationMultiplier;                        		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              PP_HighlightsMultiplier;                          		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              PP_MidTonesMultiplier;                            		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              PP_ShadowsMultiplier;                             		// 0x0088 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Player" );

		return pClassPointer;
	};

	void SwitchController ( );
};

UClass* UPlayer::pClassPointer = NULL;

// Class Engine.LocalPlayer
// 0x0520 (0x05AC - 0x008C)
class ULocalPlayer : public UPlayer
{
public:
	struct FPointer                                    VfTable_FObserverInterface;                       		// 0x008C (0x0008) [0x0000000000000000]              
	int                                                ControllerId;                                     		// 0x0094 (0x0004) [0x0000000000000000]              
	class UGameViewportClient*                         ViewportClient;                                   		// 0x0098 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   Origin;                                           		// 0x00A0 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   Size;                                             		// 0x00A8 (0x0008) [0x0000000000000000]              
	class UPostProcessChain*                           PlayerPostProcess;                                		// 0x00B0 (0x0008) [0x0000000000000000]              
	TArray< class UPostProcessChain* >                 PlayerPostProcessChains;                          		// 0x00B8 (0x0010) [0x0000000000000000]              
	DWORD                                              bForceDefaultPostProcessChain : 1;                		// 0x00C8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bWantToResetToMapDefaultPP : 1;                   		// 0x00C8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bSentSplitJoin : 1;                               		// 0x00C8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bPendingServerAuth : 1;                           		// 0x00C8 (0x0004) [0x0000000000000000] [0x00000008] 
	struct FPointer                                    ViewState;                                        		// 0x00CC (0x0008) [0x0000000000000000]              
	struct FPointer                                    ViewState2;                                       		// 0x00D4 (0x0008) [0x0000000000000000]              
	struct FSynchronizedActorVisibilityHistory         ActorVisibilityHistory;                           		// 0x00DC (0x0010) [0x0000000000000000]              
	struct FVector                                     LastViewLocation;                                 		// 0x00EC (0x000C) [0x0000000000000000]              
	struct FCurrentPostProcessVolumeInfo               CurrentPPInfo;                                    		// 0x00F8 (0x0230) [0x0000000000000000]              
	struct FCurrentPostProcessVolumeInfo               LevelPPInfo;                                      		// 0x0328 (0x0230) [0x0000000000000000]              
	TArray< struct FPostProcessSettingsOverride >      ActivePPOverrides;                                		// 0x0558 (0x0010) [0x0000000000000000]              
	unsigned char                                      AspectRatioAxisConstraint;                        		// 0x0568 (0x0001) [0x0000000000000000]              
	struct FString                                     LastMap;                                          		// 0x056C (0x0010) [0x0000000000000000]              
	class UTranslationContext*                         TagContext;                                       		// 0x057C (0x0008) [0x0000000000000000]              
	class UOnlineAuthInterface*                        CachedAuthInt;                                    		// 0x0584 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x058C (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	float                                              ServerAuthTimestamp;                              		// 0x0594 (0x0004) [0x0000000000000000]              
	int                                                ServerAuthTimeout;                                		// 0x0598 (0x0004) [0x0000000000000000]              
	int                                                ServerAuthRetryCount;                             		// 0x059C (0x0004) [0x0000000000000000]              
	int                                                MaxServerAuthRetryCount;                          		// 0x05A0 (0x0004) [0x0000000000000000]              
	struct FUniqueNetId                                ServerAuthUID;                                    		// 0x05A4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LocalPlayer" );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventExit ( );
	void eventNotifyServerConnectionClose ( );
	void eventViewportClosed ( );
	void StaticOnServerConnectionClose ( );
	void OnServerConnectionClose ( );
	void ServerAuthFailure ( );
	void eventServerAuthTimedOut ( );
	void OnServerAuthComplete ( );
	void ProcessServerAuthResponse ( );
	void ProcessClientAuthEndSessionRequest ( );
	void ProcessClientAuthRequest ( );
	void eventNotifyServerConnectionOpen ( );
	void eventGetNickname ( );
	void eventGetUniqueNetId ( );
	void FastProject ( );
	void FastDeProject ( );
	void Project ( );
	void DeProject ( );
	void TouchPlayerPostProcessChain ( );
	void GetPostProcessChain ( );
	void RemoveAllPostProcessingChains ( );
	void RemovePostProcessingChain ( );
	void InsertPostProcessingChain ( );
	void GetTranslationContext ( );
	void SetControllerId ( );
	void ClearPostProcessSettingsOverride ( );
	void OverridePostProcessSettingsCurve ( );
	void OverridePostProcessSettings ( );
	void GetActorVisibility ( );
	void SendSplitJoin ( );
	void SpawnPlayActor ( );
};

UClass* ULocalPlayer::pClassPointer = NULL;

// Class Engine.NetConnection
// 0xB050 (0xB0DC - 0x008C)
class UNetConnection : public UPlayer
{
public:
	unsigned char                                      UnknownData00[ 0xAFF8 ];                          		// 0x008C (0xAFF8) MISSED OFFSET
	TArray< class UChildConnection* >                  Children;                                         		// 0xB084 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x48 ];                            		// 0xB094 (0x0048) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NetConnection" );

		return pClassPointer;
	};

};

UClass* UNetConnection::pClassPointer = NULL;

// Class Engine.ChildConnection
// 0x0008 (0xB0E4 - 0xB0DC)
class UChildConnection : public UNetConnection
{
public:
	class UNetConnection*                              Parent;                                           		// 0xB0DC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ChildConnection" );

		return pClassPointer;
	};

};

UClass* UChildConnection::pClassPointer = NULL;

// Class Engine.DemoRecConnection
// 0x0000 (0xB0DC - 0xB0DC)
class UDemoRecConnection : public UNetConnection
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DemoRecConnection" );

		return pClassPointer;
	};

};

UClass* UDemoRecConnection::pClassPointer = NULL;

// Class Engine.PlayfabInterface
// 0x0268 (0x02C8 - 0x0060)
class UPlayfabInterface : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                          		// 0x0060 (0x0008) [0x0000000000000000]              
	class UOnlineGameSearch*                           PendingGameSearch;                                		// 0x0068 (0x0008) [0x0000000000000000]              
	struct FString                                     CachedPlayfabId;                                  		// 0x0070 (0x0010) [0x0000000000000000]              
	struct FString                                     CachedSessionTicket;                              		// 0x0080 (0x0010) [0x0000000000000000]              
	struct FString                                     CachedAuthCode;                                   		// 0x0090 (0x0010) [0x0000000000000000]              
	struct FString                                     CachedAuthForEntitlements;                        		// 0x00A0 (0x0010) [0x0000000000000000]              
	DWORD                                              bLoginProcessFinished : 1;                        		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLaunchedByPlayfab : 1;                           		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCloudServer : 1;                                 		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bServerAllocated : 1;                             		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bServerDeallocated : 1;                           		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000010] 
	int                                                LastAuthRefreshTime;                              		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                SecondsForAuthRefreshTime;                        		// 0x00B8 (0x0004) [0x0000000000000000]              
	int                                                LoginAttempts;                                    		// 0x00BC (0x0004) [0x0000000000000000]              
	int                                                MaxRetryLoginAttempts;                            		// 0x00C0 (0x0004) [0x0000000000000000]              
	struct FString                                     CatalogName;                                      		// 0x00C4 (0x0010) [0x0000000000000000]              
	TArray< struct FRegionDefinition >                 KnownRegions;                                     		// 0x00D4 (0x0010) [0x0000000000000000]              
	struct FString                                     CurrRegionName;                                   		// 0x00E4 (0x0010) [0x0000000000000000]              
	int                                                PlayfabNPServiceLabel;                            		// 0x00F4 (0x0004) [0x0000000000000000]              
	struct FMap_Mirror                                 TitleData;                                        		// 0x00F8 (0x0048) [0x0000000000000000]              
	struct FString                                     CachedLobbyId;                                    		// 0x0140 (0x0010) [0x0000000000000000]              
	struct FString                                     CachedServerId;                                   		// 0x0150 (0x0010) [0x0000000000000000]              
	float                                              ElapsedTimeSinceLastHeartBeat;                    		// 0x0160 (0x0004) [0x0000000000000000]              
	float                                              HeartbeatInterval;                                		// 0x0164 (0x0004) [0x0000000000000000]              
	class UOnlineGameSettings*                         CachedGameSettings;                               		// 0x0168 (0x0008) [0x0000000000000000]              
	float                                              CountdownToReregister;                            		// 0x0170 (0x0004) [0x0000000000000000]              
	float                                              ReregisterInterval;                               		// 0x0174 (0x0004) [0x0000000000000000]              
	struct FString                                     AllocateAPIEndpoint;                              		// 0x0178 (0x0010) [0x0000000000000000]              
	struct FString                                     DeallocateAPIEndpoint;                            		// 0x0188 (0x0010) [0x0000000000000000]              
	struct FQWord                                      DeallocatedTimeStamp;                             		// 0x0198 (0x0008) [0x0000000000000000]              
	float                                              TimeSinceLastDeallocationUpdate;                  		// 0x01A0 (0x0004) [0x0000000000000000]              
	float                                              DeallocateTimeUpdateInterval;                     		// 0x01A4 (0x0004) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   FindOnlineGamesCompleteDelegates;                 		// 0x01A8 (0x0010) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   OnQueryServerInfoCompleteDelegates;               		// 0x01B8 (0x0010) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   LoginCompleteDelegates;                           		// 0x01C8 (0x0010) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   RegionQueryCompleteDelegates;                     		// 0x01D8 (0x0010) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   ServerStartedDelegates;                           		// 0x01E8 (0x0010) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   InventoryReadDelegates;                           		// 0x01F8 (0x0010) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   TitleDataReadDelegates;                           		// 0x0208 (0x0010) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   StoreDataReadDelegates;                           		// 0x0218 (0x0010) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   CloudScriptExecutionCompleteDelegates;            		// 0x0228 (0x0010) [0x0000000000000000]              
	struct FScriptDelegate                             __OnLoginComplete__Delegate;                      		// 0x0238 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x023C (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnStoreDataRead__Delegate;                      		// 0x0248 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x4 ];                             		// 0x024C (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnInventoryRead__Delegate;                      		// 0x0258 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x4 ];                             		// 0x025C (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnTitleDataRead__Delegate;                      		// 0x0268 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData03[ 0x4 ];                             		// 0x026C (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnFindOnlineGamesComplete__Delegate;            		// 0x0278 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData04[ 0x4 ];                             		// 0x027C (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnQueryServerInfoComplete__Delegate;            		// 0x0288 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData05[ 0x4 ];                             		// 0x028C (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnRegionQueryComplete__Delegate;                		// 0x0298 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData06[ 0x4 ];                             		// 0x029C (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnServerStarted__Delegate;                      		// 0x02A8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData07[ 0x4 ];                             		// 0x02AC (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnCloudScriptExecutionComplete__Delegate;       		// 0x02B8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData08[ 0x4 ];                             		// 0x02BC (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PlayfabInterface" );

		return pClassPointer;
	};

	void OnlineServiceAuthComplete ( );
	void OnTokenAndSignatureRetrieved ( );
	void eventAuthWithOnlineService ( );
	void eventGetGameSettings ( );
	void CreateGameSettings ( );
	void ServerDeallocate ( );
	void ServerAllocate ( );
	void ServerGrantItemsForUser ( );
	void ServerRemoveVirtualCurrencyForUser ( );
	void ServerAddVirtualCurrencyForUser ( );
	void ServerRetrieveInternalUserData ( );
	void ServerUpdateInternalUserData ( );
	void ServerSetOpenStatus ( );
	void ServerRegisterGame ( );
	void ServerUpdateOnlineGame ( );
	void ServerNotifyPlayerLeft ( );
	void ServerNotifyPlayerJoined ( );
	void ServerValidatePlayer ( );
	void eventGetProfileSettings ( );
	void GetLocalizedRegionName ( );
	void GetLocalizedRegionList ( );
	void SetIndexForCurrentRegion ( );
	void GetIndexForCurrentRegion ( );
	void eventGetServerId ( );
	void eventIsCloudServer ( );
	void GetCachedLobbyId ( );
	void IsRegisteredWithPlayfab ( );
	void ClearOnCloudScriptExecutionCompleteDelegate ( );
	void AddOnCloudScriptExecutionCompleteDelegate ( );
	void OnCloudScriptExecutionComplete ( );
	void ExecuteCloudScript ( );
	void ClearOnServerStartedDelegate ( );
	void AddOnServerStartedDelegate ( );
	void OnServerStarted ( );
	void StartNewServerInstance ( );
	void ClearRegionQueryCompleteDelegate ( );
	void AddRegionQueryCompleteDelegate ( );
	void QueryAvailableRegions ( );
	void OnRegionQueryComplete ( );
	void ClearQueryServerInfoCompleteDelegate ( );
	void AddQueryServerInfoCompleteDelegate ( );
	void OnQueryServerInfoComplete ( );
	void QueryServerInfo ( );
	void CancelGameSearch ( );
	void ClearFindOnlineGamesCompleteDelegate ( );
	void AddFindOnlineGamesCompleteDelegate ( );
	void OnFindOnlineGamesComplete ( );
	void FindOnlineGames ( );
	void ConsumeEntitlements ( );
	void UnlockContainer ( );
	void GetTitleDataForKey ( );
	void ClearTitleDataReadCompleteDelegate ( );
	void AddTitleDataReadCompleteDelegate ( );
	void OnTitleDataRead ( );
	void ReadTitleData ( );
	void ClearInventoryReadCompleteDelegate ( );
	void AddInventoryReadCompleteDelegate ( );
	void OnInventoryRead ( );
	void ReadInventory ( );
	void ClearStoreDataReadCompleteDelegate ( );
	void AddStoreDataReadCompleteDelegate ( );
	void OnStoreDataRead ( );
	void ReadStoreData ( );
	void Logout ( );
	void SetDefaultRegion ( );
	void GetRegionIndex ( );
	void ClearOnLoginCompleteDelegate ( );
	void AddOnLoginCompleteDelegate ( );
	void OnLoginComplete ( );
	void Login ( );
};

UClass* UPlayfabInterface::pClassPointer = NULL;

// Class Engine.Polys
// 0x0018 (0x0078 - 0x0060)
class UPolys : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0x18 ];                            		// 0x0060 (0x0018) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Polys" );

		return pClassPointer;
	};

};

UClass* UPolys::pClassPointer = NULL;

// Class Engine.PostProcessChain
// 0x0010 (0x0070 - 0x0060)
class UPostProcessChain : public UObject
{
public:
	TArray< class UPostProcessEffect* >                Effects;                                          		// 0x0060 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PostProcessChain" );

		return pClassPointer;
	};

	void FindPostProcessEffect ( );
};

UClass* UPostProcessChain::pClassPointer = NULL;

// Class Engine.PostProcessEffect
// 0x0025 (0x0085 - 0x0060)
class UPostProcessEffect : public UObject
{
public:
	DWORD                                              bShowInEditor : 1;                                		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bShowInGame : 1;                                  		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUseWorldSettings : 1;                            		// 0x0060 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bAffectsLightingOnly : 1;                         		// 0x0060 (0x0004) [0x0000000000000000] [0x00000008] 
	struct FName                                       EffectName;                                       		// 0x0064 (0x0008) [0x0000000000000000]              
	int                                                NodePosY;                                         		// 0x006C (0x0004) [0x0000000000000000]              
	int                                                NodePosX;                                         		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                DrawWidth;                                        		// 0x0074 (0x0004) [0x0000000000000000]              
	int                                                DrawHeight;                                       		// 0x0078 (0x0004) [0x0000000000000000]              
	int                                                OutDrawY;                                         		// 0x007C (0x0004) [0x0000000000000000]              
	int                                                InDrawY;                                          		// 0x0080 (0x0004) [0x0000000000000000]              
	unsigned char                                      SceneDPG;                                         		// 0x0084 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PostProcessEffect" );

		return pClassPointer;
	};

};

UClass* UPostProcessEffect::pClassPointer = NULL;

// Class Engine.AmbientOcclusionEffect
// 0x007F (0x0104 - 0x0085)
class UAmbientOcclusionEffect : public UPostProcessEffect
{
public:
	struct FLinearColor                                OcclusionColor;                                   		// 0x0088 (0x0010) [0x0000000000000000]              
	float                                              OcclusionPower;                                   		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              OcclusionScale;                                   		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              OcclusionBias;                                    		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              MinOcclusion;                                     		// 0x00A4 (0x0004) [0x0000000000000000]              
	DWORD                                              SSAO2 : 1;                                        		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAngleBasedSSAO : 1;                              		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              HBAO_EnableDepthThreshold : 1;                    		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              HBAO_EnableBlur : 1;                              		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              OcclusionRadius;                                  		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              OcclusionAttenuation;                             		// 0x00B0 (0x0004) [0x0000000000000000]              
	unsigned char                                      OcclusionQuality;                                 		// 0x00B4 (0x0001) [0x0000000000000000]              
	unsigned char                                      HBAO_BlurRadius;                                  		// 0x00B5 (0x0001) [0x0000000000000000]              
	float                                              OcclusionFadeoutMinDistance;                      		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              OcclusionFadeoutMaxDistance;                      		// 0x00BC (0x0004) [0x0000000000000000]              
	float                                              HaloDistanceThreshold;                            		// 0x00C0 (0x0004) [0x0000000000000000]              
	float                                              HaloDistanceScale;                                		// 0x00C4 (0x0004) [0x0000000000000000]              
	float                                              HaloOcclusion;                                    		// 0x00C8 (0x0004) [0x0000000000000000]              
	float                                              EdgeDistanceThreshold;                            		// 0x00CC (0x0004) [0x0000000000000000]              
	float                                              EdgeDistanceScale;                                		// 0x00D0 (0x0004) [0x0000000000000000]              
	float                                              FilterDistanceScale;                              		// 0x00D4 (0x0004) [0x0000000000000000]              
	int                                                FilterSize;                                       		// 0x00D8 (0x0004) [0x0000000000000000]              
	float                                              HistoryConvergenceTime;                           		// 0x00DC (0x0004) [0x0000000000000000]              
	float                                              HistoryWeightConvergenceTime;                     		// 0x00E0 (0x0004) [0x0000000000000000]              
	float                                              HBAO_Radius;                                      		// 0x00E4 (0x0004) [0x0000000000000000]              
	float                                              HBAO_Bias;                                        		// 0x00E8 (0x0004) [0x0000000000000000]              
	float                                              HBAO_DetailAO;                                    		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              HBAO_CoarseAO;                                    		// 0x00F0 (0x0004) [0x0000000000000000]              
	float                                              HBAO_PowerExponent;                               		// 0x00F4 (0x0004) [0x0000000000000000]              
	float                                              HBAO_MaxViewDepth;                                		// 0x00F8 (0x0004) [0x0000000000000000]              
	float                                              HBAO_Sharpness;                                   		// 0x00FC (0x0004) [0x0000000000000000]              
	float                                              HBAO_BlurSharpness;                               		// 0x0100 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AmbientOcclusionEffect" );

		return pClassPointer;
	};

};

UClass* UAmbientOcclusionEffect::pClassPointer = NULL;

// Class Engine.BlurEffect
// 0x0007 (0x008C - 0x0085)
class UBlurEffect : public UPostProcessEffect
{
public:
	int                                                BlurKernelSize;                                   		// 0x0088 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.BlurEffect" );

		return pClassPointer;
	};

};

UClass* UBlurEffect::pClassPointer = NULL;

// Class Engine.DOFEffect
// 0x002F (0x00B4 - 0x0085)
class UDOFEffect : public UPostProcessEffect
{
public:
	float                                              FalloffExponent;                                  		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              BlurKernelSize;                                   		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              MaxNearBlurAmount;                                		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              MinBlurAmount;                                    		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              MaxFarBlurAmount;                                 		// 0x0098 (0x0004) [0x0000000000000000]              
	unsigned char                                      FocusType;                                        		// 0x009C (0x0001) [0x0000000000000000]              
	float                                              FocusInnerRadius;                                 		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              FocusDistance;                                    		// 0x00A4 (0x0004) [0x0000000000000000]              
	struct FVector                                     FocusPosition;                                    		// 0x00A8 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DOFEffect" );

		return pClassPointer;
	};

};

UClass* UDOFEffect::pClassPointer = NULL;

// Class Engine.DOFAndBloomEffect
// 0x0038 (0x00EC - 0x00B4)
class UDOFAndBloomEffect : public UDOFEffect
{
public:
	float                                              BloomScale;                                       		// 0x00B4 (0x0004) [0x0000000000000000]              
	float                                              BloomThreshold;                                   		// 0x00B8 (0x0004) [0x0000000000000000]              
	struct FColor                                      BloomTint;                                        		// 0x00BC (0x0004) [0x0000000000000000]              
	float                                              BloomScreenBlendThreshold;                        		// 0x00C0 (0x0004) [0x0000000000000000]              
	float                                              SceneMultiplier;                                  		// 0x00C4 (0x0004) [0x0000000000000000]              
	float                                              BlurBloomKernelSize;                              		// 0x00C8 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnableReferenceDOF : 1;                          		// 0x00CC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              BloomIntensity;                                   		// 0x00D0 (0x0004) [0x0000000000000000]              
	float                                              BloomWidth;                                       		// 0x00D4 (0x0004) [0x0000000000000000]              
	float                                              Exposure;                                         		// 0x00D8 (0x0004) [0x0000000000000000]              
	float                                              BloomThreshold2;                                  		// 0x00DC (0x0004) [0x0000000000000000]              
	unsigned char                                      DepthOfFieldType;                                 		// 0x00E0 (0x0001) [0x0000000000000000]              
	unsigned char                                      DepthOfFieldQuality;                              		// 0x00E1 (0x0001) [0x0000000000000000]              
	class UTexture2D*                                  BokehTexture;                                     		// 0x00E4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DOFAndBloomEffect" );

		return pClassPointer;
	};

};

UClass* UDOFAndBloomEffect::pClassPointer = NULL;

// Class Engine.DOFBloomMotionBlurEffect
// 0x0014 (0x0100 - 0x00EC)
class UDOFBloomMotionBlurEffect : public UDOFAndBloomEffect
{
public:
	float                                              MaxVelocity;                                      		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              MotionBlurAmount;                                 		// 0x00F0 (0x0004) [0x0000000000000000]              
	DWORD                                              FullMotionBlur : 1;                               		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              CameraRotationThreshold;                          		// 0x00F8 (0x0004) [0x0000000000000000]              
	float                                              CameraTranslationThreshold;                       		// 0x00FC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DOFBloomMotionBlurEffect" );

		return pClassPointer;
	};

};

UClass* UDOFBloomMotionBlurEffect::pClassPointer = NULL;

// Class Engine.UberPostProcessEffect
// 0x0094 (0x0194 - 0x0100)
class UUberPostProcessEffect : public UDOFBloomMotionBlurEffect
{
public:
	struct FVector                                     SceneShadows;                                     		// 0x0100 (0x000C) [0x0000000000000000]              
	struct FVector                                     SceneHighLights;                                  		// 0x010C (0x000C) [0x0000000000000000]              
	struct FVector                                     SceneMidTones;                                    		// 0x0118 (0x000C) [0x0000000000000000]              
	float                                              SceneDesaturation;                                		// 0x0124 (0x0004) [0x0000000000000000]              
	struct FVector                                     SceneColorize;                                    		// 0x0128 (0x000C) [0x0000000000000000]              
	unsigned char                                      TonemapperType;                                   		// 0x0134 (0x0001) [0x0000000000000000]              
	unsigned char                                      PostProcessAAType;                                		// 0x0135 (0x0001) [0x0000000000000000]              
	float                                              TonemapperRange;                                  		// 0x0138 (0x0004) [0x0000000000000000]              
	float                                              TonemapperToeFactor;                              		// 0x013C (0x0004) [0x0000000000000000]              
	float                                              TonemapperScale;                                  		// 0x0140 (0x0004) [0x0000000000000000]              
	float                                              MotionBlurSoftEdgeKernelSize;                     		// 0x0144 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnableImageGrain : 1;                            		// 0x0148 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bScaleEffectsWithViewSize : 1;                    		// 0x0148 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bEnableHDRTonemapper : 1;                         		// 0x0148 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              SceneImageGrainScale;                             		// 0x014C (0x0004) [0x0000000000000000]              
	float                                              BloomWeightSmall;                                 		// 0x0150 (0x0004) [0x0000000000000000]              
	float                                              BloomWeightMedium;                                		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              BloomWeightLarge;                                 		// 0x0158 (0x0004) [0x0000000000000000]              
	float                                              BloomSizeScaleSmall;                              		// 0x015C (0x0004) [0x0000000000000000]              
	float                                              BloomSizeScaleMedium;                             		// 0x0160 (0x0004) [0x0000000000000000]              
	float                                              BloomSizeScaleLarge;                              		// 0x0164 (0x0004) [0x0000000000000000]              
	float                                              EdgeDetectionThreshold;                           		// 0x0168 (0x0004) [0x0000000000000000]              
	struct FLUTBlender                                 PreviousLUTBlender;                               		// 0x016C (0x0024) [0x0000000000000000]              
	float                                              SceneHDRTonemapperScale;                          		// 0x0190 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UberPostProcessEffect" );

		return pClassPointer;
	};

};

UClass* UUberPostProcessEffect::pClassPointer = NULL;

// Class Engine.MaterialEffect
// 0x000B (0x0090 - 0x0085)
class UMaterialEffect : public UPostProcessEffect
{
public:
	class UMaterialInterface*                          Material;                                         		// 0x0088 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialEffect" );

		return pClassPointer;
	};

};

UClass* UMaterialEffect::pClassPointer = NULL;

// Class Engine.MotionBlurEffect
// 0x0017 (0x009C - 0x0085)
class UMotionBlurEffect : public UPostProcessEffect
{
public:
	float                                              MaxVelocity;                                      		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              MotionBlurAmount;                                 		// 0x008C (0x0004) [0x0000000000000000]              
	DWORD                                              FullMotionBlur : 1;                               		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              CameraRotationThreshold;                          		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              CameraTranslationThreshold;                       		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MotionBlurEffect" );

		return pClassPointer;
	};

};

UClass* UMotionBlurEffect::pClassPointer = NULL;

// Class Engine.TWPostProcessEffect
// 0x00B3 (0x0138 - 0x0085)
class UTWPostProcessEffect : public UPostProcessEffect
{
public:
	float                                              DOF_FocalDistance;                                		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              DOF_SharpRadius;                                  		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              DOF_FocalRadius;                                  		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              DOF_MinBlurSize;                                  		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              DOF_MaxNearBlurSize;                              		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              DOF_MaxFarBlurSize;                               		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              DOF_ExpFalloff;                                   		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              DOF_FG_SharpRadius;                               		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              DOF_FG_FocalRadius;                               		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              DOF_FG_MinBlurSize;                               		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              DOF_FG_MaxNearBlurSize;                           		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              DOF_FG_ExpFalloff;                                		// 0x00B4 (0x0004) [0x0000000000000000]              
	DWORD                                              MB_TileMaxEnabled : 1;                            		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              Bloom_Intensity;                                  		// 0x00BC (0x0004) [0x0000000000000000]              
	float                                              Bloom_Width;                                      		// 0x00C0 (0x0004) [0x0000000000000000]              
	float                                              Bloom_Exposure;                                   		// 0x00C4 (0x0004) [0x0000000000000000]              
	float                                              Bloom_Threshold;                                  		// 0x00C8 (0x0004) [0x0000000000000000]              
	struct FColor                                      Bloom_Tint;                                       		// 0x00CC (0x0004) [0x0000000000000000]              
	float                                              Bloom_ScreenBlendThreshold;                       		// 0x00D0 (0x0004) [0x0000000000000000]              
	struct FVector                                     SceneShadows;                                     		// 0x00D4 (0x000C) [0x0000000000000000]              
	struct FVector                                     SceneHighLights;                                  		// 0x00E0 (0x000C) [0x0000000000000000]              
	struct FVector                                     SceneMidTones;                                    		// 0x00EC (0x000C) [0x0000000000000000]              
	float                                              SceneDesaturation;                                		// 0x00F8 (0x0004) [0x0000000000000000]              
	struct FVector                                     SceneColorize;                                    		// 0x00FC (0x000C) [0x0000000000000000]              
	unsigned char                                      TonemapperType;                                   		// 0x0108 (0x0001) [0x0000000000000000]              
	unsigned char                                      PostProcessAAType;                                		// 0x0109 (0x0001) [0x0000000000000000]              
	float                                              TonemapperRange;                                  		// 0x010C (0x0004) [0x0000000000000000]              
	float                                              TonemapperToeFactor;                              		// 0x0110 (0x0004) [0x0000000000000000]              
	float                                              TonemapperScale;                                  		// 0x0114 (0x0004) [0x0000000000000000]              
	float                                              NoiseIntensity;                                   		// 0x0118 (0x0004) [0x0000000000000000]              
	float                                              EdgeDetectionThreshold;                           		// 0x011C (0x0004) [0x0000000000000000]              
	float                                              Fog_Start_Distance;                               		// 0x0120 (0x0004) [0x0000000000000000]              
	float                                              Fog_MaxStrength_Distance;                         		// 0x0124 (0x0004) [0x0000000000000000]              
	float                                              Fog_AnimationCutoff_Distance;                     		// 0x0128 (0x0004) [0x0000000000000000]              
	float                                              Fog_Intensity;                                    		// 0x012C (0x0004) [0x0000000000000000]              
	float                                              Fog_MinAmount;                                    		// 0x0130 (0x0004) [0x0000000000000000]              
	struct FColor                                      Fog_Color;                                        		// 0x0134 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWPostProcessEffect" );

		return pClassPointer;
	};

};

UClass* UTWPostProcessEffect::pClassPointer = NULL;

// Class Engine.PrimitiveComponentFactory
// 0x0004 (0x0064 - 0x0060)
class UPrimitiveComponentFactory : public UObject
{
public:
	DWORD                                              CollideActors : 1;                                		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              BlockActors : 1;                                  		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              BlockZeroExtent : 1;                              		// 0x0060 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              BlockNonZeroExtent : 1;                           		// 0x0060 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              BlockRigidBody : 1;                               		// 0x0060 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              HiddenGame : 1;                                   		// 0x0060 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              HiddenEditor : 1;                                 		// 0x0060 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              CastShadow : 1;                                   		// 0x0060 (0x0004) [0x0000000000000000] [0x00000080] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PrimitiveComponentFactory" );

		return pClassPointer;
	};

};

UClass* UPrimitiveComponentFactory::pClassPointer = NULL;

// Class Engine.MeshComponentFactory
// 0x0010 (0x0074 - 0x0064)
class UMeshComponentFactory : public UPrimitiveComponentFactory
{
public:
	TArray< class UMaterialInterface* >                Materials;                                        		// 0x0064 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MeshComponentFactory" );

		return pClassPointer;
	};

};

UClass* UMeshComponentFactory::pClassPointer = NULL;

// Class Engine.StaticMeshComponentFactory
// 0x0008 (0x007C - 0x0074)
class UStaticMeshComponentFactory : public UMeshComponentFactory
{
public:
	class UStaticMesh*                                 StaticMesh;                                       		// 0x0074 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.StaticMeshComponentFactory" );

		return pClassPointer;
	};

};

UClass* UStaticMeshComponentFactory::pClassPointer = NULL;

// Class Engine.ReachSpec
// 0x0068 (0x00C8 - 0x0060)
class UReachSpec : public UObject
{
public:
	struct FPointer                                    NavOctreeObject;                                  		// 0x0060 (0x0008) [0x0000000000000000]              
	int                                                Distance;                                         		// 0x0068 (0x0004) [0x0000000000000000]              
	struct FVector                                     Direction;                                        		// 0x006C (0x000C) [0x0000000000000000]              
	class ANavigationPoint*                            Start;                                            		// 0x0078 (0x0008) [0x0000000000000000]              
	struct FActorReference                             End;                                              		// 0x0080 (0x0018) [0x0000000000000000]              
	int                                                CollisionRadius;                                  		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                CollisionHeight;                                  		// 0x009C (0x0004) [0x0000000000000000]              
	DWORD                                              bManuallyForced : 1;                              		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAddToNavigationOctree : 1;                       		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCanCutCorners : 1;                               		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bCheckForObstructions : 1;                        		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bSkipPrune : 1;                                   		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bDisabled : 1;                                    		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000020] 
	int                                                reachFlags;                                       		// 0x00A4 (0x0004) [0x0000000000000000]              
	int                                                MaxLandingVelocity;                               		// 0x00A8 (0x0004) [0x0000000000000000]              
	unsigned char                                      bPruned;                                          		// 0x00AC (0x0001) [0x0000000000000000]              
	unsigned char                                      PathColorIndex;                                   		// 0x00AD (0x0001) [0x0000000000000000]              
	TArray< class UClass* >                            PruneSpecList;                                    		// 0x00B0 (0x0010) [0x0000000000000000]              
	class AActor*                                      BlockedBy;                                        		// 0x00C0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ReachSpec" );

		return pClassPointer;
	};

	void GetCostFor ( );
	void IsBlockedFor ( );
	void GetDirection ( );
	void GetEnd ( );
	void CostFor ( );
};

UClass* UReachSpec::pClassPointer = NULL;

// Class Engine.AdvancedReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UAdvancedReachSpec : public UReachSpec
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AdvancedReachSpec" );

		return pClassPointer;
	};

};

UClass* UAdvancedReachSpec::pClassPointer = NULL;

// Class Engine.CeilingReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UCeilingReachSpec : public UReachSpec
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CeilingReachSpec" );

		return pClassPointer;
	};

};

UClass* UCeilingReachSpec::pClassPointer = NULL;

// Class Engine.ForcedReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UForcedReachSpec : public UReachSpec
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ForcedReachSpec" );

		return pClassPointer;
	};

};

UClass* UForcedReachSpec::pClassPointer = NULL;

// Class Engine.CoverSlipReachSpec
// 0x0001 (0x00C9 - 0x00C8)
class UCoverSlipReachSpec : public UForcedReachSpec
{
public:
	unsigned char                                      SpecDirection;                                    		// 0x00C8 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CoverSlipReachSpec" );

		return pClassPointer;
	};

};

UClass* UCoverSlipReachSpec::pClassPointer = NULL;

// Class Engine.FloorToCeilingReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UFloorToCeilingReachSpec : public UForcedReachSpec
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FloorToCeilingReachSpec" );

		return pClassPointer;
	};

};

UClass* UFloorToCeilingReachSpec::pClassPointer = NULL;

// Class Engine.MantleReachSpec
// 0x0004 (0x00CC - 0x00C8)
class UMantleReachSpec : public UForcedReachSpec
{
public:
	DWORD                                              bClimbUp : 1;                                     		// 0x00C8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MantleReachSpec" );

		return pClassPointer;
	};

};

UClass* UMantleReachSpec::pClassPointer = NULL;

// Class Engine.SlotToSlotReachSpec
// 0x0001 (0x00C9 - 0x00C8)
class USlotToSlotReachSpec : public UForcedReachSpec
{
public:
	unsigned char                                      SpecDirection;                                    		// 0x00C8 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SlotToSlotReachSpec" );

		return pClassPointer;
	};

};

UClass* USlotToSlotReachSpec::pClassPointer = NULL;

// Class Engine.SwatTurnReachSpec
// 0x0001 (0x00C9 - 0x00C8)
class USwatTurnReachSpec : public UForcedReachSpec
{
public:
	unsigned char                                      SpecDirection;                                    		// 0x00C8 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SwatTurnReachSpec" );

		return pClassPointer;
	};

};

UClass* USwatTurnReachSpec::pClassPointer = NULL;

// Class Engine.WallTransReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UWallTransReachSpec : public UForcedReachSpec
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.WallTransReachSpec" );

		return pClassPointer;
	};

};

UClass* UWallTransReachSpec::pClassPointer = NULL;

// Class Engine.LadderReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class ULadderReachSpec : public UReachSpec
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LadderReachSpec" );

		return pClassPointer;
	};

};

UClass* ULadderReachSpec::pClassPointer = NULL;

// Class Engine.ProscribedReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UProscribedReachSpec : public UReachSpec
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ProscribedReachSpec" );

		return pClassPointer;
	};

};

UClass* UProscribedReachSpec::pClassPointer = NULL;

// Class Engine.TeleportReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UTeleportReachSpec : public UReachSpec
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TeleportReachSpec" );

		return pClassPointer;
	};

};

UClass* UTeleportReachSpec::pClassPointer = NULL;

// Class Engine.SavedMove
// 0x00C4 (0x0124 - 0x0060)
class USavedMove : public UObject
{
public:
	class USavedMove*                                  NextMove;                                         		// 0x0060 (0x0008) [0x0000000000000000]              
	float                                              TimeStamp;                                        		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              Delta;                                            		// 0x006C (0x0004) [0x0000000000000000]              
	DWORD                                              bRun : 1;                                         		// 0x0070 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDuck : 1;                                        		// 0x0070 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bPressedJump : 1;                                 		// 0x0070 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bDoubleJump : 1;                                  		// 0x0070 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bPreciseDestination : 1;                          		// 0x0070 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bForceRMVelocity : 1;                             		// 0x0070 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bForceMaxAccel : 1;                               		// 0x0070 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bRootMotionFromInterpCurve : 1;                   		// 0x0070 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned char                                      DoubleClickMove;                                  		// 0x0074 (0x0001) [0x0000000000000000]              
	unsigned char                                      SavedPhysics;                                     		// 0x0075 (0x0001) [0x0000000000000000]              
	unsigned char                                      RootMotionMode;                                   		// 0x0076 (0x0001) [0x0000000000000000]              
	struct FVector                                     StartLocation;                                    		// 0x0078 (0x000C) [0x0000000000000000]              
	struct FVector                                     StartRelativeLocation;                            		// 0x0084 (0x000C) [0x0000000000000000]              
	struct FVector                                     StartVelocity;                                    		// 0x0090 (0x000C) [0x0000000000000000]              
	struct FVector                                     StartFloor;                                       		// 0x009C (0x000C) [0x0000000000000000]              
	struct FVector                                     SavedLocation;                                    		// 0x00A8 (0x000C) [0x0000000000000000]              
	struct FVector                                     SavedVelocity;                                    		// 0x00B4 (0x000C) [0x0000000000000000]              
	struct FVector                                     SavedRelativeLocation;                            		// 0x00C0 (0x000C) [0x0000000000000000]              
	struct FVector                                     RMVelocity;                                       		// 0x00CC (0x000C) [0x0000000000000000]              
	struct FVector                                     Acceleration;                                     		// 0x00D8 (0x000C) [0x0000000000000000]              
	struct FRotator                                    Rotation;                                         		// 0x00E4 (0x000C) [0x0000000000000000]              
	class AActor*                                      StartBase;                                        		// 0x00F0 (0x0008) [0x0000000000000000]              
	class AActor*                                      EndBase;                                          		// 0x00F8 (0x0008) [0x0000000000000000]              
	float                                              CustomTimeDilation;                               		// 0x0100 (0x0004) [0x0000000000000000]              
	float                                              AccelDotThreshold;                                		// 0x0104 (0x0004) [0x0000000000000000]              
	float                                              RootMotionInterpCurrentTime;                      		// 0x0108 (0x0004) [0x0000000000000000]              
	struct FVector                                     RootMotionInterpCurveLastValue;                   		// 0x010C (0x000C) [0x0000000000000000]              
	struct FRotator                                    WeaponBufferRotation;                             		// 0x0118 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SavedMove" );

		return pClassPointer;
	};

	void GetDebugString ( );
	void SetFlags ( );
	void CompressedFlags ( );
	void ResetMoveFor ( );
	void PrepMoveFor ( );
	void SetMoveFor ( );
	void CanCombineWith ( );
	void SetInitialPosition ( );
	void GetStartLocation ( );
	void IsImportantMove ( );
	void PostUpdate ( );
	void Clear ( );
};

UClass* USavedMove::pClassPointer = NULL;

// Class Engine.SaveGameSummary
// 0x0018 (0x0078 - 0x0060)
class USaveGameSummary : public UObject
{
public:
	struct FName                                       BaseLevel;                                        		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FString                                     Description;                                      		// 0x0068 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SaveGameSummary" );

		return pClassPointer;
	};

};

UClass* USaveGameSummary::pClassPointer = NULL;

// Class Engine.ScriptViewportClient
// 0x0008 (0x0068 - 0x0060)
class UScriptViewportClient : public UObject
{
public:
	struct FPointer                                    VfTable_FViewportClient;                          		// 0x0060 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ScriptViewportClient" );

		return pClassPointer;
	};

};

UClass* UScriptViewportClient::pClassPointer = NULL;

// Class Engine.GameViewportClient
// 0x0138 (0x01A0 - 0x0068)
class UGameViewportClient : public UScriptViewportClient
{
public:
	struct FPointer                                    VfTable_FExec;                                    		// 0x0068 (0x0008) [0x0000000000000000]              
	struct FPointer                                    Viewport;                                         		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FPointer                                    ViewportFrame;                                    		// 0x0078 (0x0008) [0x0000000000000000]              
	TArray< class UInteraction* >                      GlobalInteractions;                               		// 0x0080 (0x0010) [0x0000000000000000]              
	class UClass*                                      UIControllerClass;                                		// 0x0090 (0x0008) [0x0000000000000000]              
	class UUIInteraction*                              UIController;                                     		// 0x0098 (0x0008) [0x0000000000000000]              
	class UConsole*                                    ViewportConsole;                                  		// 0x00A0 (0x0008) [0x0000000000000000]              
	struct FExportShowFlags_Mirror                     ShowFlags;                                        		// 0x00A8 (0x0010) [0x0000000000000000]              
	struct FString                                     LoadingMessage;                                   		// 0x00B8 (0x0010) [0x0000000000000000]              
	struct FString                                     SavingMessage;                                    		// 0x00C8 (0x0010) [0x0000000000000000]              
	struct FString                                     ConnectingMessage;                                		// 0x00D8 (0x0010) [0x0000000000000000]              
	struct FString                                     PausedMessage;                                    		// 0x00E8 (0x0010) [0x0000000000000000]              
	struct FString                                     PrecachingMessage;                                		// 0x00F8 (0x0010) [0x0000000000000000]              
	DWORD                                              bShowTitleSafeZone : 1;                           		// 0x0108 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDisplayHardwareMouseCursor : 1;                  		// 0x0108 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bOverrideDiffuseAndSpecular : 1;                  		// 0x0108 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bIsPlayInEditorViewport : 1;                      		// 0x0108 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bShowSystemMouseCursor : 1;                       		// 0x0108 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bDisableWorldRendering : 1;                       		// 0x0108 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bCapturedWorldRendering : 1;                      		// 0x0108 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bDebugNoGFxUI : 1;                                		// 0x0108 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bAllowInputFromMultipleControllers : 1;           		// 0x0108 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bNeedsNewGamepadPairingForControllerDisconnect : 1;		// 0x0108 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bNeedsNewGamepadPairingForNewProfile : 1;         		// 0x0108 (0x0004) [0x0000000000000000] [0x00000400] 
	struct FTitleSafeZoneArea                          TitleSafeZone;                                    		// 0x010C (0x0010) [0x0000000000000000]              
	TArray< struct FSplitscreenData >                  SplitscreenInfo;                                  		// 0x011C (0x0010) [0x0000000000000000]              
	unsigned char                                      DesiredSplitscreenType;                           		// 0x012C (0x0001) [0x0000000000000000]              
	unsigned char                                      ActiveSplitscreenType;                            		// 0x012D (0x0001) [0x0000000000000000]              
	unsigned char                                      Default2PSplitType;                               		// 0x012E (0x0001) [0x0000000000000000]              
	unsigned char                                      Default3PSplitType;                               		// 0x012F (0x0001) [0x0000000000000000]              
	struct FString                                     ProgressMessage[ 0x2 ];                           		// 0x0130 (0x0020) [0x0000000000000000]              
	float                                              ProgressTimeOut;                                  		// 0x0150 (0x0004) [0x0000000000000000]              
	float                                              ProgressFadeTime;                                 		// 0x0154 (0x0004) [0x0000000000000000]              
	TArray< struct FDebugDisplayProperty >             DebugProperties;                                  		// 0x0158 (0x0010) [0x0000000000000000]              
	struct FPointer                                    ScaleformInteraction;                             		// 0x0168 (0x0008) [0x0000000000000000]              
	struct FScriptDelegate                             __HandleInputKey__Delegate;                       		// 0x0170 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0174 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __HandleInputAxis__Delegate;                      		// 0x0180 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x4 ];                             		// 0x0184 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __HandleInputChar__Delegate;                      		// 0x0190 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x4 ];                             		// 0x0194 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GameViewportClient" );

		return pClassPointer;
	};

	void eventSetHardwareMouseCursorVisibility ( );
	void DebugSetUISystemEnabled ( );
	void IsScaleformEnabled ( );
	void DisableScaleform ( );
	void EnableScaleform ( );
	void BecomePrimaryPlayer ( );
	void OnPrimaryPlayerSwitch ( );
	void FixupOwnerReferences ( );
	void GetPlayerOwner ( );
	void ClearProgressMessages ( );
	void SetProgressTime ( );
	void NotifyConnectionError ( );
	void eventSetProgressMessage ( );
	void RemoveLocalPlayer ( );
	void AddLocalPlayer ( );
	void NotifyPlayerRemoved ( );
	void NotifyPlayerAdded ( );
	void DrawTransitionMessage ( );
	void DrawTransition ( );
	void DisplayProgressMessage ( );
	void eventPostRender ( );
	void DrawTitleSafeArea ( );
	void eventTick ( );
	void CalculateDeadZoneForAllSides ( );
	void CalculateSafeZoneValues ( );
	void GetPixelSizeOfScreen ( );
	void HasRightSafeZone ( );
	void HasLeftSafeZone ( );
	void HasBottomSafeZone ( );
	void HasTopSafeZone ( );
	void ConvertLocalPlayerToGamePlayerIndex ( );
	void eventGetSubtitleRegion ( );
	void eventLayoutPlayers ( );
	void UpdateActiveSplitscreenType ( );
	void GetSplitscreenConfiguration ( );
	void SetSplitscreenConfiguration ( );
	void eventGameSessionEnded ( );
	void eventInsertInteraction ( );
	void CreateInitialPlayer ( );
	void eventInit ( );
	void eventFindPlayerByControllerId ( );
	void eventRemovePlayer ( );
	void eventCreatePlayer ( );
	void SetMouse ( );
	void ForceUpdateMouseCursor ( );
	void NotifySplitscreenLayoutChanged ( );
	void SetCustomInteractionObject ( );
	void GetCustomInteractionClass ( );
	void GetNumCustomInteractions ( );
	void ShouldForceFullscreenViewport ( );
	void GetMousePosition ( );
	void IsFullScreenViewport ( );
	void GetViewportSize(FVector2D &Out);
	void ConsoleCommand ( );
	void HandleInputChar ( );
	void HandleInputAxis ( );
	void HandleInputKey ( );
};

UClass* UGameViewportClient::pClassPointer = NULL;

// Class Engine.Selection
// 0x002C (0x008C - 0x0060)
class USelection : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0x2C ];                            		// 0x0060 (0x002C) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Selection" );

		return pClassPointer;
	};

};

UClass* USelection::pClassPointer = NULL;

// Class Engine.ServerCommandlet
// 0x0000 (0x00B4 - 0x00B4)
class UServerCommandlet : public UCommandlet
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ServerCommandlet" );

		return pClassPointer;
	};

};

UClass* UServerCommandlet::pClassPointer = NULL;

// Class Engine.Settings
// 0x0040 (0x00A0 - 0x0060)
class USettings : public UObject
{
public:
	TArray< struct FLocalizedStringSetting >           LocalizedSettings;                                		// 0x0060 (0x0010) [0x0000000000000000]              
	TArray< struct FSettingsProperty >                 Properties;                                       		// 0x0070 (0x0010) [0x0000000000000000]              
	TArray< struct FLocalizedStringSettingMetaData >   LocalizedSettingsMappings;                        		// 0x0080 (0x0010) [0x0000000000000000]              
	TArray< struct FSettingsPropertyPropertyMetaData > PropertyMappings;                                 		// 0x0090 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Settings" );

		return pClassPointer;
	};

	void UpdateFromURL ( );
	void BuildURL ( );
	void AppendContextsToURL ( );
	void AppendPropertiesToURL ( );
	void AppendDataBindingsToURL ( );
	void GetQoSAdvertisedStringSettings ( );
	void GetQoSAdvertisedProperties ( );
	void GetRangedPropertyValue ( );
	void SetRangedPropertyValue ( );
	void GetPropertyRange ( );
	void GetPropertyMappingType ( );
	void HasStringSetting ( );
	void HasProperty ( );
	void UpdateProperties ( );
	void UpdateStringSettings ( );
	void GetPropertyType ( );
	void GetPropertyValueId ( );
	void SetPropertyValueId ( );
	void GetStringProperty ( );
	void SetStringProperty ( );
	void GetIntProperty ( );
	void SetIntProperty ( );
	void GetFloatProperty ( );
	void SetFloatProperty ( );
	void SetPropertyFromStringByName ( );
	void GetPropertyAsStringByName ( );
	void GetPropertyAsString ( );
	void GetPropertyColumnHeader ( );
	void GetPropertyName ( );
	void GetPropertyId ( );
	void SetStringSettingValueFromStringByName ( );
	void GetStringSettingValueNameByName ( );
	void GetStringSettingValueName ( );
	void IsWildcardStringSetting ( );
	void GetStringSettingColumnHeader ( );
	void GetStringSettingName ( );
	void GetStringSettingId ( );
	void GetStringSettingValueByName ( );
	void SetStringSettingValueByName ( );
	void GetStringSettingValueNames ( );
	void IncrementStringSettingValue ( );
	void GetStringSettingValue ( );
	void SetStringSettingValue ( );
	void GetSettingsDataDateTime ( );
	void GetSettingsDataBlob ( );
	void GetSettingsDataInt ( );
	void GetSettingsDataFloat ( );
	void EmptySettingsData ( );
	void SetSettingsData ( );
	void SetSettingsDataBlob ( );
	void SetSettingsDataDateTime ( );
	void SetSettingsDataInt ( );
	void SetSettingsDataFloat ( );
};

UClass* USettings::pClassPointer = NULL;

// Class Engine.OnlineGameSearch
// 0x00CC (0x016C - 0x00A0)
class UOnlineGameSearch : public USettings
{
public:
	int                                                MaxSearchResults;                                 		// 0x00A0 (0x0004) [0x0000000000000000]              
	struct FLocalizedStringSetting                     Query;                                            		// 0x00A4 (0x000C) [0x0000000000000000]              
	DWORD                                              bIsLanQuery : 1;                                  		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUsesArbitration : 1;                             		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIsSearchInProgress : 1;                          		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000004] 
	class UClass*                                      GameSettingsClass;                                		// 0x00B4 (0x0008) [0x0000000000000000]              
	TArray< struct FOnlineGameSearchResult >           Results;                                          		// 0x00BC (0x0010) [0x0000000000000000]              
	struct FOverrideSkill                              ManualSkillOverride;                              		// 0x00CC (0x0034) [0x0000000000000000]              
	TArray< struct FNamedObjectProperty >              NamedProperties;                                  		// 0x0100 (0x0010) [0x0000000000000000]              
	struct FOnlineGameSearchQuery                      FilterQuery;                                      		// 0x0110 (0x0020) [0x0000000000000000]              
	TArray< struct FString >                           MasterServerSearchKeys;                           		// 0x0130 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           MasterServerSearchValues;                         		// 0x0140 (0x0010) [0x0000000000000000]              
	struct FString                                     AdditionalSearchCriteria;                         		// 0x0150 (0x0010) [0x0000000000000000]              
	int                                                PingBucketSize;                                   		// 0x0160 (0x0004) [0x0000000000000000]              
	int                                                NumPingProbes;                                    		// 0x0164 (0x0004) [0x0000000000000000]              
	int                                                MaxPingBytes;                                     		// 0x0168 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineGameSearch" );

		return pClassPointer;
	};

	void GetGametagStringBool ( );
	void GetGametagString ( );
	void AddGametagFilter ( );
	void TestAddBoolGametagFilter ( );
	void TestAddServerFilter ( );
	void AddServerFilter ( );
	void ClearServerFilters ( );
	void eventGetNamedProperty ( );
	void eventSetNamedProperty ( );
	void eventSortSearchResults ( );
	void SetSkillOverride ( );
};

UClass* UOnlineGameSearch::pClassPointer = NULL;

// Class Engine.OnlineGameSettings
// 0x00F8 (0x0198 - 0x00A0)
class UOnlineGameSettings : public USettings
{
public:
	int                                                NumPublicConnections;                             		// 0x00A0 (0x0004) [0x0000000000000000]              
	int                                                NumPrivateConnections;                            		// 0x00A4 (0x0004) [0x0000000000000000]              
	int                                                NumOpenPublicConnections;                         		// 0x00A8 (0x0004) [0x0000000000000000]              
	int                                                NumOpenPrivateConnections;                        		// 0x00AC (0x0004) [0x0000000000000000]              
	struct FQWord                                      ServerNonce;                                      		// 0x00B0 (0x0008) [0x0000000000000000]              
	struct FString                                     JoinString;                                       		// 0x00B8 (0x0010) [0x0000000000000000]              
	struct FString                                     ServiceConfigId;                                  		// 0x00C8 (0x0010) [0x0000000000000000]              
	struct FString                                     SessionTemplateName;                              		// 0x00D8 (0x0010) [0x0000000000000000]              
	struct FString                                     MatchHopperName;                                  		// 0x00E8 (0x0010) [0x0000000000000000]              
	struct FString                                     SessionGuid;                                      		// 0x00F8 (0x0010) [0x0000000000000000]              
	struct FString                                     SessionHandle;                                    		// 0x0108 (0x0010) [0x0000000000000000]              
	TArray< struct FUniqueNetId >                      ReservedMembers;                                  		// 0x0118 (0x0010) [0x0000000000000000]              
	DWORD                                              bShouldAdvertise : 1;                             		// 0x0128 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIsLanMatch : 1;                                  		// 0x0128 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUsesStats : 1;                                   		// 0x0128 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bAllowJoinInProgress : 1;                         		// 0x0128 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bAllowInvites : 1;                                		// 0x0128 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bUsesPresence : 1;                                		// 0x0128 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bAllowJoinViaPresence : 1;                        		// 0x0128 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bAllowJoinViaPresenceFriendsOnly : 1;             		// 0x0128 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bUsesArbitration : 1;                             		// 0x0128 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bAntiCheatProtected : 1;                          		// 0x0128 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bWasFromInvite : 1;                               		// 0x0128 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bIsDedicated : 1;                                 		// 0x0128 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bHasSkillUpdateInProgress : 1;                    		// 0x0128 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bShouldShrinkArbitratedSessions : 1;              		// 0x0128 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bRequiresPassword : 1;                            		// 0x0128 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bCloudServer : 1;                                 		// 0x0128 (0x0004) [0x0000000000000000] [0x00008000] 
	struct FString                                     OwningPlayerName;                                 		// 0x012C (0x0010) [0x0000000000000000]              
	struct FUniqueNetId                                OwningPlayerId;                                   		// 0x013C (0x0008) [0x0000000000000000]              
	int                                                PingInMs;                                         		// 0x0144 (0x0004) [0x0000000000000000]              
	float                                              MatchQuality;                                     		// 0x0148 (0x0004) [0x0000000000000000]              
	unsigned char                                      GameState;                                        		// 0x014C (0x0001) [0x0000000000000000]              
	int                                                BuildUniqueId;                                    		// 0x0150 (0x0004) [0x0000000000000000]              
	struct FString                                     LobbyId;                                          		// 0x0154 (0x0010) [0x0000000000000000]              
	int                                                GfxID;                                            		// 0x0164 (0x0004) [0x0000000000000000]              
	int                                                ElementIdx;                                       		// 0x0168 (0x0004) [0x0000000000000000]              
	int                                                SecondsDeallocated;                               		// 0x016C (0x0004) [0x0000000000000000]              
	int                                                SecondsDeallocatedBucket;                         		// 0x0170 (0x0004) [0x0000000000000000]              
	int                                                SecondsDeallocatedBucketSize;                     		// 0x0174 (0x0004) [0x0000000000000000]              
	struct FString                                     Region;                                           		// 0x0178 (0x0010) [0x0000000000000000]              
	TArray< struct FPlayerResult >                     PlayersInGame;                                    		// 0x0188 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineGameSettings" );

		return pClassPointer;
	};

};

UClass* UOnlineGameSettings::pClassPointer = NULL;

// Class Engine.ShaderCache
// 0x005C (0x00BC - 0x0060)
class UShaderCache : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0x5C ];                            		// 0x0060 (0x005C) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ShaderCache" );

		return pClassPointer;
	};

};

UClass* UShaderCache::pClassPointer = NULL;

// Class Engine.ShadowMap1D
// 0x005C (0x00BC - 0x0060)
class UShadowMap1D : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0x5C ];                            		// 0x0060 (0x005C) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ShadowMap1D" );

		return pClassPointer;
	};

};

UClass* UShadowMap1D::pClassPointer = NULL;

// Class Engine.ShadowMap2D
// 0x0038 (0x0098 - 0x0060)
class UShadowMap2D : public UObject
{
public:
	class UShadowMapTexture2D*                         Texture;                                          		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   CoordinateScale;                                  		// 0x0068 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   CoordinateBias;                                   		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FGuid                                       LightGuid;                                        		// 0x0078 (0x0010) [0x0000000000000000]              
	DWORD                                              bIsShadowFactorTexture : 1;                       		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 
	class UInstancedStaticMeshComponent*               Component;                                        		// 0x008C (0x0008) [0x0000000000000000]              
	int                                                InstanceIndex;                                    		// 0x0094 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ShadowMap2D" );

		return pClassPointer;
	};

};

UClass* UShadowMap2D::pClassPointer = NULL;

// Class Engine.SmokeTestCommandlet
// 0x0000 (0x00B4 - 0x00B4)
class USmokeTestCommandlet : public UCommandlet
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SmokeTestCommandlet" );

		return pClassPointer;
	};

};

UClass* USmokeTestCommandlet::pClassPointer = NULL;

// Class Engine.SpeechRecognition
// 0x00B0 (0x0110 - 0x0060)
class USpeechRecognition : public UObject
{
public:
	struct FString                                     Language;                                         		// 0x0060 (0x0010) [0x0000000000000000]              
	float                                              ConfidenceThreshhold;                             		// 0x0070 (0x0004) [0x0000000000000000]              
	TArray< struct FRecogVocabulary >                  Vocabularies;                                     		// 0x0074 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            VoiceData;                                        		// 0x0084 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            WorkingVoiceData;                                 		// 0x0094 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            UserData;                                         		// 0x00A4 (0x0010) [0x0000000000000000]              
	struct FRecogUserData                              InstanceData[ 0x4 ];                              		// 0x00B4 (0x0050) [0x0000000000000000]              
	DWORD                                              bDirty : 1;                                       		// 0x0104 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bInitialised : 1;                                 		// 0x0104 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FPointer                                    FnxVoiceData;                                     		// 0x0108 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SpeechRecognition" );

		return pClassPointer;
	};

};

UClass* USpeechRecognition::pClassPointer = NULL;

// Class Engine.StaticMesh
// 0x01C0 (0x0220 - 0x0060)
class UStaticMesh : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0x10 ];                            		// 0x0060 (0x0010) MISSED OFFSET
	TArray< struct FStaticMeshLODInfo >                LODInfo;                                          		// 0x0070 (0x0010) [0x0000000000000000]              
	float                                              LODDistanceRatio;                                 		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              LODMaxRange;                                      		// 0x0084 (0x0004) [0x0000000000000000]              
	class UFlexAsset*                                  FlexAsset;                                        		// 0x0088 (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x10 ];                            		// 0x0090 (0x0010) MISSED OFFSET
	int                                                LightMapResolution;                               		// 0x00A0 (0x0004) [0x0000000000000000]              
	int                                                LightMapCoordinateIndex;                          		// 0x00A4 (0x0004) [0x0000000000000000]              
	int                                                SplatterMapCoordinateIndex;                  			// 0x00A8 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x5C ];                            		// 0x00AC (0x005C) MISSED OFFSET
	class URB_BodySetup*                               BodySetup;                                        		// 0x0108 (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData03[ 0x4C ];                            		// 0x0110 (0x004C) MISSED OFFSET
	DWORD                                              UseSimpleLineCollision : 1;                       		// 0x015C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              UseSimpleBoxCollision : 1;                        		// 0x0160 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              UseSimpleRigidBodyCollision : 1;                  		// 0x0164 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              UseFullPrecisionUVs : 1;                          		// 0x0168 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUsedForInstancing : 1;                           		// 0x016C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIgnoreForVisibilityCollision : 1;                		// 0x0170 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                ConsolePreallocateInstanceCount;                  		// 0x0174 (0x0004) [0x0000000000000000]              
	DWORD                                              bUseMaximumStreamingTexelRatio : 1;               		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPartitionForEdgeGeometry : 1;                    		// 0x017C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bCanBecomeDynamic : 1;                            		// 0x0180 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      UnknownData04[ 0x4 ];                             		// 0x0184 (0x0004) MISSED OFFSET
	DWORD                                              bStripComplexCollisionForConsole : 1;             		// 0x0188 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPerLODStaticLightingForInstancing : 1;           		// 0x018C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              StreamingDistanceMultiplier;                      		// 0x0190 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData05[ 0x28 ];                            		// 0x0194 (0x0028) MISSED OFFSET
	class UInstancedFoliageSettings*                   FoliageDefaultSettings;                           		// 0x01BC (0x0008) [0x0000000000000000]              
	struct FString                                     SourceFilePath;                                   		// 0x01C4 (0x0010) [0x0000000000000000]              
	struct FString                                     SourceFileTimestamp;                              		// 0x01D4 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData06[ 0x1C ];                            		// 0x01E4 (0x001C) MISSED OFFSET
	unsigned char                                      FlexCollision;                                    		// 0x0200 (0x0001) [0x0000000000000000]              
	unsigned char                                      UnknownData07[ 0x1F ];                            		// 0x0201 (0x001F) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.StaticMesh" );

		return pClassPointer;
	};

};

UClass* UStaticMesh::pClassPointer = NULL;

// Class Engine.Surface
// 0x0000 (0x0060 - 0x0060)
class USurface : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Surface" );

		return pClassPointer;
	};

	void GetSurfaceHeight ( );
	void GetSurfaceWidth ( );
};

UClass* USurface::pClassPointer = NULL;

// Class Engine.MaterialInterface
// 0x0204 (0x0264 - 0x0060)
class UMaterialInterface : public USurface
{
public:
	struct FRenderCommandFence_Mirror                  ParentRefFence;                                   		// 0x0060 (0x0004) [0x0000000000000000]              
	struct FLightmassMaterialInterfaceSettings         LightmassSettings;                                		// 0x0064 (0x001C) [0x0000000000000000]              
	struct FString                                     PreviewMesh;                                      		// 0x0080 (0x0010) [0x0000000000000000]              
	struct FGuid                                       LightingGuid;                                     		// 0x0090 (0x0010) [0x0000000000000000]              
	DWORD                                              bHasQualitySwitch : 1;                            		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAutoFlattenMobile : 1;                           		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAutoFlattenMobileNormalTexture : 1;              		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bMobileAllowFog : 1;                              		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bGenerateSubUV : 1;                               		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bUseMobileSpecular : 1;                           		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bUseMobileVertexSpecular : 1;                     		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bUseMobilePixelSpecular : 1;                      		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bUseMobileBumpOffset : 1;                         		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bLockColorBlending : 1;                           		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bUseMobileUniformColorMultiply : 1;               		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bUseMobileVertexColorMultiply : 1;                		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bUseMobileDetailNormal : 1;                       		// 0x00A0 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bBaseTextureTransformed : 1;                      		// 0x00A0 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bEmissiveTextureTransformed : 1;                  		// 0x00A0 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bNormalTextureTransformed : 1;                    		// 0x00A0 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bMaskTextureTransformed : 1;                      		// 0x00A0 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bDetailTextureTransformed : 1;                    		// 0x00A0 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bUseMobileWaveVertexMovement : 1;                 		// 0x00A0 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bMobileEnableBounceLight : 1;                     		// 0x00A0 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bUseMobileLandscapeMonochromeLayerBlending : 1;   		// 0x00A0 (0x0004) [0x0000000000000000] [0x00100000] 
	struct FColor                                      FlattenBackgroundColor;                           		// 0x00A4 (0x0004) [0x0000000000000000]              
	class UTexture*                                    MobileBaseTexture;                                		// 0x00A8 (0x0008) [0x0000000000000000]              
	class UTexture*                                    FlattenedTexture;                                 		// 0x00B0 (0x0008) [0x0000000000000000]              
	unsigned char                                      MobileBaseTextureTexCoordsSource;                 		// 0x00B8 (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileAmbientOcclusionSource;                     		// 0x00B9 (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileSpecularMask;                               		// 0x00BA (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileEmissiveColorSource;                        		// 0x00BB (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileEmissiveMaskSource;                         		// 0x00BC (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileEnvironmentMaskSource;                      		// 0x00BD (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileEnvironmentBlendMode;                       		// 0x00BE (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileRimLightingMaskSource;                      		// 0x00BF (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileMaskTextureTexCoordsSource;                 		// 0x00C0 (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileAlphaValueSource;                           		// 0x00C1 (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileDetailTextureTexCoordsSource;               		// 0x00C2 (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileTextureBlendFactorSource;                   		// 0x00C3 (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileColorMultiplySource;                        		// 0x00C4 (0x0001) [0x0000000000000000]              
	class UTexture*                                    MobileNormalTexture;                              		// 0x00C8 (0x0008) [0x0000000000000000]              
	float                                              SubUVFrameRate;                                   		// 0x00D0 (0x0004) [0x0000000000000000]              
	int                                                SubUVFrameCountAlongAxes;                         		// 0x00D4 (0x0004) [0x0000000000000000]              
	float                                              SubUVFrameSize;                                   		// 0x00D8 (0x0004) [0x0000000000000000]              
	struct FLinearColor                                MobileSpecularColor;                              		// 0x00DC (0x0010) [0x0000000000000000]              
	float                                              MobileSpecularPower;                              		// 0x00EC (0x0004) [0x0000000000000000]              
	class UTexture*                                    MobileEmissiveTexture;                            		// 0x00F0 (0x0008) [0x0000000000000000]              
	struct FLinearColor                                MobileEmissiveColor;                              		// 0x00F8 (0x0010) [0x0000000000000000]              
	class UTexture*                                    MobileEnvironmentTexture;                         		// 0x0108 (0x0008) [0x0000000000000000]              
	float                                              MobileEnvironmentAmount;                          		// 0x0110 (0x0004) [0x0000000000000000]              
	struct FLinearColor                                MobileEnvironmentColor;                           		// 0x0114 (0x0010) [0x0000000000000000]              
	float                                              MobileEnvironmentFresnelAmount;                   		// 0x0124 (0x0004) [0x0000000000000000]              
	float                                              MobileEnvironmentFresnelExponent;                 		// 0x0128 (0x0004) [0x0000000000000000]              
	float                                              MobileRimLightingStrength;                        		// 0x012C (0x0004) [0x0000000000000000]              
	float                                              MobileRimLightingExponent;                        		// 0x0130 (0x0004) [0x0000000000000000]              
	struct FLinearColor                                MobileRimLightingColor;                           		// 0x0134 (0x0010) [0x0000000000000000]              
	float                                              MobileBumpOffsetReferencePlane;                   		// 0x0144 (0x0004) [0x0000000000000000]              
	float                                              MobileBumpOffsetHeightRatio;                      		// 0x0148 (0x0004) [0x0000000000000000]              
	class UTexture*                                    MobileMaskTexture;                                		// 0x014C (0x0008) [0x0000000000000000]              
	float                                              MobileOpacityMultiplier;                          		// 0x0154 (0x0004) [0x0000000000000000]              
	class UTexture*                                    MobileDetailTexture;                              		// 0x0158 (0x0008) [0x0000000000000000]              
	class UTexture*                                    MobileDetailTexture2;                             		// 0x0160 (0x0008) [0x0000000000000000]              
	class UTexture*                                    MobileDetailTexture3;                             		// 0x0168 (0x0008) [0x0000000000000000]              
	struct FLinearColor                                DefaultUniformColor;                              		// 0x0170 (0x0010) [0x0000000000000000]              
	struct FLinearColor                                MobileDefaultUniformColor;                        		// 0x0180 (0x0010) [0x0000000000000000]              
	float                                              TransformCenterX;                                 		// 0x0190 (0x0004) [0x0000000000000000]              
	float                                              MobileTransformCenterX;                           		// 0x0194 (0x0004) [0x0000000000000000]              
	float                                              TransformCenterY;                                 		// 0x0198 (0x0004) [0x0000000000000000]              
	float                                              MobileTransformCenterY;                           		// 0x019C (0x0004) [0x0000000000000000]              
	float                                              PannerSpeedX;                                     		// 0x01A0 (0x0004) [0x0000000000000000]              
	float                                              MobilePannerSpeedX;                               		// 0x01A4 (0x0004) [0x0000000000000000]              
	float                                              PannerSpeedY;                                     		// 0x01A8 (0x0004) [0x0000000000000000]              
	float                                              MobilePannerSpeedY;                               		// 0x01AC (0x0004) [0x0000000000000000]              
	float                                              RotateSpeed;                                      		// 0x01B0 (0x0004) [0x0000000000000000]              
	float                                              MobileRotateSpeed;                                		// 0x01B4 (0x0004) [0x0000000000000000]              
	float                                              FixedScaleX;                                      		// 0x01B8 (0x0004) [0x0000000000000000]              
	float                                              MobileFixedScaleX;                                		// 0x01BC (0x0004) [0x0000000000000000]              
	float                                              FixedScaleY;                                      		// 0x01C0 (0x0004) [0x0000000000000000]              
	float                                              MobileFixedScaleY;                                		// 0x01C4 (0x0004) [0x0000000000000000]              
	float                                              SineScaleX;                                       		// 0x01C8 (0x0004) [0x0000000000000000]              
	float                                              MobileSineScaleX;                                 		// 0x01CC (0x0004) [0x0000000000000000]              
	float                                              SineScaleY;                                       		// 0x01D0 (0x0004) [0x0000000000000000]              
	float                                              MobileSineScaleY;                                 		// 0x01D4 (0x0004) [0x0000000000000000]              
	float                                              SineScaleFrequencyMultipler;                      		// 0x01D8 (0x0004) [0x0000000000000000]              
	float                                              MobileSineScaleFrequencyMultipler;                		// 0x01DC (0x0004) [0x0000000000000000]              
	float                                              FixedOffsetX;                                     		// 0x01E0 (0x0004) [0x0000000000000000]              
	float                                              MobileFixedOffsetX;                               		// 0x01E4 (0x0004) [0x0000000000000000]              
	float                                              FixedOffsetY;                                     		// 0x01E8 (0x0004) [0x0000000000000000]              
	float                                              MobileFixedOffsetY;                               		// 0x01EC (0x0004) [0x0000000000000000]              
	float                                              MobileTangentVertexFrequencyMultiplier;           		// 0x01F0 (0x0004) [0x0000000000000000]              
	float                                              MobileVerticalFrequencyMultiplier;                		// 0x01F4 (0x0004) [0x0000000000000000]              
	float                                              MobileMaxVertexMovementAmplitude;                 		// 0x01F8 (0x0004) [0x0000000000000000]              
	float                                              MobileSwayFrequencyMultiplier;                    		// 0x01FC (0x0004) [0x0000000000000000]              
	float                                              MobileSwayMaxAngle;                               		// 0x0200 (0x0004) [0x0000000000000000]              
	struct FVector                                     MobileDirectionalLightDirection;                  		// 0x0204 (0x000C) [0x0000000000000000]              
	float                                              MobileDirectionalLightBrightness;                 		// 0x0210 (0x0004) [0x0000000000000000]              
	struct FColor                                      MobileDirectionalLightColor;                      		// 0x0214 (0x0004) [0x0000000000000000]              
	struct FVector                                     MobileBounceLightDirection;                       		// 0x0218 (0x000C) [0x0000000000000000]              
	float                                              MobileBounceLightBrightness;                      		// 0x0224 (0x0004) [0x0000000000000000]              
	struct FColor                                      MobileBounceLightColor;                           		// 0x0228 (0x0004) [0x0000000000000000]              
	float                                              MobileSkyLightBrightness;                         		// 0x022C (0x0004) [0x0000000000000000]              
	struct FColor                                      MobileSkyLightColor;                              		// 0x0230 (0x0004) [0x0000000000000000]              
	struct FName                                       MobileLandscapeLayerNames[ 0x4 ];                 		// 0x0234 (0x0020) [0x0000000000000000]              
	struct FColor                                      MobileLandscapeMonochomeLayerColors[ 0x4 ];       		// 0x0254 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialInterface" );

		return pClassPointer;
	};

	void SetForceMipLevelsToBeResident ( );
	void GetMobileVectorParameterValue ( );
	void GetMobileTextureParameterValue ( );
	void GetMobileScalarParameterValue ( );
	void GetGroupName ( );
	void GetLinearColorCurveParameterValue ( );
	void GetLinearColorParameterValue ( );
	void GetVectorCurveParameterValue ( );
	void GetVectorParameterValue ( );
	void GetTextureParameterValue ( );
	void GetScalarCurveParameterValue ( );
	void GetScalarParameterValue ( );
	void GetFontParameterValue ( );
	void GetParameterDesc ( );
	void GetPhysicalMaterial ( );
	void GetMaterial ( );
};

UClass* UMaterialInterface::pClassPointer = NULL;

// Class Engine.RB_BodySetup
// 0x0060 (0x0128 - 0x00C8)
class URB_BodySetup : public UKMeshProps
{
public:
	unsigned char                                      SleepFamily;                                      		// 0x00C8 (0x0001) [0x0000000000000000]              
	struct FName                                       BoneName;                                         		// 0x00CC (0x0008) [0x0000000000000000]              
	DWORD                                              bFixed : 1;                                       		// 0x00D4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bNoCollision : 1;                                 		// 0x00D4 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bBlockZeroExtent : 1;                             		// 0x00D4 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bBlockNonZeroExtent : 1;                          		// 0x00D4 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bEnableContinuousCollisionDetection : 1;          		// 0x00D4 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bAlwaysFullAnimWeight : 1;                        		// 0x00D4 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bConsiderForBounds : 1;                           		// 0x00D4 (0x0004) [0x0000000000000000] [0x00000040] 
	class UPhysicalMaterial*                           PhysMaterial;                                     		// 0x00D8 (0x0008) [0x0000000000000000]              
	float                                              MassScale;                                        		// 0x00E0 (0x0004) [0x0000000000000000]              
	TArray< struct FPointer >                          CollisionGeom;                                    		// 0x00E4 (0x0010) [0x0000000000000000]              
	TArray< struct FVector >                           CollisionGeomScale3D;                             		// 0x00F4 (0x0010) [0x0000000000000000]              
	TArray< struct FVector >                           PreCachedPhysScale;                               		// 0x0104 (0x0010) [0x0000000000000000]              
	struct FKCachedConvexData                          PreCachedPhysData;                                		// 0x0114 (0x0010) [0x0000000000000000]              
	int                                                PreCachedPhysDataVersion;                         		// 0x0124 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_BodySetup" );

		return pClassPointer;
	};

};

UClass* URB_BodySetup::pClassPointer = NULL;

// Class Engine.InstancedFoliageSettings
// 0x0068 (0x00C8 - 0x0060)
class UInstancedFoliageSettings : public UObject
{
public:
	float                                              Density;                                          		// 0x0060 (0x0004) [0x0000000000000000]              
	float                                              Radius;                                           		// 0x0064 (0x0004) [0x0000000000000000]              
	float                                              ScaleMinX;                                        		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              ScaleMinY;                                        		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              ScaleMinZ;                                        		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              ScaleMaxX;                                        		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              ScaleMaxY;                                        		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              ScaleMaxZ;                                        		// 0x007C (0x0004) [0x0000000000000000]              
	DWORD                                              LockScaleX : 1;                                   		// 0x0080 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              LockScaleY : 1;                                   		// 0x0080 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              LockScaleZ : 1;                                   		// 0x0080 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              AlignToNormal : 1;                                		// 0x0080 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              RandomYaw : 1;                                    		// 0x0080 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              UniformScale : 1;                                 		// 0x0080 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              ReapplyDensity : 1;                               		// 0x0080 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              ReapplyRadius : 1;                                		// 0x0080 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              ReapplyAlignToNormal : 1;                         		// 0x0080 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              ReapplyRandomYaw : 1;                             		// 0x0080 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              ReapplyScaleX : 1;                                		// 0x0080 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              ReapplyScaleY : 1;                                		// 0x0080 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              ReapplyScaleZ : 1;                                		// 0x0080 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              ReapplyRandomPitchAngle : 1;                      		// 0x0080 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              ReapplyGroundSlope : 1;                           		// 0x0080 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              ReapplyHeight : 1;                                		// 0x0080 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              ReapplyLandscapeLayer : 1;                        		// 0x0080 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              ReapplyZOffset : 1;                               		// 0x0080 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              CastShadow : 1;                                   		// 0x0080 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bCastDynamicShadow : 1;                           		// 0x0080 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bCastStaticShadow : 1;                            		// 0x0080 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bSelfShadowOnly : 1;                              		// 0x0080 (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bNoModSelfShadow : 1;                             		// 0x0080 (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bAcceptsDynamicDominantLightShadows : 1;          		// 0x0080 (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bCastHiddenShadow : 1;                            		// 0x0080 (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bCastShadowAsTwoSided : 1;                        		// 0x0080 (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bAcceptsLights : 1;                               		// 0x0080 (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bAcceptsDynamicLights : 1;                        		// 0x0080 (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bUseOnePassLightingOnTranslucency : 1;            		// 0x0080 (0x0004) [0x0000000000000000] [0x10000000] 
	DWORD                                              bUsePrecomputedShadows : 1;                       		// 0x0080 (0x0004) [0x0000000000000000] [0x20000000] 
	DWORD                                              bCollideActors : 1;                               		// 0x0080 (0x0004) [0x0000000000000000] [0x40000000] 
	DWORD                                              bBlockActors : 1;                                 		// 0x0080 (0x0004) [0x0000000000000000] [0x80000000] 
	DWORD                                              bBlockNonZeroExtent : 1;                          		// 0x0084 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bBlockZeroExtent : 1;                             		// 0x0084 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              IsSelected : 1;                                   		// 0x0084 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              ShowNothing : 1;                                  		// 0x0084 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              ShowPaintSettings : 1;                            		// 0x0084 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              ShowInstanceSettings : 1;                         		// 0x0084 (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              AlignMaxAngle;                                    		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              RandomPitchAngle;                                 		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              GroundSlope;                                      		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              HeightMin;                                        		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              HeightMax;                                        		// 0x0098 (0x0004) [0x0000000000000000]              
	struct FName                                       LandscapeLayer;                                   		// 0x009C (0x0008) [0x0000000000000000]              
	float                                              ZOffsetMin;                                       		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              ZOffsetMax;                                       		// 0x00A8 (0x0004) [0x0000000000000000]              
	int                                                MaxInstancesPerCluster;                           		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              MaxClusterRadius;                                 		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              ReapplyDensityAmount;                             		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                StartCullDistance;                                		// 0x00B8 (0x0004) [0x0000000000000000]              
	int                                                EndCullDistance;                                  		// 0x00BC (0x0004) [0x0000000000000000]              
	unsigned char                                      CullOption;                                       		// 0x00C0 (0x0001) [0x0000000000000000]              
	unsigned char                                      DetailMode;                                       		// 0x00C1 (0x0001) [0x0000000000000000]              
	int                                                DisplayOrder;                                     		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InstancedFoliageSettings" );

		return pClassPointer;
	};

};

UClass* UInstancedFoliageSettings::pClassPointer = NULL;

// Class Engine.FlexAsset
// 0x00C0 (0x0120 - 0x0060)
class UFlexAsset : public UObject
{
public:
	unsigned char                                      Type;                                             		// 0x0060 (0x0001) [0x0000000000000000]              
	class UFlexContainer*                              FlexAssetContainerTemplate;                       		// 0x0064 (0x0008) [0x0000000000000000]              
	int                                                FlexAssetPhaseId;                                 		// 0x006C (0x0004) [0x0000000000000000]              
	DWORD                                              bFlexAssetAutoAssignPhase : 1;                    		// 0x0070 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnableInflatable : 1;                            		// 0x0070 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              Mass;                                             		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              StretchStiffness;                                 		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              BendStiffness;                                    		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              TetherStiffness;                                  		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              TetherGive;                                       		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              OverPressure;                                     		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              RigidStiffness;                                   		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              RigidSamplingDistance;                            		// 0x0090 (0x0004) [0x0000000000000000]              
	struct FVector                                     RigidCenter;                                      		// 0x0094 (0x000C) [0x0000000000000000]              
	float                                              InflatableStiffness;                              		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              InflatableVolume;                                 		// 0x00A4 (0x0004) [0x0000000000000000]              
	TArray< struct FVector4 >                          Particles;                                        		// 0x00A8 (0x0010) [0x0000000000000000]              
	TArray< int >                                      Phases;                                           		// 0x00B8 (0x0010) [0x0000000000000000]              
	TArray< int >                                      SpringIndices;                                    		// 0x00C8 (0x0010) [0x0000000000000000]              
	TArray< float >                                    SpringCoefficients;                               		// 0x00D8 (0x0010) [0x0000000000000000]              
	TArray< float >                                    SpringRestLengths;                                		// 0x00E8 (0x0010) [0x0000000000000000]              
	TArray< int >                                      Triangles;                                        		// 0x00F8 (0x0010) [0x0000000000000000]              
	TArray< int >                                      VertexToParticleMap;                              		// 0x0108 (0x0010) [0x0000000000000000]              
	struct FPointer                                    Object;                                           		// 0x0118 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FlexAsset" );

		return pClassPointer;
	};

};

UClass* UFlexAsset::pClassPointer = NULL;

// Class Engine.FracturedStaticMesh
// 0x00F0 (0x0310 - 0x0220)
class UFracturedStaticMesh : public UStaticMesh
{
public:
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0220 (0x0008) MISSED OFFSET
	class UStaticMesh*                                 SourceCoreMesh;                                   		// 0x0228 (0x0008) [0x0000000000000000]              
	float                                              CoreMeshScale;                                    		// 0x0230 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x30 ];                            		// 0x0234 (0x0030) MISSED OFFSET
	DWORD                                              bSliceUsingCoreCollision : 1;                     		// 0x0264 (0x0004) [0x0000000000000000] [0x00000001] 
	class UParticleSystem*                             FragmentDestroyEffect;                            		// 0x0268 (0x0008) [0x0000000000000000]              
	TArray< class UParticleSystem* >                   FragmentDestroyEffects;                           		// 0x0270 (0x0010) [0x0000000000000000]              
	float                                              FragmentDestroyEffectScale;                       		// 0x0280 (0x0004) [0x0000000000000000]              
	float                                              FragmentHealthScale;                              		// 0x0284 (0x0004) [0x0000000000000000]              
	float                                              FragmentMinHealth;                                		// 0x0288 (0x0004) [0x0000000000000000]              
	float                                              FragmentMaxHealth;                                		// 0x028C (0x0004) [0x0000000000000000]              
	DWORD                                              bUniformFragmentHealth : 1;                       		// 0x0290 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              ChunkLinVel;                                      		// 0x0294 (0x0004) [0x0000000000000000]              
	float                                              ChunkAngVel;                                      		// 0x0298 (0x0004) [0x0000000000000000]              
	float                                              ChunkLinHorizontalScale;                          		// 0x029C (0x0004) [0x0000000000000000]              
	float                                              ExplosionVelScale;                                		// 0x02A0 (0x0004) [0x0000000000000000]              
	DWORD                                              bCompositeChunksExplodeOnImpact : 1;              		// 0x02A4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFixIsolatedChunks : 1;                           		// 0x02A8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAlwaysBreakOffIsolatedIslands : 1;               		// 0x02AC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSpawnPhysicsChunks : 1;                          		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              ChanceOfPhysicsChunk;                             		// 0x02B4 (0x0004) [0x0000000000000000]              
	float                                              ExplosionChanceOfPhysicsChunk;                    		// 0x02B8 (0x0004) [0x0000000000000000]              
	float                                              NormalPhysicsChunkScaleMin;                       		// 0x02BC (0x0004) [0x0000000000000000]              
	float                                              NormalPhysicsChunkScaleMax;                       		// 0x02C0 (0x0004) [0x0000000000000000]              
	float                                              ExplosionPhysicsChunkScaleMin;                    		// 0x02C4 (0x0004) [0x0000000000000000]              
	float                                              ExplosionPhysicsChunkScaleMax;                    		// 0x02C8 (0x0004) [0x0000000000000000]              
	float                                              MinConnectionSupportArea;                         		// 0x02CC (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          DynamicOutsideMaterial;                           		// 0x02D0 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          LoseChunkOutsideMaterial;                         		// 0x02D8 (0x0008) [0x0000000000000000]              
	int                                                OutsideMaterialIndex;                             		// 0x02E0 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x2C ];                            		// 0x02E4 (0x002C) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FracturedStaticMesh" );

		return pClassPointer;
	};

};

UClass* UFracturedStaticMesh::pClassPointer = NULL;

// Class Engine.ParticleSystem
// 0x0130 (0x0190 - 0x0060)
class UParticleSystem : public UObject
{
public:
	unsigned char                                      SystemUpdateMode;                                 		// 0x0060 (0x0001) [0x0000000000000000]              
	unsigned char                                      LODMethod;                                        		// 0x0061 (0x0001) [0x0000000000000000]              
	unsigned char                                      OcclusionBoundsMethod;                            		// 0x0062 (0x0001) [0x0000000000000000]              
	unsigned char                                      MinimumPhysXLevelExt;                             		// 0x0063 (0x0001) [0x0000000000000000]              
	unsigned char                                      MinimumPhysXLevelOverride;                        		// 0x0064 (0x0001) [0x0000000000000000]              
	float                                              UpdateTime_FPS;                                   		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              UpdateTime_Delta;                                 		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              WarmupTime;                                       		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              WarmupTickRate;                                   		// 0x0074 (0x0004) [0x0000000000000000]              
	TArray< class UParticleEmitter* >                  Emitters;                                         		// 0x0078 (0x0010) [0x0000000000000000]              
	class UParticleSystemComponent*                    PreviewComponent;                                 		// 0x0088 (0x0008) [0x0000000000000000]              
	struct FRotator                                    ThumbnailAngle;                                   		// 0x0090 (0x000C) [0x0000000000000000]              
	float                                              ThumbnailDistance;                                		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              ThumbnailWarmup;                                  		// 0x00A0 (0x0004) [0x0000000000000000]              
	DWORD                                              bLit : 1;                                         		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bOrientZAxisTowardCamera : 1;                     		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bRegenerateLODDuplicate : 1;                      		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUseFixedRelativeBoundingBox : 1;                 		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bShouldResetPeakCounts : 1;                       		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bHasPhysics : 1;                                  		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bUseRealtimeThumbnail : 1;                        		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              ThumbnailImageOutOfDate : 1;                      		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bSkipSpawnCountCheck : 1;                         		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bUseDelayRange : 1;                               		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000200] 
	class UInterpCurveEdSetup*                         CurveEdSetup;                                     		// 0x00A8 (0x0008) [0x0000000000000000]              
	float                                              LODDistanceCheckTime;                             		// 0x00B0 (0x0004) [0x0000000000000000]              
	TArray< float >                                    LODDistances;                                     		// 0x00B4 (0x0010) [0x0000000000000000]              
	int                                                EditorLODSetting;                                 		// 0x00C4 (0x0004) [0x0000000000000000]              
	TArray< struct FParticleSystemLOD >                LODSettings;                                      		// 0x00C8 (0x0010) [0x0000000000000000]              
	struct FBox                                        FixedRelativeBoundingBox;                         		// 0x00D8 (0x001C) [0x0000000000000000]              
	float                                              SecondsBeforeInactive;                            		// 0x00F4 (0x0004) [0x0000000000000000]              
	struct FString                                     FloorMesh;                                        		// 0x00F8 (0x0010) [0x0000000000000000]              
	struct FVector                                     FloorPosition;                                    		// 0x0108 (0x000C) [0x0000000000000000]              
	struct FRotator                                    FloorRotation;                                    		// 0x0114 (0x000C) [0x0000000000000000]              
	float                                              FloorScale;                                       		// 0x0120 (0x0004) [0x0000000000000000]              
	struct FVector                                     FloorScale3D;                                     		// 0x0124 (0x000C) [0x0000000000000000]              
	struct FColor                                      BackgroundColor;                                  		// 0x0130 (0x0004) [0x0000000000000000]              
	class UTexture2D*                                  ThumbnailImage;                                   		// 0x0134 (0x0008) [0x0000000000000000]              
	float                                              Delay;                                            		// 0x013C (0x0004) [0x0000000000000000]              
	float                                              DelayLow;                                         		// 0x0140 (0x0004) [0x0000000000000000]              
	struct FVector                                     MacroUVPosition;                                  		// 0x0144 (0x000C) [0x0000000000000000]              
	float                                              MacroUVRadius;                                    		// 0x0150 (0x0004) [0x0000000000000000]              
	struct FBox                                        CustomOcclusionBounds;                            		// 0x0154 (0x001C) [0x0000000000000000]              
	TArray< struct FLODSoloTrack >                     SoloTracking;                                     		// 0x0170 (0x0010) [0x0000000000000000]              
	class UParticleSystem*                             PhysxParticleSystemExtRef;                        		// 0x0180 (0x0008) [0x0000000000000000]              
	class UParticleSystem*                             PhysxParticleSystemRef;                           		// 0x0188 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleSystem" );

		return pClassPointer;
	};

	void GetMaxLifespan ( );
	void SetLODDistance ( );
	void SetCurrentLODMethod ( );
	void GetLODDistance ( );
	void GetLODLevelCount ( );
	void GetCurrentLODMethod ( );
	void EffectiveParticleSystemAfterPhysXExtension ( );
	void EffectiveParticleSystemAfterPhysXOverride ( );
};

UClass* UParticleSystem::pClassPointer = NULL;

// Class Engine.Texture
// 0x00D0 (0x0130 - 0x0060)
class UTexture : public USurface
{
public:
	DWORD                                              SRGB : 1;                                         		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              RGBE : 1;                                         		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIsSourceArtUncompressed : 1;                     		// 0x0060 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              CompressionNoAlpha : 1;                           		// 0x0060 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              CompressionNone : 1;                              		// 0x0060 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              CompressionNoMipmaps : 1;                         		// 0x0060 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              CompressionFullDynamicRange : 1;                  		// 0x0060 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              DeferCompression : 1;                             		// 0x0060 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              NeverStream : 1;                                  		// 0x0060 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bDitherMipMapAlpha : 1;                           		// 0x0060 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bPreserveBorderR : 1;                             		// 0x0060 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bPreserveBorderG : 1;                             		// 0x0060 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bPreserveBorderB : 1;                             		// 0x0060 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bPreserveBorderA : 1;                             		// 0x0060 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bNoTiling : 1;                                    		// 0x0060 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bForcePVRTC4 : 1;                                 		// 0x0060 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bAsyncResourceReleaseHasBeenStarted : 1;          		// 0x0060 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bUseCinematicMipLevels : 1;                       		// 0x0060 (0x0004) [0x0000000000000000] [0x00020000] 
	float                                              UnpackMin[ 0x4 ];                                 		// 0x0064 (0x0010) [0x0000000000000000]              
	float                                              UnpackMax[ 0x4 ];                                 		// 0x0074 (0x0010) [0x0000000000000000]              
	struct FUntypedBulkData_Mirror                     SourceArt;                                        		// 0x0084 (0x0040) [0x0000000000000000]              
	unsigned char                                      CompressionSettings;                              		// 0x00C4 (0x0001) [0x0000000000000000]              
	unsigned char                                      Filter;                                           		// 0x00C5 (0x0001) [0x0000000000000000]              
	unsigned char                                      LODGroup;                                         		// 0x00C6 (0x0001) [0x0000000000000000]              
	unsigned char                                      CachedLODGroup;                                   		// 0x00C7 (0x0001) [0x0000000000000000]              
	unsigned char                                      MipGenSettings;                                   		// 0x00C8 (0x0001) [0x0000000000000000]              
	int                                                LODBias;                                          		// 0x00CC (0x0004) [0x0000000000000000]              
	int                                                CachedCombinedLODBias;                            		// 0x00D0 (0x0004) [0x0000000000000000]              
	int                                                NumCinematicMipLevels;                            		// 0x00D4 (0x0004) [0x0000000000000000]              
	struct FString                                     SourceFilePath;                                   		// 0x00D8 (0x0010) [0x0000000000000000]              
	struct FString                                     SourceFileTimestamp;                              		// 0x00E8 (0x0010) [0x0000000000000000]              
	struct FPointer                                    Resource;                                         		// 0x00F8 (0x0008) [0x0000000000000000]              
	struct FGuid                                       LightingGuid;                                     		// 0x0100 (0x0010) [0x0000000000000000]              
	float                                              AdjustBrightness;                                 		// 0x0110 (0x0004) [0x0000000000000000]              
	float                                              AdjustBrightnessCurve;                            		// 0x0114 (0x0004) [0x0000000000000000]              
	float                                              AdjustVibrance;                                   		// 0x0118 (0x0004) [0x0000000000000000]              
	float                                              AdjustSaturation;                                 		// 0x011C (0x0004) [0x0000000000000000]              
	float                                              AdjustRGBCurve;                                   		// 0x0120 (0x0004) [0x0000000000000000]              
	float                                              AdjustHue;                                        		// 0x0124 (0x0004) [0x0000000000000000]              
	int                                                InternalFormatLODBias;                            		// 0x0128 (0x0004) [0x0000000000000000]              
	int                                                RequiredCreationFlags;                            		// 0x012C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Texture" );

		return pClassPointer;
	};

};

UClass* UTexture::pClassPointer = NULL;

// Class Engine.Texture2D
// 0x0110 (0x0240 - 0x0130)
class UTexture2D : public UTexture
{
public:
	struct FIndirectArray_Mirror                       Mips;                                             		// 0x0130 (0x0010) [0x0000000000000000]              
	struct FIndirectArray_Mirror                       CachedPVRTCMips;                                  		// 0x0140 (0x0010) [0x0000000000000000]              
	struct FIndirectArray_Mirror                       CachedATITCMips;                                  		// 0x0150 (0x0010) [0x0000000000000000]              
	struct FIndirectArray_Mirror                       CachedETCMips;                                    		// 0x0160 (0x0010) [0x0000000000000000]              
	int                                                CachedFlashMipsMaxResolution;                     		// 0x0170 (0x0004) [0x0000000000000000]              
	struct FUntypedBulkData_Mirror                     CachedFlashMips;                                  		// 0x0174 (0x0040) [0x0000000000000000]              
	int                                                SizeX;                                            		// 0x01B4 (0x0004) [0x0000000000000000]              
	int                                                SizeY;                                            		// 0x01B8 (0x0004) [0x0000000000000000]              
	int                                                OriginalSizeX;                                    		// 0x01BC (0x0004) [0x0000000000000000]              
	int                                                OriginalSizeY;                                    		// 0x01C0 (0x0004) [0x0000000000000000]              
	unsigned char                                      Format;                                           		// 0x01C4 (0x0001) [0x0000000000000000]              
	unsigned char                                      AddressX;                                         		// 0x01C5 (0x0001) [0x0000000000000000]              
	unsigned char                                      AddressY;                                         		// 0x01C6 (0x0001) [0x0000000000000000]              
	DWORD                                              bIsEditorOnly : 1;                                		// 0x01C8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIsStreamable : 1;                                		// 0x01C8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bHasCancelationPending : 1;                       		// 0x01C8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bHasBeenLoadedFromPersistentArchive : 1;          		// 0x01C8 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bForceMiplevelsToBeResident : 1;                  		// 0x01C8 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bGlobalForceMipLevelsToBeResident : 1;            		// 0x01C8 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bIsCompositingSource : 1;                         		// 0x01C8 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bHasBeenPaintedInEditor : 1;                      		// 0x01C8 (0x0004) [0x0000000000000000] [0x00000080] 
	float                                              ForceMipLevelsToBeResidentTimestamp;              		// 0x01CC (0x0004) [0x0000000000000000]              
	struct FName                                       TextureFileCacheName;                             		// 0x01D0 (0x0008) [0x0000000000000000]              
	struct FGuid                                       TextureFileCacheGuid;                             		// 0x01D8 (0x0010) [0x0000000000000000]              
	int                                                RequestedMips;                                    		// 0x01E8 (0x0004) [0x0000000000000000]              
	int                                                ResidentMips;                                     		// 0x01EC (0x0004) [0x0000000000000000]              
	int                                                MipsToRemoveOnCompress;                           		// 0x01F0 (0x0004) [0x0000000000000000]              
	struct FPointer                                    ReleaseTexture2DFence;                            		// 0x01F4 (0x0008) [0x0000000000000000]              
	struct FThreadSafeCounter                          PendingMipChangeRequestStatus;                    		// 0x01FC (0x0004) [0x0000000000000000]              
	TArray< unsigned char >                            SystemMemoryData;                                 		// 0x0200 (0x0010) [0x0000000000000000]              
	struct FTextureLinkedListMirror                    StreamableTexturesLink;                           		// 0x0210 (0x0018) [0x0000000000000000]              
	int                                                StreamingIndex;                                   		// 0x0228 (0x0004) [0x0000000000000000]              
	int                                                MipTailBaseIdx;                                   		// 0x022C (0x0004) [0x0000000000000000]              
	struct FPointer                                    ResourceMem;                                      		// 0x0230 (0x0008) [0x0000000000000000]              
	int                                                FirstResourceMemMip;                              		// 0x0238 (0x0004) [0x0000000000000000]              
	float                                              Timer;                                            		// 0x023C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Texture2D" );

		return pClassPointer;
	};

	void Create ( );
	void SetForceMipLevelsToBeResident ( );
};

UClass* UTexture2D::pClassPointer = NULL;

// Class Engine.LightMapTexture2D
// 0x0004 (0x0244 - 0x0240)
class ULightMapTexture2D : public UTexture2D
{
public:
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0240 (0x0004) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LightMapTexture2D" );

		return pClassPointer;
	};

};

UClass* ULightMapTexture2D::pClassPointer = NULL;

// Class Engine.ShadowMapTexture2D
// 0x0004 (0x0244 - 0x0240)
class UShadowMapTexture2D : public UTexture2D
{
public:
	int                                                ShadowmapFlags;                                   		// 0x0240 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ShadowMapTexture2D" );

		return pClassPointer;
	};

};

UClass* UShadowMapTexture2D::pClassPointer = NULL;

// Class Engine.TWSplatterMapTexture2D
// 0x0014 (0x0254 - 0x0240)
class UTWSplatterMapTexture2D : public UTexture2D
{
public:
	TArray< unsigned char >                            SystemMemoryCache;                                		// 0x0240 (0x0010) [0x0000000000000000]              
	DWORD                                              bDirty : 1;                                       		// 0x0250 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWSplatterMapTexture2D" );

		return pClassPointer;
	};

};

UClass* UTWSplatterMapTexture2D::pClassPointer = NULL;

// Class Engine.TranslationContext
// 0x0010 (0x0070 - 0x0060)
class UTranslationContext : public UObject
{
public:
	TArray< class UTranslatorTag* >                    TranslatorTags;                                   		// 0x0060 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TranslationContext" );

		return pClassPointer;
	};

	void RegisterTranslatorTag ( );
};

UClass* UTranslationContext::pClassPointer = NULL;

// Class Engine.TranslatorTag
// 0x0008 (0x0068 - 0x0060)
class UTranslatorTag : public UObject
{
public:
	struct FName                                       Tag;                                              		// 0x0060 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TranslatorTag" );

		return pClassPointer;
	};

	void Translate ( );
};

UClass* UTranslatorTag::pClassPointer = NULL;

// Class Engine.StringsTag
// 0x0000 (0x0068 - 0x0068)
class UStringsTag : public UTranslatorTag
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.StringsTag" );

		return pClassPointer;
	};

	void Translate ( );
};

UClass* UStringsTag::pClassPointer = NULL;

// Class Engine.TWFixupSplattermapUVCommandlet
// 0x0000 (0x00B4 - 0x00B4)
class UTWFixupSplattermapUVCommandlet : public UCommandlet
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWFixupSplattermapUVCommandlet" );

		return pClassPointer;
	};

	void eventMain ( );
};

UClass* UTWFixupSplattermapUVCommandlet::pClassPointer = NULL;

// Class Engine.TWGenerateLightmapUVCommandlet
// 0x0010 (0x00C4 - 0x00B4)
class UTWGenerateLightmapUVCommandlet : public UCommandlet
{
public:
	int                                                LightmapUVChannel;                                		// 0x00B4 (0x0004) [0x0000000000000000]              
	float                                              MinChartSpacingPercent;                           		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              BorderSpacingPercent;                             		// 0x00BC (0x0004) [0x0000000000000000]              
	DWORD                                              bUseMaxStretch : 1;                               		// 0x00C0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWGenerateLightmapUVCommandlet" );

		return pClassPointer;
	};

	void eventMain ( );
};

UClass* UTWGenerateLightmapUVCommandlet::pClassPointer = NULL;

// Class Engine.TWOnlineLobby
// 0x0000 (0x0060 - 0x0060)
class UTWOnlineLobby : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWOnlineLobby" );

		return pClassPointer;
	};

	void LobbyInvite ( );
	void GetLobbyFromCommandline ( );
	void GetCurrentLobbyId ( );
	void MakeLobby ( );
	void GetCurrentPartySize ( );
	void GetCurrentLobby ( );
	void LobbyMessage ( );
	void SendInviteToUsers ( );
	void ShowLobbyInviteInterface ( );
	void SetVisibility ( );
	void GetLobbyData ( );
	void SetLobbyData ( );
	void GetFriendNickname ( );
	void GetMyId ( );
	void GetLobbyAdmin ( );
	void QuitLobby ( );
	void IsLobbyOwner ( );
	void IsInLobby ( );
	void GetLobbyURLString ( );
	void SetServerPassword ( );
	void LobbyJoinServer ( );
	void LobbyJoinGame ( );
};

UClass* UTWOnlineLobby::pClassPointer = NULL;

// Class Engine.TWOnlineUGCInterface
// 0x0010 (0x0070 - 0x0060)
class UTWOnlineUGCInterface : public UObject
{
public:
	struct FScriptDelegate                             __UGCDownloadProgressDelegate__Delegate;          		// 0x0060 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0064 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWOnlineUGCInterface" );

		return pClassPointer;
	};

	void GetUGCForPackage ( );
	void ClearUGCDownloadProgressDelegate ( );
	void SetUGCDownloadProgressDelegate ( );
	void UGCDownloadProgressDelegate ( );
	void EnumerateWorkshopFiles ( );
};

UClass* UTWOnlineUGCInterface::pClassPointer = NULL;

// Class Engine.TWSplatterMap2D
// 0x0018 (0x0078 - 0x0060)
class UTWSplatterMap2D : public UObject
{
public:
	class UTWSplatterMapTexture2D*                     Texture;                                          		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   CoordinateScale;                                  		// 0x0068 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   CoordinateBias;                                   		// 0x0070 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWSplatterMap2D" );

		return pClassPointer;
	};

};

UClass* UTWSplatterMap2D::pClassPointer = NULL;

// Class Engine.UIRoot
// 0x0010 (0x0070 - 0x0060)
class UUIRoot : public UObject
{
public:
	TArray< struct FString >                           BadCapsLocContexts;                               		// 0x0060 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIRoot" );

		return pClassPointer;
	};

	void SafeCaps ( );
	void GetOnlinePlayerInterfaceEx ( );
	void GetOnlinePlayerInterface ( );
	void GetOnlineGameInterface ( );
	void StaticResolveDataStore ( );
	void GetSceneClient ( );
	void GetCurrentUIController ( );
	void GetInputPlatformType ( );
};

UClass* UUIRoot::pClassPointer = NULL;

// Class Engine.Interaction
// 0x0040 (0x00B0 - 0x0070)
class UInteraction : public UUIRoot
{
public:
	struct FScriptDelegate                             __OnReceivedNativeInputKey__Delegate;             		// 0x0070 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0074 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnReceivedNativeInputAxis__Delegate;            		// 0x0080 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x4 ];                             		// 0x0084 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnReceivedNativeInputChar__Delegate;            		// 0x0090 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x4 ];                             		// 0x0094 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnInitialize__Delegate;                         		// 0x00A0 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData03[ 0x4 ];                             		// 0x00A4 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Interaction" );

		return pClassPointer;
	};

	void NotifyPlayerRemoved ( );
	void NotifyPlayerAdded ( );
	void NotifyGameSessionEnded ( );
	void Initialized ( );
	void OnInitialize ( );
	void Init ( );
	void eventPostRender ( );
	void eventTick ( );
	void OnReceivedNativeInputChar ( );
	void OnReceivedNativeInputAxis ( );
	void OnReceivedNativeInputKey ( );
};

UClass* UInteraction::pClassPointer = NULL;

// Class Engine.UIInteraction
// 0x02B4 (0x0364 - 0x00B0)
class UUIInteraction : public UInteraction
{
public:
	struct FPointer                                    VfTable_FExec;                                    		// 0x00B0 (0x0008) [0x0000000000000000]              
	struct FPointer                                    VfTable_FGlobalDataStoreClientManager;            		// 0x00B8 (0x0008) [0x0000000000000000]              
	struct FPointer                                    VfTable_FCallbackEventDevice;                     		// 0x00C0 (0x0008) [0x0000000000000000]              
	class UUIManager*                                  UIManager;                                        		// 0x00C8 (0x0008) [0x0000000000000000]              
	class UClass*                                      UIManagerClass;                                   		// 0x00D0 (0x0008) [0x0000000000000000]              
	class UClass*                                      SceneClientClass;                                 		// 0x00D8 (0x0008) [0x0000000000000000]              
	class UGameUISceneClient*                          SceneClient;                                      		// 0x00E0 (0x0008) [0x0000000000000000]              
	TArray< struct FName >                             SupportedDoubleClickKeys;                         		// 0x00E8 (0x0010) [0x0000000000000000]              
	class UDataStoreClient*                            DataStoreManager;                                 		// 0x00F8 (0x0008) [0x0000000000000000]              
	DWORD                                              bProcessInput : 1;                                		// 0x0100 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              UIJoystickDeadZone;                               		// 0x0104 (0x0004) [0x0000000000000000]              
	float                                              UIAxisMultiplier;                                 		// 0x0108 (0x0004) [0x0000000000000000]              
	float                                              AxisRepeatDelay;                                  		// 0x010C (0x0004) [0x0000000000000000]              
	float                                              MouseButtonRepeatDelay;                           		// 0x0110 (0x0004) [0x0000000000000000]              
	float                                              DoubleClickTriggerSeconds;                        		// 0x0114 (0x0004) [0x0000000000000000]              
	int                                                DoubleClickPixelTolerance;                        		// 0x0118 (0x0004) [0x0000000000000000]              
	struct FUIKeyRepeatData                            MouseButtonRepeatInfo;                            		// 0x011C (0x0010) [0x0000000000000000]              
	TArray< struct FUIAxisEmulationDefinition >        ConfiguredAxisEmulationDefinitions;               		// 0x012C (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x013C (0x0048) UNKNOWN PROPERTY: MapProperty Engine.UIInteraction.AxisEmulationDefinitions
	struct FUIAxisEmulationData                        AxisInputEmulation[ 0x18 ];                       		// 0x0184 (0x01E0) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIInteraction" );

		return pClassPointer;
	};

	void NotifyGameSessionEnded ( );
	void eventGetNATType ( );
	void GetConnectedGamepadCount ( );
	void IsGamepadConnected ( );
	void GetNumGuestsLoggedIn ( );
	void GetLoggedInPlayerCount ( );
	void eventIsLoggedIn ( );
	void eventHasLinkConnection ( );
	void GetLowestLoginStatusOfControllers ( );
	void eventGetLoginStatus ( );
	void NotifyPlayerRemoved ( );
	void NotifyPlayerAdded ( );
	void GetLocalPlayer ( );
	void GetDataStoreClient ( );
	void GetPlayerControllerId ( );
	void GetPlayerIndex ( );
	void GetPlayerCount ( );
};

UClass* UUIInteraction::pClassPointer = NULL;

// Class Engine.UIManager
// 0x0000 (0x0060 - 0x0060)
class UUIManager : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIManager" );

		return pClassPointer;
	};

	void FindLocalPlayerIndex ( );
	void NotifyPlayerRemoved ( );
	void NotifyPlayerAdded ( );
	void eventPauseGame ( );
	void CanUnpauseInternalUI ( );
	void GetUIManager ( );
};

UClass* UUIManager::pClassPointer = NULL;

// Class Engine.WaveFormBase
// 0x0008 (0x0068 - 0x0060)
class UWaveFormBase : public UObject
{
public:
	class UForceFeedbackWaveform*                      TheWaveForm;                                      		// 0x0060 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.WaveFormBase" );

		return pClassPointer;
	};

};

UClass* UWaveFormBase::pClassPointer = NULL;

// Class Engine.World
// 0x0368 (0x03C8 - 0x0060)
class UWorld : public UObject
{
public:
	unsigned char                                      UnknownData00[ 0x368 ];                           		// 0x0060 (0x0368) MISSED OFFSET

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.World" );

		return pClassPointer;
	};

};

UClass* UWorld::pClassPointer = NULL;

// Class Engine.EnvironmentVolume
// 0x0014 (0x0294 - 0x0280)
class AEnvironmentVolume : public AVolume
{
public:
	struct FPointer                                    VfTable_IInterface_NavMeshPathObstacle;           		// 0x0280 (0x0008) [0x0000000000000000]              
	struct FPointer                                    VfTable_IInterface_NavMeshPathObject;             		// 0x0288 (0x0008) [0x0000000000000000]              
	DWORD                                              bSplitNavMesh : 1;                                		// 0x0290 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.EnvironmentVolume" );

		return pClassPointer;
	};

	void SetSplitNavMesh ( );
};

UClass* AEnvironmentVolume::pClassPointer = NULL;

// Class Engine.TestSplittingVolume
// 0x0008 (0x0288 - 0x0280)
class ATestSplittingVolume : public AVolume
{
public:
	struct FPointer                                    VfTable_IInterface_NavMeshPathObject;             		// 0x0280 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TestSplittingVolume" );

		return pClassPointer;
	};

};

UClass* ATestSplittingVolume::pClassPointer = NULL;

// Class Engine.AIController
// 0x0024 (0x045C - 0x0438)
class AAIController : public AController
{
public:
	float                                              Skill;                                            		// 0x0438 (0x0004) [0x0000000000000000]              
	class AActor*                                      ScriptedMoveTarget;                               		// 0x043C (0x0008) [0x0000000000000000]              
	class ARoute*                                      ScriptedRoute;                                    		// 0x0444 (0x0008) [0x0000000000000000]              
	DWORD                                              bReverseScriptedRoute : 1;                        		// 0x044C (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                ScriptedRouteIndex;                               		// 0x0450 (0x0004) [0x0000000000000000]              
	class AActor*                                      ScriptedFocus;                                    		// 0x0454 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AIController" );

		return pClassPointer;
	};

	void CanFireWeapon ( );
	void NotifyWeaponFinishedFiring ( );
	void NotifyWeaponFired ( );
	void OnAIMoveToActor ( );
	void eventGetPlayerViewPoint ( );
	void eventSetTeam ( );
	void DisplayDebug ( );
	void Reset ( );
	void eventAILog_Internal ( );
	void eventPreBeginPlay ( );
};

UClass* AAIController::pClassPointer = NULL;

// Class Engine.CrowdAgentBase
// 0x0008 (0x024C - 0x0244)
class ACrowdAgentBase : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;              		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CrowdAgentBase" );

		return pClassPointer;
	};

	void eventNotifyPathChanged ( );
};

UClass* ACrowdAgentBase::pClassPointer = NULL;

// Class Engine.CrowdPopulationManagerBase
// 0x0000 (0x0244 - 0x0244)
class ACrowdPopulationManagerBase : public AActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CrowdPopulationManagerBase" );

		return pClassPointer;
	};

};

UClass* ACrowdPopulationManagerBase::pClassPointer = NULL;

// Class Engine.PathTargetPoint
// 0x0000 (0x024C - 0x024C)
class APathTargetPoint : public AKeypoint
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PathTargetPoint" );

		return pClassPointer;
	};

	void ShouldBeHiddenBySHOW_NavigationNodes ( );
};

UClass* APathTargetPoint::pClassPointer = NULL;

// Class Engine.NavMeshObstacle
// 0x000C (0x0250 - 0x0244)
class ANavMeshObstacle : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavMeshPathObstacle;           		// 0x0244 (0x0008) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x024C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPreserveInternalGeo : 1;                         		// 0x024C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshObstacle" );

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void SetEnabled ( );
	void OnToggle ( );
	void PostBeginPlay ( );
	void UnRegisterObstacle ( );
	void RegisterObstacle ( );
	void eventGetObstacleBoudingShape ( );
};

UClass* ANavMeshObstacle::pClassPointer = NULL;

// Class Engine.PylonSeed
// 0x0008 (0x024C - 0x0244)
class APylonSeed : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavMeshPathObject;             		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PylonSeed" );

		return pClassPointer;
	};

};

UClass* APylonSeed::pClassPointer = NULL;

// Class Engine.CoverGroupRenderingComponent
// 0x0000 (0x0238 - 0x0238)
class UCoverGroupRenderingComponent : public UPrimitiveComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CoverGroupRenderingComponent" );

		return pClassPointer;
	};

};

UClass* UCoverGroupRenderingComponent::pClassPointer = NULL;

// Class Engine.MeshComponent
// 0x0010 (0x0248 - 0x0238)
class UMeshComponent : public UPrimitiveComponent
{
public:
	TArray< class UMaterialInterface* >                Materials;                                        		// 0x0238 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MeshComponent" );

		return pClassPointer;
	};

	void CreateAndSetMaterialInstanceTimeVarying ( );
	void CreateAndSetMaterialInstanceConstant ( );
	void PrestreamTextures ( );
	void GetNumElements ( );
	void SetMaterial ( );
	void GetMaterial ( );
};

UClass* UMeshComponent::pClassPointer = NULL;

// Class Engine.StaticMeshComponent
// 0x0094 (0x02DC - 0x0248)
class UStaticMeshComponent : public UMeshComponent
{
public:
	int                                                ForcedLodModel;                                   		// 0x0248 (0x0004) [0x0000000000000000]              
	int                                                PreviousLODLevel;                                 		// 0x024C (0x0004) [0x0000000000000000]              
	class UStaticMesh*                                 StaticMesh;                                       		// 0x0250 (0x0008) [0x0000000000000000]              
	struct FColor                                      WireframeColor;                                   		// 0x0258 (0x0004) [0x0000000000000000]              
	DWORD                                              bIgnoreInstanceForTextureStreaming : 1;           		// 0x025C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bOverrideLightMapResolution : 1;                  		// 0x025C (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                LightmapRes;                                      		// 0x0260 (0x0004) [0x0000000000000000]              
	DWORD                                              bOverrideLightMapRes : 1;                         		// 0x0264 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                OverriddenLightMapResolution;                     		// 0x0268 (0x0004) [0x0000000000000000]              
	int                                                OverriddenLightMapRes;                            		// 0x026C (0x0004) [0x0000000000000000]              
	int                                                SplatterMapRes;                                   		// 0x0270 (0x0004) [0x0000000000000000]              
	DWORD                                              bOverrideSplatterMapRes : 1;                      		// 0x0274 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                OverriddenSplatterMapRes;                         		// 0x0278 (0x0004) [0x0000000000000000]              
	float                                              OverriddenLODMaxRange;                            		// 0x027C (0x0004) [0x0000000000000000]              
	float                                              StreamingDistanceMultiplier;                      		// 0x0280 (0x0004) [0x0000000000000000]              
	int                                                SubDivisionStepSize;                              		// 0x0284 (0x0004) [0x0000000000000000]              
	DWORD                                              bUseSubDivisions : 1;                             		// 0x0288 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bForceStaticDecals : 1;                           		// 0x0288 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCanHighlightSelectedSections : 1;                		// 0x0288 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUseSimpleLightmapModifications : 1;              		// 0x0288 (0x0004) [0x0000000000000000] [0x00000008] 
	class UTexture*                                    SimpleLightmapModificationTexture;                		// 0x028C (0x0008) [0x0000000000000000]              
	unsigned char                                      SimpleLightmapModificationFunction;               		// 0x0294 (0x0001) [0x0000000000000000]              
	DWORD                                              bNeverBecomeDynamic : 1;                          		// 0x0298 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bOverrideVisibilityCollision : 1;                 		// 0x0298 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< struct FGuid >                             IrrelevantLights;                                 		// 0x029C (0x0010) [0x0000000000000000]              
	TArray< struct FStaticMeshComponentLODInfo >       LODData;                                          		// 0x02AC (0x0010) [0x0000000000000000]              
	int                                                VertexPositionVersionNumber;                      		// 0x02BC (0x0004) [0x0000000000000000]              
	struct FLightmassPrimitiveSettings                 LightmassSettings;                                		// 0x02C0 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.StaticMeshComponent" );

		return pClassPointer;
	};

	void CanBecomeDynamic ( );
	void SetForceStaticDecals ( );
	void DisableRBCollisionWithSMC ( );
	void SetStaticMesh ( );
};

UClass* UStaticMeshComponent::pClassPointer = NULL;

// Class Engine.CoverMeshComponent
// 0x0038 (0x0314 - 0x02DC)
class UCoverMeshComponent : public UStaticMeshComponent
{
public:
	TArray< struct FCoverMeshes >                      Meshes;                                           		// 0x02DC (0x0010) [0x0000000000000000]              
	struct FVector                                     LocationOffset;                                   		// 0x02EC (0x000C) [0x0000000000000000]              
	class UStaticMesh*                                 AutoAdjustOn;                                     		// 0x02F8 (0x0008) [0x0000000000000000]              
	class UStaticMesh*                                 AutoAdjustOff;                                    		// 0x0300 (0x0008) [0x0000000000000000]              
	class UStaticMesh*                                 Disabled;                                         		// 0x0308 (0x0008) [0x0000000000000000]              
	DWORD                                              bShowWhenNotSelected : 1;                         		// 0x0310 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CoverMeshComponent" );

		return pClassPointer;
	};

};

UClass* UCoverMeshComponent::pClassPointer = NULL;

// Class Engine.NavMeshRenderingComponent
// 0x0000 (0x0238 - 0x0238)
class UNavMeshRenderingComponent : public UPrimitiveComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshRenderingComponent" );

		return pClassPointer;
	};

};

UClass* UNavMeshRenderingComponent::pClassPointer = NULL;

// Class Engine.PathRenderingComponent
// 0x0000 (0x0238 - 0x0238)
class UPathRenderingComponent : public UPrimitiveComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PathRenderingComponent" );

		return pClassPointer;
	};

};

UClass* UPathRenderingComponent::pClassPointer = NULL;

// Class Engine.RouteRenderingComponent
// 0x0000 (0x0238 - 0x0238)
class URouteRenderingComponent : public UPrimitiveComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RouteRenderingComponent" );

		return pClassPointer;
	};

};

UClass* URouteRenderingComponent::pClassPointer = NULL;

// Class Engine.AICommandBase
// 0x0000 (0x0060 - 0x0060)
class UAICommandBase : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AICommandBase" );

		return pClassPointer;
	};

	void eventGetUtility ( );
};

UClass* UAICommandBase::pClassPointer = NULL;

// Class Engine.AutoNavMeshPathObstacleUnregister
// 0x0010 (0x0070 - 0x0060)
class UAutoNavMeshPathObstacleUnregister : public UObject
{
public:
	class UInterface_NavMeshPathObstacle*              PathObstacleRef;                                  		// 0x0060 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0068 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AutoNavMeshPathObstacleUnregister" );

		return pClassPointer;
	};

};

UClass* UAutoNavMeshPathObstacleUnregister::pClassPointer = NULL;

// Class Engine.Interface_NavMeshPathObject
// 0x0000 (0x0060 - 0x0060)
class UInterface_NavMeshPathObject : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Interface_NavMeshPathObject" );

		return pClassPointer;
	};

};

UClass* UInterface_NavMeshPathObject::pClassPointer = NULL;

// Class Engine.Interface_NavMeshPathSwitch
// 0x0000 (0x0060 - 0x0060)
class UInterface_NavMeshPathSwitch : public UInterface_NavMeshPathObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Interface_NavMeshPathSwitch" );

		return pClassPointer;
	};

	void eventAIActivateSwitch ( );
};

UClass* UInterface_NavMeshPathSwitch::pClassPointer = NULL;

// Class Engine.Interface_NavMeshPathObstacle
// 0x0000 (0x0060 - 0x0060)
class UInterface_NavMeshPathObstacle : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Interface_NavMeshPathObstacle" );

		return pClassPointer;
	};

};

UClass* UInterface_NavMeshPathObstacle::pClassPointer = NULL;

// Class Engine.Interface_PylonGeometryProvider
// 0x0000 (0x0060 - 0x0060)
class UInterface_PylonGeometryProvider : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Interface_PylonGeometryProvider" );

		return pClassPointer;
	};

};

UClass* UInterface_PylonGeometryProvider::pClassPointer = NULL;

// Class Engine.Interface_RVO
// 0x0000 (0x0060 - 0x0060)
class UInterface_RVO : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Interface_RVO" );

		return pClassPointer;
	};

};

UClass* UInterface_RVO::pClassPointer = NULL;

// Class Engine.NavigationHandle
// 0x0140 (0x01A0 - 0x0060)
class UNavigationHandle : public UObject
{
public:
	class APylon*                                      AnchorPylon;                                      		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FPointer                                    AnchorPoly;                                       		// 0x0068 (0x0008) [0x0000000000000000]              
	struct FPathStore                                  PathCache;                                        		// 0x0070 (0x0010) [0x0000000000000000]              
	struct FPointer                                    BestUnfinishedPathPoint;                          		// 0x0080 (0x0008) [0x0000000000000000]              
	struct FPointer                                    CurrentEdge;                                      		// 0x0088 (0x0008) [0x0000000000000000]              
	struct FPointer                                    SubGoal_DestPoly;                                 		// 0x0090 (0x0008) [0x0000000000000000]              
	struct FBasedPosition                              FinalDestination;                                 		// 0x0098 (0x0038) [0x0000000000000000]              
	DWORD                                              bSkipRouteCacheUpdates : 1;                       		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseORforEvaluateGoal : 1;                        		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDebugConstraintsAndGoalEvals : 1;                		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUltraVerbosePathDebugging : 1;                   		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bVisualPathDebugging : 1;                         		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bDebug_Breadcrumbs : 1;                           		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000020] 
	class UNavMeshPathConstraint*                      PathConstraintList;                               		// 0x00D4 (0x0008) [0x0000000000000000]              
	class UNavMeshPathGoalEvaluator*                   PathGoalList;                                     		// 0x00DC (0x0008) [0x0000000000000000]              
	struct FNavMeshPathParams                          CachedPathParams;                                 		// 0x00E4 (0x0034) [0x0000000000000000]              
	unsigned char                                      LastPathError;                                    		// 0x0118 (0x0001) [0x0000000000000000]              
	float                                              LastPathFailTime;                                 		// 0x011C (0x0004) [0x0000000000000000]              
	struct FVector                                     Breadcrumbs[ 0xA ];                               		// 0x0120 (0x0078) [0x0000000000000000]              
	int                                                BreadCrumbMostRecentIdx;                          		// 0x0198 (0x0004) [0x0000000000000000]              
	float                                              BreadCrumbDistanceInterval;                       		// 0x019C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavigationHandle" );

		return pClassPointer;
	};

	void DrawBreadCrumbs ( );
	void StaticGetValidatedAnchorPosition ( );
	void GetValidatedAnchorPosition ( );
	void GetAllCoverSlotsInRadius ( );
	void PopulatePathfindingParamCache ( );
	void MoveToDesiredHeightAboveMesh ( );
	void CopyMovePointsFromPathCache ( );
	void CalculatePathDistance ( );
	void GetFirstMoveLocation ( );
	void IsAnchorInescapable ( );
	void LimitPathCacheDistance ( );
	void GetValidPositionsForBox ( );
	void GetAllPolyCentersWithinBounds ( );
	void GetCurrentEdgeType ( );
	void ClearCurrentEdge ( );
	void GetCurrentEdgeDebugText ( );
	void PrintPathCacheDebugText ( );
	void DrawPathCache ( );
	void ActorReachable ( );
	void PointReachable ( );
	void PointCheck ( );
	void LineCheck ( );
	void ObstaclePointCheck ( );
	void ObstacleLineCheck ( );
	void SuggestMovePreparation ( );
	void FindPath ( );
	void ComputeValidFinalDestination ( );
	void SetFinalDestination ( );
	void GetNextMoveLocation ( );
	void GetPylonFromPos ( );
	void FindPylon ( );
	void GetBestUnfinishedPathPoint ( );
	void PathCache_RemoveIndex ( );
	void PathCache_GetGoalPoint ( );
	void PathCache_Empty ( );
	void GetPathCacheLength ( );
	void CreatePathGoalEvaluator ( );
	void CreatePathConstraint ( );
	void DoesPylonAHaveAPathToPylonB ( );
	void BuildFromPylonAToPylonB ( );
	void AddGoalEvaluator ( );
	void AddPathConstraint ( );
	void ClearConstraints ( );
	void GetNextBreadCrumb ( );
	void UpdateBreadCrumbs ( );
	void CopyPathStoreToPathCache ( );
};

UClass* UNavigationHandle::pClassPointer = NULL;

// Class Engine.NavMeshGoal_Filter
// 0x000C (0x006C - 0x0060)
class UNavMeshGoal_Filter : public UObject
{
public:
	DWORD                                              bShowDebug : 1;                                   		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                NumNodesThrownOut;                                		// 0x0064 (0x0004) [0x0000000000000000]              
	int                                                NumNodesProcessed;                                		// 0x0068 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoal_Filter" );

		return pClassPointer;
	};

	void eventGetDumpString ( );
};

UClass* UNavMeshGoal_Filter::pClassPointer = NULL;

// Class Engine.NavMeshGoalFilter_MinPathDistance
// 0x0004 (0x0070 - 0x006C)
class UNavMeshGoalFilter_MinPathDistance : public UNavMeshGoal_Filter
{
public:
	int                                                MinDistancePathShouldBe;                          		// 0x006C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoalFilter_MinPathDistance" );

		return pClassPointer;
	};

	void MustBeLongerPathThan ( );
};

UClass* UNavMeshGoalFilter_MinPathDistance::pClassPointer = NULL;

// Class Engine.NavMeshGoalFilter_NotNearOtherAI
// 0x0004 (0x0070 - 0x006C)
class UNavMeshGoalFilter_NotNearOtherAI : public UNavMeshGoal_Filter
{
public:
	float                                              DistanceToCheck;                                  		// 0x006C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoalFilter_NotNearOtherAI" );

		return pClassPointer;
	};

	void NotNearOtherAI ( );
};

UClass* UNavMeshGoalFilter_NotNearOtherAI::pClassPointer = NULL;

// Class Engine.NavMeshGoalFilter_OutOfViewFrom
// 0x0014 (0x0080 - 0x006C)
class UNavMeshGoalFilter_OutOfViewFrom : public UNavMeshGoal_Filter
{
public:
	struct FPointer                                    GoalPoly;                                         		// 0x006C (0x0008) [0x0000000000000000]              
	struct FVector                                     OutOfViewLocation;                                		// 0x0074 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoalFilter_OutOfViewFrom" );

		return pClassPointer;
	};

	void MustBeHiddenFromThisPoint ( );
};

UClass* UNavMeshGoalFilter_OutOfViewFrom::pClassPointer = NULL;

// Class Engine.NavMeshGoalFilter_OutSideOfDotProductWedge
// 0x001C (0x0088 - 0x006C)
class UNavMeshGoalFilter_OutSideOfDotProductWedge : public UNavMeshGoal_Filter
{
public:
	struct FVector                                     Location;                                         		// 0x006C (0x000C) [0x0000000000000000]              
	struct FVector                                     Rotation;                                         		// 0x0078 (0x000C) [0x0000000000000000]              
	float                                              Epsilon;                                          		// 0x0084 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoalFilter_OutSideOfDotProductWedge" );

		return pClassPointer;
	};

	void OutsideOfDotProductWedge ( );
};

UClass* UNavMeshGoalFilter_OutSideOfDotProductWedge::pClassPointer = NULL;

// Class Engine.NavMeshGoalFilter_PolyEncompassesAI
// 0x000C (0x0078 - 0x006C)
class UNavMeshGoalFilter_PolyEncompassesAI : public UNavMeshGoal_Filter
{
public:
	struct FVector                                     OverrideExtentToCheck;                            		// 0x006C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoalFilter_PolyEncompassesAI" );

		return pClassPointer;
	};

	void MakeSureAIFits ( );
};

UClass* UNavMeshGoalFilter_PolyEncompassesAI::pClassPointer = NULL;

// Class Engine.NavMeshPathConstraint
// 0x0018 (0x0078 - 0x0060)
class UNavMeshPathConstraint : public UObject
{
public:
	class UNavMeshPathConstraint*                      NextConstraint;                                   		// 0x0060 (0x0008) [0x0000000000000000]              
	int                                                NumNodesProcessed;                                		// 0x0068 (0x0004) [0x0000000000000000]              
	int                                                NumThrownOutNodes;                                		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              AddedDirectCost;                                  		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              AddedHeuristicCost;                               		// 0x0074 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshPathConstraint" );

		return pClassPointer;
	};

	void eventGetDumpString ( );
	void eventRecycle ( );
};

UClass* UNavMeshPathConstraint::pClassPointer = NULL;

// Class Engine.NavMeshPath_AlongLine
// 0x000C (0x0084 - 0x0078)
class UNavMeshPath_AlongLine : public UNavMeshPathConstraint
{
public:
	struct FVector                                     Direction;                                        		// 0x0078 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshPath_AlongLine" );

		return pClassPointer;
	};

	void Recycle ( );
	void AlongLine ( );
};

UClass* UNavMeshPath_AlongLine::pClassPointer = NULL;

// Class Engine.NavMeshPath_EnforceTwoWayEdges
// 0x0000 (0x0078 - 0x0078)
class UNavMeshPath_EnforceTwoWayEdges : public UNavMeshPathConstraint
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshPath_EnforceTwoWayEdges" );

		return pClassPointer;
	};

	void EnforceTwoWayEdges ( );
};

UClass* UNavMeshPath_EnforceTwoWayEdges::pClassPointer = NULL;

// Class Engine.NavMeshPath_MinDistBetweenSpecsOfType
// 0x0018 (0x0090 - 0x0078)
class UNavMeshPath_MinDistBetweenSpecsOfType : public UNavMeshPathConstraint
{
public:
	float                                              MinDistBetweenEdgeTypes;                          		// 0x0078 (0x0004) [0x0000000000000000]              
	struct FVector                                     InitLocation;                                     		// 0x007C (0x000C) [0x0000000000000000]              
	unsigned char                                      EdgeType;                                         		// 0x0088 (0x0001) [0x0000000000000000]              
	float                                              Penalty;                                          		// 0x008C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshPath_MinDistBetweenSpecsOfType" );

		return pClassPointer;
	};

	void Recycle ( );
	void EnforceMinDist ( );
};

UClass* UNavMeshPath_MinDistBetweenSpecsOfType::pClassPointer = NULL;

// Class Engine.NavMeshPath_SameCoverLink
// 0x0008 (0x0080 - 0x0078)
class UNavMeshPath_SameCoverLink : public UNavMeshPathConstraint
{
public:
	class ACoverLink*                                  TestLink;                                         		// 0x0078 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshPath_SameCoverLink" );

		return pClassPointer;
	};

	void Recycle ( );
	void SameCoverLink ( );
};

UClass* UNavMeshPath_SameCoverLink::pClassPointer = NULL;

// Class Engine.NavMeshPath_Toward
// 0x001C (0x0094 - 0x0078)
class UNavMeshPath_Toward : public UNavMeshPathConstraint
{
public:
	DWORD                                              bBiasAgainstHighLevelPath : 1;                    		// 0x0078 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              OutOfHighLevelPathBias;                           		// 0x007C (0x0004) [0x0000000000000000]              
	class AActor*                                      GoalActor;                                        		// 0x0080 (0x0008) [0x0000000000000000]              
	struct FVector                                     GoalPoint;                                        		// 0x0088 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshPath_Toward" );

		return pClassPointer;
	};

	void Recycle ( );
	void TowardPoint ( );
	void TowardGoal ( );
};

UClass* UNavMeshPath_Toward::pClassPointer = NULL;

// Class Engine.NavMeshPath_WithinDistanceEnvelope
// 0x001C (0x0094 - 0x0078)
class UNavMeshPath_WithinDistanceEnvelope : public UNavMeshPathConstraint
{
public:
	float                                              MaxDistance;                                      		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              MinDistance;                                      		// 0x007C (0x0004) [0x0000000000000000]              
	DWORD                                              bSoft : 1;                                        		// 0x0080 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bOnlyThrowOutNodesThatLeaveEnvelope : 1;          		// 0x0080 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              SoftStartPenalty;                                 		// 0x0084 (0x0004) [0x0000000000000000]              
	struct FVector                                     EnvelopeTestPoint;                                		// 0x0088 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshPath_WithinDistanceEnvelope" );

		return pClassPointer;
	};

	void Recycle ( );
	void StayWithinEnvelopeToLoc ( );
};

UClass* UNavMeshPath_WithinDistanceEnvelope::pClassPointer = NULL;

// Class Engine.NavMeshPath_WithinTraversalDist
// 0x000C (0x0084 - 0x0078)
class UNavMeshPath_WithinTraversalDist : public UNavMeshPathConstraint
{
public:
	float                                              MaxTraversalDist;                                 		// 0x0078 (0x0004) [0x0000000000000000]              
	DWORD                                              bSoft : 1;                                        		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              SoftStartPenalty;                                 		// 0x0080 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshPath_WithinTraversalDist" );

		return pClassPointer;
	};

	void Recycle ( );
	void DontExceedMaxDist ( );
};

UClass* UNavMeshPath_WithinTraversalDist::pClassPointer = NULL;

// Class Engine.NavMeshPathGoalEvaluator
// 0x001C (0x007C - 0x0060)
class UNavMeshPathGoalEvaluator : public UObject
{
public:
	class UNavMeshPathGoalEvaluator*                   NextEvaluator;                                    		// 0x0060 (0x0008) [0x0000000000000000]              
	int                                                MaxPathVisits;                                    		// 0x0068 (0x0004) [0x0000000000000000]              
	DWORD                                              bAlwaysCallEvaluateGoal : 1;                      		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDoPartialAStar : 1;                              		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                NumNodesThrownOut;                                		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                NumNodesProcessed;                                		// 0x0074 (0x0004) [0x0000000000000000]              
	int                                                MaxOpenListSize;                                  		// 0x0078 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshPathGoalEvaluator" );

		return pClassPointer;
	};

	void eventGetDumpString ( );
	void eventRecycle ( );
};

UClass* UNavMeshPathGoalEvaluator::pClassPointer = NULL;

// Class Engine.NavMeshGoal_At
// 0x0028 (0x00A4 - 0x007C)
class UNavMeshGoal_At : public UNavMeshPathGoalEvaluator
{
public:
	struct FVector                                     Goal;                                             		// 0x007C (0x000C) [0x0000000000000000]              
	float                                              GoalDist;                                         		// 0x0088 (0x0004) [0x0000000000000000]              
	DWORD                                              bKeepPartial : 1;                                 		// 0x008C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bWeightPartialByDist : 1;                         		// 0x008C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bGoalInSamePolyAsAnchor : 1;                      		// 0x008C (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              PartialDistSq;                                    		// 0x0090 (0x0004) [0x0000000000000000]              
	struct FPointer                                    GoalPoly;                                         		// 0x0094 (0x0008) [0x0000000000000000]              
	struct FPointer                                    PartialGoal;                                      		// 0x009C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoal_At" );

		return pClassPointer;
	};

	void Recycle ( );
	void AtLocation ( );
	void AtActor ( );
	void RecycleNative ( );
};

UClass* UNavMeshGoal_At::pClassPointer = NULL;

// Class Engine.NavMeshGoal_ClosestActorInList
// 0x0060 (0x00DC - 0x007C)
class UNavMeshGoal_ClosestActorInList : public UNavMeshPathGoalEvaluator
{
public:
	TArray< struct FBiasedGoalActor >                  GoalList;                                         		// 0x007C (0x0010) [0x0000000000000000]              
	struct FMultiMap_Mirror                            PolyToGoalActorMap;                               		// 0x008C (0x0048) [0x0000000000000000]              
	struct FPointer                                    CachedAnchorPoly;                                 		// 0x00D4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoal_ClosestActorInList" );

		return pClassPointer;
	};

	void RecycleInternal ( );
	void eventRecycle ( );
	void ClosestActorInList ( );
};

UClass* UNavMeshGoal_ClosestActorInList::pClassPointer = NULL;

// Class Engine.NavMeshGoal_GenericFilterContainer
// 0x0030 (0x00AC - 0x007C)
class UNavMeshGoal_GenericFilterContainer : public UNavMeshPathGoalEvaluator
{
public:
	TArray< class UNavMeshGoal_Filter* >               GoalFilters;                                      		// 0x007C (0x0010) [0x0000000000000000]              
	struct FPointer                                    SuccessfulGoal;                                   		// 0x008C (0x0008) [0x0000000000000000]              
	class UNavigationHandle*                           MyNavigationHandle;                               		// 0x0094 (0x0008) [0x0000000000000000]              
	TArray< struct FVector >                           SeedLocations;                                    		// 0x009C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoal_GenericFilterContainer" );

		return pClassPointer;
	};

	void Recycle ( );
	void GetGoalPoint ( );
	void GetFilterOfType ( );
	void CreateAndAddFilterToNavHandleFromSeedList ( );
	void CreateAndAddFilterToNavHandle ( );
};

UClass* UNavMeshGoal_GenericFilterContainer::pClassPointer = NULL;

// Class Engine.NavMeshGoal_Null
// 0x0008 (0x0084 - 0x007C)
class UNavMeshGoal_Null : public UNavMeshPathGoalEvaluator
{
public:
	struct FPointer                                    PartialGoal;                                      		// 0x007C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoal_Null" );

		return pClassPointer;
	};

	void Recycle ( );
	void RecycleNative ( );
	void GoUntilBust ( );
};

UClass* UNavMeshGoal_Null::pClassPointer = NULL;

// Class Engine.NavMeshGoal_PolyEncompassesAI
// 0x000C (0x0088 - 0x007C)
class UNavMeshGoal_PolyEncompassesAI : public UNavMeshPathGoalEvaluator
{
public:
	struct FVector                                     OverrideExtentToCheck;                            		// 0x007C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoal_PolyEncompassesAI" );

		return pClassPointer;
	};

	void Recycle ( );
	void MakeSureAIFits ( );
};

UClass* UNavMeshGoal_PolyEncompassesAI::pClassPointer = NULL;

// Class Engine.NavMeshGoal_Random
// 0x0010 (0x008C - 0x007C)
class UNavMeshGoal_Random : public UNavMeshPathGoalEvaluator
{
public:
	int                                                MinDist;                                          		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              BestRating;                                       		// 0x0080 (0x0004) [0x0000000000000000]              
	struct FPointer                                    PartialGoal;                                      		// 0x0084 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoal_Random" );

		return pClassPointer;
	};

	void Recycle ( );
	void RecycleNative ( );
	void FindRandom ( );
};

UClass* UNavMeshGoal_Random::pClassPointer = NULL;

// Class Engine.NavMeshGoal_WithinDistanceEnvelope
// 0x0018 (0x0094 - 0x007C)
class UNavMeshGoal_WithinDistanceEnvelope : public UNavMeshPathGoalEvaluator
{
public:
	float                                              MaxDistance;                                      		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              MinDistance;                                      		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              MinTraversalDist;                                 		// 0x0084 (0x0004) [0x0000000000000000]              
	struct FVector                                     EnvelopeTestPoint;                                		// 0x0088 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshGoal_WithinDistanceEnvelope" );

		return pClassPointer;
	};

	void Recycle ( );
	void GoalWithinEnvelopeToLoc ( );
};

UClass* UNavMeshGoal_WithinDistanceEnvelope::pClassPointer = NULL;

// Class Engine.PathConstraint
// 0x000C (0x006C - 0x0060)
class UPathConstraint : public UObject
{
public:
	int                                                CacheIdx;                                         		// 0x0060 (0x0004) [0x0000000000000000]              
	class UPathConstraint*                             NextConstraint;                                   		// 0x0064 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PathConstraint" );

		return pClassPointer;
	};

	void eventGetDumpString ( );
	void eventRecycle ( );
};

UClass* UPathConstraint::pClassPointer = NULL;

// Class Engine.Path_AlongLine
// 0x000C (0x0078 - 0x006C)
class UPath_AlongLine : public UPathConstraint
{
public:
	struct FVector                                     Direction;                                        		// 0x006C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Path_AlongLine" );

		return pClassPointer;
	};

	void Recycle ( );
	void AlongLine ( );
};

UClass* UPath_AlongLine::pClassPointer = NULL;

// Class Engine.Path_AvoidInEscapableNodes
// 0x0010 (0x007C - 0x006C)
class UPath_AvoidInEscapableNodes : public UPathConstraint
{
public:
	int                                                Radius;                                           		// 0x006C (0x0004) [0x0000000000000000]              
	int                                                Height;                                           		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                MaxFallSpeed;                                     		// 0x0074 (0x0004) [0x0000000000000000]              
	int                                                MoveFlags;                                        		// 0x0078 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Path_AvoidInEscapableNodes" );

		return pClassPointer;
	};

	void Recycle ( );
	void DontGetStuck ( );
	void CachePawnReacFlags ( );
};

UClass* UPath_AvoidInEscapableNodes::pClassPointer = NULL;

// Class Engine.Path_MinDistBetweenSpecsOfType
// 0x0018 (0x0084 - 0x006C)
class UPath_MinDistBetweenSpecsOfType : public UPathConstraint
{
public:
	float                                              MinDistBetweenSpecTypes;                          		// 0x006C (0x0004) [0x0000000000000000]              
	struct FVector                                     InitLocation;                                     		// 0x0070 (0x000C) [0x0000000000000000]              
	class UClass*                                      ReachSpecClass;                                   		// 0x007C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Path_MinDistBetweenSpecsOfType" );

		return pClassPointer;
	};

	void Recycle ( );
	void EnforceMinDist ( );
};

UClass* UPath_MinDistBetweenSpecsOfType::pClassPointer = NULL;

// Class Engine.Path_TowardGoal
// 0x0008 (0x0074 - 0x006C)
class UPath_TowardGoal : public UPathConstraint
{
public:
	class AActor*                                      GoalActor;                                        		// 0x006C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Path_TowardGoal" );

		return pClassPointer;
	};

	void Recycle ( );
	void TowardGoal ( );
};

UClass* UPath_TowardGoal::pClassPointer = NULL;

// Class Engine.Path_TowardPoint
// 0x000C (0x0078 - 0x006C)
class UPath_TowardPoint : public UPathConstraint
{
public:
	struct FVector                                     GoalPoint;                                        		// 0x006C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Path_TowardPoint" );

		return pClassPointer;
	};

	void Recycle ( );
	void TowardPoint ( );
};

UClass* UPath_TowardPoint::pClassPointer = NULL;

// Class Engine.Path_WithinDistanceEnvelope
// 0x001C (0x0088 - 0x006C)
class UPath_WithinDistanceEnvelope : public UPathConstraint
{
public:
	float                                              MaxDistance;                                      		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              MinDistance;                                      		// 0x0070 (0x0004) [0x0000000000000000]              
	DWORD                                              bSoft : 1;                                        		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bOnlyThrowOutNodesThatLeaveEnvelope : 1;          		// 0x0074 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              SoftStartPenalty;                                 		// 0x0078 (0x0004) [0x0000000000000000]              
	struct FVector                                     EnvelopeTestPoint;                                		// 0x007C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Path_WithinDistanceEnvelope" );

		return pClassPointer;
	};

	void Recycle ( );
	void StayWithinEnvelopeToLoc ( );
};

UClass* UPath_WithinDistanceEnvelope::pClassPointer = NULL;

// Class Engine.Path_WithinTraversalDist
// 0x000C (0x0078 - 0x006C)
class UPath_WithinTraversalDist : public UPathConstraint
{
public:
	float                                              MaxTraversalDist;                                 		// 0x006C (0x0004) [0x0000000000000000]              
	DWORD                                              bSoft : 1;                                        		// 0x0070 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              SoftStartPenalty;                                 		// 0x0074 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Path_WithinTraversalDist" );

		return pClassPointer;
	};

	void Recycle ( );
	void DontExceedMaxDist ( );
};

UClass* UPath_WithinTraversalDist::pClassPointer = NULL;

// Class Engine.PathGoalEvaluator
// 0x001C (0x007C - 0x0060)
class UPathGoalEvaluator : public UObject
{
public:
	class UPathGoalEvaluator*                          NextEvaluator;                                    		// 0x0060 (0x0008) [0x0000000000000000]              
	class ANavigationPoint*                            GeneratedGoal;                                    		// 0x0068 (0x0008) [0x0000000000000000]              
	int                                                MaxPathVisits;                                    		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                CacheIdx;                                         		// 0x0074 (0x0004) [0x0000000000000000]              
	DWORD                                              bDebug : 1;                                       		// 0x0078 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PathGoalEvaluator" );

		return pClassPointer;
	};

	void eventGetDumpString ( );
	void eventRecycle ( );
};

UClass* UPathGoalEvaluator::pClassPointer = NULL;

// Class Engine.Goal_AtActor
// 0x0010 (0x008C - 0x007C)
class UGoal_AtActor : public UPathGoalEvaluator
{
public:
	class AActor*                                      GoalActor;                                        		// 0x007C (0x0008) [0x0000000000000000]              
	float                                              GoalDist;                                         		// 0x0084 (0x0004) [0x0000000000000000]              
	DWORD                                              bKeepPartial : 1;                                 		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Goal_AtActor" );

		return pClassPointer;
	};

	void Recycle ( );
	void AtActor ( );
};

UClass* UGoal_AtActor::pClassPointer = NULL;

// Class Engine.Goal_Null
// 0x0000 (0x007C - 0x007C)
class UGoal_Null : public UPathGoalEvaluator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Goal_Null" );

		return pClassPointer;
	};

	void Recycle ( );
	void GoUntilBust ( );
};

UClass* UGoal_Null::pClassPointer = NULL;

// Class Engine.SkeletalMeshActor
// 0x0060 (0x02A4 - 0x0244)
class ASkeletalMeshActor : public AActor
{
public:
	DWORD                                              bDamageAppliesImpulse : 1;                        		// 0x0244 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bShouldDoAnimNotifies : 1;                        		// 0x0244 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bForceSaveInCheckpoint : 1;                       		// 0x0244 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bCollideActors_OldValue : 1;                      		// 0x0244 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bShouldShadowParentAllAttachedActors : 1;         		// 0x0244 (0x0004) [0x0000000000000000] [0x00000010] 
	class USkeletalMeshComponent*                      SkeletalMeshComponent;                            		// 0x0248 (0x0008) [0x0000000000000000]              
	class ULightEnvironmentComponent*                  LightEnvironment;                                 		// 0x0250 (0x0008) [0x0000000000000000]              
	class UAudioComponent*                             FacialAudioComp;                                  		// 0x0258 (0x0008) [0x0000000000000000]              
	class USkeletalMesh*                               ReplicatedMesh;                                   		// 0x0260 (0x0008) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )
	class UMaterialInterface*                          ReplicatedMaterial0;                              		// 0x0268 (0x0008) [0x0000000000160000]              ( CPF_EditConst | CPF_GlobalConfig )
	class UMaterialInterface*                          ReplicatedMaterial1;                              		// 0x0270 (0x0008) [0x0000000000170000]              ( CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
	TArray< struct FSkelMeshActorControlTarget >       ControlTargets;                                   		// 0x0278 (0x0010) [0x0000000000000000]              
	TArray< class UInterpGroup* >                      InterpGroupList;                                  		// 0x0288 (0x0010) [0x0000000000000000]              
	struct FName                                       SavedAnimSeqName;                                 		// 0x0298 (0x0008) [0x0000000000000000]              
	float                                              SavedCurrentTime;                                 		// 0x02A0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkeletalMeshActor" );

		return pClassPointer;
	};

	void eventCreateForceField ( );
	void SkelMeshActorOnParticleSystemFinished ( );
	void eventPlayParticleEffect ( );
	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void ShouldSaveForCheckpoint ( );
	void eventTakeDamage ( );
	void DoKismetAttachment ( );
	void eventOnSetSkelControlTarget ( );
	void eventOnUpdatePhysBonesFromAnim ( );
	void eventOnSetMesh ( );
	void IsActorPlayingFaceFXAnim ( );
	void eventGetActorFaceFXAsset ( );
	void OnPlayFaceFXAnim ( );
	void eventGetFaceFXAudioComponent ( );
	void eventStopActorFaceFXAnim ( );
	void eventPlayActorFaceFXAnim ( );
	void MAT_FinishAnimControl ( );
	void eventFinishAnimControl ( );
	void eventSetAnimPosition ( );
	void MAT_BeginAnimControl ( );
	void eventBeginAnimControl ( );
	void OnSetMaterial ( );
	void OnToggle ( );
	void eventReplicatedEvent ( );
	void UpdateAnimSetList ( );
	void eventDestroyed ( );
	void eventPostBeginPlay ( );
};

UClass* ASkeletalMeshActor::pClassPointer = NULL;

// Class Engine.SkeletalMeshActorBasedOnExtremeContent
// 0x0020 (0x02C4 - 0x02A4)
class ASkeletalMeshActorBasedOnExtremeContent : public ASkeletalMeshActor
{
public:
	TArray< struct FSkelMaterialSetterDatum >          ExtremeContent;                                   		// 0x02A4 (0x0010) [0x0000000000000000]              
	TArray< struct FSkelMaterialSetterDatum >          NonExtremeContent;                                		// 0x02B4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkeletalMeshActorBasedOnExtremeContent" );

		return pClassPointer;
	};

	void SetMaterialBasedOnExtremeContent ( );
	void eventPostBeginPlay ( );
};

UClass* ASkeletalMeshActorBasedOnExtremeContent::pClassPointer = NULL;

// Class Engine.SkeletalMeshActorSpawnable
// 0x0000 (0x02A4 - 0x02A4)
class ASkeletalMeshActorSpawnable : public ASkeletalMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkeletalMeshActorSpawnable" );

		return pClassPointer;
	};

};

UClass* ASkeletalMeshActorSpawnable::pClassPointer = NULL;

// Class Engine.SkeletalMeshCinematicActor
// 0x0000 (0x02A4 - 0x02A4)
class ASkeletalMeshCinematicActor : public ASkeletalMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkeletalMeshCinematicActor" );

		return pClassPointer;
	};

};

UClass* ASkeletalMeshCinematicActor::pClassPointer = NULL;

// Class Engine.SkeletalMeshActorMAT
// 0x0010 (0x02B4 - 0x02A4)
class ASkeletalMeshActorMAT : public ASkeletalMeshCinematicActor
{
public:
	TArray< class UAnimNodeSlot* >                     SlotNodes;                                        		// 0x02A4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkeletalMeshActorMAT" );

		return pClassPointer;
	};

	void eventSetSkelControlScale ( );
	void eventSetMorphWeight ( );
	void eventFinishAnimControl ( );
	void MAT_SetAnimPosition ( );
	void eventSetAnimPosition ( );
	void ClearAnimNodes ( );
	void CacheAnimNodes ( );
	void eventPostInitAnimTree ( );
	void eventDestroyed ( );
	void MAT_SetSkelControlStrength ( );
	void MAT_SetSkelControlScale ( );
	void MAT_SetMorphWeight ( );
	void MAT_SetAnimWeights ( );
};

UClass* ASkeletalMeshActorMAT::pClassPointer = NULL;

// Class Engine.HeadTrackingComponent
// 0x00BF (0x0144 - 0x0085)
class UHeadTrackingComponent : public UActorComponent
{
public:
	TArray< struct FName >                             TrackControllerName;                              		// 0x0088 (0x0010) [0x0000000000000000]              
	float                                              LookAtActorRadius;                                		// 0x0098 (0x0004) [0x0000000000000000]              
	DWORD                                              bDisableBeyondLimit : 1;                          		// 0x009C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              MaxLookAtTime;                                    		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              MinLookAtTime;                                    		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              MaxInterestTime;                                  		// 0x00A8 (0x0004) [0x0000000000000000]              
	TArray< class UClass* >                            ActorClassesToLookAt;                             		// 0x00AC (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             TargetBoneNames;                                  		// 0x00BC (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x00CC (0x0048) UNKNOWN PROPERTY: MapProperty Engine.HeadTrackingComponent.CurrentActorMap
	class USkeletalMeshComponent*                      SkeletalMeshComp;                                 		// 0x0114 (0x0008) [0x0000000000000000]              
	TArray< class USkelControlLookAt* >                TrackControls;                                    		// 0x011C (0x0010) [0x0000000000000000]              
	struct FVector                                     RootMeshLocation;                                 		// 0x012C (0x000C) [0x0000000000000000]              
	struct FRotator                                    RootMeshRotation;                                 		// 0x0138 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.HeadTrackingComponent" );

		return pClassPointer;
	};

};

UClass* UHeadTrackingComponent::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm
// 0x0016 (0x0076 - 0x0060)
class UAnimationCompressionAlgorithm : public UObject
{
public:
	struct FString                                     Description;                                      		// 0x0060 (0x0010) [0x0000000000000000]              
	DWORD                                              bNeedsSkeleton : 1;                               		// 0x0070 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      TranslationCompressionFormat;                     		// 0x0074 (0x0001) [0x0000000000000000]              
	unsigned char                                      RotationCompressionFormat;                        		// 0x0075 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimationCompressionAlgorithm" );

		return pClassPointer;
	};

};

UClass* UAnimationCompressionAlgorithm::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_Automatic
// 0x000A (0x0080 - 0x0076)
class UAnimationCompressionAlgorithm_Automatic : public UAnimationCompressionAlgorithm
{
public:
	float                                              MaxEndEffectorError;                              		// 0x0078 (0x0004) [0x0000000000000000]              
	DWORD                                              bTryFixedBitwiseCompression : 1;                  		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bTryPerTrackBitwiseCompression : 1;               		// 0x007C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bTryLinearKeyRemovalCompression : 1;              		// 0x007C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bTryIntervalKeyRemoval : 1;                       		// 0x007C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bRunCurrentDefaultCompressor : 1;                 		// 0x007C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bAutoReplaceIfExistingErrorTooGreat : 1;          		// 0x007C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bRaiseMaxErrorToExisting : 1;                     		// 0x007C (0x0004) [0x0000000000000000] [0x00000040] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimationCompressionAlgorithm_Automatic" );

		return pClassPointer;
	};

};

UClass* UAnimationCompressionAlgorithm_Automatic::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_BitwiseCompressOnly
// 0x0002 (0x0078 - 0x0076)
class UAnimationCompressionAlgorithm_BitwiseCompressOnly : public UAnimationCompressionAlgorithm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimationCompressionAlgorithm_BitwiseCompressOnly" );

		return pClassPointer;
	};

};

UClass* UAnimationCompressionAlgorithm_BitwiseCompressOnly::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_LeastDestructive
// 0x0002 (0x0078 - 0x0076)
class UAnimationCompressionAlgorithm_LeastDestructive : public UAnimationCompressionAlgorithm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimationCompressionAlgorithm_LeastDestructive" );

		return pClassPointer;
	};

};

UClass* UAnimationCompressionAlgorithm_LeastDestructive::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_RemoveEverySecondKey
// 0x000A (0x0080 - 0x0076)
class UAnimationCompressionAlgorithm_RemoveEverySecondKey : public UAnimationCompressionAlgorithm
{
public:
	int                                                MinKeys;                                          		// 0x0078 (0x0004) [0x0000000000000000]              
	DWORD                                              bStartAtSecondKey : 1;                            		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimationCompressionAlgorithm_RemoveEverySecondKey" );

		return pClassPointer;
	};

};

UClass* UAnimationCompressionAlgorithm_RemoveEverySecondKey::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_RemoveLinearKeys
// 0x001E (0x0094 - 0x0076)
class UAnimationCompressionAlgorithm_RemoveLinearKeys : public UAnimationCompressionAlgorithm
{
public:
	float                                              MaxPosDiff;                                       		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              MaxAngleDiff;                                     		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              MaxEffectorDiff;                                  		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              MinEffectorDiff;                                  		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              EffectorDiffSocket;                               		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              ParentKeyScale;                                   		// 0x008C (0x0004) [0x0000000000000000]              
	DWORD                                              bRetarget : 1;                                    		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bActuallyFilterLinearKeys : 1;                    		// 0x0090 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimationCompressionAlgorithm_RemoveLinearKeys" );

		return pClassPointer;
	};

};

UClass* UAnimationCompressionAlgorithm_RemoveLinearKeys::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_PerTrackCompression
// 0x005C (0x00F0 - 0x0094)
class UAnimationCompressionAlgorithm_PerTrackCompression : public UAnimationCompressionAlgorithm_RemoveLinearKeys
{
public:
	float                                              MaxZeroingThreshold;                              		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              MaxPosDiffBitwise;                                		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              MaxAngleDiffBitwise;                              		// 0x009C (0x0004) [0x0000000000000000]              
	TArray< unsigned char >                            AllowedRotationFormats;                           		// 0x00A0 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            AllowedTranslationFormats;                        		// 0x00B0 (0x0010) [0x0000000000000000]              
	DWORD                                              bResampleAnimation : 1;                           		// 0x00C0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseAdaptiveError : 1;                            		// 0x00C0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUseOverrideForEndEffectors : 1;                  		// 0x00C0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUseAdaptiveError2 : 1;                           		// 0x00C0 (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              ResampledFramerate;                               		// 0x00C4 (0x0004) [0x0000000000000000]              
	int                                                MinKeysForResampling;                             		// 0x00C8 (0x0004) [0x0000000000000000]              
	int                                                TrackHeightBias;                                  		// 0x00CC (0x0004) [0x0000000000000000]              
	float                                              ParentingDivisor;                                 		// 0x00D0 (0x0004) [0x0000000000000000]              
	float                                              ParentingDivisorExponent;                         		// 0x00D4 (0x0004) [0x0000000000000000]              
	float                                              RotationErrorSourceRatio;                         		// 0x00D8 (0x0004) [0x0000000000000000]              
	float                                              TranslationErrorSourceRatio;                      		// 0x00DC (0x0004) [0x0000000000000000]              
	float                                              MaxErrorPerTrackRatio;                            		// 0x00E0 (0x0004) [0x0000000000000000]              
	float                                              PerturbationProbeSize;                            		// 0x00E4 (0x0004) [0x0000000000000000]              
	struct FPointer                                    PerReductionCachedData;                           		// 0x00E8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimationCompressionAlgorithm_PerTrackCompression" );

		return pClassPointer;
	};

};

UClass* UAnimationCompressionAlgorithm_PerTrackCompression::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_RemoveTrivialKeys
// 0x000A (0x0080 - 0x0076)
class UAnimationCompressionAlgorithm_RemoveTrivialKeys : public UAnimationCompressionAlgorithm
{
public:
	float                                              MaxPosDiff;                                       		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              MaxAngleDiff;                                     		// 0x007C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimationCompressionAlgorithm_RemoveTrivialKeys" );

		return pClassPointer;
	};

};

UClass* UAnimationCompressionAlgorithm_RemoveTrivialKeys::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_RevertToRaw
// 0x0002 (0x0078 - 0x0076)
class UAnimationCompressionAlgorithm_RevertToRaw : public UAnimationCompressionAlgorithm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimationCompressionAlgorithm_RevertToRaw" );

		return pClassPointer;
	};

};

UClass* UAnimationCompressionAlgorithm_RevertToRaw::pClassPointer = NULL;

// Class Engine.AnimMetaData
// 0x0000 (0x0060 - 0x0060)
class UAnimMetaData : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimMetaData" );

		return pClassPointer;
	};

};

UClass* UAnimMetaData::pClassPointer = NULL;

// Class Engine.AnimMetaData_SkelControl
// 0x001C (0x007C - 0x0060)
class UAnimMetaData_SkelControl : public UAnimMetaData
{
public:
	TArray< struct FName >                             SkelControlNameList;                              		// 0x0060 (0x0010) [0x0000000000000000]              
	DWORD                                              bFullControlOverController : 1;                   		// 0x0070 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FName                                       SkelControlName;                                  		// 0x0074 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimMetaData_SkelControl" );

		return pClassPointer;
	};

};

UClass* UAnimMetaData_SkelControl::pClassPointer = NULL;

// Class Engine.AnimMetaData_SkelControlKeyFrame
// 0x0010 (0x008C - 0x007C)
class UAnimMetaData_SkelControlKeyFrame : public UAnimMetaData_SkelControl
{
public:
	TArray< struct FTimeModifier >                     KeyFrames;                                        		// 0x007C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimMetaData_SkelControlKeyFrame" );

		return pClassPointer;
	};

};

UClass* UAnimMetaData_SkelControlKeyFrame::pClassPointer = NULL;

// Class Engine.AnimNotify
// 0x0004 (0x0064 - 0x0060)
class UAnimNotify : public UObject
{
public:
	struct FColor                                      NotifyColor;                                      		// 0x0060 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify" );

		return pClassPointer;
	};

	void FindNextNotifyOfClass ( );
};

UClass* UAnimNotify::pClassPointer = NULL;

// Class Engine.AnimNotify_AkEvent
// 0x0018 (0x007C - 0x0064)
class UAnimNotify_AkEvent : public UAnimNotify
{
public:
	class UAkEvent*                                    AkEvent;                                          		// 0x0064 (0x0008) [0x0000000000000000]              
	DWORD                                              bFollowActor : 1;                                 		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIgnoreIfActorHidden : 1;                         		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIgnoreIfActorDead : 1;                           		// 0x006C (0x0004) [0x0000000000000000] [0x00000004] 
	struct FName                                       BoneName;                                         		// 0x0070 (0x0008) [0x0000000000000000]              
	float                                              PercentToPlay;                                    		// 0x0078 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_AkEvent" );

		return pClassPointer;
	};

};

UClass* UAnimNotify_AkEvent::pClassPointer = NULL;

// Class Engine.AnimNotify_CameraEffect
// 0x0008 (0x006C - 0x0064)
class UAnimNotify_CameraEffect : public UAnimNotify
{
public:
	class UClass*                                      CameraLensEffect;                                 		// 0x0064 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_CameraEffect" );

		return pClassPointer;
	};

};

UClass* UAnimNotify_CameraEffect::pClassPointer = NULL;

// Class Engine.AnimNotify_ClothingMaxDistanceScale
// 0x0010 (0x0074 - 0x0064)
class UAnimNotify_ClothingMaxDistanceScale : public UAnimNotify
{
public:
	float                                              StartScale;                                       		// 0x0064 (0x0004) [0x0000000000000000]              
	float                                              EndScale;                                         		// 0x0068 (0x0004) [0x0000000000000000]              
	unsigned char                                      ScaleMode;                                        		// 0x006C (0x0001) [0x0000000000000000]              
	float                                              Duration;                                         		// 0x0070 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_ClothingMaxDistanceScale" );

		return pClassPointer;
	};

};

UClass* UAnimNotify_ClothingMaxDistanceScale::pClassPointer = NULL;

// Class Engine.AnimNotify_Footstep
// 0x0004 (0x0068 - 0x0064)
class UAnimNotify_Footstep : public UAnimNotify
{
public:
	int                                                FootDown;                                         		// 0x0064 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_Footstep" );

		return pClassPointer;
	};

};

UClass* UAnimNotify_Footstep::pClassPointer = NULL;

// Class Engine.AnimNotify_ForceField
// 0x001C (0x0080 - 0x0064)
class UAnimNotify_ForceField : public UAnimNotify
{
public:
	class UNxForceFieldComponent*                      ForceFieldComponent;                              		// 0x0064 (0x0008) [0x0000000000000000]              
	DWORD                                              bAttach : 1;                                      		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	struct FName                                       SocketName;                                       		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FName                                       BoneName;                                         		// 0x0078 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_ForceField" );

		return pClassPointer;
	};

};

UClass* UAnimNotify_ForceField::pClassPointer = NULL;

// Class Engine.AnimNotify_Kismet
// 0x0008 (0x006C - 0x0064)
class UAnimNotify_Kismet : public UAnimNotify
{
public:
	struct FName                                       NotifyName;                                       		// 0x0064 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_Kismet" );

		return pClassPointer;
	};

};

UClass* UAnimNotify_Kismet::pClassPointer = NULL;

// Class Engine.AnimNotify_PlayParticleEffect
// 0x002C (0x0090 - 0x0064)
class UAnimNotify_PlayParticleEffect : public UAnimNotify
{
public:
	class UParticleSystem*                             PSTemplate;                                       		// 0x0064 (0x0008) [0x0000000000000000]              
	DWORD                                              bIsExtremeContent : 1;                            		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAttach : 1;                                      		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bPreview : 1;                                     		// 0x006C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bSkipIfOwnerIsHidden : 1;                         		// 0x006C (0x0004) [0x0000000000000000] [0x00000008] 
	class UParticleSystem*                             PSNonExtremeContentTemplate;                      		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FName                                       SocketName;                                       		// 0x0078 (0x0008) [0x0000000000000000]              
	struct FName                                       BoneName;                                         		// 0x0080 (0x0008) [0x0000000000000000]              
	struct FName                                       BoneSocketModuleActorName;                        		// 0x0088 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_PlayParticleEffect" );

		return pClassPointer;
	};

};

UClass* UAnimNotify_PlayParticleEffect::pClassPointer = NULL;

// Class Engine.AnimNotify_Rumble
// 0x0018 (0x007C - 0x0064)
class UAnimNotify_Rumble : public UAnimNotify
{
public:
	class UClass*                                      PredefinedWaveForm;                               		// 0x0064 (0x0008) [0x0000000000000000]              
	class UForceFeedbackWaveform*                      WaveForm;                                         		// 0x006C (0x0008) [0x0000000000000000]              
	DWORD                                              bCheckForBasedPlayer : 1;                         		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              EffectRadius;                                     		// 0x0078 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_Rumble" );

		return pClassPointer;
	};

};

UClass* UAnimNotify_Rumble::pClassPointer = NULL;

// Class Engine.AnimNotify_Script
// 0x0018 (0x007C - 0x0064)
class UAnimNotify_Script : public UAnimNotify
{
public:
	struct FName                                       NotifyName;                                       		// 0x0064 (0x0008) [0x0000000000000000]              
	struct FName                                       NotifyTickName;                                   		// 0x006C (0x0008) [0x0000000000000000]              
	struct FName                                       NotifyEndName;                                    		// 0x0074 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_Script" );

		return pClassPointer;
	};

};

UClass* UAnimNotify_Script::pClassPointer = NULL;

// Class Engine.AnimNotify_Scripted
// 0x0000 (0x0064 - 0x0064)
class UAnimNotify_Scripted : public UAnimNotify
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_Scripted" );

		return pClassPointer;
	};

	void eventNotifyEnd ( );
	void eventNotify ( );
};

UClass* UAnimNotify_Scripted::pClassPointer = NULL;

// Class Engine.AnimNotify_PawnMaterialParam
// 0x0010 (0x0074 - 0x0064)
class UAnimNotify_PawnMaterialParam : public UAnimNotify_Scripted
{
public:
	TArray< struct FScalarParameterInterpStruct >      ScalarParameterInterpArray;                       		// 0x0064 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_PawnMaterialParam" );

		return pClassPointer;
	};

	void eventNotify ( );
};

UClass* UAnimNotify_PawnMaterialParam::pClassPointer = NULL;

// Class Engine.AnimNotify_ViewShake
// 0x0054 (0x00B8 - 0x0064)
class UAnimNotify_ViewShake : public UAnimNotify_Scripted
{
public:
	float                                              Duration;                                         		// 0x0064 (0x0004) [0x0000000000000000]              
	struct FVector                                     RotAmplitude;                                     		// 0x0068 (0x000C) [0x0000000000000000]              
	struct FVector                                     RotFrequency;                                     		// 0x0074 (0x000C) [0x0000000000000000]              
	struct FVector                                     LocAmplitude;                                     		// 0x0080 (0x000C) [0x0000000000000000]              
	struct FVector                                     LocFrequency;                                     		// 0x008C (0x000C) [0x0000000000000000]              
	float                                              FOVAmplitude;                                     		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              FOVFrequency;                                     		// 0x009C (0x0004) [0x0000000000000000]              
	DWORD                                              bDoControllerVibration : 1;                       		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseBoneLocation : 1;                             		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              ShakeRadius;                                      		// 0x00A4 (0x0004) [0x0000000000000000]              
	struct FName                                       BoneName;                                         		// 0x00A8 (0x0008) [0x0000000000000000]              
	class UCameraShake*                                ShakeParams;                                      		// 0x00B0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_ViewShake" );

		return pClassPointer;
	};

	void eventNotify ( );
};

UClass* UAnimNotify_ViewShake::pClassPointer = NULL;

// Class Engine.AnimNotify_Sound
// 0x0020 (0x0084 - 0x0064)
class UAnimNotify_Sound : public UAnimNotify
{
public:
	class USoundCue*                                   SoundCue;                                         		// 0x0064 (0x0008) [0x0000000000000000]              
	DWORD                                              bFollowActor : 1;                                 		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIgnoreIfActorHidden : 1;                         		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 
	struct FName                                       BoneName;                                         		// 0x0070 (0x0008) [0x0000000000000000]              
	float                                              PercentToPlay;                                    		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              VolumeMultiplier;                                 		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              PitchMultiplier;                                  		// 0x0080 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_Sound" );

		return pClassPointer;
	};

};

UClass* UAnimNotify_Sound::pClassPointer = NULL;

// Class Engine.AnimNotify_Trails
// 0x006C (0x00D0 - 0x0064)
class UAnimNotify_Trails : public UAnimNotify
{
public:
	class UParticleSystem*                             PSTemplate;                                       		// 0x0064 (0x0008) [0x0000000000000000]              
	class USkeletalMesh*                               SampledSkeletalMesh;                              		// 0x006C (0x0008) [0x0000000000000000]              
	DWORD                                              bIsExtremeContent : 1;                            		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPreview : 1;                                     		// 0x0074 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bPreviewForceExplicit : 1;                        		// 0x0074 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bSkipIfOwnerIsHidden : 1;                         		// 0x0074 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bResampleRequired : 1;                            		// 0x0074 (0x0004) [0x0000000000000000] [0x00000010] 
	struct FName                                       FirstEdgeSocketName;                              		// 0x0078 (0x0008) [0x0000000000000000]              
	struct FName                                       ControlPointSocketName;                           		// 0x0080 (0x0008) [0x0000000000000000]              
	struct FName                                       SecondEdgeSocketName;                             		// 0x0088 (0x0008) [0x0000000000000000]              
	float                                              LastStartTime;                                    		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              EndTime;                                          		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              SampleTimeStep;                                   		// 0x0098 (0x0004) [0x0000000000000000]              
	TArray< struct FTrailSamplePoint >                 TrailSampleData;                                  		// 0x009C (0x0010) [0x0000000000000000]              
	float                                              SamplesPerSecond;                                 		// 0x00AC (0x0004) [0x0000000000000000]              
	TArray< struct FTrailSample >                      TrailSampledData;                                 		// 0x00B0 (0x0010) [0x0000000000000000]              
	float                                              CurrentTime;                                      		// 0x00C0 (0x0004) [0x0000000000000000]              
	float                                              TimeStep;                                         		// 0x00C4 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           AnimNodeSeq;                                      		// 0x00C8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_Trails" );

		return pClassPointer;
	};

	void GetNumSteps ( );
};

UClass* UAnimNotify_Trails::pClassPointer = NULL;

// Class Engine.AnimObject
// 0x002C (0x008C - 0x0060)
class UAnimObject : public UObject
{
public:
	int                                                DrawWidth;                                        		// 0x0060 (0x0004) [0x0000000000000000]              
	int                                                DrawHeight;                                       		// 0x0064 (0x0004) [0x0000000000000000]              
	int                                                NodePosX;                                         		// 0x0068 (0x0004) [0x0000000000000000]              
	int                                                NodePosY;                                         		// 0x006C (0x0004) [0x0000000000000000]              
	int                                                OutDrawY;                                         		// 0x0070 (0x0004) [0x0000000000000000]              
	struct FString                                     CategoryDesc;                                     		// 0x0074 (0x0010) [0x0000000000000000]              
	class USkeletalMeshComponent*                      SkelComponent;                                    		// 0x0084 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimObject" );

		return pClassPointer;
	};

};

UClass* UAnimObject::pClassPointer = NULL;

// Class Engine.AnimNode
// 0x009C (0x0128 - 0x008C)
class UAnimNode : public UAnimObject
{
public:
	DWORD                                              bRelevant : 1;                                    		// 0x008C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bJustBecameRelevant : 1;                          		// 0x008C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bTickDuringPausedAnims : 1;                       		// 0x008C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bEditorOnly : 1;                                  		// 0x008C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bDisableCaching : 1;                              		// 0x008C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bCallScriptEventOnInit : 1;                       		// 0x008C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bCallScriptEventOnBecomeRelevant : 1;             		// 0x008C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bCallScriptEventOnCeaseRelevant : 1;              		// 0x008C (0x0004) [0x0000000000000000] [0x00000080] 
	int                                                NodeTickTag;                                      		// 0x0090 (0x0004) [0x0000000000000000]              
	int                                                NodeInitTag;                                      		// 0x0094 (0x0004) [0x0000000000000000]              
	int                                                NodeEndEventTick;                                 		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                TickArrayIndex;                                   		// 0x009C (0x0004) [0x0000000000000000]              
	int                                                NodeCachedAtomsTag;                               		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              NodeTotalWeight;                                  		// 0x00A4 (0x0004) [0x0000000000000000]              
	TArray< class UAnimNodeBlendBase* >                ParentNodes;                                      		// 0x00A8 (0x0010) [0x0000000000000000]              
	struct FName                                       NodeName;                                         		// 0x00B8 (0x0008) [0x0000000000000000]              
	TArray< struct FBoneAtom >                         CachedBoneAtoms;                                  		// 0x00C0 (0x0010) [0x0000000000000000]              
	unsigned char                                      CachedNumDesiredBones;                            		// 0x00D0 (0x0001) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0xF ];                             		// 0x00D1 (0x000F) MISSED OFFSET
	struct FBoneAtom                                   CachedRootMotionDelta;                            		// 0x00E0 (0x0020) [0x0000000000000000]              
	int                                                bCachedHasRootMotion;                             		// 0x0100 (0x0004) [0x0000000000000000]              
	TArray< struct FCurveKey >                         CachedCurveKeys;                                  		// 0x0104 (0x0010) [0x0000000000000000]              
	int                                                SearchTag;                                        		// 0x0114 (0x0004) [0x0000000000000000]              
	TArray< struct FCurveKey >                         LastUpdatedAnimMorphKeys;                         		// 0x0118 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNode" );

		return pClassPointer;
	};

	void ReplayAnim ( );
	void StopAnim ( );
	void PlayAnim ( );
	void FindAnimNode ( );
	void eventOnCeaseRelevant ( );
	void eventOnBecomeRelevant ( );
	void eventOnInit ( );
};

UClass* UAnimNode::pClassPointer = NULL;

// Class Engine.AnimNodeBlendBase
// 0x0015 (0x013D - 0x0128)
class UAnimNodeBlendBase : public UAnimNode
{
public:
	TArray< struct FAnimBlendChild >                   Children;                                         		// 0x0128 (0x0010) [0x0000000000000000]              
	DWORD                                              bFixNumChildren : 1;                              		// 0x0138 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      BlendType;                                        		// 0x013C (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeBlendBase" );

		return pClassPointer;
	};

	void ReplayAnim ( );
	void StopAnim ( );
	void PlayAnim ( );
};

UClass* UAnimNodeBlendBase::pClassPointer = NULL;

// Class Engine.AnimNode_MultiBlendPerBone
// 0x001C (0x0159 - 0x013D)
class UAnimNode_MultiBlendPerBone : public UAnimNodeBlendBase
{
public:
	class APawn*                                       PawnOwner;                                        		// 0x0140 (0x0008) [0x0000000000000000]              
	TArray< struct FPerBoneMaskInfo >                  MaskList;                                         		// 0x0148 (0x0010) [0x0000000000000000]              
	unsigned char                                      RotationBlendType;                                		// 0x0158 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNode_MultiBlendPerBone" );

		return pClassPointer;
	};

	void SetMaskWeight ( );
};

UClass* UAnimNode_MultiBlendPerBone::pClassPointer = NULL;

// Class Engine.AnimNodeAimOffset
// 0x005B (0x0198 - 0x013D)
class UAnimNodeAimOffset : public UAnimNodeBlendBase
{
public:
	struct FVector2D                                   Aim;                                              		// 0x0140 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   AngleOffset;                                      		// 0x0148 (0x0008) [0x0000000000000000]              
	DWORD                                              bForceAimDir : 1;                                 		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bBakeFromAnimations : 1;                          		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bPassThroughWhenNotRendered : 1;                  		// 0x0150 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bSynchronizeNodesInEditor : 1;                    		// 0x0150 (0x0004) [0x0000000000000000] [0x00000008] 
	int                                                PassThroughAtOrAboveLOD;                          		// 0x0154 (0x0004) [0x0000000000000000]              
	unsigned char                                      ForcedAimDir;                                     		// 0x0158 (0x0001) [0x0000000000000000]              
	TArray< unsigned char >                            RequiredBones;                                    		// 0x015C (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            AimCpntIndexLUT;                                  		// 0x016C (0x0010) [0x0000000000000000]              
	class UAnimNodeAimOffset*                          TemplateNode;                                     		// 0x017C (0x0008) [0x0000000000000000]              
	TArray< struct FAimOffsetProfile >                 Profiles;                                         		// 0x0184 (0x0010) [0x0000000000000000]              
	int                                                CurrentProfileIndex;                              		// 0x0194 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeAimOffset" );

		return pClassPointer;
	};

	void SetActiveProfileByIndex ( );
	void SetActiveProfileByName ( );
};

UClass* UAnimNodeAimOffset::pClassPointer = NULL;

// Class Engine.AnimNodeBlend
// 0x0013 (0x0150 - 0x013D)
class UAnimNodeBlend : public UAnimNodeBlendBase
{
public:
	float                                              Child2Weight;                                     		// 0x0140 (0x0004) [0x0000000000000000]              
	float                                              Child2WeightTarget;                               		// 0x0144 (0x0004) [0x0000000000000000]              
	float                                              BlendTimeToGo;                                    		// 0x0148 (0x0004) [0x0000000000000000]              
	DWORD                                              bSkipBlendWhenNotRendered : 1;                    		// 0x014C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeBlend" );

		return pClassPointer;
	};

	void SetBlendTarget ( );
};

UClass* UAnimNodeBlend::pClassPointer = NULL;

// Class Engine.AnimNodeAdditiveBlending
// 0x0004 (0x0154 - 0x0150)
class UAnimNodeAdditiveBlending : public UAnimNodeBlend
{
public:
	DWORD                                              bPassThroughWhenNotRendered : 1;                  		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeAdditiveBlending" );

		return pClassPointer;
	};

	void SetBlendTarget ( );
};

UClass* UAnimNodeAdditiveBlending::pClassPointer = NULL;

// Class Engine.AnimNodeBlendPerBone
// 0x0034 (0x0184 - 0x0150)
class UAnimNodeBlendPerBone : public UAnimNodeBlend
{
public:
	DWORD                                              bForceLocalSpaceBlend : 1;                        		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< struct FName >                             BranchStartBoneName;                              		// 0x0154 (0x0010) [0x0000000000000000]              
	TArray< float >                                    Child2PerBoneWeight;                              		// 0x0164 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            LocalToCompReqBones;                              		// 0x0174 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeBlendPerBone" );

		return pClassPointer;
	};

	void SetBlendTarget ( );
};

UClass* UAnimNodeBlendPerBone::pClassPointer = NULL;

// Class Engine.AnimNodeCrossfader
// 0x0010 (0x0160 - 0x0150)
class UAnimNodeCrossfader : public UAnimNodeBlend
{
public:
	struct FName                                       DefaultAnimSeqName;                               		// 0x0150 (0x0008) [0x0000000000000000]              
	DWORD                                              bDontBlendOutOneShot : 1;                         		// 0x0158 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              PendingBlendOutTimeOneShot;                       		// 0x015C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeCrossfader" );

		return pClassPointer;
	};

	void GetActiveChild ( );
	void GetAnimName ( );
	void BlendToLoopingAnim ( );
	void PlayOneShotAnim ( );
};

UClass* UAnimNodeCrossfader::pClassPointer = NULL;

// Class Engine.AnimNodePlayCustomAnim
// 0x0008 (0x0158 - 0x0150)
class UAnimNodePlayCustomAnim : public UAnimNodeBlend
{
public:
	DWORD                                              bIsPlayingCustomAnim : 1;                         		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              CustomPendingBlendOutTime;                        		// 0x0154 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodePlayCustomAnim" );

		return pClassPointer;
	};

	void SetRootBoneAxisOption ( );
	void GetCustomAnimNodeSeq ( );
	void SetActorAnimEndNotification ( );
	void SetCustomAnim ( );
	void StopCustomAnim ( );
	void PlayCustomAnimByDuration ( );
	void PlayCustomAnim ( );
};

UClass* UAnimNodePlayCustomAnim::pClassPointer = NULL;

// Class Engine.AnimNodeBlendDirectional
// 0x001F (0x015C - 0x013D)
class UAnimNodeBlendDirectional : public UAnimNodeBlendBase
{
public:
	float                                              DirDegreesPerSecond;                              		// 0x0140 (0x0004) [0x0000000000000000]              
	float                                              DirAngle;                                         		// 0x0144 (0x0004) [0x0000000000000000]              
	int                                                SingleAnimAtOrAboveLOD;                           		// 0x0148 (0x0004) [0x0000000000000000]              
	struct FRotator                                    RotationOffset;                                   		// 0x014C (0x000C) [0x0000000000000000]              
	DWORD                                              bUseAcceleration : 1;                             		// 0x0158 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeBlendDirectional" );

		return pClassPointer;
	};

};

UClass* UAnimNodeBlendDirectional::pClassPointer = NULL;

// Class Engine.AnimNodeBlendList
// 0x0027 (0x0164 - 0x013D)
class UAnimNodeBlendList : public UAnimNodeBlendBase
{
public:
	TArray< float >                                    TargetWeight;                                     		// 0x0140 (0x0010) [0x0000000000000000]              
	float                                              BlendTimeToGo;                                    		// 0x0150 (0x0004) [0x0000000000000000]              
	int                                                ActiveChildIndex;                                 		// 0x0154 (0x0004) [0x0000000000000000]              
	DWORD                                              bPlayActiveChild : 1;                             		// 0x0158 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bForceChildFullWeightWhenBecomingRelevant : 1;    		// 0x0158 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bSkipBlendWhenNotRendered : 1;                    		// 0x0158 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              SliderPosition;                                   		// 0x015C (0x0004) [0x0000000000000000]              
	int                                                EditorActiveChildIndex;                           		// 0x0160 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeBlendList" );

		return pClassPointer;
	};

	void SetActiveChild ( );
};

UClass* UAnimNodeBlendList::pClassPointer = NULL;

// Class Engine.AnimNodeBlendByBase
// 0x0020 (0x0184 - 0x0164)
class UAnimNodeBlendByBase : public UAnimNodeBlendList
{
public:
	unsigned char                                      Type;                                             		// 0x0164 (0x0001) [0x0000000000000000]              
	struct FName                                       ActorTag;                                         		// 0x0168 (0x0008) [0x0000000000000000]              
	class UClass*                                      ActorClass;                                       		// 0x0170 (0x0008) [0x0000000000000000]              
	float                                              BlendTime;                                        		// 0x0178 (0x0004) [0x0000000000000000]              
	class AActor*                                      CachedBase;                                       		// 0x017C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeBlendByBase" );

		return pClassPointer;
	};

};

UClass* UAnimNodeBlendByBase::pClassPointer = NULL;

// Class Engine.AnimNodeBlendByPhysics
// 0x0000 (0x0164 - 0x0164)
class UAnimNodeBlendByPhysics : public UAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeBlendByPhysics" );

		return pClassPointer;
	};

};

UClass* UAnimNodeBlendByPhysics::pClassPointer = NULL;

// Class Engine.AnimNodeBlendByPosture
// 0x0000 (0x0164 - 0x0164)
class UAnimNodeBlendByPosture : public UAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeBlendByPosture" );

		return pClassPointer;
	};

};

UClass* UAnimNodeBlendByPosture::pClassPointer = NULL;

// Class Engine.AnimNodeBlendByProperty
// 0x0048 (0x01AC - 0x0164)
class UAnimNodeBlendByProperty : public UAnimNodeBlendList
{
public:
	struct FName                                       PropertyName;                                     		// 0x0164 (0x0008) [0x0000000000000000]              
	DWORD                                              bUseOwnersBase : 1;                               		// 0x016C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bForceUpdate : 1;                                 		// 0x016C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUseSpecificBlendTimes : 1;                       		// 0x016C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bSynchronizeNodesInEditor : 1;                    		// 0x016C (0x0004) [0x0000000000000000] [0x00000008] 
	struct FName                                       CachedPropertyName;                               		// 0x0170 (0x0008) [0x0000000000000000]              
	struct FPointer                                    CachedFloatProperty;                              		// 0x0178 (0x0008) [0x0000000000000000]              
	struct FPointer                                    CachedBoolProperty;                               		// 0x0180 (0x0008) [0x0000000000000000]              
	struct FPointer                                    CachedByteProperty;                               		// 0x0188 (0x0008) [0x0000000000000000]              
	class AActor*                                      CachedOwner;                                      		// 0x0190 (0x0008) [0x0000000000000000]              
	float                                              BlendTime;                                        		// 0x0198 (0x0004) [0x0000000000000000]              
	float                                              FloatPropMin;                                     		// 0x019C (0x0004) [0x0000000000000000]              
	float                                              FloatPropMax;                                     		// 0x01A0 (0x0004) [0x0000000000000000]              
	float                                              BlendToChild1Time;                                		// 0x01A4 (0x0004) [0x0000000000000000]              
	float                                              BlendToChild2Time;                                		// 0x01A8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeBlendByProperty" );

		return pClassPointer;
	};

};

UClass* UAnimNodeBlendByProperty::pClassPointer = NULL;

// Class Engine.AnimNodeBlendBySpeed
// 0x0034 (0x0198 - 0x0164)
class UAnimNodeBlendBySpeed : public UAnimNodeBlendList
{
public:
	float                                              Speed;                                            		// 0x0164 (0x0004) [0x0000000000000000]              
	int                                                LastChannel;                                      		// 0x0168 (0x0004) [0x0000000000000000]              
	float                                              BlendUpTime;                                      		// 0x016C (0x0004) [0x0000000000000000]              
	float                                              BlendDownTime;                                    		// 0x0170 (0x0004) [0x0000000000000000]              
	float                                              BlendDownPerc;                                    		// 0x0174 (0x0004) [0x0000000000000000]              
	TArray< float >                                    Constraints;                                      		// 0x0178 (0x0010) [0x0000000000000000]              
	DWORD                                              bUseAcceleration : 1;                             		// 0x0188 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              BlendUpDelay;                                     		// 0x018C (0x0004) [0x0000000000000000]              
	float                                              BlendDownDelay;                                   		// 0x0190 (0x0004) [0x0000000000000000]              
	float                                              BlendDelayRemaining;                              		// 0x0194 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeBlendBySpeed" );

		return pClassPointer;
	};

};

UClass* UAnimNodeBlendBySpeed::pClassPointer = NULL;

// Class Engine.AnimNodeRandom
// 0x0020 (0x0184 - 0x0164)
class UAnimNodeRandom : public UAnimNodeBlendList
{
public:
	TArray< struct FRandomAnimInfo >                   RandomInfo;                                       		// 0x0164 (0x0010) [0x0000000000000000]              
	class UAnimNodeSequence*                           PlayingSeqNode;                                   		// 0x0174 (0x0008) [0x0000000000000000]              
	int                                                PendingChildIndex;                                		// 0x017C (0x0004) [0x0000000000000000]              
	DWORD                                              bPickedPendingChildIndex : 1;                     		// 0x0180 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeRandom" );

		return pClassPointer;
	};

};

UClass* UAnimNodeRandom::pClassPointer = NULL;

// Class Engine.AnimNodeBlendMultiBone
// 0x0023 (0x0160 - 0x013D)
class UAnimNodeBlendMultiBone : public UAnimNodeBlendBase
{
public:
	TArray< struct FChildBoneBlendInfo >               BlendTargetList;                                  		// 0x0140 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            SourceRequiredBones;                              		// 0x0150 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeBlendMultiBone" );

		return pClassPointer;
	};

	void SetTargetStartBone ( );
};

UClass* UAnimNodeBlendMultiBone::pClassPointer = NULL;

// Class Engine.AnimNodeMirror
// 0x0007 (0x0144 - 0x013D)
class UAnimNodeMirror : public UAnimNodeBlendBase
{
public:
	DWORD                                              bEnableMirroring : 1;                             		// 0x0140 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeMirror" );

		return pClassPointer;
	};

};

UClass* UAnimNodeMirror::pClassPointer = NULL;

// Class Engine.AnimNodeScalePlayRate
// 0x0007 (0x0144 - 0x013D)
class UAnimNodeScalePlayRate : public UAnimNodeBlendBase
{
public:
	float                                              ScaleByValue;                                     		// 0x0140 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeScalePlayRate" );

		return pClassPointer;
	};

};

UClass* UAnimNodeScalePlayRate::pClassPointer = NULL;

// Class Engine.AnimNodeScaleRateBySpeed
// 0x0004 (0x0148 - 0x0144)
class UAnimNodeScaleRateBySpeed : public UAnimNodeScalePlayRate
{
public:
	float                                              BaseSpeed;                                        		// 0x0144 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeScaleRateBySpeed" );

		return pClassPointer;
	};

};

UClass* UAnimNodeScaleRateBySpeed::pClassPointer = NULL;

// Class Engine.AnimNodeSlot
// 0x0027 (0x0164 - 0x013D)
class UAnimNodeSlot : public UAnimNodeBlendBase
{
public:
	DWORD                                              bIsPlayingCustomAnim : 1;                         		// 0x0140 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEarlyAnimEndNotify : 1;                          		// 0x0140 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bSkipBlendWhenNotRendered : 1;                    		// 0x0140 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bAdditiveAnimationsOverrideSource : 1;            		// 0x0140 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bIsBeingUsedByInterpGroup : 1;                    		// 0x0140 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bDontAddToAlwaysTickArray : 1;                    		// 0x0140 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bNoNotifies : 1;                                  		// 0x0140 (0x0004) [0x0000000000000000] [0x00000040] 
	float                                              PendingBlendOutTime;                              		// 0x0144 (0x0004) [0x0000000000000000]              
	int                                                CustomChildIndex;                                 		// 0x0148 (0x0004) [0x0000000000000000]              
	int                                                TargetChildIndex;                                 		// 0x014C (0x0004) [0x0000000000000000]              
	TArray< float >                                    TargetWeight;                                     		// 0x0150 (0x0010) [0x0000000000000000]              
	float                                              BlendTimeToGo;                                    		// 0x0160 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeSlot" );

		return pClassPointer;
	};

	void TickChildWeights ( );
	void SetRootBoneRotationOption ( );
	void SetRootBoneAxisOption ( );
	void GetCustomAnimNodeSeq ( );
	void SetNotifyWeightThreshold ( );
	void SetActorAnimEndNotification ( );
	void SetCustomAnim ( );
	void SetAllowPauseAnims ( );
	void StopCustomAnim ( );
	void GetPlayedAnimation ( );
	void PlayCustomAnimByDuration ( );
	void PlayCustomAnim ( );
};

UClass* UAnimNodeSlot::pClassPointer = NULL;

// Class Engine.AnimNodeSynch
// 0x0013 (0x0150 - 0x013D)
class UAnimNodeSynch : public UAnimNodeBlendBase
{
public:
	TArray< struct FSynchGroup >                       Groups;                                           		// 0x0140 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeSynch" );

		return pClassPointer;
	};

	void SetGroupRateScale ( );
	void GetRelativePosition ( );
	void ForceRelativePosition ( );
	void GetMasterNodeOfGroup ( );
	void RemoveNodeFromGroup ( );
	void AddNodeToGroup ( );
};

UClass* UAnimNodeSynch::pClassPointer = NULL;

// Class Engine.AnimTree
// 0x014F (0x028C - 0x013D)
class UAnimTree : public UAnimNodeBlendBase
{
public:
	class UAnimTree*                                   AnimTreeTemplate;                                 		// 0x0140 (0x0008) [0x0000000000000000]              
	DWORD                                              bEnablePooling : 1;                               		// 0x0148 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseSavedPose : 1;                                		// 0x0148 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bBeingEdited : 1;                                 		// 0x0148 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bParentNodeArrayBuilt : 1;                        		// 0x0148 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bRebuildAnimTickArray : 1;                        		// 0x0148 (0x0004) [0x0000000000000000] [0x00000010] 
	TArray< struct FAnimGroup >                        AnimGroups;                                       		// 0x014C (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             PrioritizedSkelBranches;                          		// 0x015C (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             ComposePrePassBoneNames;                          		// 0x016C (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             ComposePostPassBoneNames;                         		// 0x017C (0x0010) [0x0000000000000000]              
	TArray< class UMorphNodeBase* >                    RootMorphNodes;                                   		// 0x018C (0x0010) [0x0000000000000000]              
	TArray< struct FSkelControlListHead >              SkelControlLists;                                 		// 0x019C (0x0010) [0x0000000000000000]              
	TArray< struct FBoneAtom >                         SavedPose;                                        		// 0x01AC (0x0010) [0x0000000000000000]              
	int                                                MorphConnDrawY;                                   		// 0x01BC (0x0004) [0x0000000000000000]              
	float                                              PreviewPlayRate;                                  		// 0x01C0 (0x0004) [0x0000000000000000]              
	class USkeletalMesh*                               PreviewSkelMesh;                                  		// 0x01C4 (0x0008) [0x0000000000000000]              
	class USkeletalMesh*                               SocketSkelMesh;                                   		// 0x01CC (0x0008) [0x0000000000000000]              
	class UStaticMesh*                                 SocketStaticMesh;                                 		// 0x01D4 (0x0008) [0x0000000000000000]              
	struct FName                                       SocketName;                                       		// 0x01DC (0x0008) [0x0000000000000000]              
	TArray< class UAnimSet* >                          PreviewAnimSets;                                  		// 0x01E4 (0x0010) [0x0000000000000000]              
	TArray< class UMorphTargetSet* >                   PreviewMorphSets;                                 		// 0x01F4 (0x0010) [0x0000000000000000]              
	TArray< struct FPreviewSkelMeshStruct >            PreviewMeshList;                                  		// 0x0204 (0x0010) [0x0000000000000000]              
	int                                                PreviewMeshIndex;                                 		// 0x0214 (0x0004) [0x0000000000000000]              
	TArray< struct FPreviewSocketStruct >              PreviewSocketList;                                		// 0x0218 (0x0010) [0x0000000000000000]              
	int                                                PreviewSocketIndex;                               		// 0x0228 (0x0004) [0x0000000000000000]              
	TArray< struct FPreviewAnimSetsStruct >            PreviewAnimSetList;                               		// 0x022C (0x0010) [0x0000000000000000]              
	int                                                PreviewAnimSetListIndex;                          		// 0x023C (0x0004) [0x0000000000000000]              
	int                                                PreviewAnimSetIndex;                              		// 0x0240 (0x0004) [0x0000000000000000]              
	struct FVector                                     PreviewCamPos;                                    		// 0x0244 (0x000C) [0x0000000000000000]              
	struct FRotator                                    PreviewCamRot;                                    		// 0x0250 (0x000C) [0x0000000000000000]              
	struct FVector                                     PreviewFloorPos;                                  		// 0x025C (0x000C) [0x0000000000000000]              
	int                                                PreviewFloorYaw;                                  		// 0x0268 (0x0004) [0x0000000000000000]              
	TArray< class UAnimNodeFrame* >                    AnimNodeFrames;                                   		// 0x026C (0x0010) [0x0000000000000000]              
	TArray< class UAnimNode* >                         AnimTickArray;                                    		// 0x027C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimTree" );

		return pClassPointer;
	};

	void GetGroupIndex ( );
	void GetGroupRateScale ( );
	void SetGroupRateScale ( );
	void GetGroupRelativePosition ( );
	void ForceGroupRelativePosition ( );
	void GetGroupNotifyMaster ( );
	void GetGroupSynchMaster ( );
	void SetAnimGroupForNode ( );
	void SetUseSavedPose ( );
	void FindMorphNode ( );
	void FindSkelControl ( );
};

UClass* UAnimTree::pClassPointer = NULL;

// Class Engine.AnimNodeSequence
// 0x0070 (0x0198 - 0x0128)
class UAnimNodeSequence : public UAnimNode
{
public:
	struct FName                                       AnimSeqName;                                      		// 0x0128 (0x0008) [0x0000000000000000]              
	float                                              Rate;                                             		// 0x0130 (0x0004) [0x0000000000000000]              
	DWORD                                              bPlaying : 1;                                     		// 0x0134 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLooping : 1;                                     		// 0x0134 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCauseActorAnimEnd : 1;                           		// 0x0134 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bCauseActorAnimPlay : 1;                          		// 0x0134 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bZeroRootRotation : 1;                            		// 0x0134 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bZeroRootTranslation : 1;                         		// 0x0134 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bDisableWarningWhenAnimNotFound : 1;              		// 0x0134 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bNoNotifies : 1;                                  		// 0x0134 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bForceRefposeWhenNotPlaying : 1;                  		// 0x0134 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bIsIssuingNotifies : 1;                           		// 0x0134 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bForceAlwaysSlave : 1;                            		// 0x0134 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bSynchronize : 1;                                 		// 0x0134 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bReverseSync : 1;                                 		// 0x0134 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bShowTimeLineSlider : 1;                          		// 0x0134 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bLoopCameraAnim : 1;                              		// 0x0134 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bRandomizeCameraAnimLoopStartTime : 1;            		// 0x0134 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bEditorOnlyAddRefPoseToAdditiveAnimation : 1;     		// 0x0134 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bCheckForFinishAnimEarly : 1;                     		// 0x0134 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bBlendingOut : 1;                                 		// 0x0134 (0x0004) [0x0000000000000000] [0x00040000] 
	float                                              CurrentTime;                                      		// 0x0138 (0x0004) [0x0000000000000000]              
	float                                              PreviousTime;                                     		// 0x013C (0x0004) [0x0000000000000000]              
	float                                              EndTime;                                          		// 0x0140 (0x0004) [0x0000000000000000]              
	class UAnimSequence*                               AnimSeq;                                          		// 0x0144 (0x0008) [0x0000000000000000]              
	int                                                AnimLinkupIndex;                                  		// 0x014C (0x0004) [0x0000000000000000]              
	float                                              NotifyWeightThreshold;                            		// 0x0150 (0x0004) [0x0000000000000000]              
	struct FName                                       SynchGroupName;                                   		// 0x0154 (0x0008) [0x0000000000000000]              
	float                                              SynchPosOffset;                                   		// 0x015C (0x0004) [0x0000000000000000]              
	class UCameraAnim*                                 CameraAnim;                                       		// 0x0160 (0x0008) [0x0000000000000000]              
	class UCameraAnimInst*                             ActiveCameraAnimInstance;                         		// 0x0168 (0x0008) [0x0000000000000000]              
	float                                              CameraAnimScale;                                  		// 0x0170 (0x0004) [0x0000000000000000]              
	float                                              CameraAnimPlayRate;                               		// 0x0174 (0x0004) [0x0000000000000000]              
	float                                              CameraAnimBlendInTime;                            		// 0x0178 (0x0004) [0x0000000000000000]              
	float                                              CameraAnimBlendOutTime;                           		// 0x017C (0x0004) [0x0000000000000000]              
	unsigned char                                      RootBoneOption[ 0x3 ];                            		// 0x0180 (0x0003) [0x0000000000000000]              
	unsigned char                                      RootRotationOption[ 0x3 ];                        		// 0x0183 (0x0003) [0x0000000000000000]              
	TArray< class USkelControlBase* >                  MetaDataSkelControlList;                          		// 0x0188 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeSequence" );

		return pClassPointer;
	};

	void SetRootBoneRotationOption ( );
	void SetRootBoneAxisOption ( );
	void GetTimeLeft ( );
	void GetAnimPlaybackLength ( );
	void GetGlobalPlayRate ( );
	void GetGroupRelativePosition ( );
	void FindGroupPosition ( );
	void FindGroupRelativePosition ( );
	void GetNormalizedPosition ( );
	void SetPosition ( );
	void ReplayAnim ( );
	void StopAnim ( );
	void PlayAnim ( );
	void SetAnim ( );
};

UClass* UAnimNodeSequence::pClassPointer = NULL;

// Class Engine.AnimNodeSequenceBlendBase
// 0x0010 (0x01A8 - 0x0198)
class UAnimNodeSequenceBlendBase : public UAnimNodeSequence
{
public:
	TArray< struct FAnimBlendInfo >                    Anims;                                            		// 0x0198 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeSequenceBlendBase" );

		return pClassPointer;
	};

};

UClass* UAnimNodeSequenceBlendBase::pClassPointer = NULL;

// Class Engine.AnimNodeSequenceBlendByAim
// 0x0070 (0x0218 - 0x01A8)
class UAnimNodeSequenceBlendByAim : public UAnimNodeSequenceBlendBase
{
public:
	struct FVector2D                                   Aim;                                              		// 0x01A8 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   PreviousAim;                                      		// 0x01B0 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   HorizontalRange;                                  		// 0x01B8 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   VerticalRange;                                    		// 0x01C0 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   AngleOffset;                                      		// 0x01C8 (0x0008) [0x0000000000000000]              
	struct FName                                       AnimName_LU;                                      		// 0x01D0 (0x0008) [0x0000000000000000]              
	struct FName                                       AnimName_LC;                                      		// 0x01D8 (0x0008) [0x0000000000000000]              
	struct FName                                       AnimName_LD;                                      		// 0x01E0 (0x0008) [0x0000000000000000]              
	struct FName                                       AnimName_CU;                                      		// 0x01E8 (0x0008) [0x0000000000000000]              
	struct FName                                       AnimName_CC;                                      		// 0x01F0 (0x0008) [0x0000000000000000]              
	struct FName                                       AnimName_CD;                                      		// 0x01F8 (0x0008) [0x0000000000000000]              
	struct FName                                       AnimName_RU;                                      		// 0x0200 (0x0008) [0x0000000000000000]              
	struct FName                                       AnimName_RC;                                      		// 0x0208 (0x0008) [0x0000000000000000]              
	struct FName                                       AnimName_RD;                                      		// 0x0210 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeSequenceBlendByAim" );

		return pClassPointer;
	};

	void CheckAnimsUpToDate ( );
};

UClass* UAnimNodeSequenceBlendByAim::pClassPointer = NULL;

// Class Engine.AnimNodeFrame
// 0x0038 (0x00C4 - 0x008C)
class UAnimNodeFrame : public UAnimObject
{
public:
	int                                                SizeX;                                            		// 0x008C (0x0004) [0x0000000000000000]              
	int                                                SizeY;                                            		// 0x0090 (0x0004) [0x0000000000000000]              
	int                                                BorderWidth;                                      		// 0x0094 (0x0004) [0x0000000000000000]              
	DWORD                                              bDrawBox : 1;                                     		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFilled : 1;                                      		// 0x0098 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bTileFill : 1;                                    		// 0x0098 (0x0004) [0x0000000000000000] [0x00000004] 
	struct FColor                                      BorderColor;                                      		// 0x009C (0x0004) [0x0000000000000000]              
	struct FColor                                      FillColor;                                        		// 0x00A0 (0x0004) [0x0000000000000000]              
	class UTexture2D*                                  FillTexture;                                      		// 0x00A4 (0x0008) [0x0000000000000000]              
	class UMaterial*                                   FillMaterial;                                     		// 0x00AC (0x0008) [0x0000000000000000]              
	struct FString                                     ObjComment;                                       		// 0x00B4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNodeFrame" );

		return pClassPointer;
	};

};

UClass* UAnimNodeFrame::pClassPointer = NULL;

// Class Engine.MorphNodeBase
// 0x000C (0x0098 - 0x008C)
class UMorphNodeBase : public UAnimObject
{
public:
	struct FName                                       NodeName;                                         		// 0x008C (0x0008) [0x0000000000000000]              
	DWORD                                              bDrawSlider : 1;                                  		// 0x0094 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MorphNodeBase" );

		return pClassPointer;
	};

};

UClass* UMorphNodeBase::pClassPointer = NULL;

// Class Engine.MorphNodeMultiPose
// 0x0030 (0x00C8 - 0x0098)
class UMorphNodeMultiPose : public UMorphNodeBase
{
public:
	TArray< class UMorphTarget* >                      Targets;                                          		// 0x0098 (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             MorphNames;                                       		// 0x00A8 (0x0010) [0x0000000000000000]              
	TArray< float >                                    Weights;                                          		// 0x00B8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MorphNodeMultiPose" );

		return pClassPointer;
	};

	void UpdateMorphTarget ( );
	void RemoveMorphTarget ( );
	void AddMorphTarget ( );
};

UClass* UMorphNodeMultiPose::pClassPointer = NULL;

// Class Engine.MorphNodePose
// 0x0014 (0x00AC - 0x0098)
class UMorphNodePose : public UMorphNodeBase
{
public:
	class UMorphTarget*                                Target;                                           		// 0x0098 (0x0008) [0x0000000000000000]              
	struct FName                                       MorphName;                                        		// 0x00A0 (0x0008) [0x0000000000000000]              
	float                                              Weight;                                           		// 0x00A8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MorphNodePose" );

		return pClassPointer;
	};

	void SetMorphTarget ( );
};

UClass* UMorphNodePose::pClassPointer = NULL;

// Class Engine.MorphNodeWeightBase
// 0x0010 (0x00A8 - 0x0098)
class UMorphNodeWeightBase : public UMorphNodeBase
{
public:
	TArray< struct FMorphNodeConn >                    NodeConns;                                        		// 0x0098 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MorphNodeWeightBase" );

		return pClassPointer;
	};

};

UClass* UMorphNodeWeightBase::pClassPointer = NULL;

// Class Engine.MorphNodeWeight
// 0x0004 (0x00AC - 0x00A8)
class UMorphNodeWeight : public UMorphNodeWeightBase
{
public:
	float                                              NodeWeight;                                       		// 0x00A8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MorphNodeWeight" );

		return pClassPointer;
	};

	void SetNodeWeight ( );
};

UClass* UMorphNodeWeight::pClassPointer = NULL;

// Class Engine.MorphNodeWeightByBoneAngle
// 0x0044 (0x00EC - 0x00A8)
class UMorphNodeWeightByBoneAngle : public UMorphNodeWeightBase
{
public:
	float                                              Angle;                                            		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              NodeWeight;                                       		// 0x00AC (0x0004) [0x0000000000000000]              
	struct FName                                       BaseBoneName;                                     		// 0x00B0 (0x0008) [0x0000000000000000]              
	unsigned char                                      BaseBoneAxis;                                     		// 0x00B8 (0x0001) [0x0000000000000000]              
	unsigned char                                      AngleBoneAxis;                                    		// 0x00B9 (0x0001) [0x0000000000000000]              
	DWORD                                              bInvertBaseBoneAxis : 1;                          		// 0x00BC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bInvertAngleBoneAxis : 1;                         		// 0x00BC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bControlMaterialParameter : 1;                    		// 0x00BC (0x0004) [0x0000000000000000] [0x00000004] 
	struct FName                                       AngleBoneName;                                    		// 0x00C0 (0x0008) [0x0000000000000000]              
	int                                                MaterialSlotId;                                   		// 0x00C8 (0x0004) [0x0000000000000000]              
	struct FName                                       ScalarParameterName;                              		// 0x00CC (0x0008) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   MaterialInstanceConstant;                         		// 0x00D4 (0x0008) [0x0000000000000000]              
	TArray< struct FBoneAngleMorph >                   WeightArray;                                      		// 0x00DC (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MorphNodeWeightByBoneAngle" );

		return pClassPointer;
	};

};

UClass* UMorphNodeWeightByBoneAngle::pClassPointer = NULL;

// Class Engine.MorphNodeWeightByBoneRotation
// 0x003C (0x00E4 - 0x00A8)
class UMorphNodeWeightByBoneRotation : public UMorphNodeWeightBase
{
public:
	float                                              Angle;                                            		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              NodeWeight;                                       		// 0x00AC (0x0004) [0x0000000000000000]              
	struct FName                                       BoneName;                                         		// 0x00B0 (0x0008) [0x0000000000000000]              
	unsigned char                                      BoneAxis;                                         		// 0x00B8 (0x0001) [0x0000000000000000]              
	DWORD                                              bInvertBoneAxis : 1;                              		// 0x00BC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bControlMaterialParameter : 1;                    		// 0x00BC (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< struct FBoneAngleMorph >                   WeightArray;                                      		// 0x00C0 (0x0010) [0x0000000000000000]              
	int                                                MaterialSlotId;                                   		// 0x00D0 (0x0004) [0x0000000000000000]              
	struct FName                                       ScalarParameterName;                              		// 0x00D4 (0x0008) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   MaterialInstanceConstant;                         		// 0x00DC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MorphNodeWeightByBoneRotation" );

		return pClassPointer;
	};

};

UClass* UMorphNodeWeightByBoneRotation::pClassPointer = NULL;

// Class Engine.SkelControlBase
// 0x0068 (0x00F4 - 0x008C)
class USkelControlBase : public UAnimObject
{
public:
	struct FName                                       ControlName;                                      		// 0x008C (0x0008) [0x0000000000000000]              
	float                                              ControlStrength;                                  		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              BlendInTime;                                      		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              BlendOutTime;                                     		// 0x009C (0x0004) [0x0000000000000000]              
	unsigned char                                      BlendType;                                        		// 0x00A0 (0x0001) [0x0000000000000000]              
	DWORD                                              bPostPhysicsController : 1;                       		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSetStrengthFromAnimNode : 1;                     		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bInitializedCachedNodeList : 1;                   		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bControlledByAnimMetada : 1;                      		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bInvertMetadataWeight : 1;                        		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bPropagateSetActive : 1;                          		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bIgnoreWhenNotRendered : 1;                       		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bShouldTickInScript : 1;                          		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bShouldTickOwner : 1;                             		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bEnableEaseInOut : 1;                             		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000200] 
	float                                              StrengthTarget;                                   		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              BlendTimeToGo;                                    		// 0x00AC (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             StrengthAnimNodeNameList;                         		// 0x00B0 (0x0010) [0x0000000000000000]              
	TArray< class UAnimNode* >                         CachedNodeList;                                   		// 0x00C0 (0x0010) [0x0000000000000000]              
	float                                              AnimMetadataWeight;                               		// 0x00D0 (0x0004) [0x0000000000000000]              
	int                                                AnimMetaDataUpdateTag;                            		// 0x00D4 (0x0004) [0x0000000000000000]              
	float                                              BoneScale;                                        		// 0x00D8 (0x0004) [0x0000000000000000]              
	int                                                ControlTickTag;                                   		// 0x00DC (0x0004) [0x0000000000000000]              
	int                                                IgnoreAtOrAboveLOD;                               		// 0x00E0 (0x0004) [0x0000000000000000]              
	class USkelControlBase*                            NextControl;                                      		// 0x00E4 (0x0008) [0x0000000000000000]              
	int                                                ControlPosX;                                      		// 0x00EC (0x0004) [0x0000000000000000]              
	int                                                ControlPosY;                                      		// 0x00F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkelControlBase" );

		return pClassPointer;
	};

	void GetControlMetadataWeight ( );
	void eventTickSkelControl ( );
	void SetSkelControlStrength ( );
	void SetSkelControlActive ( );
};

UClass* USkelControlBase::pClassPointer = NULL;

// Class Engine.SkelControl_CCD_IK
// 0x004C (0x0140 - 0x00F4)
class USkelControl_CCD_IK : public USkelControlBase
{
public:
	struct FVector                                     EffectorLocation;                                 		// 0x00F4 (0x000C) [0x0000000000000000]              
	unsigned char                                      EffectorLocationSpace;                            		// 0x0100 (0x0001) [0x0000000000000000]              
	struct FName                                       EffectorSpaceBoneName;                            		// 0x0104 (0x0008) [0x0000000000000000]              
	struct FVector                                     EffectorTranslationFromBone;                      		// 0x010C (0x000C) [0x0000000000000000]              
	int                                                NumBones;                                         		// 0x0118 (0x0004) [0x0000000000000000]              
	int                                                MaxPerBoneIterations;                             		// 0x011C (0x0004) [0x0000000000000000]              
	int                                                IterationsCount;                                  		// 0x0120 (0x0004) [0x0000000000000000]              
	float                                              Precision;                                        		// 0x0124 (0x0004) [0x0000000000000000]              
	DWORD                                              bStartFromTail : 1;                               		// 0x0128 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bNoTurnOptimization : 1;                          		// 0x0128 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< float >                                    AngleConstraint;                                  		// 0x012C (0x0010) [0x0000000000000000]              
	float                                              MaxAngleSteps;                                    		// 0x013C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkelControl_CCD_IK" );

		return pClassPointer;
	};

};

UClass* USkelControl_CCD_IK::pClassPointer = NULL;

// Class Engine.SkelControl_Multiply
// 0x0004 (0x00F8 - 0x00F4)
class USkelControl_Multiply : public USkelControlBase
{
public:
	float                                              Multiplier;                                       		// 0x00F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkelControl_Multiply" );

		return pClassPointer;
	};

};

UClass* USkelControl_Multiply::pClassPointer = NULL;

// Class Engine.SkelControl_TwistBone
// 0x000C (0x0100 - 0x00F4)
class USkelControl_TwistBone : public USkelControlBase
{
public:
	struct FName                                       SourceBoneName;                                   		// 0x00F4 (0x0008) [0x0000000000000000]              
	float                                              TwistAngleScale;                                  		// 0x00FC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkelControl_TwistBone" );

		return pClassPointer;
	};

};

UClass* USkelControl_TwistBone::pClassPointer = NULL;

// Class Engine.SkelControlLimb
// 0x0058 (0x014C - 0x00F4)
class USkelControlLimb : public USkelControlBase
{
public:
	struct FVector                                     EffectorLocation;                                 		// 0x00F4 (0x000C) [0x0000000000000000]              
	unsigned char                                      EffectorLocationSpace;                            		// 0x0100 (0x0001) [0x0000000000000000]              
	unsigned char                                      JointTargetLocationSpace;                         		// 0x0101 (0x0001) [0x0000000000000000]              
	unsigned char                                      JointOffsetSpace;                                 		// 0x0102 (0x0001) [0x0000000000000000]              
	unsigned char                                      BoneAxis;                                         		// 0x0103 (0x0001) [0x0000000000000000]              
	unsigned char                                      JointAxis;                                        		// 0x0104 (0x0001) [0x0000000000000000]              
	struct FName                                       EffectorSpaceBoneName;                            		// 0x0108 (0x0008) [0x0000000000000000]              
	struct FVector                                     JointTargetLocation;                              		// 0x0110 (0x000C) [0x0000000000000000]              
	struct FName                                       JointTargetSpaceBoneName;                         		// 0x011C (0x0008) [0x0000000000000000]              
	struct FVector                                     JointOffset;                                      		// 0x0124 (0x000C) [0x0000000000000000]              
	struct FName                                       JointOffsetBoneName;                              		// 0x0130 (0x0008) [0x0000000000000000]              
	DWORD                                              bInvertBoneAxis : 1;                              		// 0x0138 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bInvertJointAxis : 1;                             		// 0x0138 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bRotateJoint : 1;                                 		// 0x0138 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bMaintainEffectorRelRot : 1;                      		// 0x0138 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bTakeRotationFromEffectorSpace : 1;               		// 0x0138 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bAllowStretching : 1;                             		// 0x0138 (0x0004) [0x0000000000000000] [0x00000020] 
	struct FVector2D                                   StretchLimits;                                    		// 0x013C (0x0008) [0x0000000000000000]              
	struct FName                                       StretchRollBoneName;                              		// 0x0144 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkelControlLimb" );

		return pClassPointer;
	};

};

UClass* USkelControlLimb::pClassPointer = NULL;

// Class Engine.SkelControlFootPlacement
// 0x0024 (0x0170 - 0x014C)
class USkelControlFootPlacement : public USkelControlLimb
{
public:
	float                                              FootOffset;                                       		// 0x014C (0x0004) [0x0000000000000000]              
	unsigned char                                      FootUpAxis;                                       		// 0x0150 (0x0001) [0x0000000000000000]              
	struct FRotator                                    FootRotOffset;                                    		// 0x0154 (0x000C) [0x0000000000000000]              
	DWORD                                              bInvertFootUpAxis : 1;                            		// 0x0160 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bOrientFootToGround : 1;                          		// 0x0160 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bOnlyEnableForUpAdjustment : 1;                   		// 0x0160 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              MaxUpAdjustment;                                  		// 0x0164 (0x0004) [0x0000000000000000]              
	float                                              MaxDownAdjustment;                                		// 0x0168 (0x0004) [0x0000000000000000]              
	float                                              MaxFootOrientAdjust;                              		// 0x016C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkelControlFootPlacement" );

		return pClassPointer;
	};

};

UClass* USkelControlFootPlacement::pClassPointer = NULL;

// Class Engine.SkelControlLookAt
// 0x009C (0x0190 - 0x00F4)
class USkelControlLookAt : public USkelControlBase
{
public:
	struct FVector                                     TargetLocation;                                   		// 0x00F4 (0x000C) [0x0000000000000000]              
	unsigned char                                      TargetLocationSpace;                              		// 0x0100 (0x0001) [0x0000000000000000]              
	unsigned char                                      LookAtAxis;                                       		// 0x0101 (0x0001) [0x0000000000000000]              
	unsigned char                                      UpAxis;                                           		// 0x0102 (0x0001) [0x0000000000000000]              
	unsigned char                                      AllowRotationSpace;                               		// 0x0103 (0x0001) [0x0000000000000000]              
	struct FName                                       TargetSpaceBoneName;                              		// 0x0104 (0x0008) [0x0000000000000000]              
	DWORD                                              bInvertLookAtAxis : 1;                            		// 0x010C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDefineUpAxis : 1;                                		// 0x010C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bInvertUpAxis : 1;                                		// 0x010C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bEnableLimit : 1;                                 		// 0x010C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bLimitBasedOnRefPose : 1;                         		// 0x010C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bDisableBeyondLimit : 1;                          		// 0x010C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bNotifyBeyondLimit : 1;                           		// 0x010C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bShowLimit : 1;                                   		// 0x010C (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bAllowRotationX : 1;                              		// 0x010C (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bAllowRotationY : 1;                              		// 0x010C (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bAllowRotationZ : 1;                              		// 0x010C (0x0004) [0x0000000000000000] [0x00000400] 
	float                                              TargetLocationInterpSpeed;                        		// 0x0110 (0x0004) [0x0000000000000000]              
	struct FVector                                     DesiredTargetLocation;                            		// 0x0114 (0x000C) [0x0000000000000000]              
	struct FVector                                     ActorSpaceLookAtTarget;                           		// 0x0120 (0x000C) [0x0000000000000000]              
	float                                              MaxAngle;                                         		// 0x012C (0x0004) [0x0000000000000000]              
	float                                              OuterMaxAngle;                                    		// 0x0130 (0x0004) [0x0000000000000000]              
	float                                              DeadZoneAngle;                                    		// 0x0134 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   RotationAngleRangeX;                              		// 0x0138 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   RotationAngleRangeY;                              		// 0x0140 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   RotationAngleRangeZ;                              		// 0x0148 (0x0008) [0x0000000000000000]              
	struct FName                                       AllowRotationOtherBoneName;                       		// 0x0150 (0x0008) [0x0000000000000000]              
	float                                              LookAtAlpha;                                      		// 0x0158 (0x0004) [0x0000000000000000]              
	float                                              LookAtAlphaTarget;                                		// 0x015C (0x0004) [0x0000000000000000]              
	float                                              LookAtAlphaBlendTimeToGo;                         		// 0x0160 (0x0004) [0x0000000000000000]              
	struct FVector                                     LimitLookDir;                                     		// 0x0164 (0x000C) [0x0000000000000000]              
	struct FVector                                     BaseLookDir;                                      		// 0x0170 (0x000C) [0x0000000000000000]              
	struct FVector                                     BaseBonePos;                                      		// 0x017C (0x000C) [0x0000000000000000]              
	float                                              LastCalcTime;                                     		// 0x0188 (0x0004) [0x0000000000000000]              
	int                                                ControlBoneIndex;                                 		// 0x018C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkelControlLookAt" );

		return pClassPointer;
	};

	void CanLookAtPoint ( );
	void SetLookAtAlpha ( );
	void InterpolateTargetLocation ( );
	void SetTargetLocation ( );
};

UClass* USkelControlLookAt::pClassPointer = NULL;

// Class Engine.SkelControlSingleBone
// 0x0030 (0x0124 - 0x00F4)
class USkelControlSingleBone : public USkelControlBase
{
public:
	DWORD                                              bApplyTranslation : 1;                            		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bApplyRotation : 1;                               		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAddTranslation : 1;                              		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bAddRotation : 1;                                 		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bRemoveMeshRotation : 1;                          		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000010] 
	struct FVector                                     BoneTranslation;                                  		// 0x00F8 (0x000C) [0x0000000000000000]              
	unsigned char                                      BoneTranslationSpace;                             		// 0x0104 (0x0001) [0x0000000000000000]              
	unsigned char                                      BoneRotationSpace;                                		// 0x0105 (0x0001) [0x0000000000000000]              
	struct FName                                       TranslationSpaceBoneName;                         		// 0x0108 (0x0008) [0x0000000000000000]              
	struct FRotator                                    BoneRotation;                                     		// 0x0110 (0x000C) [0x0000000000000000]              
	struct FName                                       RotationSpaceBoneName;                            		// 0x011C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkelControlSingleBone" );

		return pClassPointer;
	};

};

UClass* USkelControlSingleBone::pClassPointer = NULL;

// Class Engine.SkelControlHandlebars
// 0x0014 (0x0138 - 0x0124)
class USkelControlHandlebars : public USkelControlSingleBone
{
public:
	unsigned char                                      WheelRollAxis;                                    		// 0x0124 (0x0001) [0x0000000000000000]              
	unsigned char                                      HandlebarRotateAxis;                              		// 0x0125 (0x0001) [0x0000000000000000]              
	struct FName                                       WheelBoneName;                                    		// 0x0128 (0x0008) [0x0000000000000000]              
	DWORD                                              bInvertRotation : 1;                              		// 0x0130 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                SteerWheelBoneIndex;                              		// 0x0134 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkelControlHandlebars" );

		return pClassPointer;
	};

};

UClass* USkelControlHandlebars::pClassPointer = NULL;

// Class Engine.SkelControlWheel
// 0x0018 (0x013C - 0x0124)
class USkelControlWheel : public USkelControlSingleBone
{
public:
	float                                              WheelDisplacement;                                		// 0x0124 (0x0004) [0x0000000000000000]              
	float                                              WheelMaxRenderDisplacement;                       		// 0x0128 (0x0004) [0x0000000000000000]              
	float                                              WheelRoll;                                        		// 0x012C (0x0004) [0x0000000000000000]              
	unsigned char                                      WheelRollAxis;                                    		// 0x0130 (0x0001) [0x0000000000000000]              
	unsigned char                                      WheelSteeringAxis;                                		// 0x0131 (0x0001) [0x0000000000000000]              
	float                                              WheelSteering;                                    		// 0x0134 (0x0004) [0x0000000000000000]              
	DWORD                                              bInvertWheelRoll : 1;                             		// 0x0138 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bInvertWheelSteering : 1;                         		// 0x0138 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkelControlWheel" );

		return pClassPointer;
	};

};

UClass* USkelControlWheel::pClassPointer = NULL;

// Class Engine.SkelControlSpline
// 0x0014 (0x0108 - 0x00F4)
class USkelControlSpline : public USkelControlBase
{
public:
	int                                                SplineLength;                                     		// 0x00F4 (0x0004) [0x0000000000000000]              
	unsigned char                                      SplineBoneAxis;                                   		// 0x00F8 (0x0001) [0x0000000000000000]              
	unsigned char                                      BoneRotMode;                                      		// 0x00F9 (0x0001) [0x0000000000000000]              
	DWORD                                              bInvertSplineBoneAxis : 1;                        		// 0x00FC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              EndSplineTension;                                 		// 0x0100 (0x0004) [0x0000000000000000]              
	float                                              StartSplineTension;                               		// 0x0104 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkelControlSpline" );

		return pClassPointer;
	};

};

UClass* USkelControlSpline::pClassPointer = NULL;

// Class Engine.SkelControlTrail
// 0x007C (0x0170 - 0x00F4)
class USkelControlTrail : public USkelControlBase
{
public:
	int                                                ChainLength;                                      		// 0x00F4 (0x0004) [0x0000000000000000]              
	unsigned char                                      ChainBoneAxis;                                    		// 0x00F8 (0x0001) [0x0000000000000000]              
	DWORD                                              bInvertChainBoneAxis : 1;                         		// 0x00FC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLimitStretch : 1;                                		// 0x00FC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bActorSpaceFakeVel : 1;                           		// 0x00FC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bHadValidStrength : 1;                            		// 0x00FC (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              TrailRelaxation;                                  		// 0x0100 (0x0004) [0x0000000000000000]              
	float                                              StretchLimit;                                     		// 0x0104 (0x0004) [0x0000000000000000]              
	struct FVector                                     FakeVelocity;                                     		// 0x0108 (0x000C) [0x0000000000000000]              
	float                                              ThisTimstep;                                      		// 0x0114 (0x0004) [0x0000000000000000]              
	TArray< struct FVector >                           TrailBoneLocations;                               		// 0x0118 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0128 (0x0008) MISSED OFFSET
	struct FMatrix                                     OldLocalToWorld;                                  		// 0x0130 (0x0040) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkelControlTrail" );

		return pClassPointer;
	};

};

UClass* USkelControlTrail::pClassPointer = NULL;

// Class Engine.AnimSequence
// 0x0138 (0x0198 - 0x0060)
class UAnimSequence : public UObject
{
public:
	struct FName                                       SequenceName;                                     		// 0x0060 (0x0008) [0x0000000000000000]              
	TArray< struct FAnimNotifyEvent >                  Notifies;                                         		// 0x0068 (0x0010) [0x0000000000000000]              
	TArray< class UAnimMetaData* >                     MetaData;                                         		// 0x0078 (0x0010) [0x0000000000000000]              
	TArray< struct FSkelControlModifier >              BoneControlModifiers;                             		// 0x0088 (0x0010) [0x0000000000000000]              
	float                                              SequenceLength;                                   		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                NumFrames;                                        		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              RateScale;                                        		// 0x00A0 (0x0004) [0x0000000000000000]              
	DWORD                                              bNoLoopingInterpolation : 1;                      		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIsAdditive : 1;                                  		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAdditiveBuiltLooping : 1;                        		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bDoNotOverrideCompression : 1;                    		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bHasBeenUsed : 1;                                 		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bWasCompressedWithoutTranslations : 1;            		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000020] 
	TArray< struct FRawAnimSequenceTrack >             RawAnimData;                                      		// 0x00A8 (0x0010) [0x0000000000000000]              
	TArray< struct FRawAnimSequenceTrack >             RawAnimationData;                                 		// 0x00B8 (0x0010) [0x0000000000000000]              
	TArray< struct FTranslationTrack >                 TranslationData;                                  		// 0x00C8 (0x0010) [0x0000000000000000]              
	TArray< struct FRotationTrack >                    RotationData;                                     		// 0x00D8 (0x0010) [0x0000000000000000]              
	TArray< struct FCurveTrack >                       CurveData;                                        		// 0x00E8 (0x0010) [0x0000000000000000]              
	class UAnimationCompressionAlgorithm*              CompressionScheme;                                		// 0x00F8 (0x0008) [0x0000000000000000]              
	unsigned char                                      TranslationCompressionFormat;                     		// 0x0100 (0x0001) [0x0000000000000000]              
	unsigned char                                      RotationCompressionFormat;                        		// 0x0101 (0x0001) [0x0000000000000000]              
	unsigned char                                      KeyEncodingFormat;                                		// 0x0102 (0x0001) [0x0000000000000000]              
	TArray< int >                                      CompressedTrackOffsets;                           		// 0x0104 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            CompressedByteStream;                             		// 0x0114 (0x0010) [0x0000000000000000]              
	struct FPointer                                    TranslationCodec;                                 		// 0x0124 (0x0008) [0x0000000000000000]              
	struct FPointer                                    RotationCodec;                                    		// 0x012C (0x0008) [0x0000000000000000]              
	TArray< struct FBoneAtom >                         AdditiveRefPose;                                  		// 0x0134 (0x0010) [0x0000000000000000]              
	TArray< struct FRawAnimSequenceTrack >             AdditiveBasePose;                                 		// 0x0144 (0x0010) [0x0000000000000000]              
	struct FName                                       AdditiveRefName;                                  		// 0x0154 (0x0008) [0x0000000000000000]              
	TArray< class UAnimSequence* >                     AdditiveBasePoseAnimSeq;                          		// 0x015C (0x0010) [0x0000000000000000]              
	TArray< class UAnimSequence* >                     AdditiveTargetPoseAnimSeq;                        		// 0x016C (0x0010) [0x0000000000000000]              
	TArray< class UAnimSequence* >                     RelatedAdditiveAnimSeqs;                          		// 0x017C (0x0010) [0x0000000000000000]              
	int                                                EncodingPkgVersion;                               		// 0x018C (0x0004) [0x0000000000000000]              
	int                                                CompressCommandletVersion;                        		// 0x0190 (0x0004) [0x0000000000000000]              
	float                                              UseScore;                                         		// 0x0194 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimSequence" );

		return pClassPointer;
	};

	void GetNotifyTimeByClass ( );
};

UClass* UAnimSequence::pClassPointer = NULL;

// Class Engine.AnimSet
// 0x0114 (0x0174 - 0x0060)
class UAnimSet : public UObject
{
public:
	DWORD                                              bAnimRotationOnly : 1;                            		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< struct FName >                             TrackBoneNames;                                   		// 0x0064 (0x0010) [0x0000000000000000]              
	TArray< class UAnimSequence* >                     Sequences;                                        		// 0x0074 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x0084 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.AnimSet.SequenceCache
	TArray< struct FAnimSetMeshLinkup >                LinkupCache;                                      		// 0x00CC (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x48 ];                            		// 0x00DC (0x0048) UNKNOWN PROPERTY: MapProperty Engine.AnimSet.SkelMesh2LinkupCache
	TArray< unsigned char >                            BoneUseAnimTranslation;                           		// 0x0124 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            ForceUseMeshTranslation;                          		// 0x0134 (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             UseTranslationBoneNames;                          		// 0x0144 (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             ForceMeshTranslationBoneNames;                    		// 0x0154 (0x0010) [0x0000000000000000]              
	struct FName                                       PreviewSkelMeshName;                              		// 0x0164 (0x0008) [0x0000000000000000]              
	struct FName                                       BestRatioSkelMeshName;                            		// 0x016C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimSet" );

		return pClassPointer;
	};

};

UClass* UAnimSet::pClassPointer = NULL;

// Class Engine.MorphTarget
// 0x001C (0x007C - 0x0060)
class UMorphTarget : public UObject
{
public:
	TArray< int >                                      MorphLODModels;                                   		// 0x0060 (0x0010) [0x0000000000000000]              
	int                                                MaterialSlotId;                                   		// 0x0070 (0x0004) [0x0000000000000000]              
	struct FName                                       ScalarParameterName;                              		// 0x0074 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MorphTarget" );

		return pClassPointer;
	};

};

UClass* UMorphTarget::pClassPointer = NULL;

// Class Engine.MorphTargetSet
// 0x0028 (0x0088 - 0x0060)
class UMorphTargetSet : public UObject
{
public:
	TArray< class UMorphTarget* >                      Targets;                                          		// 0x0060 (0x0010) [0x0000000000000000]              
	class USkeletalMesh*                               BaseSkelMesh;                                     		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FArray_Mirror                               RawWedgePointIndices;                             		// 0x0078 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MorphTargetSet" );

		return pClassPointer;
	};

	void FindMorphTarget ( );
};

UClass* UMorphTargetSet::pClassPointer = NULL;

// Class Engine.MorphWeightSequence
// 0x0000 (0x0060 - 0x0060)
class UMorphWeightSequence : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MorphWeightSequence" );

		return pClassPointer;
	};

};

UClass* UMorphWeightSequence::pClassPointer = NULL;

// Class Engine.DecalActorBase
// 0x0010 (0x0254 - 0x0244)
class ADecalActorBase : public AActor
{
public:
	struct FPointer                                    VfTable_IEditorLinkSelectionInterface;            		// 0x0244 (0x0008) [0x0000000000000000]              
	class UDecalComponent*                             Decal;                                            		// 0x024C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DecalActorBase" );

		return pClassPointer;
	};

};

UClass* ADecalActorBase::pClassPointer = NULL;

// Class Engine.DecalActor
// 0x0000 (0x0254 - 0x0254)
class ADecalActor : public ADecalActorBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DecalActor" );

		return pClassPointer;
	};

};

UClass* ADecalActor::pClassPointer = NULL;

// Class Engine.DecalActorMovable
// 0x0000 (0x0254 - 0x0254)
class ADecalActorMovable : public ADecalActorBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DecalActorMovable" );

		return pClassPointer;
	};

};

UClass* ADecalActorMovable::pClassPointer = NULL;

// Class Engine.DecalManager
// 0x0040 (0x0284 - 0x0244)
class ADecalManager : public AActor
{
public:
	class UDecalComponent*                             DecalTemplate;                                    		// 0x0244 (0x0008) [0x0000000000000000]              
	TArray< class UDecalComponent* >                   PoolDecals;                                       		// 0x024C (0x0010) [0x0000000000000000]              
	int                                                MaxActiveDecals;                                  		// 0x025C (0x0004) [0x0000000000000000]              
	float                                              DecalLifeSpan;                                    		// 0x0260 (0x0004) [0x0000000000000000]              
	float                                              DecalDepthBias;                                   		// 0x0264 (0x0004) [0x0000000000000000]              
	float                                              OrbisDecalDepthBias;                              		// 0x0268 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   DecalBlendRange;                                  		// 0x026C (0x0008) [0x0000000000000000]              
	TArray< struct FActiveDecalInfo >                  ActiveDecals;                                     		// 0x0274 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DecalManager" );

		return pClassPointer;
	};

	void Reset ( );
	void SpawnDecal ( );
	void GetPooledComponent ( );
	void SetDecalParameters ( );
	void CanSpawnDecals ( );
	void eventDecalFinished ( );
	void AreDynamicDecalsEnabled ( );
};

UClass* ADecalManager::pClassPointer = NULL;

// Class Engine.DecalComponent
// 0x0188 (0x03C0 - 0x0238)
class UDecalComponent : public UPrimitiveComponent
{
public:
	class UMaterialInterface*                          DecalMaterial;                                    		// 0x0238 (0x0008) [0x0000000000000000]              
	float                                              Width;                                            		// 0x0240 (0x0004) [0x0000000000000000]              
	float                                              Height;                                           		// 0x0244 (0x0004) [0x0000000000000000]              
	float                                              TileX;                                            		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              TileY;                                            		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              OffsetX;                                          		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              OffsetY;                                          		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              DecalRotation;                                    		// 0x0258 (0x0004) [0x0000000000000000]              
	float                                              FieldOfView;                                      		// 0x025C (0x0004) [0x0000000000000000]              
	float                                              NearPlane;                                        		// 0x0260 (0x0004) [0x0000000000000000]              
	float                                              FarPlane;                                         		// 0x0264 (0x0004) [0x0000000000000000]              
	struct FVector                                     Location;                                         		// 0x0268 (0x000C) [0x0000000000000000]              
	struct FRotator                                    Orientation;                                      		// 0x0274 (0x000C) [0x0000000000000000]              
	struct FVector                                     HitLocation;                                      		// 0x0280 (0x000C) [0x0000000000000000]              
	struct FVector                                     HitNormal;                                        		// 0x028C (0x000C) [0x0000000000000000]              
	struct FVector                                     HitTangent;                                       		// 0x0298 (0x000C) [0x0000000000000000]              
	struct FVector                                     HitBinormal;                                      		// 0x02A4 (0x000C) [0x0000000000000000]              
	DWORD                                              bNoClip : 1;                                      		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bStaticDecal : 1;                                 		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bProjectOnBackfaces : 1;                          		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bProjectOnHidden : 1;                             		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bProjectOnBSP : 1;                                		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bProjectOnStaticMeshes : 1;                       		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bProjectOnSkeletalMeshes : 1;                     		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bProjectOnTerrain : 1;                            		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bFlipBackfaceDirection : 1;                       		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bMovableDecal : 1;                                		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bTickParentRelativeTransform : 1;                 		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bHasBeenAttached : 1;                             		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bDecalMaterialSetAtRunTime : 1;                   		// 0x02B0 (0x0004) [0x0000000000000000] [0x00001000] 
	class UPrimitiveComponent*                         HitComponent;                                     		// 0x02B4 (0x0008) [0x0000000000000000]              
	struct FName                                       HitBone;                                          		// 0x02BC (0x0008) [0x0000000000000000]              
	int                                                HitNodeIndex;                                     		// 0x02C4 (0x0004) [0x0000000000000000]              
	int                                                HitLevelIndex;                                    		// 0x02C8 (0x0004) [0x0000000000000000]              
	int                                                FracturedStaticMeshComponentIndex;                		// 0x02CC (0x0004) [0x0000000000000000]              
	TArray< int >                                      HitNodeIndices;                                   		// 0x02D0 (0x0010) [0x0000000000000000]              
	TArray< struct FDecalReceiver >                    DecalReceivers;                                   		// 0x02E0 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          StaticReceivers;                                  		// 0x02F0 (0x0010) [0x0000000000000000]              
	struct FPointer                                    ReleaseResourcesFence;                            		// 0x0300 (0x0008) [0x0000000000000000]              
	TArray< struct FPlane >                            Planes;                                           		// 0x0308 (0x0010) [0x0000000000000000]              
	float                                              DepthBias;                                        		// 0x0318 (0x0004) [0x0000000000000000]              
	float                                              SlopeScaleDepthBias;                              		// 0x031C (0x0004) [0x0000000000000000]              
	float                                              OrbisDepthBias;                                   		// 0x0320 (0x0004) [0x0000000000000000]              
	float                                              OrbisSlopeScaleDepthBias;                         		// 0x0324 (0x0004) [0x0000000000000000]              
	int                                                SortOrder;                                        		// 0x0328 (0x0004) [0x0000000000000000]              
	float                                              BackfaceAngle;                                    		// 0x032C (0x0004) [0x0000000000000000]              
	struct FVector2D                                   BlendRange;                                       		// 0x0330 (0x0008) [0x0000000000000000]              
	float                                              StreamingDistanceMultiplier;                      		// 0x0338 (0x0004) [0x0000000000000000]              
	unsigned char                                      DecalTransform;                                   		// 0x033C (0x0001) [0x0000000000000000]              
	unsigned char                                      FilterMode;                                       		// 0x033D (0x0001) [0x0000000000000000]              
	TArray< class AActor* >                            Filter;                                           		// 0x0340 (0x0010) [0x0000000000000000]              
	TArray< class UPrimitiveComponent* >               ReceiverImages;                                   		// 0x0350 (0x0010) [0x0000000000000000]              
	struct FVector                                     ParentRelativeLocation;                           		// 0x0360 (0x000C) [0x0000000000000000]              
	struct FRotator                                    ParentRelativeOrientation;                        		// 0x036C (0x000C) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0378 (0x0008) MISSED OFFSET
	struct FMatrix                                     ParentRelLocRotMatrix;                            		// 0x0380 (0x0040) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DecalComponent" );

		return pClassPointer;
	};

	void IsWaitingForResetToDefaultsToComplete ( );
	void GetDecalMaterial ( );
	void SetDecalMaterial ( );
	void ResetToDefaults ( );
};

UClass* UDecalComponent::pClassPointer = NULL;

// Class Engine.ActorFactoryDecal
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryDecal : public UActorFactory
{
public:
	class UMaterialInterface*                          DecalMaterial;                                    		// 0x009C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryDecal" );

		return pClassPointer;
	};

};

UClass* UActorFactoryDecal::pClassPointer = NULL;

// Class Engine.ActorFactoryDecalMovable
// 0x0000 (0x00A4 - 0x00A4)
class UActorFactoryDecalMovable : public UActorFactoryDecal
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryDecalMovable" );

		return pClassPointer;
	};

};

UClass* UActorFactoryDecalMovable::pClassPointer = NULL;

// Class Engine.Material
// 0x0624 (0x0888 - 0x0264)
class UMaterial : public UMaterialInterface
{
public:
	class UPhysicalMaterial*                           PhysMaterial;                                     		// 0x0264 (0x0008) [0x0000000000000000]              
	class UClass*                                      PhysicalMaterial;                                 		// 0x026C (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  PhysMaterialMask;                                 		// 0x0274 (0x0008) [0x0000000000000000]              
	int                                                PhysMaterialMaskUVChannel;                        		// 0x027C (0x0004) [0x0000000000000000]              
	class UPhysicalMaterial*                           BlackPhysicalMaterial;                            		// 0x0280 (0x0008) [0x0000000000000000]              
	class UPhysicalMaterial*                           WhitePhysicalMaterial;                            		// 0x0288 (0x0008) [0x0000000000000000]              
	struct FColorMaterialInput                         DiffuseColor;                                     		// 0x0290 (0x003C) [0x0000000000000000]              
	struct FScalarMaterialInput                        DiffusePower;                                     		// 0x02CC (0x003C) [0x0000000000000000]              
	struct FColorMaterialInput                         SpecularColor;                                    		// 0x0308 (0x003C) [0x0000000000000000]              
	struct FScalarMaterialInput                        SpecularPower;                                    		// 0x0344 (0x003C) [0x0000000000000000]              
	struct FVectorMaterialInput                        Normal;                                           		// 0x0380 (0x0044) [0x0000000000000000]              
	struct FColorMaterialInput                         EmissiveColor;                                    		// 0x03C4 (0x003C) [0x0000000000000000]              
	struct FScalarMaterialInput                        Opacity;                                          		// 0x0400 (0x003C) [0x0000000000000000]              
	struct FScalarMaterialInput                        OpacityMask;                                      		// 0x043C (0x003C) [0x0000000000000000]              
	float                                              OpacityMaskClipValue;                             		// 0x0478 (0x0004) [0x0000000000000000]              
	float                                              ShadowDepthBias;                                  		// 0x047C (0x0004) [0x0000000000000000]              
	struct FVector2MaterialInput                       Distortion;                                       		// 0x0480 (0x0040) [0x0000000000000000]              
	unsigned char                                      BlendMode;                                        		// 0x04C0 (0x0001) [0x0000000000000000]              
	unsigned char                                      LightingModel;                                    		// 0x04C1 (0x0001) [0x0000000000000000]              
	unsigned char                                      D3D11TessellationMode;                            		// 0x04C2 (0x0001) [0x0000000000000000]              
	struct FColorMaterialInput                         CustomLighting;                                   		// 0x04C4 (0x003C) [0x0000000000000000]              
	struct FColorMaterialInput                         CustomSkylightDiffuse;                            		// 0x0500 (0x003C) [0x0000000000000000]              
	struct FVectorMaterialInput                        AnisotropicDirection;                             		// 0x053C (0x0044) [0x0000000000000000]              
	struct FScalarMaterialInput                        TwoSidedLightingMask;                             		// 0x0580 (0x003C) [0x0000000000000000]              
	struct FColorMaterialInput                         TwoSidedLightingColor;                            		// 0x05BC (0x003C) [0x0000000000000000]              
	struct FVectorMaterialInput                        WorldPositionOffset;                              		// 0x05F8 (0x0044) [0x0000000000000000]              
	struct FVectorMaterialInput                        WorldDisplacement;                                		// 0x063C (0x0044) [0x0000000000000000]              
	struct FScalarMaterialInput                        TessellationMultiplier;                           		// 0x0680 (0x003C) [0x0000000000000000]              
	struct FColorMaterialInput                         SubsurfaceInscatteringColor;                      		// 0x06BC (0x003C) [0x0000000000000000]              
	struct FColorMaterialInput                         SubsurfaceAbsorptionColor;                        		// 0x06F8 (0x003C) [0x0000000000000000]              
	struct FScalarMaterialInput                        SubsurfaceScatteringRadius;                       		// 0x0734 (0x003C) [0x0000000000000000]              
	struct FScalarMaterialInput                        SubsurfaceScatteringMask;                         		// 0x0770 (0x003C) [0x0000000000000000]              
	DWORD                                              EnableSubsurfaceScattering : 1;                   		// 0x07AC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              EnableAOMask : 1;                                 		// 0x07AC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              EnableSeparateTranslucency : 1;                   		// 0x07AC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bEnableMaskedAntialiasing : 1;                    		// 0x07AC (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              TwoSided : 1;                                     		// 0x07AC (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              TwoSidedSeparatePass : 1;                         		// 0x07AC (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bDisableDepthTest : 1;                            		// 0x07AC (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bSceneTextureRenderBehindTranslucency : 1;        		// 0x07AC (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bAllowFog : 1;                                    		// 0x07AC (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bTranslucencyReceiveDominantShadowsFromStatic : 1;		// 0x07AC (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bTranslucencyInheritDominantShadowsFromOpaque : 1;		// 0x07AC (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bAllowTranslucencyDoF : 1;                        		// 0x07AC (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bUseOneLayerDistortion : 1;                       		// 0x07AC (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bUseLitTranslucencyDepthPass : 1;                 		// 0x07AC (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bUseLitTranslucencyPostRenderDepthPass : 1;       		// 0x07AC (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bCastLitTranslucencyShadowAsMasked : 1;           		// 0x07AC (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bUsedAsLightFunction : 1;                         		// 0x07AC (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bUsedWithFogVolumes : 1;                          		// 0x07AC (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bUsedAsSpecialEngineMaterial : 1;                 		// 0x07AC (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bUsedWithSkeletalMesh : 1;                        		// 0x07AC (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bUsedWithTerrain : 1;                             		// 0x07AC (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bUsedWithLandscape : 1;                           		// 0x07AC (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bUsedWithMobileLandscape : 1;                     		// 0x07AC (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bUsedWithFracturedMeshes : 1;                     		// 0x07AC (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bUsedWithParticleSystem : 1;                      		// 0x07AC (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bUsedWithParticleSprites : 1;                     		// 0x07AC (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bUsedWithBeamTrails : 1;                          		// 0x07AC (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bUsedWithParticleSubUV : 1;                       		// 0x07AC (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bUsedWithSpeedTree : 1;                           		// 0x07AC (0x0004) [0x0000000000000000] [0x10000000] 
	DWORD                                              bUsedWithStaticLighting : 1;                      		// 0x07AC (0x0004) [0x0000000000000000] [0x20000000] 
	DWORD                                              bUsedWithLensFlare : 1;                           		// 0x07AC (0x0004) [0x0000000000000000] [0x40000000] 
	DWORD                                              bUsedWithGammaCorrection : 1;                     		// 0x07AC (0x0004) [0x0000000000000000] [0x80000000] 
	DWORD                                              bUsedWithInstancedMeshParticles : 1;              		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUsedWithFluidSurfaces : 1;                       		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUsedWithDecals : 1;                              		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUsedWithMaterialEffect : 1;                      		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bUsedWithMorphTargets : 1;                        		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bUsedWithRadialBlur : 1;                          		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bUsedWithInstancedMeshes : 1;                     		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bUsedWithSplineMeshes : 1;                        		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bUsedWithAPEXMeshes : 1;                          		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bUsedWithSPHFluid : 1;                            		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bUsedWithSPHFluidThickness : 1;                   		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bUsedWithScreenDoorFade : 1;                      		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bEnableCrackFreeDisplacement : 1;                 		// 0x07B0 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bUseImageBasedReflections : 1;                    		// 0x07B0 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bUseScreenSpaceReflections : 1;                   		// 0x07B0 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              Wireframe : 1;                                    		// 0x07B0 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bPerPixelCameraVector : 1;                        		// 0x07B0 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bAllowLightmapSpecular : 1;                       		// 0x07B0 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bIsFallbackMaterial : 1;                          		// 0x07B0 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bUsesDistortion : 1;                              		// 0x07B0 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bIsMasked : 1;                                    		// 0x07B0 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bIsPreviewMaterial : 1;                           		// 0x07B0 (0x0004) [0x0000000000000000] [0x00200000] 
	float                                              ImageReflectionNormalDampening;                   		// 0x07B4 (0x0004) [0x0000000000000000]              
	struct FPointer                                    MaterialResources[ 0x2 ];                         		// 0x07B8 (0x0010) [0x0000000000000000]              
	struct FPointer                                    DefaultMaterialInstances[ 0x3 ];                  		// 0x07C8 (0x0018) [0x0000000000000000]              
	int                                                EditorX;                                          		// 0x07E0 (0x0004) [0x0000000000000000]              
	int                                                EditorY;                                          		// 0x07E4 (0x0004) [0x0000000000000000]              
	int                                                EditorPitch;                                      		// 0x07E8 (0x0004) [0x0000000000000000]              
	int                                                EditorYaw;                                        		// 0x07EC (0x0004) [0x0000000000000000]              
	TArray< class UMaterialExpression* >               Expressions;                                      		// 0x07F0 (0x0010) [0x0000000000000000]              
	TArray< class UMaterialExpressionComment* >        EditorComments;                                   		// 0x0800 (0x0010) [0x0000000000000000]              
	TArray< struct FMaterialFunctionInfo >             MaterialFunctionInfos;                            		// 0x0810 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x0820 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.Material.EditorParameters
	TArray< class UTexture* >                          ReferencedTextures;                               		// 0x0868 (0x0010) [0x0000000000000000]              
	TArray< struct FGuid >                             ReferencedTextureGuids;                           		// 0x0878 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Material" );

		return pClassPointer;
	};

};

UClass* UMaterial::pClassPointer = NULL;

// Class Engine.DecalMaterial
// 0x0000 (0x0888 - 0x0888)
class UDecalMaterial : public UMaterial
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DecalMaterial" );

		return pClassPointer;
	};

};

UClass* UDecalMaterial::pClassPointer = NULL;

// Class Engine.FogVolumeDensityInfo
// 0x0014 (0x0258 - 0x0244)
class AFogVolumeDensityInfo : public AInfo
{
public:
	class UFogVolumeDensityComponent*                  DensityComponent;                                 		// 0x0244 (0x0008) [0x0000000000000000]              
	class UStaticMeshComponent*                        AutomaticMeshComponent;                           		// 0x024C (0x0008) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x0254 (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FogVolumeDensityInfo" );

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void ShouldSaveForCheckpoint ( );
	void OnToggle ( );
	void eventReplicatedEvent ( );
	void eventPostBeginPlay ( );
};

UClass* AFogVolumeDensityInfo::pClassPointer = NULL;

// Class Engine.FogVolumeConeDensityInfo
// 0x0000 (0x0258 - 0x0258)
class AFogVolumeConeDensityInfo : public AFogVolumeDensityInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FogVolumeConeDensityInfo" );

		return pClassPointer;
	};

};

UClass* AFogVolumeConeDensityInfo::pClassPointer = NULL;

// Class Engine.FogVolumeConstantDensityInfo
// 0x0000 (0x0258 - 0x0258)
class AFogVolumeConstantDensityInfo : public AFogVolumeDensityInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FogVolumeConstantDensityInfo" );

		return pClassPointer;
	};

};

UClass* AFogVolumeConstantDensityInfo::pClassPointer = NULL;

// Class Engine.FogVolumeLinearHalfspaceDensityInfo
// 0x0000 (0x0258 - 0x0258)
class AFogVolumeLinearHalfspaceDensityInfo : public AFogVolumeDensityInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FogVolumeLinearHalfspaceDensityInfo" );

		return pClassPointer;
	};

};

UClass* AFogVolumeLinearHalfspaceDensityInfo::pClassPointer = NULL;

// Class Engine.FogVolumeSphericalDensityInfo
// 0x0000 (0x0258 - 0x0258)
class AFogVolumeSphericalDensityInfo : public AFogVolumeDensityInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FogVolumeSphericalDensityInfo" );

		return pClassPointer;
	};

};

UClass* AFogVolumeSphericalDensityInfo::pClassPointer = NULL;

// Class Engine.ExponentialHeightFogComponent
// 0x002F (0x00B4 - 0x0085)
class UExponentialHeightFogComponent : public UActorComponent
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              FogHeight;                                        		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              FogDensity;                                       		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              FogHeightFalloff;                                 		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              FogMaxOpacity;                                    		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              StartDistance;                                    		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              LightTerminatorAngle;                             		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              OppositeLightBrightness;                          		// 0x00A4 (0x0004) [0x0000000000000000]              
	struct FColor                                      OppositeLightColor;                               		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              LightInscatteringBrightness;                      		// 0x00AC (0x0004) [0x0000000000000000]              
	struct FColor                                      LightInscatteringColor;                           		// 0x00B0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ExponentialHeightFogComponent" );

		return pClassPointer;
	};

	void SetEnabled ( );
};

UClass* UExponentialHeightFogComponent::pClassPointer = NULL;

// Class Engine.FogVolumeDensityComponent
// 0x004F (0x00D4 - 0x0085)
class UFogVolumeDensityComponent : public UActorComponent
{
public:
	class UMaterialInterface*                          FogMaterial;                                      		// 0x0088 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          DefaultFogVolumeMaterial;                         		// 0x0090 (0x0008) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAffectsTranslucency : 1;                         		// 0x0098 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bOnlyAffectsTranslucency : 1;                     		// 0x0098 (0x0004) [0x0000000000000000] [0x00000004] 
	struct FLinearColor                                SimpleLightColor;                                 		// 0x009C (0x0010) [0x0000000000000000]              
	struct FLinearColor                                ApproxFogLightColor;                              		// 0x00AC (0x0010) [0x0000000000000000]              
	float                                              StartDistance;                                    		// 0x00BC (0x0004) [0x0000000000000000]              
	float                                              MaxDistance;                                      		// 0x00C0 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            FogVolumeActors;                                  		// 0x00C4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FogVolumeDensityComponent" );

		return pClassPointer;
	};

	void SetEnabled ( );
};

UClass* UFogVolumeDensityComponent::pClassPointer = NULL;

// Class Engine.FogVolumeConeDensityComponent
// 0x002C (0x0100 - 0x00D4)
class UFogVolumeConeDensityComponent : public UFogVolumeDensityComponent
{
public:
	float                                              MaxDensity;                                       		// 0x00D4 (0x0004) [0x0000000000000000]              
	struct FVector                                     ConeVertex;                                       		// 0x00D8 (0x000C) [0x0000000000000000]              
	float                                              ConeRadius;                                       		// 0x00E4 (0x0004) [0x0000000000000000]              
	struct FVector                                     ConeAxis;                                         		// 0x00E8 (0x000C) [0x0000000000000000]              
	float                                              ConeMaxAngle;                                     		// 0x00F4 (0x0004) [0x0000000000000000]              
	class UDrawLightConeComponent*                     PreviewCone;                                      		// 0x00F8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FogVolumeConeDensityComponent" );

		return pClassPointer;
	};

};

UClass* UFogVolumeConeDensityComponent::pClassPointer = NULL;

// Class Engine.FogVolumeConstantDensityComponent
// 0x0004 (0x00D8 - 0x00D4)
class UFogVolumeConstantDensityComponent : public UFogVolumeDensityComponent
{
public:
	float                                              Density;                                          		// 0x00D4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FogVolumeConstantDensityComponent" );

		return pClassPointer;
	};

};

UClass* UFogVolumeConstantDensityComponent::pClassPointer = NULL;

// Class Engine.FogVolumeLinearHalfspaceDensityComponent
// 0x001C (0x00F0 - 0x00D4)
class UFogVolumeLinearHalfspaceDensityComponent : public UFogVolumeDensityComponent
{
public:
	float                                              PlaneDistanceFactor;                              		// 0x00D4 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x00D8 (0x0008) MISSED OFFSET
	struct FPlane                                      HalfspacePlane;                                   		// 0x00E0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FogVolumeLinearHalfspaceDensityComponent" );

		return pClassPointer;
	};

};

UClass* UFogVolumeLinearHalfspaceDensityComponent::pClassPointer = NULL;

// Class Engine.FogVolumeSphericalDensityComponent
// 0x001C (0x00F0 - 0x00D4)
class UFogVolumeSphericalDensityComponent : public UFogVolumeDensityComponent
{
public:
	float                                              MaxDensity;                                       		// 0x00D4 (0x0004) [0x0000000000000000]              
	struct FVector                                     SphereCenter;                                     		// 0x00D8 (0x000C) [0x0000000000000000]              
	float                                              SphereRadius;                                     		// 0x00E4 (0x0004) [0x0000000000000000]              
	class UDrawLightRadiusComponent*                   PreviewSphereRadius;                              		// 0x00E8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FogVolumeSphericalDensityComponent" );

		return pClassPointer;
	};

};

UClass* UFogVolumeSphericalDensityComponent::pClassPointer = NULL;

// Class Engine.ActorFactoryFogVolumeConstantDensityInfo
// 0x000C (0x00A8 - 0x009C)
class UActorFactoryFogVolumeConstantDensityInfo : public UActorFactory
{
public:
	class UMaterialInterface*                          SelectedMaterial;                                 		// 0x009C (0x0008) [0x0000000000000000]              
	DWORD                                              bNothingSelected : 1;                             		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryFogVolumeConstantDensityInfo" );

		return pClassPointer;
	};

};

UClass* UActorFactoryFogVolumeConstantDensityInfo::pClassPointer = NULL;

// Class Engine.ActorFactoryFogVolumeLinearHalfspaceDensityInfo
// 0x0000 (0x00A8 - 0x00A8)
class UActorFactoryFogVolumeLinearHalfspaceDensityInfo : public UActorFactoryFogVolumeConstantDensityInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryFogVolumeLinearHalfspaceDensityInfo" );

		return pClassPointer;
	};

};

UClass* UActorFactoryFogVolumeLinearHalfspaceDensityInfo::pClassPointer = NULL;

// Class Engine.ActorFactoryFogVolumeSphericalDensityInfo
// 0x0000 (0x00A8 - 0x00A8)
class UActorFactoryFogVolumeSphericalDensityInfo : public UActorFactoryFogVolumeConstantDensityInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryFogVolumeSphericalDensityInfo" );

		return pClassPointer;
	};

};

UClass* UActorFactoryFogVolumeSphericalDensityInfo::pClassPointer = NULL;

// Class Engine.ApexDestructibleActor
// 0x0058 (0x029C - 0x0244)
class AApexDestructibleActor : public AActor
{
public:
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                 		// 0x0244 (0x0008) [0x0000000000000000]              
	DWORD                                              bFractureMaterialOverride : 1;                    		// 0x024C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPlaySingleFractureMaterialEffect : 1;            		// 0x024C (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< class UFractureMaterial* >                 FractureMaterials;                                		// 0x0250 (0x0010) [0x0000000000000000]              
	class UApexStaticDestructibleComponent*            StaticDestructibleComponent;                      		// 0x0260 (0x0008) [0x0000000000000000]              
	int                                                LOD;                                              		// 0x0268 (0x0004) [0x0000000000000000]              
	TArray< unsigned char >                            VisibilityFactors;                                		// 0x026C (0x0010) [0x0000000000000000]              
	TArray< class USoundCue* >                         FractureSounds;                                   		// 0x027C (0x0010) [0x0000000000000000]              
	TArray< class UParticleSystem* >                   FractureParticleEffects;                          		// 0x028C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ApexDestructibleActor" );

		return pClassPointer;
	};

	void OnSetMaterial ( );
	void TakeRadiusDamage ( );
	void TakeDamage ( );
	void eventPostBeginPlay ( );
	void CacheFractureEffects ( );
	void eventSpawnFractureEmitter ( );
};

UClass* AApexDestructibleActor::pClassPointer = NULL;

// Class Engine.FracturedStaticMeshActor
// 0x0094 (0x02D8 - 0x0244)
class AFracturedStaticMeshActor : public AActor
{
public:
	int                                                MaxPartsToSpawnAtOnce;                            		// 0x0244 (0x0004) [0x0000000000000000]              
	class UFracturedStaticMeshComponent*               FracturedStaticMeshComponent;                     		// 0x0248 (0x0008) [0x0000000000000000]              
	class UFracturedSkinnedMeshComponent*              SkinnedComponent;                                 		// 0x0250 (0x0008) [0x0000000000000000]              
	TArray< int >                                      ChunkHealth;                                      		// 0x0258 (0x0010) [0x0000000000000000]              
	DWORD                                              bHasShownMissingSoundWarning : 1;                 		// 0x0268 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bBreakChunksOnActorTouch : 1;                     		// 0x0268 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bShouldSaveForCheckpoint : 1;                     		// 0x0268 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bDestroyFragmentsOnImpact : 1;                    		// 0x0268 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bHasBeenDirtied : 1;                              		// 0x0268 (0x0004) [0x0000000000000000] [0x00000010] 
	TArray< class UClass* >                            FracturedByDamageType;                            		// 0x026C (0x0010) [0x0000000000000000]              
	float                                              ChunkHealthScale;                                 		// 0x027C (0x0004) [0x0000000000000000]              
	TArray< class UParticleSystem* >                   OverrideFragmentDestroyEffects;                   		// 0x0280 (0x0010) [0x0000000000000000]              
	float                                              FractureCullMinDistance;                          		// 0x0290 (0x0004) [0x0000000000000000]              
	float                                              FractureCullMaxDistance;                          		// 0x0294 (0x0004) [0x0000000000000000]              
	TArray< struct FDeferredPartToSpawn >              DeferredPartsToSpawn;                             		// 0x0298 (0x0010) [0x0000000000000000]              
	struct FPhysEffectInfo                             PartImpactEffect;                                 		// 0x02A8 (0x0018) [0x0000000000000000]              
	class UAkBaseSoundObject*                          ExplosionFractureSound;                           		// 0x02C0 (0x0008) [0x0000000000000000]              
	class UAkBaseSoundObject*                          SingleChunkFractureSound;                         		// 0x02C8 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          MI_LoseChunkPreviousMaterial;                     		// 0x02D0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FracturedStaticMeshActor" );

		return pClassPointer;
	};

	void Reset ( );
	void NotifyHitByExplosion ( );
	void eventSetLoseChunkReplacementMaterial ( );
	void eventHideFragmentsToMaximizeMemoryUsage ( );
	void eventHideOneFragment ( );
	void eventResetVisibility ( );
	void eventBreakOffPartsInRadius ( );
	void eventExplode ( );
	void eventTakeDamage ( );
	void RemoveDecals ( );
	void FractureEffectIsRelevant ( );
	void IsFracturedByDamageType ( );
	void eventSpawnDeferredParts ( );
	void eventBreakOffIsolatedIslands ( );
	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void ShouldSaveForCheckpoint ( );
	void ResetHealth ( );
	void eventPostBeginPlay ( );
	void SpawnPartMulti ( );
	void SpawnPart ( );
};

UClass* AFracturedStaticMeshActor::pClassPointer = NULL;

// Class Engine.FracturedStaticMeshPart
// 0x0034 (0x030C - 0x02D8)
class AFracturedStaticMeshPart : public AFracturedStaticMeshActor
{
public:
	float                                              DestroyPartRadiusFactor;                          		// 0x02D8 (0x0004) [0x0000000000000000]              
	class AFracturedStaticMeshActor*                   BaseFracturedMeshActor;                           		// 0x02DC (0x0008) [0x0000000000000000]              
	DWORD                                              bHasBeenRecycled : 1;                             		// 0x02E4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bChangeRBChannelWhenAsleep : 1;                   		// 0x02E4 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCompositeThatExplodesOnImpact : 1;               		// 0x02E4 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              LastSpawnTime;                                    		// 0x02E8 (0x0004) [0x0000000000000000]              
	int                                                PartPoolIndex;                                    		// 0x02EC (0x0004) [0x0000000000000000]              
	float                                              FracPartGravScale;                                		// 0x02F0 (0x0004) [0x0000000000000000]              
	unsigned char                                      AsleepRBChannel;                                  		// 0x02F4 (0x0001) [0x0000000000000000]              
	struct FVector                                     OldVelocity;                                      		// 0x02F8 (0x000C) [0x0000000000000000]              
	float                                              CurrentVibrationLevel;                            		// 0x0304 (0x0004) [0x0000000000000000]              
	float                                              LastImpactSoundTime;                              		// 0x0308 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FracturedStaticMeshPart" );

		return pClassPointer;
	};

	void eventReset ( );
	void eventBreakOffPartsInRadius ( );
	void eventExplode ( );
	void eventFellOutOfWorld ( );
	void TryToCleanUp ( );
	void eventTakeDamage ( );
	void RecyclePart ( );
	void Initialize ( );
};

UClass* AFracturedStaticMeshPart::pClassPointer = NULL;

// Class Engine.FractureManager
// 0x0044 (0x0288 - 0x0244)
class AFractureManager : public AActor
{
public:
	int                                                FSMPartPoolSize;                                  		// 0x0244 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnableAntiVibration : 1;                         		// 0x0248 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnableSpawnChunkEffectForRadialDamage : 1;       		// 0x0248 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              DestroyVibrationLevel;                            		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              DestroyMinAngVel;                                 		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              ExplosionVelScale;                                		// 0x0254 (0x0004) [0x0000000000000000]              
	TArray< class AFracturedStaticMeshPart* >          PartPool;                                         		// 0x0258 (0x0010) [0x0000000000000000]              
	TArray< int >                                      FreeParts;                                        		// 0x0268 (0x0010) [0x0000000000000000]              
	TArray< class AFracturedStaticMeshActor* >         ActorsWithDeferredPartsToSpawn;                   		// 0x0278 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FractureManager" );

		return pClassPointer;
	};

	void Tick ( );
	void eventReturnPartActor ( );
	void eventSpawnPartActor ( );
	void GetFSMPart ( );
	void ResetPoolVisibility ( );
	void CreateFSMParts ( );
	void CleanUpFSMParts ( );
	void eventDestroyed ( );
	void eventPreBeginPlay ( );
	void GetFSMFractureCullDistanceScale ( );
	void GetFSMRadialSpawnChanceScale ( );
	void GetFSMDirectSpawnChanceScale ( );
	void GetNumFSMPartsScale ( );
	void eventSpawnChunkDestroyEffect ( );
};

UClass* AFractureManager::pClassPointer = NULL;

// Class Engine.ImageReflection
// 0x0014 (0x0258 - 0x0244)
class AImageReflection : public AActor
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x0244 (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )
	class UImageReflectionComponent*                   ReflectionComponent;                              		// 0x0248 (0x0008) [0x0000000000000000]              
	class UImageBasedReflectionComponent*              ImageReflectionComponent;                         		// 0x0250 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ImageReflection" );

		return pClassPointer;
	};

	void OnToggle ( );
	void eventReplicatedEvent ( );
	void eventPostBeginPlay ( );
};

UClass* AImageReflection::pClassPointer = NULL;

// Class Engine.ImageReflectionSceneCapture
// 0x0008 (0x0260 - 0x0258)
class AImageReflectionSceneCapture : public AImageReflection
{
public:
	float                                              DepthRange;                                       		// 0x0258 (0x0004) [0x0000000000000000]              
	float                                              ColorRange;                                       		// 0x025C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ImageReflectionSceneCapture" );

		return pClassPointer;
	};

};

UClass* AImageReflectionSceneCapture::pClassPointer = NULL;

// Class Engine.ImageReflectionShadowPlane
// 0x000C (0x0250 - 0x0244)
class AImageReflectionShadowPlane : public AActor
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x0244 (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )
	class UImageReflectionShadowPlaneComponent*        ReflectionShadowComponent;                        		// 0x0248 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ImageReflectionShadowPlane" );

		return pClassPointer;
	};

	void OnToggle ( );
	void eventReplicatedEvent ( );
	void eventPostBeginPlay ( );
};

UClass* AImageReflectionShadowPlane::pClassPointer = NULL;

// Class Engine.ImageReflectionComponent
// 0x000B (0x0090 - 0x0085)
class UImageReflectionComponent : public UActorComponent
{
public:
	class UTexture2D*                                  ReflectionTexture;                                		// 0x0088 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ImageReflectionComponent" );

		return pClassPointer;
	};

};

UClass* UImageReflectionComponent::pClassPointer = NULL;

// Class Engine.ImageReflectionShadowPlaneComponent
// 0x0018 (0x0250 - 0x0238)
class UImageReflectionShadowPlaneComponent : public UPrimitiveComponent
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x0238 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x023C (0x0004) MISSED OFFSET
	struct FPlane                                      ReflectionPlane;                                  		// 0x0240 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ImageReflectionShadowPlaneComponent" );

		return pClassPointer;
	};

	void SetEnabled ( );
};

UClass* UImageReflectionShadowPlaneComponent::pClassPointer = NULL;

// Class Engine.ApexComponentBase
// 0x001C (0x0264 - 0x0248)
class UApexComponentBase : public UMeshComponent
{
public:
	struct FPointer                                    ComponentBaseResources;                           		// 0x0248 (0x0008) [0x0000000000000000]              
	struct FRenderCommandFence_Mirror                  ReleaseResourcesFence;                            		// 0x0250 (0x0004) [0x0000000000000000]              
	class UApexAsset*                                  Asset;                                            		// 0x0254 (0x0008) [0x0000000000000000]              
	struct FColor                                      WireframeColor;                                   		// 0x025C (0x0004) [0x0000000000000000]              
	DWORD                                              bAssetChanged : 1;                                		// 0x0260 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ApexComponentBase" );

		return pClassPointer;
	};

};

UClass* UApexComponentBase::pClassPointer = NULL;

// Class Engine.ApexDynamicComponent
// 0x0008 (0x026C - 0x0264)
class UApexDynamicComponent : public UApexComponentBase
{
public:
	struct FPointer                                    ComponentDynamicResources;                        		// 0x0264 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ApexDynamicComponent" );

		return pClassPointer;
	};

};

UClass* UApexDynamicComponent::pClassPointer = NULL;

// Class Engine.ApexStaticComponent
// 0x0000 (0x0264 - 0x0264)
class UApexStaticComponent : public UApexComponentBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ApexStaticComponent" );

		return pClassPointer;
	};

};

UClass* UApexStaticComponent::pClassPointer = NULL;

// Class Engine.ApexStaticDestructibleComponent
// 0x001C (0x0280 - 0x0264)
class UApexStaticDestructibleComponent : public UApexStaticComponent
{
public:
	float                                              SleepEnergyThreshold;                             		// 0x0264 (0x0004) [0x0000000000000000]              
	float                                              SleepDamping;                                     		// 0x0268 (0x0004) [0x0000000000000000]              
	struct FPointer                                    ApexDestructibleActor;                            		// 0x026C (0x0008) [0x0000000000000000]              
	struct FPointer                                    ApexDestructiblePreview;                          		// 0x0274 (0x0008) [0x0000000000000000]              
	DWORD                                              bIsThumbnailComponent : 1;                        		// 0x027C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ApexStaticDestructibleComponent" );

		return pClassPointer;
	};

};

UClass* UApexStaticDestructibleComponent::pClassPointer = NULL;

// Class Engine.FlexComponent
// 0x0060 (0x033C - 0x02DC)
class UFlexComponent : public UStaticMeshComponent
{
public:
	class UFlexContainer*                              FlexComponentContainerTemplate;                   		// 0x02DC (0x0008) [0x0000000000000000]              
	int                                                FlexComponentPhaseId;                             		// 0x02E4 (0x0004) [0x0000000000000000]              
	DWORD                                              bFlexComponentAutoAssignPhase : 1;                		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFlexComponentAttachToRigids : 1;                 		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FPointer                                    FlexComponentAssetInstance;                       		// 0x02EC (0x0008) [0x0000000000000000]              
	struct FPointer                                    FlexComponentContainerInstance;                   		// 0x02F4 (0x0008) [0x0000000000000000]              
	TArray< struct FVector >                           FlexComponentPreSimPositions;                     		// 0x02FC (0x0010) [0x0000000000000000]              
	TArray< struct FVector4 >                          SimPositions;                                     		// 0x030C (0x0010) [0x0000000000000000]              
	TArray< struct FVector >                           SimNormals;                                       		// 0x031C (0x0010) [0x0000000000000000]              
	TArray< struct FFlexParticleAttachment >           Attachments;                                      		// 0x032C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FlexComponent" );

		return pClassPointer;
	};

};

UClass* UFlexComponent::pClassPointer = NULL;

// Class Engine.FracturedBaseComponent
// 0x0028 (0x0304 - 0x02DC)
class UFracturedBaseComponent : public UStaticMeshComponent
{
public:
	struct FPointer                                    ComponentBaseResources;                           		// 0x02DC (0x0008) [0x0000000000000000]              
	struct FRenderCommandFence_Mirror                  ReleaseResourcesFence;                            		// 0x02E4 (0x0004) [0x0000000000000000]              
	TArray< unsigned char >                            VisibleFragments;                                 		// 0x02E8 (0x0010) [0x0000000000000000]              
	DWORD                                              bVisibilityHasChanged : 1;                        		// 0x02F8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bVisibilityReset : 1;                             		// 0x02F8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bInitialVisibilityValue : 1;                      		// 0x02F8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUseDynamicIndexBuffer : 1;                       		// 0x02F8 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bUseDynamicIBWithHiddenFragments : 1;             		// 0x02F8 (0x0004) [0x0000000000000000] [0x00000010] 
	int                                                NumResourceIndices;                               		// 0x02FC (0x0004) [0x0000000000000000]              
	int                                                bResetStaticMesh;                                 		// 0x0300 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FracturedBaseComponent" );

		return pClassPointer;
	};

	void GetNumVisibleFragments ( );
	void GetNumFragments ( );
	void IsFragmentVisible ( );
	void GetVisibleFragments ( );
	void SetStaticMesh ( );
};

UClass* UFracturedBaseComponent::pClassPointer = NULL;

// Class Engine.FracturedSkinnedMeshComponent
// 0x002C (0x0330 - 0x0304)
class UFracturedSkinnedMeshComponent : public UFracturedBaseComponent
{
public:
	struct FPointer                                    ComponentSkinResources;                           		// 0x0304 (0x0008) [0x0000000000000000]              
	TArray< struct FMatrix >                           FragmentTransforms;                               		// 0x030C (0x0010) [0x0000000000000000]              
	TArray< class UFracturedStaticMeshComponent* >     DependentComponents;                              		// 0x031C (0x0010) [0x0000000000000000]              
	DWORD                                              bBecameVisible : 1;                               		// 0x032C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFragmentTransformsChanged : 1;                   		// 0x032C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FracturedSkinnedMeshComponent" );

		return pClassPointer;
	};

};

UClass* UFracturedSkinnedMeshComponent::pClassPointer = NULL;

// Class Engine.FracturedStaticMeshComponent
// 0x004C (0x0350 - 0x0304)
class UFracturedStaticMeshComponent : public UFracturedBaseComponent
{
public:
	TArray< unsigned char >                            FragmentNeighborsVisible;                         		// 0x0304 (0x0010) [0x0000000000000000]              
	struct FBox                                        VisibleBox;                                       		// 0x0314 (0x001C) [0x0000000000000000]              
	DWORD                                              bUseSkinnedRendering : 1;                         		// 0x0330 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseVisibleVertsForBounds : 1;                    		// 0x0330 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bTopFragmentsRootNonDestroyable : 1;              		// 0x0330 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bBottomFragmentsRootNonDestroyable : 1;           		// 0x0330 (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              TopBottomFragmentDistThreshold;                   		// 0x0334 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          LoseChunkOutsideMaterialOverride;                 		// 0x0338 (0x0008) [0x0000000000000000]              
	float                                              FragmentBoundsMaxZ;                               		// 0x0340 (0x0004) [0x0000000000000000]              
	float                                              FragmentBoundsMinZ;                               		// 0x0344 (0x0004) [0x0000000000000000]              
	class UFracturedSkinnedMeshComponent*              SkinnedComponent;                                 		// 0x0348 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FracturedStaticMeshComponent" );

		return pClassPointer;
	};

	void GetFracturedMeshPhysMaterial ( );
	void RecreatePhysState ( );
	void GetBoundaryHiddenFragments ( );
	void GetFragmentGroups ( );
	void GetCoreFragmentIndex ( );
	void GetFragmentAverageExteriorNormal ( );
	void GetFragmentBox ( );
	void IsNoPhysFragment ( );
	void IsRootFragment ( );
	void IsFragmentDestroyable ( );
	void SetVisibleFragments ( );
};

UClass* UFracturedStaticMeshComponent::pClassPointer = NULL;

// Class Engine.ImageBasedReflectionComponent
// 0x001C (0x02F8 - 0x02DC)
class UImageBasedReflectionComponent : public UStaticMeshComponent
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x02DC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bTwoSided : 1;                                    		// 0x02DC (0x0004) [0x0000000000000000] [0x00000002] 
	class UTexture2D*                                  ReflectionTexture;                                		// 0x02E0 (0x0008) [0x0000000000000000]              
	struct FLinearColor                                ReflectionColor;                                  		// 0x02E8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ImageBasedReflectionComponent" );

		return pClassPointer;
	};

	void OnUpdatePropertyReflectionColor ( );
	void UpdateImageReflectionParameters ( );
	void SetEnabled ( );
};

UClass* UImageBasedReflectionComponent::pClassPointer = NULL;

// Class Engine.InstancedStaticMeshComponent
// 0x0068 (0x0344 - 0x02DC)
class UInstancedStaticMeshComponent : public UStaticMeshComponent
{
public:
	TArray< struct FInstancedStaticMeshInstanceData >  PerInstanceData;                                  		// 0x02DC (0x0010) [0x0000000000000000]              
	TArray< struct FInstancedStaticMeshInstanceData >  PerInstanceSMData;                                		// 0x02EC (0x0010) [0x0000000000000000]              
	int                                                NumPendingLightmaps;                              		// 0x02FC (0x0004) [0x0000000000000000]              
	int                                                ComponentJoinKey;                                 		// 0x0300 (0x0004) [0x0000000000000000]              
	TArray< struct FInstancedStaticMeshMappingInfo >   CachedMappings;                                   		// 0x0304 (0x0010) [0x0000000000000000]              
	int                                                InstancingRandomSeed;                             		// 0x0314 (0x0004) [0x0000000000000000]              
	int                                                InstanceStartCullDistance;                        		// 0x0318 (0x0004) [0x0000000000000000]              
	int                                                InstanceEndCullDistance;                          		// 0x031C (0x0004) [0x0000000000000000]              
	struct FBitArray_Mirror                            SelectedInstances;                                		// 0x0320 (0x0020) [0x0000000000000000]              
	DWORD                                              bDontResolveInstancedLightmaps : 1;               		// 0x0340 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InstancedStaticMeshComponent" );

		return pClassPointer;
	};

};

UClass* UInstancedStaticMeshComponent::pClassPointer = NULL;

// Class Engine.SplineMeshComponent
// 0x0068 (0x0344 - 0x02DC)
class USplineMeshComponent : public UStaticMeshComponent
{
public:
	struct FSplineMeshParams                           SplineParams;                                     		// 0x02DC (0x0058) [0x0000000000000000]              
	struct FVector                                     SplineXDir;                                       		// 0x0334 (0x000C) [0x0000000000000000]              
	DWORD                                              bSmoothInterpRollScale : 1;                       		// 0x0340 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SplineMeshComponent" );

		return pClassPointer;
	};

};

UClass* USplineMeshComponent::pClassPointer = NULL;

// Class Engine.ApexAsset
// 0x0050 (0x00B0 - 0x0060)
class UApexAsset : public UObject
{
public:
	struct FString                                     OriginalApexName;                                 		// 0x0060 (0x0010) [0x0000000000000000]              
	TArray< class UApexComponentBase* >                ApexComponents;                                   		// 0x0070 (0x0010) [0x0000000000000000]              
	TArray< class UApexAsset* >                        NamedReferences;                                  		// 0x0080 (0x0010) [0x0000000000000000]              
	struct FString                                     SourceFilePath;                                   		// 0x0090 (0x0010) [0x0000000000000000]              
	struct FString                                     SourceFileTimestamp;                              		// 0x00A0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ApexAsset" );

		return pClassPointer;
	};

};

UClass* UApexAsset::pClassPointer = NULL;

// Class Engine.ApexClothingAsset
// 0x0078 (0x0128 - 0x00B0)
class UApexClothingAsset : public UApexAsset
{
public:
	TArray< struct FClothingLodInfo >                  LodMaterialInfo;                                  		// 0x00B0 (0x0010) [0x0000000000000000]              
	struct FPointer                                    MApexAsset;                                       		// 0x00C0 (0x0008) [0x0000000000000000]              
	TArray< class UMaterialInterface* >                Materials;                                        		// 0x00C8 (0x0010) [0x0000000000000000]              
	class UApexGenericAsset*                           ApexClothingLibrary;                              		// 0x00D8 (0x0008) [0x0000000000000000]              
	DWORD                                              bUseHardwareCloth : 1;                            		// 0x00E0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFallbackSkinning : 1;                            		// 0x00E0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bSlowStart : 1;                                   		// 0x00E0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bRecomputeNormals : 1;                            		// 0x00E0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bAllowAdaptiveTargetFrequency : 1;                		// 0x00E0 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bResetAfterTeleport : 1;                          		// 0x00E0 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bUseLocalSpaceSimulation : 1;                     		// 0x00E0 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bHasUniqueAssetMaterialNames : 1;                 		// 0x00E0 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              IgnoreInitialTrigger : 1;                         		// 0x00E0 (0x0004) [0x0000000000000000] [0x00000100] 
	int                                                UVChannelForTangentUpdate;                        		// 0x00E4 (0x0004) [0x0000000000000000]              
	float                                              MaxDistanceBlendTime;                             		// 0x00E8 (0x0004) [0x0000000000000000]              
	float                                              ContinuousRotationThreshold;                      		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              ContinuousDistanceThreshold;                      		// 0x00F0 (0x0004) [0x0000000000000000]              
	float                                              LodWeightsMaxDistance;                            		// 0x00F4 (0x0004) [0x0000000000000000]              
	float                                              LodWeightsDistanceWeight;                         		// 0x00F8 (0x0004) [0x0000000000000000]              
	float                                              LodWeightsBias;                                   		// 0x00FC (0x0004) [0x0000000000000000]              
	float                                              LodWeightsBenefitsBias;                           		// 0x0100 (0x0004) [0x0000000000000000]              
	float                                              LODDecayTime;                                     		// 0x0104 (0x0004) [0x0000000000000000]              
	class USoundCue*                                   SoundOnMove;                                      		// 0x0108 (0x0008) [0x0000000000000000]              
	class USoundCue*                                   SoundOnRest;                                      		// 0x0110 (0x0008) [0x0000000000000000]              
	class USoundCue*                                   SoundWhileMoving;                                 		// 0x0118 (0x0008) [0x0000000000000000]              
	float                                              SpeedThresholdOnMove;                             		// 0x0120 (0x0004) [0x0000000000000000]              
	float                                              SpeedThresholdOnRest;                             		// 0x0124 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ApexClothingAsset" );

		return pClassPointer;
	};

};

UClass* UApexClothingAsset::pClassPointer = NULL;

// Class Engine.ApexDestructibleAsset
// 0x014C (0x01FC - 0x00B0)
class UApexDestructibleAsset : public UApexAsset
{
public:
	struct FPointer                                    MApexAsset;                                       		// 0x00B0 (0x0008) [0x0000000000000000]              
	TArray< class UMaterialInterface* >                Materials;                                        		// 0x00B8 (0x0010) [0x0000000000000000]              
	TArray< class UFractureMaterial* >                 FractureMaterials;                                		// 0x00C8 (0x0010) [0x0000000000000000]              
	DWORD                                              bPlaySingleFractureMaterialEffect : 1;            		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bHasUniqueAssetMaterialNames : 1;                 		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDynamic : 1;                                     		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000004] 
	class UPhysicalMaterial*                           DefaultPhysMaterial;                              		// 0x00DC (0x0008) [0x0000000000000000]              
	struct FPointer                                    MDestructibleThumbnailComponent;                  		// 0x00E4 (0x0008) [0x0000000000000000]              
	struct FString                                     CrumbleEmitterName;                               		// 0x00EC (0x0010) [0x0000000000000000]              
	struct FString                                     DustEmitterName;                                  		// 0x00FC (0x0010) [0x0000000000000000]              
	struct FNxDestructibleParameters                   DestructibleParameters;                           		// 0x010C (0x00F0) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ApexDestructibleAsset" );

		return pClassPointer;
	};

};

UClass* UApexDestructibleAsset::pClassPointer = NULL;

// Class Engine.ApexGenericAsset
// 0x0018 (0x00C8 - 0x00B0)
class UApexGenericAsset : public UApexAsset
{
public:
	struct FPointer                                    MApexAsset;                                       		// 0x00B0 (0x0008) [0x0000000000000000]              
	TArray< class UMaterialInterface* >                Materials;                                        		// 0x00B8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ApexGenericAsset" );

		return pClassPointer;
	};

};

UClass* UApexGenericAsset::pClassPointer = NULL;

// Class Engine.InterpFilter
// 0x0010 (0x0070 - 0x0060)
class UInterpFilter : public UObject
{
public:
	struct FString                                     Caption;                                          		// 0x0060 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpFilter" );

		return pClassPointer;
	};

};

UClass* UInterpFilter::pClassPointer = NULL;

// Class Engine.InterpFilter_Classes
// 0x0018 (0x0088 - 0x0070)
class UInterpFilter_Classes : public UInterpFilter
{
public:
	class UClass*                                      ClassToFilterBy;                                  		// 0x0070 (0x0008) [0x0000000000000000]              
	TArray< class UClass* >                            TrackClasses;                                     		// 0x0078 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpFilter_Classes" );

		return pClassPointer;
	};

};

UClass* UInterpFilter_Classes::pClassPointer = NULL;

// Class Engine.InterpFilter_Custom
// 0x0010 (0x0080 - 0x0070)
class UInterpFilter_Custom : public UInterpFilter
{
public:
	TArray< class UInterpGroup* >                      GroupsToInclude;                                  		// 0x0070 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpFilter_Custom" );

		return pClassPointer;
	};

};

UClass* UInterpFilter_Custom::pClassPointer = NULL;

// Class Engine.InterpGroup
// 0x0038 (0x0098 - 0x0060)
class UInterpGroup : public UObject
{
public:
	struct FPointer                                    VfTable_FInterpEdInputInterface;                  		// 0x0060 (0x0008) [0x0000000000000000]              
	TArray< class UInterpTrack* >                      InterpTracks;                                     		// 0x0068 (0x0010) [0x0000000000000000]              
	struct FName                                       GroupName;                                        		// 0x0078 (0x0008) [0x0000000000000000]              
	struct FColor                                      GroupColor;                                       		// 0x0080 (0x0004) [0x0000000000000000]              
	TArray< class UAnimSet* >                          GroupAnimSets;                                    		// 0x0084 (0x0010) [0x0000000000000000]              
	DWORD                                              bCollapsed : 1;                                   		// 0x0094 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bVisible : 1;                                     		// 0x0094 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIsFolder : 1;                                    		// 0x0094 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bIsParented : 1;                                  		// 0x0094 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bIsSelected : 1;                                  		// 0x0094 (0x0004) [0x0000000000000000] [0x00000010] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpGroup" );

		return pClassPointer;
	};

};

UClass* UInterpGroup::pClassPointer = NULL;

// Class Engine.InterpGroupAI
// 0x0014 (0x00AC - 0x0098)
class UInterpGroupAI : public UInterpGroup
{
public:
	class UClass*                                      PreviewPawnClass;                                 		// 0x0098 (0x0008) [0x0000000000000000]              
	struct FName                                       StageMarkGroup;                                   		// 0x00A0 (0x0008) [0x0000000000000000]              
	DWORD                                              SnapToRootBoneLocationWhenFinished : 1;           		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bNoEncroachmentCheck : 1;                         		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDisableWorldCollision : 1;                       		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bIgnoreLegacyHeightAdjust : 1;                    		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bRecreatePreviewPawn : 1;                         		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bRefreshStageMarkGroup : 1;                       		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000020] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpGroupAI" );

		return pClassPointer;
	};

};

UClass* UInterpGroupAI::pClassPointer = NULL;

// Class Engine.InterpGroupCamera
// 0x004C (0x00E4 - 0x0098)
class UInterpGroupCamera : public UInterpGroup
{
public:
	class UCameraAnim*                                 CameraAnimInst;                                   		// 0x0098 (0x0008) [0x0000000000000000]              
	struct FCameraPreviewInfo                          Target;                                           		// 0x00A0 (0x0040) [0x0000000000000000]              
	float                                              CompressTolerance;                                		// 0x00E0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpGroupCamera" );

		return pClassPointer;
	};

};

UClass* UInterpGroupCamera::pClassPointer = NULL;

// Class Engine.InterpGroupDirector
// 0x0000 (0x0098 - 0x0098)
class UInterpGroupDirector : public UInterpGroup
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpGroupDirector" );

		return pClassPointer;
	};

};

UClass* UInterpGroupDirector::pClassPointer = NULL;

// Class Engine.InterpGroupInst
// 0x0028 (0x0088 - 0x0060)
class UInterpGroupInst : public UObject
{
public:
	class UInterpGroup*                                Group;                                            		// 0x0060 (0x0008) [0x0000000000000000]              
	class AActor*                                      GroupActor;                                       		// 0x0068 (0x0008) [0x0000000000000000]              
	TArray< class UInterpTrackInst* >                  TrackInst;                                        		// 0x0070 (0x0010) [0x0000000000000000]              
	struct FPointer                                    CachedCamOverridePostProcess;                     		// 0x0080 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpGroupInst" );

		return pClassPointer;
	};

};

UClass* UInterpGroupInst::pClassPointer = NULL;

// Class Engine.InterpGroupInstAI
// 0x0020 (0x00A8 - 0x0088)
class UInterpGroupInstAI : public UInterpGroupInst
{
public:
	class UInterpGroupAI*                              AIGroup;                                          		// 0x0088 (0x0008) [0x0000000000000000]              
	unsigned char                                      SavedPhysics;                                     		// 0x0090 (0x0001) [0x0000000000000000]              
	DWORD                                              bSavedNoEncroachCheck : 1;                        		// 0x0094 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSavedCollideActors : 1;                          		// 0x0094 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bSavedBlockActors : 1;                            		// 0x0094 (0x0004) [0x0000000000000000] [0x00000004] 
	class APawn*                                       PreviewPawn;                                      		// 0x0098 (0x0008) [0x0000000000000000]              
	class AActor*                                      StageMarkActor;                                   		// 0x00A0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpGroupInstAI" );

		return pClassPointer;
	};

};

UClass* UInterpGroupInstAI::pClassPointer = NULL;

// Class Engine.InterpGroupInstCamera
// 0x0000 (0x0088 - 0x0088)
class UInterpGroupInstCamera : public UInterpGroupInst
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpGroupInstCamera" );

		return pClassPointer;
	};

};

UClass* UInterpGroupInstCamera::pClassPointer = NULL;

// Class Engine.InterpGroupInstDirector
// 0x0000 (0x0088 - 0x0088)
class UInterpGroupInstDirector : public UInterpGroupInst
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpGroupInstDirector" );

		return pClassPointer;
	};

};

UClass* UInterpGroupInstDirector::pClassPointer = NULL;

// Class Engine.InterpTrackBoolProp
// 0x0018 (0x00D8 - 0x00C0)
class UInterpTrackBoolProp : public UInterpTrack
{
public:
	TArray< struct FBoolTrackKey >                     BoolTrack;                                        		// 0x00C0 (0x0010) [0x0000000000000000]              
	struct FName                                       PropertyName;                                     		// 0x00D0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackBoolProp" );

		return pClassPointer;
	};

};

UClass* UInterpTrackBoolProp::pClassPointer = NULL;

// Class Engine.InterpTrackDirector
// 0x0014 (0x00D4 - 0x00C0)
class UInterpTrackDirector : public UInterpTrack
{
public:
	TArray< struct FDirectorTrackCut >                 CutTrack;                                         		// 0x00C0 (0x0010) [0x0000000000000000]              
	DWORD                                              bSimulateCameraCutsOnClients : 1;                 		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackDirector" );

		return pClassPointer;
	};

};

UClass* UInterpTrackDirector::pClassPointer = NULL;

// Class Engine.InterpTrackEvent
// 0x0014 (0x00D4 - 0x00C0)
class UInterpTrackEvent : public UInterpTrack
{
public:
	TArray< struct FEventTrackKey >                    EventTrack;                                       		// 0x00C0 (0x0010) [0x0000000000000000]              
	DWORD                                              bFireEventsWhenForwards : 1;                      		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFireEventsWhenBackwards : 1;                     		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bFireEventsWhenJumpingForwards : 1;               		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackEvent" );

		return pClassPointer;
	};

};

UClass* UInterpTrackEvent::pClassPointer = NULL;

// Class Engine.InterpTrackFaceFX
// 0x0038 (0x00F8 - 0x00C0)
class UInterpTrackFaceFX : public UInterpTrack
{
public:
	TArray< class UFaceFXAnimSet* >                    FaceFXAnimSets;                                   		// 0x00C0 (0x0010) [0x0000000000000000]              
	TArray< struct FFaceFXTrackKey >                   FaceFXSeqs;                                       		// 0x00D0 (0x0010) [0x0000000000000000]              
	class UFaceFXAsset*                                CachedActorFXAsset;                               		// 0x00E0 (0x0008) [0x0000000000000000]              
	TArray< struct FFaceFXSoundCueKey >                FaceFXSoundCueKeys;                               		// 0x00E8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackFaceFX" );

		return pClassPointer;
	};

};

UClass* UInterpTrackFaceFX::pClassPointer = NULL;

// Class Engine.InterpTrackFloatBase
// 0x0018 (0x00D8 - 0x00C0)
class UInterpTrackFloatBase : public UInterpTrack
{
public:
	struct FInterpCurveFloat                           FloatTrack;                                       		// 0x00C0 (0x0014) [0x0000000000000000]              
	float                                              CurveTension;                                     		// 0x00D4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackFloatBase" );

		return pClassPointer;
	};

};

UClass* UInterpTrackFloatBase::pClassPointer = NULL;

// Class Engine.InterpTrackAnimControl
// 0x002C (0x0104 - 0x00D8)
class UInterpTrackAnimControl : public UInterpTrackFloatBase
{
public:
	TArray< class UAnimSet* >                          AnimSets;                                         		// 0x00D8 (0x0010) [0x0000000000000000]              
	struct FName                                       SlotName;                                         		// 0x00E8 (0x0008) [0x0000000000000000]              
	TArray< struct FAnimControlTrackKey >              AnimSeqs;                                         		// 0x00F0 (0x0010) [0x0000000000000000]              
	DWORD                                              bEnableRootMotion : 1;                            		// 0x0100 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSkipAnimNotifiers : 1;                           		// 0x0100 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackAnimControl" );

		return pClassPointer;
	};

};

UClass* UInterpTrackAnimControl::pClassPointer = NULL;

// Class Engine.InterpTrackFade
// 0x0004 (0x00DC - 0x00D8)
class UInterpTrackFade : public UInterpTrackFloatBase
{
public:
	DWORD                                              bPersistFade : 1;                                 		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackFade" );

		return pClassPointer;
	};

};

UClass* UInterpTrackFade::pClassPointer = NULL;

// Class Engine.InterpTrackFloatMaterialParam
// 0x0024 (0x00FC - 0x00D8)
class UInterpTrackFloatMaterialParam : public UInterpTrackFloatBase
{
public:
	TArray< struct FMaterialReferenceList >            Materials;                                        		// 0x00D8 (0x0010) [0x0000000000000000]              
	class UMaterialInterface*                          Material;                                         		// 0x00E8 (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName;                                        		// 0x00F0 (0x0008) [0x0000000000000000]              
	DWORD                                              bNeedsMaterialRefsUpdate : 1;                     		// 0x00F8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackFloatMaterialParam" );

		return pClassPointer;
	};

};

UClass* UInterpTrackFloatMaterialParam::pClassPointer = NULL;

// Class Engine.InterpTrackFloatParticleParam
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackFloatParticleParam : public UInterpTrackFloatBase
{
public:
	struct FName                                       ParamName;                                        		// 0x00D8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackFloatParticleParam" );

		return pClassPointer;
	};

};

UClass* UInterpTrackFloatParticleParam::pClassPointer = NULL;

// Class Engine.InterpTrackFloatProp
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackFloatProp : public UInterpTrackFloatBase
{
public:
	struct FName                                       PropertyName;                                     		// 0x00D8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackFloatProp" );

		return pClassPointer;
	};

};

UClass* UInterpTrackFloatProp::pClassPointer = NULL;

// Class Engine.InterpTrackMorphWeight
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackMorphWeight : public UInterpTrackFloatBase
{
public:
	struct FName                                       MorphNodeName;                                    		// 0x00D8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackMorphWeight" );

		return pClassPointer;
	};

};

UClass* UInterpTrackMorphWeight::pClassPointer = NULL;

// Class Engine.InterpTrackMoveAxis
// 0x0014 (0x00EC - 0x00D8)
class UInterpTrackMoveAxis : public UInterpTrackFloatBase
{
public:
	unsigned char                                      MoveAxis;                                         		// 0x00D8 (0x0001) [0x0000000000000000]              
	struct FInterpLookupTrack                          LookupTrack;                                      		// 0x00DC (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackMoveAxis" );

		return pClassPointer;
	};

};

UClass* UInterpTrackMoveAxis::pClassPointer = NULL;

// Class Engine.InterpTrackSkelControlScale
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackSkelControlScale : public UInterpTrackFloatBase
{
public:
	struct FName                                       SkelControlName;                                  		// 0x00D8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackSkelControlScale" );

		return pClassPointer;
	};

};

UClass* UInterpTrackSkelControlScale::pClassPointer = NULL;

// Class Engine.InterpTrackSkelControlStrength
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackSkelControlStrength : public UInterpTrackFloatBase
{
public:
	struct FName                                       SkelControlName;                                  		// 0x00D8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackSkelControlStrength" );

		return pClassPointer;
	};

};

UClass* UInterpTrackSkelControlStrength::pClassPointer = NULL;

// Class Engine.InterpTrackSlomo
// 0x0000 (0x00D8 - 0x00D8)
class UInterpTrackSlomo : public UInterpTrackFloatBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackSlomo" );

		return pClassPointer;
	};

};

UClass* UInterpTrackSlomo::pClassPointer = NULL;

// Class Engine.InterpTrackHeadTracking
// 0x0054 (0x0114 - 0x00C0)
class UInterpTrackHeadTracking : public UInterpTrack
{
public:
	TArray< struct FHeadTrackingKey >                  HeadTrackingTrack;                                		// 0x00C0 (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             TrackControllerName;                              		// 0x00D0 (0x0010) [0x0000000000000000]              
	float                                              LookAtActorRadius;                                		// 0x00E0 (0x0004) [0x0000000000000000]              
	DWORD                                              bDisableBeyondLimit : 1;                          		// 0x00E4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLookAtPawns : 1;                                 		// 0x00E4 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              MaxLookAtTime;                                    		// 0x00E8 (0x0004) [0x0000000000000000]              
	float                                              MinLookAtTime;                                    		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              MaxInterestTime;                                  		// 0x00F0 (0x0004) [0x0000000000000000]              
	TArray< class UClass* >                            ActorClassesToLookAt;                             		// 0x00F4 (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             TargetBoneNames;                                  		// 0x0104 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackHeadTracking" );

		return pClassPointer;
	};

};

UClass* UInterpTrackHeadTracking::pClassPointer = NULL;

// Class Engine.InterpTrackLinearColorBase
// 0x0018 (0x00D8 - 0x00C0)
class UInterpTrackLinearColorBase : public UInterpTrack
{
public:
	struct FInterpCurveLinearColor                     LinearColorTrack;                                 		// 0x00C0 (0x0014) [0x0000000000000000]              
	float                                              CurveTension;                                     		// 0x00D4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackLinearColorBase" );

		return pClassPointer;
	};

};

UClass* UInterpTrackLinearColorBase::pClassPointer = NULL;

// Class Engine.InterpTrackLinearColorProp
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackLinearColorProp : public UInterpTrackLinearColorBase
{
public:
	struct FName                                       PropertyName;                                     		// 0x00D8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackLinearColorProp" );

		return pClassPointer;
	};

};

UClass* UInterpTrackLinearColorProp::pClassPointer = NULL;

// Class Engine.InterpTrackMove
// 0x004E (0x010E - 0x00C0)
class UInterpTrackMove : public UInterpTrack
{
public:
	struct FInterpCurveVector                          PosTrack;                                         		// 0x00C0 (0x0014) [0x0000000000000000]              
	struct FInterpCurveVector                          EulerTrack;                                       		// 0x00D4 (0x0014) [0x0000000000000000]              
	struct FInterpLookupTrack                          LookupTrack;                                      		// 0x00E8 (0x0010) [0x0000000000000000]              
	struct FName                                       LookAtGroupName;                                  		// 0x00F8 (0x0008) [0x0000000000000000]              
	float                                              LinCurveTension;                                  		// 0x0100 (0x0004) [0x0000000000000000]              
	float                                              AngCurveTension;                                  		// 0x0104 (0x0004) [0x0000000000000000]              
	DWORD                                              bUseQuatInterpolation : 1;                        		// 0x0108 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bShowArrowAtKeys : 1;                             		// 0x0108 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDisableMovement : 1;                             		// 0x0108 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bShowTranslationOnCurveEd : 1;                    		// 0x0108 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bShowRotationOnCurveEd : 1;                       		// 0x0108 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bHide3DTrack : 1;                                 		// 0x0108 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bUseRawActorTMforRelativeToInitial : 1;           		// 0x0108 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned char                                      MoveFrame;                                        		// 0x010C (0x0001) [0x0000000000000000]              
	unsigned char                                      RotMode;                                          		// 0x010D (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackMove" );

		return pClassPointer;
	};

};

UClass* UInterpTrackMove::pClassPointer = NULL;

// Class Engine.InterpTrackNotify
// 0x0030 (0x00F0 - 0x00C0)
class UInterpTrackNotify : public UInterpTrack
{
public:
	class UAnimNodeSequence*                           Node;                                             		// 0x00C0 (0x0008) [0x0000000000000000]              
	struct FName                                       ParentNodeName;                                   		// 0x00C8 (0x0008) [0x0000000000000000]              
	class UAnimSequence*                               OuterSequence;                                    		// 0x00D0 (0x0008) [0x0000000000000000]              
	class UAnimSet*                                    OuterSet;                                         		// 0x00D8 (0x0008) [0x0000000000000000]              
	TArray< struct FNotifyTrackKey >                   NotifyTrack;                                      		// 0x00E0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackNotify" );

		return pClassPointer;
	};

};

UClass* UInterpTrackNotify::pClassPointer = NULL;

// Class Engine.InterpTrackParticleReplay
// 0x0018 (0x00D8 - 0x00C0)
class UInterpTrackParticleReplay : public UInterpTrack
{
public:
	TArray< struct FParticleReplayTrackKey >           TrackKeys;                                        		// 0x00C0 (0x0010) [0x0000000000000000]              
	DWORD                                              bIsCapturingReplay : 1;                           		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              FixedTimeStep;                                    		// 0x00D4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackParticleReplay" );

		return pClassPointer;
	};

};

UClass* UInterpTrackParticleReplay::pClassPointer = NULL;

// Class Engine.InterpTrackToggle
// 0x0014 (0x00D4 - 0x00C0)
class UInterpTrackToggle : public UInterpTrack
{
public:
	TArray< struct FToggleTrackKey >                   ToggleTrack;                                      		// 0x00C0 (0x0010) [0x0000000000000000]              
	DWORD                                              bActivateSystemEachUpdate : 1;                    		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bActivateWithJustAttachedFlag : 1;                		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bFireEventsWhenForwards : 1;                      		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bFireEventsWhenBackwards : 1;                     		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bFireEventsWhenJumpingForwards : 1;               		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000010] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackToggle" );

		return pClassPointer;
	};

};

UClass* UInterpTrackToggle::pClassPointer = NULL;

// Class Engine.InterpTrackVectorBase
// 0x0018 (0x00D8 - 0x00C0)
class UInterpTrackVectorBase : public UInterpTrack
{
public:
	struct FInterpCurveVector                          VectorTrack;                                      		// 0x00C0 (0x0014) [0x0000000000000000]              
	float                                              CurveTension;                                     		// 0x00D4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackVectorBase" );

		return pClassPointer;
	};

};

UClass* UInterpTrackVectorBase::pClassPointer = NULL;

// Class Engine.InterpTrackAudioMaster
// 0x0000 (0x00D8 - 0x00D8)
class UInterpTrackAudioMaster : public UInterpTrackVectorBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackAudioMaster" );

		return pClassPointer;
	};

};

UClass* UInterpTrackAudioMaster::pClassPointer = NULL;

// Class Engine.InterpTrackColorProp
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackColorProp : public UInterpTrackVectorBase
{
public:
	struct FName                                       PropertyName;                                     		// 0x00D8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackColorProp" );

		return pClassPointer;
	};

};

UClass* UInterpTrackColorProp::pClassPointer = NULL;

// Class Engine.InterpTrackColorScale
// 0x0000 (0x00D8 - 0x00D8)
class UInterpTrackColorScale : public UInterpTrackVectorBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackColorScale" );

		return pClassPointer;
	};

};

UClass* UInterpTrackColorScale::pClassPointer = NULL;

// Class Engine.InterpTrackSound
// 0x0014 (0x00EC - 0x00D8)
class UInterpTrackSound : public UInterpTrackVectorBase
{
public:
	TArray< struct FSoundTrackKey >                    Sounds;                                           		// 0x00D8 (0x0010) [0x0000000000000000]              
	DWORD                                              bPlayOnReverse : 1;                               		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bContinueSoundOnMatineeEnd : 1;                   		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bSuppressSubtitles : 1;                           		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bTreatAsDialogue : 1;                             		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000008] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackSound" );

		return pClassPointer;
	};

};

UClass* UInterpTrackSound::pClassPointer = NULL;

// Class Engine.InterpTrackVectorMaterialParam
// 0x0024 (0x00FC - 0x00D8)
class UInterpTrackVectorMaterialParam : public UInterpTrackVectorBase
{
public:
	TArray< struct FMaterialReferenceList >            Materials;                                        		// 0x00D8 (0x0010) [0x0000000000000000]              
	class UMaterialInterface*                          Material;                                         		// 0x00E8 (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName;                                        		// 0x00F0 (0x0008) [0x0000000000000000]              
	DWORD                                              bNeedsMaterialRefsUpdate : 1;                     		// 0x00F8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackVectorMaterialParam" );

		return pClassPointer;
	};

};

UClass* UInterpTrackVectorMaterialParam::pClassPointer = NULL;

// Class Engine.InterpTrackVectorProp
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackVectorProp : public UInterpTrackVectorBase
{
public:
	struct FName                                       PropertyName;                                     		// 0x00D8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackVectorProp" );

		return pClassPointer;
	};

};

UClass* UInterpTrackVectorProp::pClassPointer = NULL;

// Class Engine.InterpTrackVisibility
// 0x0014 (0x00D4 - 0x00C0)
class UInterpTrackVisibility : public UInterpTrack
{
public:
	TArray< struct FVisibilityTrackKey >               VisibilityTrack;                                  		// 0x00C0 (0x0010) [0x0000000000000000]              
	DWORD                                              bFireEventsWhenForwards : 1;                      		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFireEventsWhenBackwards : 1;                     		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bFireEventsWhenJumpingForwards : 1;               		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackVisibility" );

		return pClassPointer;
	};

};

UClass* UInterpTrackVisibility::pClassPointer = NULL;

// Class Engine.InterpTrackInst
// 0x0000 (0x0060 - 0x0060)
class UInterpTrackInst : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInst" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInst::pClassPointer = NULL;

// Class Engine.InterpTrackInstAnimControl
// 0x001C (0x007C - 0x0060)
class UInterpTrackInstAnimControl : public UInterpTrackInst
{
public:
	float                                              LastUpdatePosition;                               		// 0x0060 (0x0004) [0x0000000000000000]              
	struct FVector                                     InitPosition;                                     		// 0x0064 (0x000C) [0x0000000000000000]              
	struct FRotator                                    InitRotation;                                     		// 0x0070 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstAnimControl" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstAnimControl::pClassPointer = NULL;

// Class Engine.InterpTrackInstAudioMaster
// 0x0000 (0x0060 - 0x0060)
class UInterpTrackInstAudioMaster : public UInterpTrackInst
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstAudioMaster" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstAudioMaster::pClassPointer = NULL;

// Class Engine.InterpTrackInstColorScale
// 0x0000 (0x0060 - 0x0060)
class UInterpTrackInstColorScale : public UInterpTrackInst
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstColorScale" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstColorScale::pClassPointer = NULL;

// Class Engine.InterpTrackInstDirector
// 0x000C (0x006C - 0x0060)
class UInterpTrackInstDirector : public UInterpTrackInst
{
public:
	class AActor*                                      OldViewTarget;                                    		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FRenderingPerformanceOverrides              OldRenderingOverrides;                            		// 0x0068 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstDirector" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstDirector::pClassPointer = NULL;

// Class Engine.InterpTrackInstEvent
// 0x0004 (0x0064 - 0x0060)
class UInterpTrackInstEvent : public UInterpTrackInst
{
public:
	float                                              LastUpdatePosition;                               		// 0x0060 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstEvent" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstEvent::pClassPointer = NULL;

// Class Engine.InterpTrackInstFaceFX
// 0x0008 (0x0068 - 0x0060)
class UInterpTrackInstFaceFX : public UInterpTrackInst
{
public:
	DWORD                                              bFirstUpdate : 1;                                 		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              LastUpdatePosition;                               		// 0x0064 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstFaceFX" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstFaceFX::pClassPointer = NULL;

// Class Engine.InterpTrackInstFade
// 0x0000 (0x0060 - 0x0060)
class UInterpTrackInstFade : public UInterpTrackInst
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstFade" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstFade::pClassPointer = NULL;

// Class Engine.InterpTrackInstFloatMaterialParam
// 0x0018 (0x0078 - 0x0060)
class UInterpTrackInstFloatMaterialParam : public UInterpTrackInst
{
public:
	TArray< struct FFloatMaterialParamMICData >        MICInfos;                                         		// 0x0060 (0x0010) [0x0000000000000000]              
	class UInterpTrackFloatMaterialParam*              InstancedTrack;                                   		// 0x0070 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstFloatMaterialParam" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstFloatMaterialParam::pClassPointer = NULL;

// Class Engine.InterpTrackInstFloatParticleParam
// 0x0004 (0x0064 - 0x0060)
class UInterpTrackInstFloatParticleParam : public UInterpTrackInst
{
public:
	float                                              ResetFloat;                                       		// 0x0060 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstFloatParticleParam" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstFloatParticleParam::pClassPointer = NULL;

// Class Engine.InterpTrackInstHeadTracking
// 0x0068 (0x00C8 - 0x0060)
class UInterpTrackInstHeadTracking : public UInterpTrackInst
{
public:
	unsigned char                                      Action;                                           		// 0x0060 (0x0001) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x0064 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.InterpTrackInstHeadTracking.CurrentActorMap
	class USkeletalMeshComponent*                      Mesh;                                             		// 0x00AC (0x0008) [0x0000000000000000]              
	TArray< class USkelControlLookAt* >                TrackControls;                                    		// 0x00B4 (0x0010) [0x0000000000000000]              
	float                                              LastUpdatePosition;                               		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstHeadTracking" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstHeadTracking::pClassPointer = NULL;

// Class Engine.InterpTrackInstMorphWeight
// 0x0000 (0x0060 - 0x0060)
class UInterpTrackInstMorphWeight : public UInterpTrackInst
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstMorphWeight" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstMorphWeight::pClassPointer = NULL;

// Class Engine.InterpTrackInstMove
// 0x0070 (0x00D0 - 0x0060)
class UInterpTrackInstMove : public UInterpTrackInst
{
public:
	struct FVector                                     ResetLocation;                                    		// 0x0060 (0x000C) [0x0000000000000000]              
	struct FRotator                                    ResetRotation;                                    		// 0x006C (0x000C) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0078 (0x0008) MISSED OFFSET
	struct FMatrix                                     InitialTM;                                        		// 0x0080 (0x0040) [0x0000000000000000]              
	struct FQuat                                       InitialQuat;                                      		// 0x00C0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstMove" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstMove::pClassPointer = NULL;

// Class Engine.InterpTrackInstNotify
// 0x0004 (0x0064 - 0x0060)
class UInterpTrackInstNotify : public UInterpTrackInst
{
public:
	float                                              LastUpdatePosition;                               		// 0x0060 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstNotify" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstNotify::pClassPointer = NULL;

// Class Engine.InterpTrackInstParticleReplay
// 0x0004 (0x0064 - 0x0060)
class UInterpTrackInstParticleReplay : public UInterpTrackInst
{
public:
	float                                              LastUpdatePosition;                               		// 0x0060 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstParticleReplay" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstParticleReplay::pClassPointer = NULL;

// Class Engine.InterpTrackInstProperty
// 0x0010 (0x0070 - 0x0060)
class UInterpTrackInstProperty : public UInterpTrackInst
{
public:
	class UFunction*                                   PropertyUpdateCallback;                           		// 0x0060 (0x0008) [0x0000000000000000]              
	class UObject*                                     PropertyOuterObjectInst;                          		// 0x0068 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstProperty" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstProperty::pClassPointer = NULL;

// Class Engine.InterpTrackInstBoolProp
// 0x0010 (0x0080 - 0x0070)
class UInterpTrackInstBoolProp : public UInterpTrackInstProperty
{
public:
	struct FPointer                                    BoolProp;                                         		// 0x0070 (0x0008) [0x0000000000000000]              
	int                                                BitMask;                                          		// 0x0078 (0x0004) [0x0000000000000000]              
	DWORD                                              ResetBool : 1;                                    		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstBoolProp" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstBoolProp::pClassPointer = NULL;

// Class Engine.InterpTrackInstColorProp
// 0x000C (0x007C - 0x0070)
class UInterpTrackInstColorProp : public UInterpTrackInstProperty
{
public:
	struct FPointer                                    ColorProp;                                        		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FColor                                      ResetColor;                                       		// 0x0078 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstColorProp" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstColorProp::pClassPointer = NULL;

// Class Engine.InterpTrackInstFloatProp
// 0x0014 (0x0084 - 0x0070)
class UInterpTrackInstFloatProp : public UInterpTrackInstProperty
{
public:
	struct FPointer                                    FloatProp;                                        		// 0x0070 (0x0008) [0x0000000000000000]              
	float                                              ResetFloat;                                       		// 0x0078 (0x0004) [0x0000000000000000]              
	struct FPointer                                    DistributionProp;                                 		// 0x007C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstFloatProp" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstFloatProp::pClassPointer = NULL;

// Class Engine.InterpTrackInstLinearColorProp
// 0x0018 (0x0088 - 0x0070)
class UInterpTrackInstLinearColorProp : public UInterpTrackInstProperty
{
public:
	struct FPointer                                    ColorProp;                                        		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FLinearColor                                ResetColor;                                       		// 0x0078 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstLinearColorProp" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstLinearColorProp::pClassPointer = NULL;

// Class Engine.InterpTrackInstVectorProp
// 0x0014 (0x0084 - 0x0070)
class UInterpTrackInstVectorProp : public UInterpTrackInstProperty
{
public:
	struct FPointer                                    VectorProp;                                       		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FVector                                     ResetVector;                                      		// 0x0078 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstVectorProp" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstVectorProp::pClassPointer = NULL;

// Class Engine.InterpTrackInstSkelControlScale
// 0x0000 (0x0060 - 0x0060)
class UInterpTrackInstSkelControlScale : public UInterpTrackInst
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstSkelControlScale" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstSkelControlScale::pClassPointer = NULL;

// Class Engine.InterpTrackInstSkelControlStrength
// 0x0004 (0x0064 - 0x0060)
class UInterpTrackInstSkelControlStrength : public UInterpTrackInst
{
public:
	DWORD                                              bSavedControlledByAnimMetaData : 1;               		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstSkelControlStrength" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstSkelControlStrength::pClassPointer = NULL;

// Class Engine.InterpTrackInstSlomo
// 0x0004 (0x0064 - 0x0060)
class UInterpTrackInstSlomo : public UInterpTrackInst
{
public:
	float                                              OldTimeDilation;                                  		// 0x0060 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstSlomo" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstSlomo::pClassPointer = NULL;

// Class Engine.InterpTrackInstSound
// 0x000C (0x006C - 0x0060)
class UInterpTrackInstSound : public UInterpTrackInst
{
public:
	float                                              LastUpdatePosition;                               		// 0x0060 (0x0004) [0x0000000000000000]              
	class UAudioComponent*                             PlayAudioComp;                                    		// 0x0064 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstSound" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstSound::pClassPointer = NULL;

// Class Engine.InterpTrackInstToggle
// 0x000C (0x006C - 0x0060)
class UInterpTrackInstToggle : public UInterpTrackInst
{
public:
	unsigned char                                      Action;                                           		// 0x0060 (0x0001) [0x0000000000000000]              
	float                                              LastUpdatePosition;                               		// 0x0064 (0x0004) [0x0000000000000000]              
	DWORD                                              bSavedActiveState : 1;                            		// 0x0068 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstToggle" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstToggle::pClassPointer = NULL;

// Class Engine.InterpTrackInstVectorMaterialParam
// 0x0018 (0x0078 - 0x0060)
class UInterpTrackInstVectorMaterialParam : public UInterpTrackInst
{
public:
	TArray< struct FVectorMaterialParamMICData >       MICInfos;                                         		// 0x0060 (0x0010) [0x0000000000000000]              
	class UInterpTrackVectorMaterialParam*             InstancedTrack;                                   		// 0x0070 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstVectorMaterialParam" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstVectorMaterialParam::pClassPointer = NULL;

// Class Engine.InterpTrackInstVisibility
// 0x0008 (0x0068 - 0x0060)
class UInterpTrackInstVisibility : public UInterpTrackInst
{
public:
	unsigned char                                      Action;                                           		// 0x0060 (0x0001) [0x0000000000000000]              
	float                                              LastUpdatePosition;                               		// 0x0064 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpTrackInstVisibility" );

		return pClassPointer;
	};

};

UClass* UInterpTrackInstVisibility::pClassPointer = NULL;

// Class Engine.MaterialExpression
// 0x0058 (0x00B8 - 0x0060)
class UMaterialExpression : public UObject
{
public:
	int                                                EditorX;                                          		// 0x0060 (0x0004) [0x0000000000000000]              
	int                                                EditorY;                                          		// 0x0064 (0x0004) [0x0000000000000000]              
	int                                                MaterialExpressionEditorX;                        		// 0x0068 (0x0004) [0x0000000000000000]              
	int                                                MaterialExpressionEditorY;                        		// 0x006C (0x0004) [0x0000000000000000]              
	DWORD                                              bRealtimePreview : 1;                             		// 0x0070 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bNeedToUpdatePreview : 1;                         		// 0x0070 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIsParameterExpression : 1;                       		// 0x0070 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bShowOutputNameOnPin : 1;                         		// 0x0070 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bHidePreviewWindow : 1;                           		// 0x0070 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bShowInputs : 1;                                  		// 0x0070 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bShowOutputs : 1;                                 		// 0x0070 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bUsedByStaticParameterSet : 1;                    		// 0x0070 (0x0004) [0x0000000000000000] [0x00000080] 
	class UMaterial*                                   Material;                                         		// 0x0074 (0x0008) [0x0000000000000000]              
	class UMaterialFunction*                           Function;                                         		// 0x007C (0x0008) [0x0000000000000000]              
	struct FString                                     Desc;                                             		// 0x0084 (0x0010) [0x0000000000000000]              
	struct FColor                                      BorderColor;                                      		// 0x0094 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             MenuCategories;                                   		// 0x0098 (0x0010) [0x0000000000000000]              
	TArray< struct FExpressionOutput >                 Outputs;                                          		// 0x00A8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpression" );

		return pClassPointer;
	};

};

UClass* UMaterialExpression::pClassPointer = NULL;

// Class Engine.MaterialExpressionAbs
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionAbs : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionAbs" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionAbs::pClassPointer = NULL;

// Class Engine.MaterialExpressionActorWorldPosition
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionActorWorldPosition : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionActorWorldPosition" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionActorWorldPosition::pClassPointer = NULL;

// Class Engine.MaterialExpressionAdd
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionAdd : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00EC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionAdd" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionAdd::pClassPointer = NULL;

// Class Engine.MaterialExpressionAppendVector
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionAppendVector : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00EC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionAppendVector" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionAppendVector::pClassPointer = NULL;

// Class Engine.MaterialExpressionBumpOffset
// 0x00A4 (0x015C - 0x00B8)
class UMaterialExpressionBumpOffset : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinate;                                       		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Height;                                           		// 0x00EC (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            HeightRatioInput;                                 		// 0x0120 (0x0034) [0x0000000000000000]              
	float                                              HeightRatio;                                      		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              ReferencePlane;                                   		// 0x0158 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionBumpOffset" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionBumpOffset::pClassPointer = NULL;

// Class Engine.MaterialExpressionCameraVector
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionCameraVector : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionCameraVector" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionCameraVector::pClassPointer = NULL;

// Class Engine.MaterialExpressionCameraWorldPosition
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionCameraWorldPosition : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionCameraWorldPosition" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionCameraWorldPosition::pClassPointer = NULL;

// Class Engine.MaterialExpressionCeil
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionCeil : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionCeil" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionCeil::pClassPointer = NULL;

// Class Engine.MaterialExpressionClamp
// 0x009C (0x0154 - 0x00B8)
class UMaterialExpressionClamp : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Min;                                              		// 0x00EC (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Max;                                              		// 0x0120 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionClamp" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionClamp::pClassPointer = NULL;

// Class Engine.MaterialExpressionComment
// 0x0020 (0x00D8 - 0x00B8)
class UMaterialExpressionComment : public UMaterialExpression
{
public:
	int                                                PosX;                                             		// 0x00B8 (0x0004) [0x0000000000000000]              
	int                                                PosY;                                             		// 0x00BC (0x0004) [0x0000000000000000]              
	int                                                SizeX;                                            		// 0x00C0 (0x0004) [0x0000000000000000]              
	int                                                SizeY;                                            		// 0x00C4 (0x0004) [0x0000000000000000]              
	struct FString                                     Text;                                             		// 0x00C8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionComment" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionComment::pClassPointer = NULL;

// Class Engine.MaterialExpressionComponentMask
// 0x0038 (0x00F0 - 0x00B8)
class UMaterialExpressionComponentMask : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              
	DWORD                                              R : 1;                                            		// 0x00EC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              G : 1;                                            		// 0x00EC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              B : 1;                                            		// 0x00EC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              A : 1;                                            		// 0x00EC (0x0004) [0x0000000000000000] [0x00000008] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionComponentMask" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionComponentMask::pClassPointer = NULL;

// Class Engine.MaterialExpressionConstant
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionConstant : public UMaterialExpression
{
public:
	float                                              R;                                                		// 0x00B8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionConstant" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionConstant::pClassPointer = NULL;

// Class Engine.MaterialExpressionConstant2Vector
// 0x0008 (0x00C0 - 0x00B8)
class UMaterialExpressionConstant2Vector : public UMaterialExpression
{
public:
	float                                              R;                                                		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              G;                                                		// 0x00BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionConstant2Vector" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionConstant2Vector::pClassPointer = NULL;

// Class Engine.MaterialExpressionConstant3Vector
// 0x000C (0x00C4 - 0x00B8)
class UMaterialExpressionConstant3Vector : public UMaterialExpression
{
public:
	float                                              R;                                                		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              G;                                                		// 0x00BC (0x0004) [0x0000000000000000]              
	float                                              B;                                                		// 0x00C0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionConstant3Vector" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionConstant3Vector::pClassPointer = NULL;

// Class Engine.MaterialExpressionConstant4Vector
// 0x0010 (0x00C8 - 0x00B8)
class UMaterialExpressionConstant4Vector : public UMaterialExpression
{
public:
	float                                              R;                                                		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              G;                                                		// 0x00BC (0x0004) [0x0000000000000000]              
	float                                              B;                                                		// 0x00C0 (0x0004) [0x0000000000000000]              
	float                                              A;                                                		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionConstant4Vector" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionConstant4Vector::pClassPointer = NULL;

// Class Engine.MaterialExpressionConstantBiasScale
// 0x003C (0x00F4 - 0x00B8)
class UMaterialExpressionConstantBiasScale : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              
	float                                              Bias;                                             		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              Scale;                                            		// 0x00F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionConstantBiasScale" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionConstantBiasScale::pClassPointer = NULL;

// Class Engine.MaterialExpressionConstantClamp
// 0x003C (0x00F4 - 0x00B8)
class UMaterialExpressionConstantClamp : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              
	float                                              Min;                                              		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              Max;                                              		// 0x00F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionConstantClamp" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionConstantClamp::pClassPointer = NULL;

// Class Engine.MaterialExpressionCosine
// 0x0038 (0x00F0 - 0x00B8)
class UMaterialExpressionCosine : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              
	float                                              Period;                                           		// 0x00EC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionCosine" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionCosine::pClassPointer = NULL;

// Class Engine.MaterialExpressionCrossProduct
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionCrossProduct : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00EC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionCrossProduct" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionCrossProduct::pClassPointer = NULL;

// Class Engine.MaterialExpressionCustom
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionCustom : public UMaterialExpression
{
public:
	struct FString                                     Code;                                             		// 0x00B8 (0x0010) [0x0000000000000000]              
	unsigned char                                      OutputType;                                       		// 0x00C8 (0x0001) [0x0000000000000000]              
	struct FString                                     Description;                                      		// 0x00CC (0x0010) [0x0000000000000000]              
	TArray< struct FCustomInput >                      Inputs;                                           		// 0x00DC (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionCustom" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionCustom::pClassPointer = NULL;

// Class Engine.MaterialExpressionCustomTexture
// 0x0008 (0x00C0 - 0x00B8)
class UMaterialExpressionCustomTexture : public UMaterialExpression
{
public:
	class UTexture*                                    Texture;                                          		// 0x00B8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionCustomTexture" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionCustomTexture::pClassPointer = NULL;

// Class Engine.MaterialExpressionDepthBiasedAlpha
// 0x0070 (0x0128 - 0x00B8)
class UMaterialExpressionDepthBiasedAlpha : public UMaterialExpression
{
public:
	DWORD                                              bNormalize : 1;                                   		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              BiasScale;                                        		// 0x00BC (0x0004) [0x0000000000000000]              
	struct FExpressionInput                            Alpha;                                            		// 0x00C0 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Bias;                                             		// 0x00F4 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionDepthBiasedAlpha" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionDepthBiasedAlpha::pClassPointer = NULL;

// Class Engine.MaterialExpressionDepthBiasedBlend
// 0x00A4 (0x015C - 0x00B8)
class UMaterialExpressionDepthBiasedBlend : public UMaterialExpression
{
public:
	DWORD                                              bNormalize : 1;                                   		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              BiasScale;                                        		// 0x00BC (0x0004) [0x0000000000000000]              
	struct FExpressionInput                            RGB;                                              		// 0x00C0 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Alpha;                                            		// 0x00F4 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Bias;                                             		// 0x0128 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionDepthBiasedBlend" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionDepthBiasedBlend::pClassPointer = NULL;

// Class Engine.MaterialExpressionDepthOfFieldFunction
// 0x0038 (0x00F0 - 0x00B8)
class UMaterialExpressionDepthOfFieldFunction : public UMaterialExpression
{
public:
	unsigned char                                      FunctionValue;                                    		// 0x00B8 (0x0001) [0x0000000000000000]              
	struct FExpressionInput                            Depth;                                            		// 0x00BC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionDepthOfFieldFunction" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionDepthOfFieldFunction::pClassPointer = NULL;

// Class Engine.MaterialExpressionDeriveNormalZ
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionDeriveNormalZ : public UMaterialExpression
{
public:
	struct FExpressionInput                            InXY;                                             		// 0x00B8 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionDeriveNormalZ" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionDeriveNormalZ::pClassPointer = NULL;

// Class Engine.MaterialExpressionDesaturation
// 0x0078 (0x0130 - 0x00B8)
class UMaterialExpressionDesaturation : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Percent;                                          		// 0x00EC (0x0034) [0x0000000000000000]              
	struct FLinearColor                                LuminanceFactors;                                 		// 0x0120 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionDesaturation" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionDesaturation::pClassPointer = NULL;

// Class Engine.MaterialExpressionDestColor
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionDestColor : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionDestColor" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionDestColor::pClassPointer = NULL;

// Class Engine.MaterialExpressionDestDepth
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionDestDepth : public UMaterialExpression
{
public:
	DWORD                                              bNormalize : 1;                                   		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionDestDepth" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionDestDepth::pClassPointer = NULL;

// Class Engine.MaterialExpressionDistance
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionDistance : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00EC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionDistance" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionDistance::pClassPointer = NULL;

// Class Engine.MaterialExpressionDivide
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionDivide : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00EC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionDivide" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionDivide::pClassPointer = NULL;

// Class Engine.MaterialExpressionDotProduct
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionDotProduct : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00EC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionDotProduct" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionDotProduct::pClassPointer = NULL;

// Class Engine.MaterialExpressionDynamicParameter
// 0x0010 (0x00C8 - 0x00B8)
class UMaterialExpressionDynamicParameter : public UMaterialExpression
{
public:
	TArray< struct FString >                           ParamNames;                                       		// 0x00B8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionDynamicParameter" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionDynamicParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionMeshEmitterDynamicParameter
// 0x0000 (0x00C8 - 0x00C8)
class UMaterialExpressionMeshEmitterDynamicParameter : public UMaterialExpressionDynamicParameter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionMeshEmitterDynamicParameter" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionMeshEmitterDynamicParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionFloor
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionFloor : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionFloor" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionFloor::pClassPointer = NULL;

// Class Engine.MaterialExpressionFluidNormal
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionFluidNormal : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinates;                                      		// 0x00B8 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionFluidNormal" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionFluidNormal::pClassPointer = NULL;

// Class Engine.MaterialExpressionFmod
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionFmod : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00EC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionFmod" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionFmod::pClassPointer = NULL;

// Class Engine.MaterialExpressionFoliageImpulseDirection
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionFoliageImpulseDirection : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionFoliageImpulseDirection" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionFoliageImpulseDirection::pClassPointer = NULL;

// Class Engine.MaterialExpressionFoliageNormalizedRotationAxisAndAngle
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionFoliageNormalizedRotationAxisAndAngle : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionFoliageNormalizedRotationAxisAndAngle" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionFoliageNormalizedRotationAxisAndAngle::pClassPointer = NULL;

// Class Engine.MaterialExpressionFontSample
// 0x000C (0x00C4 - 0x00B8)
class UMaterialExpressionFontSample : public UMaterialExpression
{
public:
	class UFont*                                       Font;                                             		// 0x00B8 (0x0008) [0x0000000000000000]              
	int                                                FontTexturePage;                                  		// 0x00C0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionFontSample" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionFontSample::pClassPointer = NULL;

// Class Engine.MaterialExpressionFontSampleParameter
// 0x0020 (0x00E4 - 0x00C4)
class UMaterialExpressionFontSampleParameter : public UMaterialExpressionFontSample
{
public:
	struct FName                                       ParameterName;                                    		// 0x00C4 (0x0008) [0x0000000000000000]              
	struct FGuid                                       ExpressionGUID;                                   		// 0x00CC (0x0010) [0x0000000000000000]              
	struct FName                                       Group;                                            		// 0x00DC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionFontSampleParameter" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionFontSampleParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionFrac
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionFrac : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionFrac" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionFrac::pClassPointer = NULL;

// Class Engine.MaterialExpressionFresnel
// 0x0038 (0x00F0 - 0x00B8)
class UMaterialExpressionFresnel : public UMaterialExpression
{
public:
	float                                              Exponent;                                         		// 0x00B8 (0x0004) [0x0000000000000000]              
	struct FExpressionInput                            Normal;                                           		// 0x00BC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionFresnel" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionFresnel::pClassPointer = NULL;

// Class Engine.MaterialExpressionFunctionInput
// 0x0080 (0x0138 - 0x00B8)
class UMaterialExpressionFunctionInput : public UMaterialExpression
{
public:
	struct FExpressionInput                            Preview;                                          		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FString                                     InputName;                                        		// 0x00EC (0x0010) [0x0000000000000000]              
	struct FString                                     Description;                                      		// 0x00FC (0x0010) [0x0000000000000000]              
	struct FGuid                                       Id;                                               		// 0x010C (0x0010) [0x0000000000000000]              
	unsigned char                                      InputType;                                        		// 0x011C (0x0001) [0x0000000000000000]              
	struct FVector4                                    PreviewValue;                                     		// 0x0120 (0x0010) [0x0000000000000000]              
	DWORD                                              bUsePreviewValueAsDefault : 1;                    		// 0x0130 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bCompilingFunctionPreview : 1;                    		// 0x0130 (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                SortPriority;                                     		// 0x0134 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionFunctionInput" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionFunctionInput::pClassPointer = NULL;

// Class Engine.MaterialExpressionFunctionOutput
// 0x006C (0x0124 - 0x00B8)
class UMaterialExpressionFunctionOutput : public UMaterialExpression
{
public:
	struct FString                                     OutputName;                                       		// 0x00B8 (0x0010) [0x0000000000000000]              
	struct FString                                     Description;                                      		// 0x00C8 (0x0010) [0x0000000000000000]              
	int                                                SortPriority;                                     		// 0x00D8 (0x0004) [0x0000000000000000]              
	struct FExpressionInput                            A;                                                		// 0x00DC (0x0034) [0x0000000000000000]              
	DWORD                                              bLastPreviewed : 1;                               		// 0x0110 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FGuid                                       Id;                                               		// 0x0114 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionFunctionOutput" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionFunctionOutput::pClassPointer = NULL;

// Class Engine.MaterialExpressionIf
// 0x0104 (0x01BC - 0x00B8)
class UMaterialExpressionIf : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00EC (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            AGreaterThanB;                                    		// 0x0120 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            AEqualsB;                                         		// 0x0154 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            ALessThanB;                                       		// 0x0188 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionIf" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionIf::pClassPointer = NULL;

// Class Engine.MaterialExpressionLandscapeLayerBlend
// 0x0020 (0x00D8 - 0x00B8)
class UMaterialExpressionLandscapeLayerBlend : public UMaterialExpression
{
public:
	TArray< struct FLayerBlendInput >                  Layers;                                           		// 0x00B8 (0x0010) [0x0000000000000000]              
	struct FGuid                                       ExpressionGUID;                                   		// 0x00C8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionLandscapeLayerBlend" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionLandscapeLayerBlend::pClassPointer = NULL;

// Class Engine.MaterialExpressionLensFlareIntensity
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLensFlareIntensity : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionLensFlareIntensity" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionLensFlareIntensity::pClassPointer = NULL;

// Class Engine.MaterialExpressionLensFlareOcclusion
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLensFlareOcclusion : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionLensFlareOcclusion" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionLensFlareOcclusion::pClassPointer = NULL;

// Class Engine.MaterialExpressionLensFlareRadialDistance
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLensFlareRadialDistance : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionLensFlareRadialDistance" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionLensFlareRadialDistance::pClassPointer = NULL;

// Class Engine.MaterialExpressionLensFlareRayDistance
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLensFlareRayDistance : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionLensFlareRayDistance" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionLensFlareRayDistance::pClassPointer = NULL;

// Class Engine.MaterialExpressionLensFlareSourceDistance
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLensFlareSourceDistance : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionLensFlareSourceDistance" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionLensFlareSourceDistance::pClassPointer = NULL;

// Class Engine.MaterialExpressionLightmapUVs
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLightmapUVs : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionLightmapUVs" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionLightmapUVs::pClassPointer = NULL;

// Class Engine.MaterialExpressionLightmassReplace
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionLightmassReplace : public UMaterialExpression
{
public:
	struct FExpressionInput                            Realtime;                                         		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Lightmass;                                        		// 0x00EC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionLightmassReplace" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionLightmassReplace::pClassPointer = NULL;

// Class Engine.MaterialExpressionLightVector
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLightVector : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionLightVector" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionLightVector::pClassPointer = NULL;

// Class Engine.MaterialExpressionLinearInterpolate
// 0x009C (0x0154 - 0x00B8)
class UMaterialExpressionLinearInterpolate : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00EC (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Alpha;                                            		// 0x0120 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionLinearInterpolate" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionLinearInterpolate::pClassPointer = NULL;

// Class Engine.MaterialExpressionMaterialFunctionCall
// 0x0028 (0x00E0 - 0x00B8)
class UMaterialExpressionMaterialFunctionCall : public UMaterialExpression
{
public:
	class UMaterialFunction*                           MaterialFunction;                                 		// 0x00B8 (0x0008) [0x0000000000000000]              
	TArray< struct FFunctionExpressionInput >          FunctionInputs;                                   		// 0x00C0 (0x0010) [0x0000000000000000]              
	TArray< struct FFunctionExpressionOutput >         FunctionOutputs;                                  		// 0x00D0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionMaterialFunctionCall" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionMaterialFunctionCall::pClassPointer = NULL;

// Class Engine.MaterialExpressionMeshEmitterVertexColor
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionMeshEmitterVertexColor : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionMeshEmitterVertexColor" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionMeshEmitterVertexColor::pClassPointer = NULL;

// Class Engine.MaterialExpressionMultiply
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionMultiply : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00EC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionMultiply" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionMultiply::pClassPointer = NULL;

// Class Engine.MaterialExpressionNormalize
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionNormalize : public UMaterialExpression
{
public:
	struct FExpressionInput                            VectorInput;                                      		// 0x00B8 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionNormalize" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionNormalize::pClassPointer = NULL;

// Class Engine.MaterialExpressionObjectOrientation
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionObjectOrientation : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionObjectOrientation" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionObjectOrientation::pClassPointer = NULL;

// Class Engine.MaterialExpressionObjectRadius
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionObjectRadius : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionObjectRadius" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionObjectRadius::pClassPointer = NULL;

// Class Engine.MaterialExpressionObjectWorldPosition
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionObjectWorldPosition : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionObjectWorldPosition" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionObjectWorldPosition::pClassPointer = NULL;

// Class Engine.MaterialExpressionOcclusionPercentage
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionOcclusionPercentage : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionOcclusionPercentage" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionOcclusionPercentage::pClassPointer = NULL;

// Class Engine.MaterialExpressionOneMinus
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionOneMinus : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionOneMinus" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionOneMinus::pClassPointer = NULL;

// Class Engine.MaterialExpressionPanner
// 0x0070 (0x0128 - 0x00B8)
class UMaterialExpressionPanner : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinate;                                       		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Time;                                             		// 0x00EC (0x0034) [0x0000000000000000]              
	float                                              SpeedX;                                           		// 0x0120 (0x0004) [0x0000000000000000]              
	float                                              SpeedY;                                           		// 0x0124 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionPanner" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionPanner::pClassPointer = NULL;

// Class Engine.MaterialExpressionParameter
// 0x0020 (0x00D8 - 0x00B8)
class UMaterialExpressionParameter : public UMaterialExpression
{
public:
	struct FName                                       ParameterName;                                    		// 0x00B8 (0x0008) [0x0000000000000000]              
	struct FGuid                                       ExpressionGUID;                                   		// 0x00C0 (0x0010) [0x0000000000000000]              
	struct FName                                       Group;                                            		// 0x00D0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionParameter" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionScalarParameter
// 0x0004 (0x00DC - 0x00D8)
class UMaterialExpressionScalarParameter : public UMaterialExpressionParameter
{
public:
	float                                              DefaultValue;                                     		// 0x00D8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionScalarParameter" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionScalarParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionStaticBoolParameter
// 0x000C (0x00E4 - 0x00D8)
class UMaterialExpressionStaticBoolParameter : public UMaterialExpressionParameter
{
public:
	DWORD                                              DefaultValue : 1;                                 		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              ExtendedCaptionDisplay : 1;                       		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FPointer                                    InstanceOverride;                                 		// 0x00DC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionStaticBoolParameter" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionStaticBoolParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionStaticSwitchParameter
// 0x0068 (0x014C - 0x00E4)
class UMaterialExpressionStaticSwitchParameter : public UMaterialExpressionStaticBoolParameter
{
public:
	struct FExpressionInput                            A;                                                		// 0x00E4 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x0118 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionStaticSwitchParameter" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionStaticSwitchParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionStaticComponentMaskParameter
// 0x0040 (0x0118 - 0x00D8)
class UMaterialExpressionStaticComponentMaskParameter : public UMaterialExpressionParameter
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00D8 (0x0034) [0x0000000000000000]              
	DWORD                                              DefaultR : 1;                                     		// 0x010C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              DefaultG : 1;                                     		// 0x010C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              DefaultB : 1;                                     		// 0x010C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              DefaultA : 1;                                     		// 0x010C (0x0004) [0x0000000000000000] [0x00000008] 
	struct FPointer                                    InstanceOverride;                                 		// 0x0110 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionStaticComponentMaskParameter" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionStaticComponentMaskParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionVectorParameter
// 0x0010 (0x00E8 - 0x00D8)
class UMaterialExpressionVectorParameter : public UMaterialExpressionParameter
{
public:
	struct FLinearColor                                DefaultValue;                                     		// 0x00D8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionVectorParameter" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionVectorParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionParticleMacroUV
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionParticleMacroUV : public UMaterialExpression
{
public:
	DWORD                                              bUseViewSpace : 1;                                		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionParticleMacroUV" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionParticleMacroUV::pClassPointer = NULL;

// Class Engine.MaterialExpressionPerInstanceRandom
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionPerInstanceRandom : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionPerInstanceRandom" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionPerInstanceRandom::pClassPointer = NULL;

// Class Engine.MaterialExpressionPixelDepth
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionPixelDepth : public UMaterialExpression
{
public:
	DWORD                                              bNormalize : 1;                                   		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionPixelDepth" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionPixelDepth::pClassPointer = NULL;

// Class Engine.MaterialExpressionPower
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionPower : public UMaterialExpression
{
public:
	struct FExpressionInput                            Base;                                             		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Exponent;                                         		// 0x00EC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionPower" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionPower::pClassPointer = NULL;

// Class Engine.MaterialExpressionQualitySwitch
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionQualitySwitch : public UMaterialExpression
{
public:
	struct FExpressionInput                            High;                                             		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Low;                                              		// 0x00EC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionQualitySwitch" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionQualitySwitch::pClassPointer = NULL;

// Class Engine.MaterialExpressionReflectionVector
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionReflectionVector : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionReflectionVector" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionReflectionVector::pClassPointer = NULL;

// Class Engine.MaterialExpressionRotateAboutAxis
// 0x009C (0x0154 - 0x00B8)
class UMaterialExpressionRotateAboutAxis : public UMaterialExpression
{
public:
	struct FExpressionInput                            NormalizedRotationAxisAndAngle;                   		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            PositionOnAxis;                                   		// 0x00EC (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Position;                                         		// 0x0120 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionRotateAboutAxis" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionRotateAboutAxis::pClassPointer = NULL;

// Class Engine.MaterialExpressionRotator
// 0x0074 (0x012C - 0x00B8)
class UMaterialExpressionRotator : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinate;                                       		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Time;                                             		// 0x00EC (0x0034) [0x0000000000000000]              
	float                                              CenterX;                                          		// 0x0120 (0x0004) [0x0000000000000000]              
	float                                              CenterY;                                          		// 0x0124 (0x0004) [0x0000000000000000]              
	float                                              Speed;                                            		// 0x0128 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionRotator" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionRotator::pClassPointer = NULL;

// Class Engine.MaterialExpressionSceneDepth
// 0x0038 (0x00F0 - 0x00B8)
class UMaterialExpressionSceneDepth : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinates;                                      		// 0x00B8 (0x0034) [0x0000000000000000]              
	DWORD                                              bNormalize : 1;                                   		// 0x00EC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionSceneDepth" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionSceneDepth::pClassPointer = NULL;

// Class Engine.MaterialExpressionSceneTexture
// 0x003C (0x00F4 - 0x00B8)
class UMaterialExpressionSceneTexture : public UMaterialExpression
{
public:
	struct FExpressionInput                            Coordinates;                                      		// 0x00B8 (0x0034) [0x0000000000000000]              
	unsigned char                                      SceneTextureType;                                 		// 0x00EC (0x0001) [0x0000000000000000]              
	DWORD                                              ScreenAlign : 1;                                  		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionSceneTexture" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionSceneTexture::pClassPointer = NULL;

// Class Engine.MaterialExpressionScreenPosition
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionScreenPosition : public UMaterialExpression
{
public:
	DWORD                                              ScreenAlign : 1;                                  		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionScreenPosition" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionScreenPosition::pClassPointer = NULL;

// Class Engine.MaterialExpressionScreenSize
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionScreenSize : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionScreenSize" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionScreenSize::pClassPointer = NULL;

// Class Engine.MaterialExpressionSine
// 0x0038 (0x00F0 - 0x00B8)
class UMaterialExpressionSine : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              
	float                                              Period;                                           		// 0x00EC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionSine" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionSine::pClassPointer = NULL;

// Class Engine.MaterialExpressionSphereMask
// 0x00D8 (0x0190 - 0x00B8)
class UMaterialExpressionSphereMask : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00EC (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Radius;                                           		// 0x0120 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Hardness;                                         		// 0x0154 (0x0034) [0x0000000000000000]              
	float                                              AttenuationRadius;                                		// 0x0188 (0x0004) [0x0000000000000000]              
	float                                              HardnessPercent;                                  		// 0x018C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionSphereMask" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionSphereMask::pClassPointer = NULL;

// Class Engine.MaterialExpressionSPHFluidNormal
// 0x003C (0x00F4 - 0x00B8)
class UMaterialExpressionSPHFluidNormal : public UMaterialExpression
{
public:
	class UTexture*                                    DefaultTexture;                                   		// 0x00B8 (0x0008) [0x0000000000000000]              
	struct FExpressionInput                            DepthMipmapThreshold;                             		// 0x00C0 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionSPHFluidNormal" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionSPHFluidNormal::pClassPointer = NULL;

// Class Engine.MaterialExpressionSPHFluidThickness
// 0x0008 (0x00C0 - 0x00B8)
class UMaterialExpressionSPHFluidThickness : public UMaterialExpression
{
public:
	class UTexture*                                    DefaultTexture;                                   		// 0x00B8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionSPHFluidThickness" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionSPHFluidThickness::pClassPointer = NULL;

// Class Engine.MaterialExpressionSPHFluidVertexColor
// 0x0008 (0x00C0 - 0x00B8)
class UMaterialExpressionSPHFluidVertexColor : public UMaterialExpression
{
public:
	class UTexture*                                    DefaultTexture;                                   		// 0x00B8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionSPHFluidVertexColor" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionSPHFluidVertexColor::pClassPointer = NULL;

// Class Engine.MaterialExpressionSquareRoot
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionSquareRoot : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionSquareRoot" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionSquareRoot::pClassPointer = NULL;

// Class Engine.MaterialExpressionStaticBool
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionStaticBool : public UMaterialExpression
{
public:
	DWORD                                              Value : 1;                                        		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionStaticBool" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionStaticBool::pClassPointer = NULL;

// Class Engine.MaterialExpressionStaticSwitch
// 0x00A0 (0x0158 - 0x00B8)
class UMaterialExpressionStaticSwitch : public UMaterialExpression
{
public:
	DWORD                                              DefaultValue : 1;                                 		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              ExtendedCaptionDisplay : 1;                       		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FExpressionInput                            A;                                                		// 0x00BC (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00F0 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Value;                                            		// 0x0124 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionStaticSwitch" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionStaticSwitch::pClassPointer = NULL;

// Class Engine.MaterialExpressionSubtract
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionSubtract : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x00B8 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x00EC (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionSubtract" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionSubtract::pClassPointer = NULL;

// Class Engine.MaterialExpressionTerrainLayerCoords
// 0x0014 (0x00CC - 0x00B8)
class UMaterialExpressionTerrainLayerCoords : public UMaterialExpression
{
public:
	unsigned char                                      MappingType;                                      		// 0x00B8 (0x0001) [0x0000000000000000]              
	float                                              MappingScale;                                     		// 0x00BC (0x0004) [0x0000000000000000]              
	float                                              MappingRotation;                                  		// 0x00C0 (0x0004) [0x0000000000000000]              
	float                                              MappingPanU;                                      		// 0x00C4 (0x0004) [0x0000000000000000]              
	float                                              MappingPanV;                                      		// 0x00C8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTerrainLayerCoords" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTerrainLayerCoords::pClassPointer = NULL;

// Class Engine.MaterialExpressionTerrainLayerSwitch
// 0x008C (0x0144 - 0x00B8)
class UMaterialExpressionTerrainLayerSwitch : public UMaterialExpression
{
public:
	struct FPointer                                    InstanceOverride;                                 		// 0x00B8 (0x0008) [0x0000000000000000]              
	struct FExpressionInput                            LayerUsed;                                        		// 0x00C0 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            LayerNotUsed;                                     		// 0x00F4 (0x0034) [0x0000000000000000]              
	struct FName                                       ParameterName;                                    		// 0x0128 (0x0008) [0x0000000000000000]              
	DWORD                                              PreviewUsed : 1;                                  		// 0x0130 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FGuid                                       ExpressionGUID;                                   		// 0x0134 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTerrainLayerSwitch" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTerrainLayerSwitch::pClassPointer = NULL;

// Class Engine.MaterialExpressionTerrainLayerWeight
// 0x008C (0x0144 - 0x00B8)
class UMaterialExpressionTerrainLayerWeight : public UMaterialExpression
{
public:
	struct FPointer                                    InstanceOverride;                                 		// 0x00B8 (0x0008) [0x0000000000000000]              
	struct FExpressionInput                            Base;                                             		// 0x00C0 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            Layer;                                            		// 0x00F4 (0x0034) [0x0000000000000000]              
	struct FName                                       ParameterName;                                    		// 0x0128 (0x0008) [0x0000000000000000]              
	float                                              PreviewWeight;                                    		// 0x0130 (0x0004) [0x0000000000000000]              
	struct FGuid                                       ExpressionGUID;                                   		// 0x0134 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTerrainLayerWeight" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTerrainLayerWeight::pClassPointer = NULL;

// Class Engine.MaterialExpressionTexelSize
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionTexelSize : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTexelSize" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTexelSize::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureCoordinate
// 0x0010 (0x00C8 - 0x00B8)
class UMaterialExpressionTextureCoordinate : public UMaterialExpression
{
public:
	int                                                CoordinateIndex;                                  		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              UTiling;                                          		// 0x00BC (0x0004) [0x0000000000000000]              
	float                                              VTiling;                                          		// 0x00C0 (0x0004) [0x0000000000000000]              
	DWORD                                              UnMirrorU : 1;                                    		// 0x00C4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              UnMirrorV : 1;                                    		// 0x00C4 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureCoordinate" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureCoordinate::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureObject
// 0x0008 (0x00C0 - 0x00B8)
class UMaterialExpressionTextureObject : public UMaterialExpression
{
public:
	class UTexture*                                    Texture;                                          		// 0x00B8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureObject" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureObject::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSample
// 0x0070 (0x0128 - 0x00B8)
class UMaterialExpressionTextureSample : public UMaterialExpression
{
public:
	class UTexture*                                    Texture;                                          		// 0x00B8 (0x0008) [0x0000000000000000]              
	struct FExpressionInput                            Coordinates;                                      		// 0x00C0 (0x0034) [0x0000000000000000]              
	struct FExpressionInput                            TextureObject;                                    		// 0x00F4 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureSample" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureSample::pClassPointer = NULL;

// Class Engine.MaterialExpressionDepthBiasBlend
// 0x003C (0x0164 - 0x0128)
class UMaterialExpressionDepthBiasBlend : public UMaterialExpressionTextureSample
{
public:
	DWORD                                              bNormalize : 1;                                   		// 0x0128 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              BiasScale;                                        		// 0x012C (0x0004) [0x0000000000000000]              
	struct FExpressionInput                            Bias;                                             		// 0x0130 (0x0034) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionDepthBiasBlend" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionDepthBiasBlend::pClassPointer = NULL;

// Class Engine.MaterialExpressionFlipBookSample
// 0x0000 (0x0128 - 0x0128)
class UMaterialExpressionFlipBookSample : public UMaterialExpressionTextureSample
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionFlipBookSample" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionFlipBookSample::pClassPointer = NULL;

// Class Engine.MaterialExpressionMeshSubUV
// 0x0000 (0x0128 - 0x0128)
class UMaterialExpressionMeshSubUV : public UMaterialExpressionTextureSample
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionMeshSubUV" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionMeshSubUV::pClassPointer = NULL;

// Class Engine.MaterialExpressionMeshSubUVBlend
// 0x0000 (0x0128 - 0x0128)
class UMaterialExpressionMeshSubUVBlend : public UMaterialExpressionMeshSubUV
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionMeshSubUVBlend" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionMeshSubUVBlend::pClassPointer = NULL;

// Class Engine.MaterialExpressionParticleSubUV
// 0x0000 (0x0128 - 0x0128)
class UMaterialExpressionParticleSubUV : public UMaterialExpressionTextureSample
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionParticleSubUV" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionParticleSubUV::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameter
// 0x0020 (0x0148 - 0x0128)
class UMaterialExpressionTextureSampleParameter : public UMaterialExpressionTextureSample
{
public:
	struct FName                                       ParameterName;                                    		// 0x0128 (0x0008) [0x0000000000000000]              
	struct FGuid                                       ExpressionGUID;                                   		// 0x0130 (0x0010) [0x0000000000000000]              
	struct FName                                       Group;                                            		// 0x0140 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureSampleParameter" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureSampleParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureObjectParameter
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureObjectParameter : public UMaterialExpressionTextureSampleParameter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureObjectParameter" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureObjectParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameter2D
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameter2D : public UMaterialExpressionTextureSampleParameter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureSampleParameter2D" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureSampleParameter2D::pClassPointer = NULL;

// Class Engine.MaterialExpressionAntialiasedTextureMask
// 0x0005 (0x014D - 0x0148)
class UMaterialExpressionAntialiasedTextureMask : public UMaterialExpressionTextureSampleParameter2D
{
public:
	float                                              Threshold;                                        		// 0x0148 (0x0004) [0x0000000000000000]              
	unsigned char                                      Channel;                                          		// 0x014C (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionAntialiasedTextureMask" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionAntialiasedTextureMask::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameterFlipbook
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameterFlipbook : public UMaterialExpressionTextureSampleParameter2D
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureSampleParameterFlipbook" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureSampleParameterFlipbook::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameterMeshSubUV
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameterMeshSubUV : public UMaterialExpressionTextureSampleParameter2D
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureSampleParameterMeshSubUV" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureSampleParameterMeshSubUV::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameterMeshSubUVBlend
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameterMeshSubUVBlend : public UMaterialExpressionTextureSampleParameterMeshSubUV
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureSampleParameterMeshSubUVBlend" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureSampleParameterMeshSubUVBlend::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameterSubUV
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameterSubUV : public UMaterialExpressionTextureSampleParameter2D
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureSampleParameterSubUV" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureSampleParameterSubUV::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameterCube
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameterCube : public UMaterialExpressionTextureSampleParameter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureSampleParameterCube" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureSampleParameterCube::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameterMovie
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameterMovie : public UMaterialExpressionTextureSampleParameter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureSampleParameterMovie" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureSampleParameterMovie::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameterNormal
// 0x0008 (0x0150 - 0x0148)
class UMaterialExpressionTextureSampleParameterNormal : public UMaterialExpressionTextureSampleParameter
{
public:
	struct FPointer                                    InstanceOverride;                                 		// 0x0148 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTextureSampleParameterNormal" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTextureSampleParameterNormal::pClassPointer = NULL;

// Class Engine.MaterialExpressionTime
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionTime : public UMaterialExpression
{
public:
	DWORD                                              bIgnorePause : 1;                                 		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTime" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTime::pClassPointer = NULL;

// Class Engine.MaterialExpressionTransform
// 0x0036 (0x00EE - 0x00B8)
class UMaterialExpressionTransform : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              
	unsigned char                                      TransformSourceType;                              		// 0x00EC (0x0001) [0x0000000000000000]              
	unsigned char                                      TransformType;                                    		// 0x00ED (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTransform" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTransform::pClassPointer = NULL;

// Class Engine.MaterialExpressionTransformPosition
// 0x0036 (0x00EE - 0x00B8)
class UMaterialExpressionTransformPosition : public UMaterialExpression
{
public:
	struct FExpressionInput                            Input;                                            		// 0x00B8 (0x0034) [0x0000000000000000]              
	unsigned char                                      TransformSourceType;                              		// 0x00EC (0x0001) [0x0000000000000000]              
	unsigned char                                      TransformType;                                    		// 0x00ED (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTransformPosition" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTransformPosition::pClassPointer = NULL;

// Class Engine.MaterialExpressionTwoSidedSign
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionTwoSidedSign : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionTwoSidedSign" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionTwoSidedSign::pClassPointer = NULL;

// Class Engine.MaterialExpressionVertexColor
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionVertexColor : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionVertexColor" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionVertexColor::pClassPointer = NULL;

// Class Engine.MaterialExpressionWindDirectionAndSpeed
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionWindDirectionAndSpeed : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionWindDirectionAndSpeed" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionWindDirectionAndSpeed::pClassPointer = NULL;

// Class Engine.MaterialExpressionWorldNormal
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionWorldNormal : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionWorldNormal" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionWorldNormal::pClassPointer = NULL;

// Class Engine.MaterialExpressionWorldPosition
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionWorldPosition : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialExpressionWorldPosition" );

		return pClassPointer;
	};

};

UClass* UMaterialExpressionWorldPosition::pClassPointer = NULL;

// Class Engine.MaterialFunction
// 0x005C (0x00BC - 0x0060)
class UMaterialFunction : public UObject
{
public:
	struct FGuid                                       StateId;                                          		// 0x0060 (0x0010) [0x0000000000000000]              
	class UMaterialFunction*                           ParentFunction;                                   		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FString                                     Description;                                      		// 0x0078 (0x0010) [0x0000000000000000]              
	DWORD                                              bExposeToLibrary : 1;                             		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bReentrantFlag : 1;                               		// 0x0088 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< struct FString >                           LibraryCategories;                                		// 0x008C (0x0010) [0x0000000000000000]              
	TArray< class UMaterialExpression* >               FunctionExpressions;                              		// 0x009C (0x0010) [0x0000000000000000]              
	TArray< class UMaterialExpressionComment* >        FunctionEditorComments;                           		// 0x00AC (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialFunction" );

		return pClassPointer;
	};

};

UClass* UMaterialFunction::pClassPointer = NULL;

// Class Engine.MaterialInstance
// 0x0098 (0x02FC - 0x0264)
class UMaterialInstance : public UMaterialInterface
{
public:
	class UPhysicalMaterial*                           PhysMaterial;                                     		// 0x0264 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          Parent;                                           		// 0x026C (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  PhysMaterialMask;                                 		// 0x0274 (0x0008) [0x0000000000000000]              
	int                                                PhysMaterialMaskUVChannel;                        		// 0x027C (0x0004) [0x0000000000000000]              
	class UPhysicalMaterial*                           BlackPhysicalMaterial;                            		// 0x0280 (0x0008) [0x0000000000000000]              
	class UPhysicalMaterial*                           WhitePhysicalMaterial;                            		// 0x0288 (0x0008) [0x0000000000000000]              
	DWORD                                              bHasStaticPermutationResource : 1;                		// 0x0290 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bStaticPermutationDirty : 1;                      		// 0x0290 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              ReentrantFlag : 1;                                		// 0x0290 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bNeedsMaterialFlattening : 1;                     		// 0x0290 (0x0004) [0x0000000000000000] [0x00000008] 
	struct FPointer                                    StaticParameters[ 0x2 ];                          		// 0x0294 (0x0010) [0x0000000000000000]              
	struct FPointer                                    StaticPermutationResources[ 0x2 ];                		// 0x02A4 (0x0010) [0x0000000000000000]              
	struct FPointer                                    Resources[ 0x3 ];                                 		// 0x02B4 (0x0018) [0x0000000000000000]              
	TArray< class UTexture* >                          ReferencedTextures;                               		// 0x02CC (0x0010) [0x0000000000000000]              
	TArray< struct FGuid >                             ReferencedTextureGuids;                           		// 0x02DC (0x0010) [0x0000000000000000]              
	struct FGuid                                       ParentLightingGuid;                               		// 0x02EC (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialInstance" );

		return pClassPointer;
	};

	void IsInMapOrTransientPackage ( );
	void ClearParameterValues ( );
	void SetFontParameterValue ( );
	void GetTextureParameterValue ( );
	void SetTextureParameterValue ( );
	void SetScalarCurveParameterValue ( );
	void SetScalarParameterValue ( );
	void SetVectorParameterValue ( );
	void SetParent ( );
};

UClass* UMaterialInstance::pClassPointer = NULL;

// Class Engine.MaterialInstanceConstant
// 0x0040 (0x033C - 0x02FC)
class UMaterialInstanceConstant : public UMaterialInstance
{
public:
	TArray< struct FFontParameterValue >               FontParameterValues;                              		// 0x02FC (0x0010) [0x0000000000000000]              
	TArray< struct FScalarParameterValue >             ScalarParameterValues;                            		// 0x030C (0x0010) [0x0000000000000000]              
	TArray< struct FTextureParameterValue >            TextureParameterValues;                           		// 0x031C (0x0010) [0x0000000000000000]              
	TArray< struct FVectorParameterValue >             VectorParameterValues;                            		// 0x032C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialInstanceConstant" );

		return pClassPointer;
	};

	void ClearParameterValues ( );
	void GetMobileVectorParameterValue ( );
	void GetMobileTextureParameterValue ( );
	void GetMobileScalarParameterValue ( );
	void SetFontParameterValue ( );
	void SetVectorParameterValue ( );
	void SetTextureParameterValue ( );
	void SetScalarParameterValue ( );
	void SetParent ( );
};

UClass* UMaterialInstanceConstant::pClassPointer = NULL;

// Class Engine.LandscapeMaterialInstanceConstant
// 0x000C (0x0348 - 0x033C)
class ULandscapeMaterialInstanceConstant : public UMaterialInstanceConstant
{
public:
	DWORD                                              bIsLayerThumbnail : 1;                            		// 0x033C (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                DataWeightmapIndex;                               		// 0x0340 (0x0004) [0x0000000000000000]              
	int                                                DataWeightmapSize;                                		// 0x0344 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LandscapeMaterialInstanceConstant" );

		return pClassPointer;
	};

};

UClass* ULandscapeMaterialInstanceConstant::pClassPointer = NULL;

// Class Engine.MaterialInstanceTimeVarying
// 0x0058 (0x0354 - 0x02FC)
class UMaterialInstanceTimeVarying : public UMaterialInstance
{
public:
	DWORD                                              bAutoActivateAll : 1;                             		// 0x02FC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              Duration;                                         		// 0x0300 (0x0004) [0x0000000000000000]              
	TArray< struct FFontParameterValueOverTime >       FontParameterValues;                              		// 0x0304 (0x0010) [0x0000000000000000]              
	TArray< struct FScalarParameterValueOverTime >     ScalarParameterValues;                            		// 0x0314 (0x0010) [0x0000000000000000]              
	TArray< struct FTextureParameterValueOverTime >    TextureParameterValues;                           		// 0x0324 (0x0010) [0x0000000000000000]              
	TArray< struct FVectorParameterValueOverTime >     VectorParameterValues;                            		// 0x0334 (0x0010) [0x0000000000000000]              
	TArray< struct FLinearColorParameterValueOverTime > LinearColorParameterValues;                       		// 0x0344 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialInstanceTimeVarying" );

		return pClassPointer;
	};

	void CheckForVectorParameterConflicts ( );
	void GetMaxDurationFromAllParameters ( );
	void ClearParameterValues ( );
	void SetFontParameterValue ( );
	void SetVectorStartTime ( );
	void SetLinearColorCurveParameterValue ( );
	void SetLinearColorParameterValue ( );
	void SetVectorCurveParameterValue ( );
	void SetVectorParameterValue ( );
	void SetTextureParameterValue ( );
	void SetDuration ( );
	void SetScalarStartTime ( );
	void SetScalarCurveParameterValue ( );
	void SetScalarParameterValue ( );
	void SetParent ( );
};

UClass* UMaterialInstanceTimeVarying::pClassPointer = NULL;

// Class Engine.EmitterCameraLensEffectBase
// 0x0034 (0x028C - 0x0258)
class AEmitterCameraLensEffectBase : public AEmitter
{
public:
	class UParticleSystem*                             PS_CameraEffect;                                  		// 0x0258 (0x0008) [0x0000000000000000]              
	class UParticleSystem*                             PS_CameraEffectNonExtremeContent;                 		// 0x0260 (0x0008) [0x0000000000000000]              
	float                                              BaseFOV;                                          		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              DistFromCamera;                                   		// 0x026C (0x0004) [0x0000000000000000]              
	DWORD                                              bAllowMultipleInstances : 1;                      		// 0x0270 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class UClass* >                            EmittersToTreatAsSame;                            		// 0x0274 (0x0010) [0x0000000000000000]              
	class ACamera*                                     BaseCamera;                                       		// 0x0284 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.EmitterCameraLensEffectBase" );

		return pClassPointer;
	};

	void UpdateLocation ( );
	void ActivateLensEffect ( );
	void PostBeginPlay ( );
	void NotifyRetriggered ( );
	void RegisterCamera ( );
	void Destroyed ( );
};

UClass* AEmitterCameraLensEffectBase::pClassPointer = NULL;

// Class Engine.ParticleEventManager
// 0x0000 (0x0244 - 0x0244)
class AParticleEventManager : public AActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleEventManager" );

		return pClassPointer;
	};

	void eventHandleParticleModuleEventSendToGame ( );
};

UClass* AParticleEventManager::pClassPointer = NULL;

// Class Engine.ParticleSystemComponent
// 0x0180 (0x03B8 - 0x0238)
class UParticleSystemComponent : public UPrimitiveComponent
{
public:
	class UParticleSystem*                             Template;                                         		// 0x0238 (0x0008) [0x0000000000000000]              
	TArray< class UParticleSystem* >                   ExtensionTemplates;                               		// 0x0240 (0x0010) [0x0000000000000000]              
	class UClass*                                      LightEnvironmentClass;                            		// 0x0250 (0x0008) [0x0000000000000000]              
	class AActor*                                      LightEnvironmentSharedInstigator;                 		// 0x0258 (0x0008) [0x0000000000000000]              
	int                                                MaxLightEnvironmentPooledReuses;                  		// 0x0260 (0x0004) [0x0000000000000000]              
	int                                                NumActiveParticles;                               		// 0x0264 (0x0004) [0x0000000000000000]              
	TArray< struct FPointer >                          EmitterInstances;                                 		// 0x0268 (0x0010) [0x0000000000000000]              
	TArray< class UStaticMeshComponent* >              SMComponents;                                     		// 0x0278 (0x0010) [0x0000000000000000]              
	TArray< class UMaterialInterface* >                SMMaterialInterfaces;                             		// 0x0288 (0x0010) [0x0000000000000000]              
	TArray< class USkeletalMeshComponent* >            SkelMeshComponents;                               		// 0x0298 (0x0010) [0x0000000000000000]              
	TArray< struct FViewParticleEmitterInstanceMotionBlurInfo > ViewMBInfoArray;                                  		// 0x02A8 (0x0010) [0x0000000000000000]              
	DWORD                                              bAutoActivate : 1;                                		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bWasCompleted : 1;                                		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bSuppressSpawning : 1;                            		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bWasDeactivated : 1;                              		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bResetOnDetach : 1;                               		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bUpdateOnDedicatedServer : 1;                     		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bJustAttached : 1;                                		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bIsActive : 1;                                    		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bHasBeenActivated : 1;                            		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bWarmingUp : 1;                                   		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bIsCachedInPool : 1;                              		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bOverrideLODMethod : 1;                           		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bSkipUpdateDynamicDataDuringTick : 1;             		// 0x02B8 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bSkipBoundsUpdate : 1;                            		// 0x02B8 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bUpdateComponentInTick : 1;                       		// 0x02B8 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bDeferredBeamUpdate : 1;                          		// 0x02B8 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bForcedInActive : 1;                              		// 0x02B8 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bIsWarmingUp : 1;                                 		// 0x02B8 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bIsViewRelevanceDirty : 1;                        		// 0x02B8 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bRecacheViewRelevance : 1;                        		// 0x02B8 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bDepthTestEnabled : 1;                            		// 0x02B8 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bLODUpdatePending : 1;                            		// 0x02B8 (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bSkipSpawnCountCheck : 1;                         		// 0x02B8 (0x0004) [0x0000000000000000] [0x00400000] 
	TArray< struct FParticleSysParam >                 InstanceParameters;                               		// 0x02BC (0x0010) [0x0000000000000000]              
	struct FVector                                     OldPosition;                                      		// 0x02CC (0x000C) [0x0000000000000000]              
	struct FVector                                     PartSysVelocity;                                  		// 0x02D8 (0x000C) [0x0000000000000000]              
	float                                              WarmupTime;                                       		// 0x02E4 (0x0004) [0x0000000000000000]              
	float                                              WarmupTickRate;                                   		// 0x02E8 (0x0004) [0x0000000000000000]              
	int                                                LODLevel;                                         		// 0x02EC (0x0004) [0x0000000000000000]              
	float                                              SecondsBeforeInactive;                            		// 0x02F0 (0x0004) [0x0000000000000000]              
	float                                              TimeSinceLastForceUpdateTransform;                		// 0x02F4 (0x0004) [0x0000000000000000]              
	float                                              MaxTimeBeforeForceUpdateTransform;                		// 0x02F8 (0x0004) [0x0000000000000000]              
	int                                                EditorLODLevel;                                   		// 0x02FC (0x0004) [0x0000000000000000]              
	int                                                EditorDetailMode;                                 		// 0x0300 (0x0004) [0x0000000000000000]              
	float                                              AccumTickTime;                                    		// 0x0304 (0x0004) [0x0000000000000000]              
	unsigned char                                      LODMethod;                                        		// 0x0308 (0x0001) [0x0000000000000000]              
	unsigned char                                      ReplayState;                                      		// 0x0309 (0x0001) [0x0000000000000000]              
	TArray< struct FMaterialViewRelevance >            CachedViewRelevanceFlags;                         		// 0x030C (0x0010) [0x0000000000000000]              
	TArray< class UParticleSystemReplay* >             ReplayClips;                                      		// 0x031C (0x0010) [0x0000000000000000]              
	int                                                ReplayClipIDNumber;                               		// 0x032C (0x0004) [0x0000000000000000]              
	int                                                ReplayFrameIndex;                                 		// 0x0330 (0x0004) [0x0000000000000000]              
	float                                              AccumLODDistanceCheckTime;                        		// 0x0334 (0x0004) [0x0000000000000000]              
	TArray< struct FParticleEventSpawnData >           SpawnEvents;                                      		// 0x0338 (0x0010) [0x0000000000000000]              
	TArray< struct FParticleEventDeathData >           DeathEvents;                                      		// 0x0348 (0x0010) [0x0000000000000000]              
	TArray< struct FParticleEventCollideData >         CollisionEvents;                                  		// 0x0358 (0x0010) [0x0000000000000000]              
	TArray< struct FParticleEventKismetData >          KismetEvents;                                     		// 0x0368 (0x0010) [0x0000000000000000]              
	TArray< struct FParticleEventAttractorCollideData > AttractorCollisionEvents;                         		// 0x0378 (0x0010) [0x0000000000000000]              
	struct FPointer                                    ReleaseResourcesFence;                            		// 0x0388 (0x0008) [0x0000000000000000]              
	float                                              CustomTimeDilation;                               		// 0x0390 (0x0004) [0x0000000000000000]              
	float                                              EmitterDelay;                                     		// 0x0394 (0x0004) [0x0000000000000000]              
	TArray< struct FFlexEmitterPreSimPositions >       FlexEmitterPreSimState;                           		// 0x0398 (0x0010) [0x0000000000000000]              
	struct FScriptDelegate                             __OnSystemFinished__Delegate;                     		// 0x03A8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x03AC (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleSystemComponent" );

		return pClassPointer;
	};

	void SetStopSpawning ( );
	void ResetToDefaults ( );
	void SetActive ( );
	void ClearParameter ( );
	void GetMaterialParameter ( );
	void GetActorParameter ( );
	void GetColorParameter ( );
	void GetVectorParameter ( );
	void GetFloatParameter ( );
	void SetMaterialParameter ( );
	void SetActorParameter ( );
	void SetColorParameter ( );
	void SetVectorRandParameter ( );
	void SetVectorParameter ( );
	void SetFloatRandParameter ( );
	void SetFloatParameter ( );
	void GetEditorLODLevel ( );
	void GetLODLevel ( );
	void SetEditorLODLevel ( );
	void SetLODLevel ( );
	void SystemHasCompleted ( );
	void GetMaxLifespan ( );
	void DetermineLODLevelForLocation ( );
	void SetBeamTargetStrength ( );
	void SetBeamTargetTangent ( );
	void SetBeamTargetPoint ( );
	void SetBeamSourceStrength ( );
	void SetBeamSourceTangent ( );
	void SetBeamSourcePoint ( );
	void SetBeamDistance ( );
	void SetBeamEndPoint ( );
	void SetBeamTessellationFactor ( );
	void SetBeamType ( );
	void RewindEmitterInstances ( );
	void RewindEmitterInstance ( );
	void SetKillOnCompleted ( );
	void SetKillOnDeactivate ( );
	void GetSkipBoundsUpdate ( );
	void SetSkipBoundsUpdate ( );
	void GetSkipUpdateDynamicDataDuringTick ( );
	void SetSkipUpdateDynamicDataDuringTick ( );
	void KillParticlesInEmitter ( );
	void KillParticlesForced ( );
	void DeactivateSystem ( );
	void ActivateSystem ( );
	void SetTemplate ( );
	void OnSystemFinished ( );
};

UClass* UParticleSystemComponent::pClassPointer = NULL;

// Class Engine.DistributionFloatParticleParameter
// 0x0003 (0x009C - 0x0099)
class UDistributionFloatParticleParameter : public UDistributionFloatParameterBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionFloatParticleParameter" );

		return pClassPointer;
	};

};

UClass* UDistributionFloatParticleParameter::pClassPointer = NULL;

// Class Engine.DistributionVectorParticleParameter
// 0x0001 (0x00CC - 0x00CB)
class UDistributionVectorParticleParameter : public UDistributionVectorParameterBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionVectorParticleParameter" );

		return pClassPointer;
	};

};

UClass* UDistributionVectorParticleParameter::pClassPointer = NULL;

// Class Engine.ParticleEmitter
// 0x0048 (0x00A8 - 0x0060)
class UParticleEmitter : public UObject
{
public:
	struct FName                                       EmitterName;                                      		// 0x0060 (0x0008) [0x0000000000000000]              
	int                                                SubUVDataOffset;                                  		// 0x0068 (0x0004) [0x0000000000000000]              
	unsigned char                                      EmitterRenderMode;                                		// 0x006C (0x0001) [0x0000000000000000]              
	struct FColor                                      EmitterEditorColor;                               		// 0x0070 (0x0004) [0x0000000000000000]              
	TArray< class UParticleLODLevel* >                 LODLevels;                                        		// 0x0074 (0x0010) [0x0000000000000000]              
	DWORD                                              ConvertedModules : 1;                             		// 0x0084 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bCollapsed : 1;                                   		// 0x0084 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIsSoloing : 1;                                   		// 0x0084 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bCookedOut : 1;                                   		// 0x0084 (0x0004) [0x0000000000000000] [0x00000008] 
	int                                                PeakActiveParticles;                              		// 0x0088 (0x0004) [0x0000000000000000]              
	int                                                InitialAllocationCount;                           		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              MediumDetailSpawnRateScale;                       		// 0x0090 (0x0004) [0x0000000000000000]              
	class UFlexContainer*                              FlexContainerTemplate;                            		// 0x0094 (0x0008) [0x0000000000000000]              
	float                                              FlexSmoothScreenRadius;                           		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              FlexSmoothDepthRadius;                            		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              FlexCutoffThickness;                              		// 0x00A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleEmitter" );

		return pClassPointer;
	};

	void GetMaxLifespan ( );
};

UClass* UParticleEmitter::pClassPointer = NULL;

// Class Engine.ParticleSpriteEmitter
// 0x0000 (0x00A8 - 0x00A8)
class UParticleSpriteEmitter : public UParticleEmitter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleSpriteEmitter" );

		return pClassPointer;
	};

};

UClass* UParticleSpriteEmitter::pClassPointer = NULL;

// Class Engine.ParticleLODLevel
// 0x008C (0x00EC - 0x0060)
class UParticleLODLevel : public UObject
{
public:
	int                                                Level;                                            		// 0x0060 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x0064 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              ConvertedModules : 1;                             		// 0x0064 (0x0004) [0x0000000000000000] [0x00000002] 
	class UParticleModuleRequired*                     RequiredModule;                                   		// 0x0068 (0x0008) [0x0000000000000000]              
	TArray< class UParticleModule* >                   Modules;                                          		// 0x0070 (0x0010) [0x0000000000000000]              
	class UParticleModule*                             TypeDataModule;                                   		// 0x0080 (0x0008) [0x0000000000000000]              
	class UParticleModuleSpawn*                        SpawnModule;                                      		// 0x0088 (0x0008) [0x0000000000000000]              
	class UParticleModuleEventGenerator*               EventGenerator;                                   		// 0x0090 (0x0008) [0x0000000000000000]              
	TArray< class UParticleModuleSpawnBase* >          SpawningModules;                                  		// 0x0098 (0x0010) [0x0000000000000000]              
	TArray< class UParticleModule* >                   SpawnModules;                                     		// 0x00A8 (0x0010) [0x0000000000000000]              
	TArray< class UParticleModule* >                   UpdateModules;                                    		// 0x00B8 (0x0010) [0x0000000000000000]              
	TArray< class UParticleModuleOrbit* >              OrbitModules;                                     		// 0x00C8 (0x0010) [0x0000000000000000]              
	TArray< class UParticleModuleEventReceiverBase* >  EventReceiverModules;                             		// 0x00D8 (0x0010) [0x0000000000000000]              
	int                                                PeakActiveParticles;                              		// 0x00E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleLODLevel" );

		return pClassPointer;
	};

};

UClass* UParticleLODLevel::pClassPointer = NULL;

// Class Engine.ParticleModule
// 0x000C (0x006C - 0x0060)
class UParticleModule : public UObject
{
public:
	DWORD                                              bSpawnModule : 1;                                 		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUpdateModule : 1;                                		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bFinalUpdateModule : 1;                           		// 0x0060 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bCurvesAsColor : 1;                               		// 0x0060 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              b3DDrawMode : 1;                                  		// 0x0060 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bSupported3DDrawMode : 1;                         		// 0x0060 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bEnabled : 1;                                     		// 0x0060 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bEditable : 1;                                    		// 0x0060 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              LODDuplicate : 1;                                 		// 0x0060 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bSupportsRandomSeed : 1;                          		// 0x0060 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bRequiresLoopingNotification : 1;                 		// 0x0060 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned char                                      LODValidity;                                      		// 0x0064 (0x0001) [0x0000000000000000]              
	struct FColor                                      ModuleEditorColor;                                		// 0x0068 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModule" );

		return pClassPointer;
	};

};

UClass* UParticleModule::pClassPointer = NULL;

// Class Engine.ParticleModuleAccelerationBase
// 0x0004 (0x0070 - 0x006C)
class UParticleModuleAccelerationBase : public UParticleModule
{
public:
	DWORD                                              bAlwaysInWorldSpace : 1;                          		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleAccelerationBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleAccelerationBase::pClassPointer = NULL;

// Class Engine.ParticleModuleAcceleration
// 0x0028 (0x0098 - 0x0070)
class UParticleModuleAcceleration : public UParticleModuleAccelerationBase
{
public:
	struct FRawDistributionVector                      Acceleration;                                     		// 0x0070 (0x0024) [0x0000000000000000]              
	DWORD                                              bApplyOwnerScale : 1;                             		// 0x0094 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleAcceleration" );

		return pClassPointer;
	};

};

UClass* UParticleModuleAcceleration::pClassPointer = NULL;

// Class Engine.ParticleModuleAccelerationOverLifetime
// 0x0024 (0x0094 - 0x0070)
class UParticleModuleAccelerationOverLifetime : public UParticleModuleAccelerationBase
{
public:
	struct FRawDistributionVector                      AccelOverLife;                                    		// 0x0070 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleAccelerationOverLifetime" );

		return pClassPointer;
	};

};

UClass* UParticleModuleAccelerationOverLifetime::pClassPointer = NULL;

// Class Engine.ParticleModuleAttractorBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleAttractorBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleAttractorBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleAttractorBase::pClassPointer = NULL;

// Class Engine.ParticleModuleAttractorBoneSocket
// 0x010C (0x0178 - 0x006C)
class UParticleModuleAttractorBoneSocket : public UParticleModuleAttractorBase
{
public:
	unsigned char                                      FalloffType;                                      		// 0x006C (0x0001) [0x0000000000000000]              
	unsigned char                                      DestinationType;                                  		// 0x006D (0x0001) [0x0000000000000000]              
	unsigned char                                      SelectionMethod;                                  		// 0x006E (0x0001) [0x0000000000000000]              
	DWORD                                              bParticleLifeRelative : 1;                        		// 0x0070 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAttractAlongLengthOfBone : 1;                    		// 0x0070 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FRawDistributionFloat                       FalloffExponent;                                  		// 0x0074 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Range;                                            		// 0x0098 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Strength;                                         		// 0x00BC (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       CollisionRadius;                                  		// 0x00E0 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       DragCoefficient;                                  		// 0x0104 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       DragRadius;                                       		// 0x0128 (0x0024) [0x0000000000000000]              
	struct FVector                                     UniversalOffset;                                  		// 0x014C (0x000C) [0x0000000000000000]              
	TArray< struct FAttractLocationBoneSocketInfo >    SourceLocations;                                  		// 0x0158 (0x0010) [0x0000000000000000]              
	struct FName                                       SkelMeshActorParamName;                           		// 0x0168 (0x0008) [0x0000000000000000]              
	class USkeletalMesh*                               EditorSkelMesh;                                   		// 0x0170 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleAttractorBoneSocket" );

		return pClassPointer;
	};

};

UClass* UParticleModuleAttractorBoneSocket::pClassPointer = NULL;

// Class Engine.ParticleModuleAttractorLine
// 0x0060 (0x00CC - 0x006C)
class UParticleModuleAttractorLine : public UParticleModuleAttractorBase
{
public:
	struct FVector                                     EndPoint0;                                        		// 0x006C (0x000C) [0x0000000000000000]              
	struct FVector                                     EndPoint1;                                        		// 0x0078 (0x000C) [0x0000000000000000]              
	struct FRawDistributionFloat                       Range;                                            		// 0x0084 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Strength;                                         		// 0x00A8 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleAttractorLine" );

		return pClassPointer;
	};

};

UClass* UParticleModuleAttractorLine::pClassPointer = NULL;

// Class Engine.ParticleModuleAttractorParticle
// 0x005C (0x00C8 - 0x006C)
class UParticleModuleAttractorParticle : public UParticleModuleAttractorBase
{
public:
	struct FName                                       EmitterName;                                      		// 0x006C (0x0008) [0x0000000000000000]              
	struct FRawDistributionFloat                       Range;                                            		// 0x0074 (0x0024) [0x0000000000000000]              
	DWORD                                              bStrengthByDistance : 1;                          		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAffectBaseVelocity : 1;                          		// 0x0098 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bRenewSource : 1;                                 		// 0x0098 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bInheritSourceVel : 1;                            		// 0x0098 (0x0004) [0x0000000000000000] [0x00000008] 
	struct FRawDistributionFloat                       Strength;                                         		// 0x009C (0x0024) [0x0000000000000000]              
	unsigned char                                      SelectionMethod;                                  		// 0x00C0 (0x0001) [0x0000000000000000]              
	int                                                LastSelIndex;                                     		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleAttractorParticle" );

		return pClassPointer;
	};

};

UClass* UParticleModuleAttractorParticle::pClassPointer = NULL;

// Class Engine.ParticleModuleAttractorPoint
// 0x0070 (0x00DC - 0x006C)
class UParticleModuleAttractorPoint : public UParticleModuleAttractorBase
{
public:
	struct FRawDistributionVector                      Position;                                         		// 0x006C (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Range;                                            		// 0x0090 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Strength;                                         		// 0x00B4 (0x0024) [0x0000000000000000]              
	DWORD                                              StrengthByDistance : 1;                           		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAffectBaseVelocity : 1;                          		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bOverrideVelocity : 1;                            		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUseWorldSpacePosition : 1;                       		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000008] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleAttractorPoint" );

		return pClassPointer;
	};

};

UClass* UParticleModuleAttractorPoint::pClassPointer = NULL;

// Class Engine.ParticleModuleAttractorSkelVertSurface
// 0x0130 (0x019C - 0x006C)
class UParticleModuleAttractorSkelVertSurface : public UParticleModuleAttractorBase
{
public:
	unsigned char                                      FalloffType;                                      		// 0x006C (0x0001) [0x0000000000000000]              
	unsigned char                                      DestinationType;                                  		// 0x006D (0x0001) [0x0000000000000000]              
	DWORD                                              bParticleLifeRelative : 1;                        		// 0x0070 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnforceNormalCheck : 1;                          		// 0x0070 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FRawDistributionFloat                       FalloffExponent;                                  		// 0x0074 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Range;                                            		// 0x0098 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Strength;                                         		// 0x00BC (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       CollisionRadius;                                  		// 0x00E0 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       DragCoefficient;                                  		// 0x0104 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       DragRadius;                                       		// 0x0128 (0x0024) [0x0000000000000000]              
	struct FVector                                     UniversalOffset;                                  		// 0x014C (0x000C) [0x0000000000000000]              
	struct FName                                       SkelMeshActorParamName;                           		// 0x0158 (0x0008) [0x0000000000000000]              
	class USkeletalMesh*                               EditorSkelMesh;                                   		// 0x0160 (0x0008) [0x0000000000000000]              
	TArray< struct FName >                             ValidAssociatedBones;                             		// 0x0168 (0x0010) [0x0000000000000000]              
	struct FVector                                     NormalToCompare;                                  		// 0x0178 (0x000C) [0x0000000000000000]              
	float                                              NormalCheckToleranceDegrees;                      		// 0x0184 (0x0004) [0x0000000000000000]              
	float                                              NormalCheckTolerance;                             		// 0x0188 (0x0004) [0x0000000000000000]              
	TArray< int >                                      ValidMaterialIndices;                             		// 0x018C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleAttractorSkelVertSurface" );

		return pClassPointer;
	};

};

UClass* UParticleModuleAttractorSkelVertSurface::pClassPointer = NULL;

// Class Engine.ParticleModuleBeamBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleBeamBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleBeamBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleBeamBase::pClassPointer = NULL;

// Class Engine.ParticleModuleBeamModifier
// 0x0080 (0x00EC - 0x006C)
class UParticleModuleBeamModifier : public UParticleModuleBeamBase
{
public:
	unsigned char                                      ModifierType;                                     		// 0x006C (0x0001) [0x0000000000000000]              
	struct FBeamModifierOptions                        PositionOptions;                                  		// 0x0070 (0x0004) [0x0000000000000000]              
	struct FRawDistributionVector                      Position;                                         		// 0x0074 (0x0024) [0x0000000000000000]              
	struct FBeamModifierOptions                        TangentOptions;                                   		// 0x0098 (0x0004) [0x0000000000000000]              
	struct FRawDistributionVector                      Tangent;                                          		// 0x009C (0x0024) [0x0000000000000000]              
	DWORD                                              bAbsoluteTangent : 1;                             		// 0x00C0 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FBeamModifierOptions                        StrengthOptions;                                  		// 0x00C4 (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       Strength;                                         		// 0x00C8 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleBeamModifier" );

		return pClassPointer;
	};

};

UClass* UParticleModuleBeamModifier::pClassPointer = NULL;

// Class Engine.ParticleModuleBeamNoise
// 0x00D4 (0x0140 - 0x006C)
class UParticleModuleBeamNoise : public UParticleModuleBeamBase
{
public:
	DWORD                                              bLowFreq_Enabled : 1;                             		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bNRScaleEmitterTime : 1;                          		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bSmooth : 1;                                      		// 0x006C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bNoiseLock : 1;                                   		// 0x006C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bOscillate : 1;                                   		// 0x006C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bUseNoiseTangents : 1;                            		// 0x006C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bTargetNoise : 1;                                 		// 0x006C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bApplyNoiseScale : 1;                             		// 0x006C (0x0004) [0x0000000000000000] [0x00000080] 
	int                                                Frequency;                                        		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                Frequency_LowRange;                               		// 0x0074 (0x0004) [0x0000000000000000]              
	struct FRawDistributionVector                      NoiseRange;                                       		// 0x0078 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       NoiseRangeScale;                                  		// 0x009C (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      NoiseSpeed;                                       		// 0x00C0 (0x0024) [0x0000000000000000]              
	float                                              NoiseLockRadius;                                  		// 0x00E4 (0x0004) [0x0000000000000000]              
	float                                              NoiseLockTime;                                    		// 0x00E8 (0x0004) [0x0000000000000000]              
	float                                              NoiseTension;                                     		// 0x00EC (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       NoiseTangentStrength;                             		// 0x00F0 (0x0024) [0x0000000000000000]              
	int                                                NoiseTessellation;                                		// 0x0114 (0x0004) [0x0000000000000000]              
	float                                              FrequencyDistance;                                		// 0x0118 (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       NoiseScale;                                       		// 0x011C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleBeamNoise" );

		return pClassPointer;
	};

};

UClass* UParticleModuleBeamNoise::pClassPointer = NULL;

// Class Engine.ParticleModuleBeamSource
// 0x0084 (0x00F0 - 0x006C)
class UParticleModuleBeamSource : public UParticleModuleBeamBase
{
public:
	unsigned char                                      SourceMethod;                                     		// 0x006C (0x0001) [0x0000000000000000]              
	unsigned char                                      SourceTangentMethod;                              		// 0x006D (0x0001) [0x0000000000000000]              
	struct FName                                       SourceName;                                       		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FName                                       SourceSocketName;                                 		// 0x0078 (0x0008) [0x0000000000000000]              
	DWORD                                              bSourceAbsolute : 1;                              		// 0x0080 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLockSource : 1;                                  		// 0x0080 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bLockSourceTangent : 1;                           		// 0x0080 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bLockSourceStength : 1;                           		// 0x0080 (0x0004) [0x0000000000000000] [0x00000008] 
	struct FRawDistributionVector                      Source;                                           		// 0x0084 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      SourceTangent;                                    		// 0x00A8 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       SourceStrength;                                   		// 0x00CC (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleBeamSource" );

		return pClassPointer;
	};

};

UClass* UParticleModuleBeamSource::pClassPointer = NULL;

// Class Engine.ParticleModuleBeamTarget
// 0x0088 (0x00F4 - 0x006C)
class UParticleModuleBeamTarget : public UParticleModuleBeamBase
{
public:
	unsigned char                                      TargetMethod;                                     		// 0x006C (0x0001) [0x0000000000000000]              
	unsigned char                                      TargetTangentMethod;                              		// 0x006D (0x0001) [0x0000000000000000]              
	struct FName                                       TargetName;                                       		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FName                                       TargetSocketName;                                 		// 0x0078 (0x0008) [0x0000000000000000]              
	struct FRawDistributionVector                      Target;                                           		// 0x0080 (0x0024) [0x0000000000000000]              
	DWORD                                              bTargetAbsolute : 1;                              		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLockTarget : 1;                                  		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bLockTargetTangent : 1;                           		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bLockTargetStength : 1;                           		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000008] 
	struct FRawDistributionVector                      TargetTangent;                                    		// 0x00A8 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       TargetStrength;                                   		// 0x00CC (0x0024) [0x0000000000000000]              
	float                                              LockRadius;                                       		// 0x00F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleBeamTarget" );

		return pClassPointer;
	};

};

UClass* UParticleModuleBeamTarget::pClassPointer = NULL;

// Class Engine.ParticleModuleCameraBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleCameraBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleCameraBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleCameraBase::pClassPointer = NULL;

// Class Engine.ParticleModuleCameraOffset
// 0x0029 (0x0095 - 0x006C)
class UParticleModuleCameraOffset : public UParticleModuleCameraBase
{
public:
	struct FRawDistributionFloat                       CameraOffset;                                     		// 0x006C (0x0024) [0x0000000000000000]              
	DWORD                                              bSpawnTimeOnly : 1;                               		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      UpdateMethod;                                     		// 0x0094 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleCameraOffset" );

		return pClassPointer;
	};

};

UClass* UParticleModuleCameraOffset::pClassPointer = NULL;

// Class Engine.ParticleModuleCollisionBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleCollisionBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleCollisionBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleCollisionBase::pClassPointer = NULL;

// Class Engine.ParticleModuleCollision
// 0x00D8 (0x0144 - 0x006C)
class UParticleModuleCollision : public UParticleModuleCollisionBase
{
public:
	struct FRawDistributionVector                      DampingFactor;                                    		// 0x006C (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      DampingFactorRotation;                            		// 0x0090 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       MaxCollisions;                                    		// 0x00B4 (0x0024) [0x0000000000000000]              
	unsigned char                                      CollisionCompletionOption;                        		// 0x00D8 (0x0001) [0x0000000000000000]              
	DWORD                                              bApplyPhysics : 1;                                		// 0x00DC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPawnsDoNotDecrementCount : 1;                    		// 0x00DC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bOnlyVerticalNormalsDecrementCount : 1;           		// 0x00DC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bDropDetail : 1;                                  		// 0x00DC (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bCollideOnlyIfVisible : 1;                        		// 0x00DC (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bCollideWithWorld : 1;                            		// 0x00DC (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bCollideWithWorldAttractors : 1;                  		// 0x00DC (0x0004) [0x0000000000000000] [0x00000040] 
	struct FRawDistributionFloat                       ParticleMass;                                     		// 0x00E0 (0x0024) [0x0000000000000000]              
	float                                              DirScalar;                                        		// 0x0104 (0x0004) [0x0000000000000000]              
	float                                              VerticalFudgeFactor;                              		// 0x0108 (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       DelayAmount;                                      		// 0x010C (0x0024) [0x0000000000000000]              
	float                                              MaxCollisionDistance;                             		// 0x0130 (0x0004) [0x0000000000000000]              
	TArray< struct FParticleAttractorCollisionAction > ParticleAttractorCollisionActions;                		// 0x0134 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleCollision" );

		return pClassPointer;
	};

};

UClass* UParticleModuleCollision::pClassPointer = NULL;

// Class Engine.ParticleModuleCollisionActor
// 0x0014 (0x0158 - 0x0144)
class UParticleModuleCollisionActor : public UParticleModuleCollision
{
public:
	TArray< struct FName >                             ActorsToCollideWith;                              		// 0x0144 (0x0010) [0x0000000000000000]              
	DWORD                                              bCheckPawnCollisions : 1;                         		// 0x0154 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleCollisionActor" );

		return pClassPointer;
	};

};

UClass* UParticleModuleCollisionActor::pClassPointer = NULL;

// Class Engine.ParticleModuleColorBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleColorBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleColorBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleColorBase::pClassPointer = NULL;

// Class Engine.ParticleModuleColor
// 0x004C (0x00B8 - 0x006C)
class UParticleModuleColor : public UParticleModuleColorBase
{
public:
	struct FRawDistributionVector                      StartColor;                                       		// 0x006C (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       StartAlpha;                                       		// 0x0090 (0x0024) [0x0000000000000000]              
	DWORD                                              bClampAlpha : 1;                                  		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleColor" );

		return pClassPointer;
	};

};

UClass* UParticleModuleColor::pClassPointer = NULL;

// Class Engine.ParticleModuleColor_Seeded
// 0x001C (0x00D4 - 0x00B8)
class UParticleModuleColor_Seeded : public UParticleModuleColor
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x00B8 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleColor_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleColor_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleColorByParameter
// 0x000C (0x0078 - 0x006C)
class UParticleModuleColorByParameter : public UParticleModuleColorBase
{
public:
	struct FName                                       ColorParam;                                       		// 0x006C (0x0008) [0x0000000000000000]              
	struct FColor                                      DefaultColor;                                     		// 0x0074 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleColorByParameter" );

		return pClassPointer;
	};

};

UClass* UParticleModuleColorByParameter::pClassPointer = NULL;

// Class Engine.ParticleModuleColorOverDensity
// 0x0048 (0x00B4 - 0x006C)
class UParticleModuleColorOverDensity : public UParticleModuleColorBase
{
public:
	struct FRawDistributionVector                      ColorOverDensity;                                 		// 0x006C (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       AlphaOverDensity;                                 		// 0x0090 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleColorOverDensity" );

		return pClassPointer;
	};

};

UClass* UParticleModuleColorOverDensity::pClassPointer = NULL;

// Class Engine.ParticleModuleColorOverLife
// 0x004C (0x00B8 - 0x006C)
class UParticleModuleColorOverLife : public UParticleModuleColorBase
{
public:
	struct FRawDistributionVector                      ColorOverLife;                                    		// 0x006C (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       AlphaOverLife;                                    		// 0x0090 (0x0024) [0x0000000000000000]              
	DWORD                                              bClampAlpha : 1;                                  		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleColorOverLife" );

		return pClassPointer;
	};

};

UClass* UParticleModuleColorOverLife::pClassPointer = NULL;

// Class Engine.ParticleModuleColorScaleOverDensity
// 0x0048 (0x00B4 - 0x006C)
class UParticleModuleColorScaleOverDensity : public UParticleModuleColorBase
{
public:
	struct FRawDistributionVector                      ColorScaleOverDensity;                            		// 0x006C (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       AlphaScaleOverDensity;                            		// 0x0090 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleColorScaleOverDensity" );

		return pClassPointer;
	};

};

UClass* UParticleModuleColorScaleOverDensity::pClassPointer = NULL;

// Class Engine.ParticleModuleColorScaleOverLife
// 0x004C (0x00B8 - 0x006C)
class UParticleModuleColorScaleOverLife : public UParticleModuleColorBase
{
public:
	struct FRawDistributionVector                      ColorScaleOverLife;                               		// 0x006C (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       AlphaScaleOverLife;                               		// 0x0090 (0x0024) [0x0000000000000000]              
	DWORD                                              bEmitterTime : 1;                                 		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleColorScaleOverLife" );

		return pClassPointer;
	};

};

UClass* UParticleModuleColorScaleOverLife::pClassPointer = NULL;

// Class Engine.ParticleModuleEventBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleEventBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleEventBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleEventBase::pClassPointer = NULL;

// Class Engine.ParticleModuleEventGenerator
// 0x0010 (0x007C - 0x006C)
class UParticleModuleEventGenerator : public UParticleModuleEventBase
{
public:
	TArray< struct FParticleEvent_GenerateInfo >       Events;                                           		// 0x006C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleEventGenerator" );

		return pClassPointer;
	};

};

UClass* UParticleModuleEventGenerator::pClassPointer = NULL;

// Class Engine.ParticleModuleEventReceiverBase
// 0x000C (0x0078 - 0x006C)
class UParticleModuleEventReceiverBase : public UParticleModuleEventBase
{
public:
	unsigned char                                      EventGeneratorType;                               		// 0x006C (0x0001) [0x0000000000000000]              
	struct FName                                       EventName;                                        		// 0x0070 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleEventReceiverBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleEventReceiverBase::pClassPointer = NULL;

// Class Engine.ParticleModuleEventReceiverKillParticles
// 0x0004 (0x007C - 0x0078)
class UParticleModuleEventReceiverKillParticles : public UParticleModuleEventReceiverBase
{
public:
	DWORD                                              bStopSpawning : 1;                                		// 0x0078 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleEventReceiverKillParticles" );

		return pClassPointer;
	};

};

UClass* UParticleModuleEventReceiverKillParticles::pClassPointer = NULL;

// Class Engine.ParticleModuleEventReceiverSpawn
// 0x004C (0x00C4 - 0x0078)
class UParticleModuleEventReceiverSpawn : public UParticleModuleEventReceiverBase
{
public:
	struct FRawDistributionFloat                       SpawnCount;                                       		// 0x0078 (0x0024) [0x0000000000000000]              
	DWORD                                              bUseParticleTime : 1;                             		// 0x009C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUsePSysLocation : 1;                             		// 0x009C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bInheritVelocity : 1;                             		// 0x009C (0x0004) [0x0000000000000000] [0x00000004] 
	struct FRawDistributionVector                      InheritVelocityScale;                             		// 0x00A0 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleEventReceiverSpawn" );

		return pClassPointer;
	};

};

UClass* UParticleModuleEventReceiverSpawn::pClassPointer = NULL;

// Class Engine.TWParticleModuleEventReceiverBlood
// 0x0000 (0x0078 - 0x0078)
class UTWParticleModuleEventReceiverBlood : public UParticleModuleEventReceiverBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWParticleModuleEventReceiverBlood" );

		return pClassPointer;
	};

};

UClass* UTWParticleModuleEventReceiverBlood::pClassPointer = NULL;

// Class Engine.TWParticleModuleEventReceiverSFX
// 0x0008 (0x0080 - 0x0078)
class UTWParticleModuleEventReceiverSFX : public UParticleModuleEventReceiverBase
{
public:
	class UAkEvent*                                    SFXEvent;                                         		// 0x0078 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWParticleModuleEventReceiverSFX" );

		return pClassPointer;
	};

};

UClass* UTWParticleModuleEventReceiverSFX::pClassPointer = NULL;

// Class Engine.ParticleModuleForceFieldBase
// 0x0008 (0x0074 - 0x006C)
class UParticleModuleForceFieldBase : public UParticleModule
{
public:
	class UNxForceFieldComponent*                      ForceField;                                       		// 0x006C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleForceFieldBase" );

		return pClassPointer;
	};

	void eventGetForceFieldInstance ( );
};

UClass* UParticleModuleForceFieldBase::pClassPointer = NULL;

// Class Engine.ParticleModuleFlexForceField
// 0x0008 (0x007C - 0x0074)
class UParticleModuleFlexForceField : public UParticleModuleForceFieldBase
{
public:
	class UFlexForceFieldComponent*                    FlexForceField;                                   		// 0x0074 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleFlexForceField" );

		return pClassPointer;
	};

	void eventGetFlexForceFieldInstance ( );
};

UClass* UParticleModuleFlexForceField::pClassPointer = NULL;

// Class Engine.ParticleModuleKillBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleKillBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleKillBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleKillBase::pClassPointer = NULL;

// Class Engine.ParticleModuleKillBox
// 0x004C (0x00B8 - 0x006C)
class UParticleModuleKillBox : public UParticleModuleKillBase
{
public:
	struct FRawDistributionVector                      LowerLeftCorner;                                  		// 0x006C (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      UpperRightCorner;                                 		// 0x0090 (0x0024) [0x0000000000000000]              
	DWORD                                              bAbsolute : 1;                                    		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bKillInside : 1;                                  		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAxisAlignedAndFixedSize : 1;                     		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleKillBox" );

		return pClassPointer;
	};

};

UClass* UParticleModuleKillBox::pClassPointer = NULL;

// Class Engine.ParticleModuleKillHeight
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleKillHeight : public UParticleModuleKillBase
{
public:
	struct FRawDistributionFloat                       Height;                                           		// 0x006C (0x0024) [0x0000000000000000]              
	DWORD                                              bAbsolute : 1;                                    		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFloor : 1;                                       		// 0x0090 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bApplyPSysScale : 1;                              		// 0x0090 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleKillHeight" );

		return pClassPointer;
	};

};

UClass* UParticleModuleKillHeight::pClassPointer = NULL;

// Class Engine.ParticleModuleLifetimeBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleLifetimeBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLifetimeBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLifetimeBase::pClassPointer = NULL;

// Class Engine.ParticleModuleLifetime
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleLifetime : public UParticleModuleLifetimeBase
{
public:
	struct FRawDistributionFloat                       Lifetime;                                         		// 0x006C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLifetime" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLifetime::pClassPointer = NULL;

// Class Engine.ParticleModuleLifetime_Seeded
// 0x001C (0x00AC - 0x0090)
class UParticleModuleLifetime_Seeded : public UParticleModuleLifetime
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x0090 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLifetime_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLifetime_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleLocationBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationBase::pClassPointer = NULL;

// Class Engine.ParticleModuleLocation
// 0x002C (0x0098 - 0x006C)
class UParticleModuleLocation : public UParticleModuleLocationBase
{
public:
	struct FRawDistributionVector                      StartLocation;                                    		// 0x006C (0x0024) [0x0000000000000000]              
	float                                              DistributeOverNPoints;                            		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              DistributeThreshold;                              		// 0x0094 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocation" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocation::pClassPointer = NULL;

// Class Engine.ParticleModuleLocation_Seeded
// 0x001C (0x00B4 - 0x0098)
class UParticleModuleLocation_Seeded : public UParticleModuleLocation
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x0098 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocation_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocation_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationWorldOffset
// 0x0000 (0x0098 - 0x0098)
class UParticleModuleLocationWorldOffset : public UParticleModuleLocation
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationWorldOffset" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationWorldOffset::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationWorldOffset_Seeded
// 0x001C (0x00B4 - 0x0098)
class UParticleModuleLocationWorldOffset_Seeded : public UParticleModuleLocationWorldOffset
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x0098 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationWorldOffset_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationWorldOffset_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationBoneSocket
// 0x0038 (0x00A4 - 0x006C)
class UParticleModuleLocationBoneSocket : public UParticleModuleLocationBase
{
public:
	unsigned char                                      SourceType;                                       		// 0x006C (0x0001) [0x0000000000000000]              
	unsigned char                                      SelectionMethod;                                  		// 0x006D (0x0001) [0x0000000000000000]              
	struct FVector                                     UniversalOffset;                                  		// 0x0070 (0x000C) [0x0000000000000000]              
	TArray< struct FLocationBoneSocketInfo >           SourceLocations;                                  		// 0x007C (0x0010) [0x0000000000000000]              
	DWORD                                              bUpdatePositionEachFrame : 1;                     		// 0x008C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bOrientMeshEmitters : 1;                          		// 0x008C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bInheritVelocityAtSpawn : 1;                      		// 0x008C (0x0004) [0x0000000000000000] [0x00000004] 
	struct FName                                       SkelMeshActorParamName;                           		// 0x0090 (0x0008) [0x0000000000000000]              
	class USkeletalMesh*                               EditorSkelMesh;                                   		// 0x0098 (0x0008) [0x0000000000000000]              
	float                                              LastUpdateTime;                                   		// 0x00A0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationBoneSocket" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationBoneSocket::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationDirect
// 0x0090 (0x00FC - 0x006C)
class UParticleModuleLocationDirect : public UParticleModuleLocationBase
{
public:
	struct FRawDistributionVector                      Location;                                         		// 0x006C (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      LocationOffset;                                   		// 0x0090 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      ScaleFactor;                                      		// 0x00B4 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      Direction;                                        		// 0x00D8 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationDirect" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationDirect::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationEmitter
// 0x0018 (0x0084 - 0x006C)
class UParticleModuleLocationEmitter : public UParticleModuleLocationBase
{
public:
	struct FName                                       EmitterName;                                      		// 0x006C (0x0008) [0x0000000000000000]              
	unsigned char                                      SelectionMethod;                                  		// 0x0074 (0x0001) [0x0000000000000000]              
	DWORD                                              InheritSourceVelocity : 1;                        		// 0x0078 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bInheritSourceRotation : 1;                       		// 0x0078 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              InheritSourceVelocityScale;                       		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              InheritSourceRotationScale;                       		// 0x0080 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationEmitter" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationEmitter::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationEmitterDirect
// 0x0008 (0x0074 - 0x006C)
class UParticleModuleLocationEmitterDirect : public UParticleModuleLocationBase
{
public:
	struct FName                                       EmitterName;                                      		// 0x006C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationEmitterDirect" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationEmitterDirect::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationPrimitiveBase
// 0x004C (0x00B8 - 0x006C)
class UParticleModuleLocationPrimitiveBase : public UParticleModuleLocationBase
{
public:
	DWORD                                              Positive_X : 1;                                   		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              Positive_Y : 1;                                   		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              Positive_Z : 1;                                   		// 0x006C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              Negative_X : 1;                                   		// 0x006C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              Negative_Y : 1;                                   		// 0x006C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              Negative_Z : 1;                                   		// 0x006C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              SurfaceOnly : 1;                                  		// 0x006C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              Velocity : 1;                                     		// 0x006C (0x0004) [0x0000000000000000] [0x00000080] 
	struct FRawDistributionFloat                       VelocityScale;                                    		// 0x0070 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartLocation;                                    		// 0x0094 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationPrimitiveBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationPrimitiveBase::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationPrimitiveCylinder
// 0x004D (0x0105 - 0x00B8)
class UParticleModuleLocationPrimitiveCylinder : public UParticleModuleLocationPrimitiveBase
{
public:
	DWORD                                              RadialVelocity : 1;                               		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAdjustForWorldSpace : 1;                         		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FRawDistributionFloat                       StartRadius;                                      		// 0x00BC (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       StartHeight;                                      		// 0x00E0 (0x0024) [0x0000000000000000]              
	unsigned char                                      HeightAxis;                                       		// 0x0104 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationPrimitiveCylinder" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationPrimitiveCylinder::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationPrimitiveCylinder_Seeded
// 0x001F (0x0124 - 0x0105)
class UParticleModuleLocationPrimitiveCylinder_Seeded : public UParticleModuleLocationPrimitiveCylinder
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x0108 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationPrimitiveCylinder_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationPrimitiveCylinder_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationPrimitiveSphere
// 0x0024 (0x00DC - 0x00B8)
class UParticleModuleLocationPrimitiveSphere : public UParticleModuleLocationPrimitiveBase
{
public:
	struct FRawDistributionFloat                       StartRadius;                                      		// 0x00B8 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationPrimitiveSphere" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationPrimitiveSphere::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationPrimitiveSphere_Seeded
// 0x001C (0x00F8 - 0x00DC)
class UParticleModuleLocationPrimitiveSphere_Seeded : public UParticleModuleLocationPrimitiveSphere
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x00DC (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationPrimitiveSphere_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationPrimitiveSphere_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationSkelVertSurface
// 0x0058 (0x00C4 - 0x006C)
class UParticleModuleLocationSkelVertSurface : public UParticleModuleLocationBase
{
public:
	unsigned char                                      SourceType;                                       		// 0x006C (0x0001) [0x0000000000000000]              
	struct FVector                                     UniversalOffset;                                  		// 0x0070 (0x000C) [0x0000000000000000]              
	DWORD                                              bUpdatePositionEachFrame : 1;                     		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bOrientMeshEmitters : 1;                          		// 0x007C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bEnforceNormalCheck : 1;                          		// 0x007C (0x0004) [0x0000000000000000] [0x00000004] 
	struct FName                                       SkelMeshActorParamName;                           		// 0x0080 (0x0008) [0x0000000000000000]              
	class USkeletalMesh*                               EditorSkelMesh;                                   		// 0x0088 (0x0008) [0x0000000000000000]              
	TArray< struct FName >                             ValidAssociatedBones;                             		// 0x0090 (0x0010) [0x0000000000000000]              
	struct FVector                                     NormalToCompare;                                  		// 0x00A0 (0x000C) [0x0000000000000000]              
	float                                              NormalCheckToleranceDegrees;                      		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              NormalCheckTolerance;                             		// 0x00B0 (0x0004) [0x0000000000000000]              
	TArray< int >                                      ValidMaterialIndices;                             		// 0x00B4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationSkelVertSurface" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationSkelVertSurface::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationStaticVertSurface
// 0x0048 (0x00B4 - 0x006C)
class UParticleModuleLocationStaticVertSurface : public UParticleModuleLocationBase
{
public:
	unsigned char                                      SourceType;                                       		// 0x006C (0x0001) [0x0000000000000000]              
	struct FVector                                     UniversalOffset;                                  		// 0x0070 (0x000C) [0x0000000000000000]              
	DWORD                                              bUpdatePositionEachFrame : 1;                     		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bOrientMeshEmitters : 1;                          		// 0x007C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bEnforceNormalCheck : 1;                          		// 0x007C (0x0004) [0x0000000000000000] [0x00000004] 
	struct FName                                       StaticMeshActorParamName;                         		// 0x0080 (0x0008) [0x0000000000000000]              
	class UStaticMesh*                                 EditorStaticMesh;                                 		// 0x0088 (0x0008) [0x0000000000000000]              
	struct FVector                                     NormalToCompare;                                  		// 0x0090 (0x000C) [0x0000000000000000]              
	float                                              NormalCheckToleranceDegrees;                      		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              NormalCheckTolerance;                             		// 0x00A0 (0x0004) [0x0000000000000000]              
	TArray< int >                                      ValidMaterialIndices;                             		// 0x00A4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleLocationStaticVertSurface" );

		return pClassPointer;
	};

};

UClass* UParticleModuleLocationStaticVertSurface::pClassPointer = NULL;

// Class Engine.ParticleModuleSourceMovement
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleSourceMovement : public UParticleModuleLocationBase
{
public:
	struct FRawDistributionVector                      SourceMovementScale;                              		// 0x006C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSourceMovement" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSourceMovement::pClassPointer = NULL;

// Class Engine.ParticleModuleMaterialBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleMaterialBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleMaterialBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleMaterialBase::pClassPointer = NULL;

// Class Engine.ParticleModuleMaterialByParameter
// 0x0020 (0x008C - 0x006C)
class UParticleModuleMaterialByParameter : public UParticleModuleMaterialBase
{
public:
	TArray< struct FName >                             MaterialParameters;                               		// 0x006C (0x0010) [0x0000000000000000]              
	TArray< class UMaterialInterface* >                DefaultMaterials;                                 		// 0x007C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleMaterialByParameter" );

		return pClassPointer;
	};

};

UClass* UParticleModuleMaterialByParameter::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshMaterial
// 0x0010 (0x007C - 0x006C)
class UParticleModuleMeshMaterial : public UParticleModuleMaterialBase
{
public:
	TArray< class UMaterialInterface* >                MeshMaterials;                                    		// 0x006C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleMeshMaterial" );

		return pClassPointer;
	};

};

UClass* UParticleModuleMeshMaterial::pClassPointer = NULL;

// Class Engine.ParticleModuleOrbitBase
// 0x0004 (0x0070 - 0x006C)
class UParticleModuleOrbitBase : public UParticleModule
{
public:
	DWORD                                              bUseEmitterTime : 1;                              		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleOrbitBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleOrbitBase::pClassPointer = NULL;

// Class Engine.ParticleModuleOrbit
// 0x007C (0x00EC - 0x0070)
class UParticleModuleOrbit : public UParticleModuleOrbitBase
{
public:
	unsigned char                                      ChainMode;                                        		// 0x0070 (0x0001) [0x0000000000000000]              
	struct FRawDistributionVector                      OffsetAmount;                                     		// 0x0074 (0x0024) [0x0000000000000000]              
	struct FOrbitOptions                               OffsetOptions;                                    		// 0x0098 (0x0004) [0x0000000000000000]              
	struct FRawDistributionVector                      RotationAmount;                                   		// 0x009C (0x0024) [0x0000000000000000]              
	struct FOrbitOptions                               RotationOptions;                                  		// 0x00C0 (0x0004) [0x0000000000000000]              
	struct FRawDistributionVector                      RotationRateAmount;                               		// 0x00C4 (0x0024) [0x0000000000000000]              
	struct FOrbitOptions                               RotationRateOptions;                              		// 0x00E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleOrbit" );

		return pClassPointer;
	};

};

UClass* UParticleModuleOrbit::pClassPointer = NULL;

// Class Engine.ParticleModuleOrientationBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleOrientationBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleOrientationBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleOrientationBase::pClassPointer = NULL;

// Class Engine.ParticleModuleOrientationAxisLock
// 0x0001 (0x006D - 0x006C)
class UParticleModuleOrientationAxisLock : public UParticleModuleOrientationBase
{
public:
	unsigned char                                      LockAxisFlags;                                    		// 0x006C (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleOrientationAxisLock" );

		return pClassPointer;
	};

};

UClass* UParticleModuleOrientationAxisLock::pClassPointer = NULL;

// Class Engine.ParticleModuleParameterBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleParameterBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleParameterBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleParameterBase::pClassPointer = NULL;

// Class Engine.ParticleModuleParameterDynamic
// 0x0018 (0x0084 - 0x006C)
class UParticleModuleParameterDynamic : public UParticleModuleParameterBase
{
public:
	TArray< struct FEmitterDynamicParameter >          DynamicParams;                                    		// 0x006C (0x0010) [0x0000000000000000]              
	int                                                UpdateFlags;                                      		// 0x007C (0x0004) [0x0000000000000000]              
	DWORD                                              bUsesVelocity : 1;                                		// 0x0080 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleParameterDynamic" );

		return pClassPointer;
	};

};

UClass* UParticleModuleParameterDynamic::pClassPointer = NULL;

// Class Engine.ParticleModuleParameterDynamic_Seeded
// 0x001C (0x00A0 - 0x0084)
class UParticleModuleParameterDynamic_Seeded : public UParticleModuleParameterDynamic
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x0084 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleParameterDynamic_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleParameterDynamic_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleRequired
// 0x00AC (0x0118 - 0x006C)
class UParticleModuleRequired : public UParticleModule
{
public:
	class UMaterialInterface*                          Material;                                         		// 0x006C (0x0008) [0x0000000000000000]              
	unsigned char                                      ScreenAlignment;                                  		// 0x0074 (0x0001) [0x0000000000000000]              
	unsigned char                                      SortMode;                                         		// 0x0075 (0x0001) [0x0000000000000000]              
	unsigned char                                      ParticleBurstMethod;                              		// 0x0076 (0x0001) [0x0000000000000000]              
	unsigned char                                      InterpolationMethod;                              		// 0x0077 (0x0001) [0x0000000000000000]              
	unsigned char                                      EmitterNormalsMode;                               		// 0x0078 (0x0001) [0x0000000000000000]              
	DWORD                                              bAllowImageFlipping : 1;                          		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSquareImageFlipping : 1;                         		// 0x007C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUseLocalSpace : 1;                               		// 0x007C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bKillOnDeactivate : 1;                            		// 0x007C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bKillOnCompleted : 1;                             		// 0x007C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bRequiresSorting : 1;                             		// 0x007C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bUseLegacyEmitterTime : 1;                        		// 0x007C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bEnableNearParticleCulling : 1;                   		// 0x007C (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bEnableFarParticleCulling : 1;                    		// 0x007C (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bEmitterDurationUseRange : 1;                     		// 0x007C (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bDurationRecalcEachLoop : 1;                      		// 0x007C (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bEmitterDelayUseRange : 1;                        		// 0x007C (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bDelayFirstLoopOnly : 1;                          		// 0x007C (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bScaleUV : 1;                                     		// 0x007C (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bDirectUV : 1;                                    		// 0x007C (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bOverrideSystemMacroUV : 1;                       		// 0x007C (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bUseMaxDrawCount : 1;                             		// 0x007C (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bOrbitModuleAffectsVelocityAlignment : 1;         		// 0x007C (0x0004) [0x0000000000000000] [0x00020000] 
	float                                              NearCullDistance;                                 		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              NearFadeDistance;                                 		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              FarFadeDistance;                                  		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              FarCullDistance;                                  		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              EmitterDuration;                                  		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              EmitterDurationLow;                               		// 0x0094 (0x0004) [0x0000000000000000]              
	int                                                EmitterLoops;                                     		// 0x0098 (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       SpawnRate;                                        		// 0x009C (0x0024) [0x0000000000000000]              
	TArray< struct FParticleBurst >                    BurstList;                                        		// 0x00C0 (0x0010) [0x0000000000000000]              
	float                                              EmitterDelay;                                     		// 0x00D0 (0x0004) [0x0000000000000000]              
	float                                              EmitterDelayLow;                                  		// 0x00D4 (0x0004) [0x0000000000000000]              
	int                                                SubImages_Horizontal;                             		// 0x00D8 (0x0004) [0x0000000000000000]              
	int                                                SubImages_Vertical;                               		// 0x00DC (0x0004) [0x0000000000000000]              
	float                                              RandomImageTime;                                  		// 0x00E0 (0x0004) [0x0000000000000000]              
	int                                                RandomImageChanges;                               		// 0x00E4 (0x0004) [0x0000000000000000]              
	struct FVector                                     MacroUVPosition;                                  		// 0x00E8 (0x000C) [0x0000000000000000]              
	float                                              MacroUVRadius;                                    		// 0x00F4 (0x0004) [0x0000000000000000]              
	int                                                MaxDrawCount;                                     		// 0x00F8 (0x0004) [0x0000000000000000]              
	float                                              DownsampleThresholdScreenFraction;                		// 0x00FC (0x0004) [0x0000000000000000]              
	struct FVector                                     NormalsSphereCenter;                              		// 0x0100 (0x000C) [0x0000000000000000]              
	struct FVector                                     NormalsCylinderDirection;                         		// 0x010C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleRequired" );

		return pClassPointer;
	};

};

UClass* UParticleModuleRequired::pClassPointer = NULL;

// Class Engine.ParticleModuleRotationBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleRotationBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleRotationBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleRotationBase::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshRotation
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleMeshRotation : public UParticleModuleRotationBase
{
public:
	struct FRawDistributionVector                      StartRotation;                                    		// 0x006C (0x0024) [0x0000000000000000]              
	DWORD                                              bInheritParent : 1;                               		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleMeshRotation" );

		return pClassPointer;
	};

};

UClass* UParticleModuleMeshRotation::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshRotation_Seeded
// 0x001C (0x00B0 - 0x0094)
class UParticleModuleMeshRotation_Seeded : public UParticleModuleMeshRotation
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x0094 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleMeshRotation_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleMeshRotation_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleRotation
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleRotation : public UParticleModuleRotationBase
{
public:
	struct FRawDistributionFloat                       StartRotation;                                    		// 0x006C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleRotation" );

		return pClassPointer;
	};

};

UClass* UParticleModuleRotation::pClassPointer = NULL;

// Class Engine.ParticleModuleRotation_Seeded
// 0x001C (0x00AC - 0x0090)
class UParticleModuleRotation_Seeded : public UParticleModuleRotation
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x0090 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleRotation_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleRotation_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleRotationOverLifetime
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleRotationOverLifetime : public UParticleModuleRotationBase
{
public:
	struct FRawDistributionFloat                       RotationOverLife;                                 		// 0x006C (0x0024) [0x0000000000000000]              
	DWORD                                              Scale : 1;                                        		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleRotationOverLifetime" );

		return pClassPointer;
	};

};

UClass* UParticleModuleRotationOverLifetime::pClassPointer = NULL;

// Class Engine.ParticleModuleRotationRateBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleRotationRateBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleRotationRateBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleRotationRateBase::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshRotationRate
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleMeshRotationRate : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionVector                      StartRotationRate;                                		// 0x006C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleMeshRotationRate" );

		return pClassPointer;
	};

};

UClass* UParticleModuleMeshRotationRate::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshRotationRate_Seeded
// 0x001C (0x00AC - 0x0090)
class UParticleModuleMeshRotationRate_Seeded : public UParticleModuleMeshRotationRate
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x0090 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleMeshRotationRate_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleMeshRotationRate_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshRotationRateMultiplyLife
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleMeshRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionVector                      LifeMultiplier;                                   		// 0x006C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleMeshRotationRateMultiplyLife" );

		return pClassPointer;
	};

};

UClass* UParticleModuleMeshRotationRateMultiplyLife::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshRotationRateOverLife
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleMeshRotationRateOverLife : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionVector                      RotRate;                                          		// 0x006C (0x0024) [0x0000000000000000]              
	DWORD                                              bScaleRotRate : 1;                                		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleMeshRotationRateOverLife" );

		return pClassPointer;
	};

};

UClass* UParticleModuleMeshRotationRateOverLife::pClassPointer = NULL;

// Class Engine.ParticleModuleRotationRate
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleRotationRate : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionFloat                       StartRotationRate;                                		// 0x006C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleRotationRate" );

		return pClassPointer;
	};

};

UClass* UParticleModuleRotationRate::pClassPointer = NULL;

// Class Engine.ParticleModuleRotationRate_Seeded
// 0x001C (0x00AC - 0x0090)
class UParticleModuleRotationRate_Seeded : public UParticleModuleRotationRate
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x0090 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleRotationRate_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleRotationRate_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleRotationRateMultiplyLife
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionFloat                       LifeMultiplier;                                   		// 0x006C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleRotationRateMultiplyLife" );

		return pClassPointer;
	};

};

UClass* UParticleModuleRotationRateMultiplyLife::pClassPointer = NULL;

// Class Engine.ParticleModuleSizeBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleSizeBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSizeBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSizeBase::pClassPointer = NULL;

// Class Engine.ParticleModuleSize
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleSize : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                      StartSize;                                        		// 0x006C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSize" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSize::pClassPointer = NULL;

// Class Engine.ParticleModuleSize_Seeded
// 0x001C (0x00AC - 0x0090)
class UParticleModuleSize_Seeded : public UParticleModuleSize
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x0090 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSize_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSize_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleSizeMultiplyLife
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleSizeMultiplyLife : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                      LifeMultiplier;                                   		// 0x006C (0x0024) [0x0000000000000000]              
	DWORD                                              MultiplyX : 1;                                    		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              MultiplyY : 1;                                    		// 0x0090 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              MultiplyZ : 1;                                    		// 0x0090 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSizeMultiplyLife" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSizeMultiplyLife::pClassPointer = NULL;

// Class Engine.ParticleModuleSizeMultiplyVelocity
// 0x0040 (0x00AC - 0x006C)
class UParticleModuleSizeMultiplyVelocity : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                      VelocityMultiplier;                               		// 0x006C (0x0024) [0x0000000000000000]              
	DWORD                                              MultiplyX : 1;                                    		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              MultiplyY : 1;                                    		// 0x0090 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              MultiplyZ : 1;                                    		// 0x0090 (0x0004) [0x0000000000000000] [0x00000004] 
	struct FVector                                     CapMaxSize;                                       		// 0x0094 (0x000C) [0x0000000000000000]              
	struct FVector                                     CapMinSize;                                       		// 0x00A0 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSizeMultiplyVelocity" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSizeMultiplyVelocity::pClassPointer = NULL;

// Class Engine.ParticleModuleSizeScale
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleSizeScale : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                      SizeScale;                                        		// 0x006C (0x0024) [0x0000000000000000]              
	DWORD                                              EnableX : 1;                                      		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              EnableY : 1;                                      		// 0x0090 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              EnableZ : 1;                                      		// 0x0090 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSizeScale" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSizeScale::pClassPointer = NULL;

// Class Engine.ParticleModuleSizeScaleByTime
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleSizeScaleByTime : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                      SizeScaleByTime;                                  		// 0x006C (0x0024) [0x0000000000000000]              
	DWORD                                              bEnableX : 1;                                     		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnableY : 1;                                     		// 0x0090 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bEnableZ : 1;                                     		// 0x0090 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSizeScaleByTime" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSizeScaleByTime::pClassPointer = NULL;

// Class Engine.ParticleModuleSizeScaleOverDensity
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleSizeScaleOverDensity : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                      SizeScaleOverDensity;                             		// 0x006C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSizeScaleOverDensity" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSizeScaleOverDensity::pClassPointer = NULL;

// Class Engine.ParticleModuleSpawnBase
// 0x0004 (0x0070 - 0x006C)
class UParticleModuleSpawnBase : public UParticleModule
{
public:
	DWORD                                              bProcessSpawnRate : 1;                            		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bProcessBurstList : 1;                            		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSpawnBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSpawnBase::pClassPointer = NULL;

// Class Engine.ParticleModuleFlexSpawn
// 0x000C (0x007C - 0x0070)
class UParticleModuleFlexSpawn : public UParticleModuleSpawnBase
{
public:
	int                                                DimX;                                             		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                DimY;                                             		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              Velocity;                                         		// 0x0078 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleFlexSpawn" );

		return pClassPointer;
	};

};

UClass* UParticleModuleFlexSpawn::pClassPointer = NULL;

// Class Engine.ParticleModuleSpawn
// 0x005C (0x00CC - 0x0070)
class UParticleModuleSpawn : public UParticleModuleSpawnBase
{
public:
	struct FRawDistributionFloat                       Rate;                                             		// 0x0070 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       RateScale;                                        		// 0x0094 (0x0024) [0x0000000000000000]              
	unsigned char                                      ParticleBurstMethod;                              		// 0x00B8 (0x0001) [0x0000000000000000]              
	TArray< struct FParticleBurst >                    BurstList;                                        		// 0x00BC (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSpawn" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSpawn::pClassPointer = NULL;

// Class Engine.ParticleModuleSpawnPerUnit
// 0x0038 (0x00A8 - 0x0070)
class UParticleModuleSpawnPerUnit : public UParticleModuleSpawnBase
{
public:
	float                                              UnitScalar;                                       		// 0x0070 (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       SpawnPerUnit;                                     		// 0x0074 (0x0024) [0x0000000000000000]              
	DWORD                                              bIgnoreSpawnRateWhenMoving : 1;                   		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIgnoreMovementAlongX : 1;                        		// 0x0098 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIgnoreMovementAlongY : 1;                        		// 0x0098 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bIgnoreMovementAlongZ : 1;                        		// 0x0098 (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              MovementTolerance;                                		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              MaxFrameDistance;                                 		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              MinFrameDistance;                                 		// 0x00A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSpawnPerUnit" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSpawnPerUnit::pClassPointer = NULL;

// Class Engine.ParticleModuleStoreSpawnTimeBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleStoreSpawnTimeBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleStoreSpawnTimeBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleStoreSpawnTimeBase::pClassPointer = NULL;

// Class Engine.ParticleModuleStoreSpawnTime
// 0x0000 (0x006C - 0x006C)
class UParticleModuleStoreSpawnTime : public UParticleModuleStoreSpawnTimeBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleStoreSpawnTime" );

		return pClassPointer;
	};

};

UClass* UParticleModuleStoreSpawnTime::pClassPointer = NULL;

// Class Engine.ParticleModuleSubUVBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleSubUVBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSubUVBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSubUVBase::pClassPointer = NULL;

// Class Engine.ParticleModuleSubUV
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleSubUV : public UParticleModuleSubUVBase
{
public:
	struct FRawDistributionFloat                       SubImageIndex;                                    		// 0x006C (0x0024) [0x0000000000000000]              
	DWORD                                              bUseRealTime : 1;                                 		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSubUV" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSubUV::pClassPointer = NULL;

// Class Engine.ParticleModuleSubUVMovie
// 0x002C (0x00C0 - 0x0094)
class UParticleModuleSubUVMovie : public UParticleModuleSubUV
{
public:
	DWORD                                              bUseEmitterTime : 1;                              		// 0x0094 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FRawDistributionFloat                       FrameRate;                                        		// 0x0098 (0x0024) [0x0000000000000000]              
	int                                                StartingFrame;                                    		// 0x00BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSubUVMovie" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSubUVMovie::pClassPointer = NULL;

// Class Engine.ParticleModuleSubUVDirect
// 0x0048 (0x00B4 - 0x006C)
class UParticleModuleSubUVDirect : public UParticleModuleSubUVBase
{
public:
	struct FRawDistributionVector                      SubUVPosition;                                    		// 0x006C (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      SubUVSize;                                        		// 0x0090 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSubUVDirect" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSubUVDirect::pClassPointer = NULL;

// Class Engine.ParticleModuleSubUVSelect
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleSubUVSelect : public UParticleModuleSubUVBase
{
public:
	struct FRawDistributionVector                      SubImageSelect;                                   		// 0x006C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleSubUVSelect" );

		return pClassPointer;
	};

};

UClass* UParticleModuleSubUVSelect::pClassPointer = NULL;

// Class Engine.ParticleModuleTrailBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleTrailBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTrailBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTrailBase::pClassPointer = NULL;

// Class Engine.ParticleModuleTrailSource
// 0x0048 (0x00B4 - 0x006C)
class UParticleModuleTrailSource : public UParticleModuleTrailBase
{
public:
	unsigned char                                      SourceMethod;                                     		// 0x006C (0x0001) [0x0000000000000000]              
	unsigned char                                      SelectionMethod;                                  		// 0x006D (0x0001) [0x0000000000000000]              
	struct FName                                       SourceName;                                       		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FRawDistributionFloat                       SourceStrength;                                   		// 0x0078 (0x0024) [0x0000000000000000]              
	DWORD                                              bLockSourceStength : 1;                           		// 0x009C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bInheritRotation : 1;                             		// 0x009C (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                SourceOffsetCount;                                		// 0x00A0 (0x0004) [0x0000000000000000]              
	TArray< struct FVector >                           SourceOffsetDefaults;                             		// 0x00A4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTrailSource" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTrailSource::pClassPointer = NULL;

// Class Engine.ParticleModuleTrailSpawn
// 0x000C (0x0078 - 0x006C)
class UParticleModuleTrailSpawn : public UParticleModuleTrailBase
{
public:
	class UDistributionFloatParticleParameter*         SpawnDistanceMap;                                 		// 0x006C (0x0008) [0x0000000000000000]              
	float                                              MinSpawnVelocity;                                 		// 0x0074 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTrailSpawn" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTrailSpawn::pClassPointer = NULL;

// Class Engine.ParticleModuleTrailTaper
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleTrailTaper : public UParticleModuleTrailBase
{
public:
	unsigned char                                      TaperMethod;                                      		// 0x006C (0x0001) [0x0000000000000000]              
	struct FRawDistributionFloat                       TaperFactor;                                      		// 0x0070 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTrailTaper" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTrailTaper::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleTypeDataBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTypeDataBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTypeDataBase::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataAnimTrail
// 0x001C (0x0088 - 0x006C)
class UParticleModuleTypeDataAnimTrail : public UParticleModuleTypeDataBase
{
public:
	struct FName                                       ControlEdgeName;                                  		// 0x006C (0x0008) [0x0000000000000000]              
	int                                                SheetsPerTrail;                                   		// 0x0074 (0x0004) [0x0000000000000000]              
	DWORD                                              bDeadTrailsOnDeactivate : 1;                      		// 0x0078 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bClipSourceSegement : 1;                          		// 0x0078 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bEnablePreviousTangentRecalculation : 1;          		// 0x0078 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bTangentRecalculationEveryFrame : 1;              		// 0x0078 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bRenderGeometry : 1;                              		// 0x0078 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bRenderSpawnPoints : 1;                           		// 0x0078 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bRenderTangents : 1;                              		// 0x0078 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bRenderTessellation : 1;                          		// 0x0078 (0x0004) [0x0000000000000000] [0x00000080] 
	float                                              TilingDistance;                                   		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              DistanceTessellationStepSize;                     		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              TangentTessellationScalar;                        		// 0x0084 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTypeDataAnimTrail" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTypeDataAnimTrail::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataApex
// 0x0010 (0x007C - 0x006C)
class UParticleModuleTypeDataApex : public UParticleModuleTypeDataBase
{
public:
	class UApexGenericAsset*                           ApexIOFX;                                         		// 0x006C (0x0008) [0x0000000000000000]              
	class UApexGenericAsset*                           ApexEmitter;                                      		// 0x0074 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTypeDataApex" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTypeDataApex::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataBeam
// 0x00C4 (0x0130 - 0x006C)
class UParticleModuleTypeDataBeam : public UParticleModuleTypeDataBase
{
public:
	unsigned char                                      BeamMethod;                                       		// 0x006C (0x0001) [0x0000000000000000]              
	unsigned char                                      EndPointMethod;                                   		// 0x006D (0x0001) [0x0000000000000000]              
	struct FRawDistributionFloat                       Distance;                                         		// 0x0070 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      EndPoint;                                         		// 0x0094 (0x0024) [0x0000000000000000]              
	int                                                TessellationFactor;                               		// 0x00B8 (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       EmitterStrength;                                  		// 0x00BC (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       TargetStrength;                                   		// 0x00E0 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      EndPointDirection;                                		// 0x0104 (0x0024) [0x0000000000000000]              
	int                                                TextureTile;                                      		// 0x0128 (0x0004) [0x0000000000000000]              
	DWORD                                              RenderGeometry : 1;                               		// 0x012C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              RenderDirectLine : 1;                             		// 0x012C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              RenderLines : 1;                                  		// 0x012C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              RenderTessellation : 1;                           		// 0x012C (0x0004) [0x0000000000000000] [0x00000008] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTypeDataBeam" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTypeDataBeam::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataBeam2
// 0x0098 (0x0104 - 0x006C)
class UParticleModuleTypeDataBeam2 : public UParticleModuleTypeDataBase
{
public:
	unsigned char                                      BeamMethod;                                       		// 0x006C (0x0001) [0x0000000000000000]              
	unsigned char                                      TaperMethod;                                      		// 0x006D (0x0001) [0x0000000000000000]              
	int                                                TextureTile;                                      		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              TextureTileDistance;                              		// 0x0074 (0x0004) [0x0000000000000000]              
	int                                                Sheets;                                           		// 0x0078 (0x0004) [0x0000000000000000]              
	int                                                MaxBeamCount;                                     		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              Speed;                                            		// 0x0080 (0x0004) [0x0000000000000000]              
	int                                                InterpolationPoints;                              		// 0x0084 (0x0004) [0x0000000000000000]              
	DWORD                                              bAlwaysOn : 1;                                    		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              RenderGeometry : 1;                               		// 0x0088 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              RenderDirectLine : 1;                             		// 0x0088 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              RenderLines : 1;                                  		// 0x0088 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              RenderTessellation : 1;                           		// 0x0088 (0x0004) [0x0000000000000000] [0x00000010] 
	int                                                UpVectorStepSize;                                 		// 0x008C (0x0004) [0x0000000000000000]              
	struct FName                                       BranchParentName;                                 		// 0x0090 (0x0008) [0x0000000000000000]              
	struct FRawDistributionFloat                       Distance;                                         		// 0x0098 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       TaperFactor;                                      		// 0x00BC (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       TaperScale;                                       		// 0x00E0 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTypeDataBeam2" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTypeDataBeam2::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataMesh
// 0x001C (0x0088 - 0x006C)
class UParticleModuleTypeDataMesh : public UParticleModuleTypeDataBase
{
public:
	class UStaticMesh*                                 Mesh;                                             		// 0x006C (0x0008) [0x0000000000000000]              
	DWORD                                              CastShadows : 1;                                  		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              DoCollisions : 1;                                 		// 0x0074 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAllowMotionBlur : 1;                             		// 0x0074 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bOverrideMaterial : 1;                            		// 0x0074 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bCameraFacing : 1;                                		// 0x0074 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bApplyParticleRotationAsSpin : 1;                 		// 0x0074 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned char                                      MeshAlignment;                                    		// 0x0078 (0x0001) [0x0000000000000000]              
	unsigned char                                      AxisLockOption;                                   		// 0x0079 (0x0001) [0x0000000000000000]              
	unsigned char                                      CameraFacingUpAxisOption;                         		// 0x007A (0x0001) [0x0000000000000000]              
	unsigned char                                      CameraFacingOption;                               		// 0x007B (0x0001) [0x0000000000000000]              
	float                                              Pitch;                                            		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              Roll;                                             		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              Yaw;                                              		// 0x0084 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTypeDataMesh" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTypeDataMesh::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataMeshPhysX
// 0x0024 (0x00AC - 0x0088)
class UParticleModuleTypeDataMeshPhysX : public UParticleModuleTypeDataMesh
{
public:
	class UPhysXParticleSystem*                        PhysXParSys;                                      		// 0x0088 (0x0008) [0x0000000000000000]              
	unsigned char                                      PhysXRotationMethod;                              		// 0x0090 (0x0001) [0x0000000000000000]              
	float                                              FluidRotationCoefficient;                         		// 0x0094 (0x0004) [0x0000000000000000]              
	struct FPhysXEmitterVerticalLodProperties          VerticalLod;                                      		// 0x0098 (0x0010) [0x0000000000000000]              
	float                                              ZOffset;                                          		// 0x00A8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTypeDataMeshPhysX" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTypeDataMeshPhysX::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataPhysX
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleTypeDataPhysX : public UParticleModuleTypeDataBase
{
public:
	class UPhysXParticleSystem*                        PhysXParSys;                                      		// 0x006C (0x0008) [0x0000000000000000]              
	struct FPhysXEmitterVerticalLodProperties          VerticalLod;                                      		// 0x0074 (0x0010) [0x0000000000000000]              
	float                                              SPHSmoothScreenRadius;                            		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              SPHSmoothDepthRadius;                             		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              SPHCutoffThickness;                               		// 0x008C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTypeDataPhysX" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTypeDataPhysX::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataRibbon
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleTypeDataRibbon : public UParticleModuleTypeDataBase
{
public:
	int                                                MaxTessellationBetweenParticles;                  		// 0x006C (0x0004) [0x0000000000000000]              
	int                                                SheetsPerTrail;                                   		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                MaxTrailCount;                                    		// 0x0074 (0x0004) [0x0000000000000000]              
	int                                                MaxParticleInTrailCount;                          		// 0x0078 (0x0004) [0x0000000000000000]              
	DWORD                                              bDeadTrailsOnDeactivate : 1;                      		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDeadTrailsOnSourceLoss : 1;                      		// 0x007C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bClipSourceSegement : 1;                          		// 0x007C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bEnablePreviousTangentRecalculation : 1;          		// 0x007C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bTangentRecalculationEveryFrame : 1;              		// 0x007C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bSpawnInitialParticle : 1;                        		// 0x007C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bRenderGeometry : 1;                              		// 0x007C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bRenderSpawnPoints : 1;                           		// 0x007C (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bRenderTangents : 1;                              		// 0x007C (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bRenderTessellation : 1;                          		// 0x007C (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bEnableTangentDiffInterpScale : 1;                		// 0x007C (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned char                                      RenderAxis;                                       		// 0x0080 (0x0001) [0x0000000000000000]              
	float                                              TangentSpawningScalar;                            		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              TilingDistance;                                   		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              DistanceTessellationStepSize;                     		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              TangentTessellationScalar;                        		// 0x0090 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTypeDataRibbon" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTypeDataRibbon::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataTrail
// 0x0038 (0x00A4 - 0x006C)
class UParticleModuleTypeDataTrail : public UParticleModuleTypeDataBase
{
public:
	DWORD                                              RenderGeometry : 1;                               		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              RenderLines : 1;                                  		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              RenderTessellation : 1;                           		// 0x006C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              Tapered : 1;                                      		// 0x006C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              SpawnByDistance : 1;                              		// 0x006C (0x0004) [0x0000000000000000] [0x00000010] 
	int                                                TessellationFactor;                               		// 0x0070 (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       Tension;                                          		// 0x0074 (0x0024) [0x0000000000000000]              
	struct FVector                                     SpawnDistance;                                    		// 0x0098 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTypeDataTrail" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTypeDataTrail::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataTrail2
// 0x0020 (0x008C - 0x006C)
class UParticleModuleTypeDataTrail2 : public UParticleModuleTypeDataBase
{
public:
	int                                                TessellationFactor;                               		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              TessellationFactorDistance;                       		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              TessellationStrength;                             		// 0x0074 (0x0004) [0x0000000000000000]              
	int                                                TextureTile;                                      		// 0x0078 (0x0004) [0x0000000000000000]              
	int                                                Sheets;                                           		// 0x007C (0x0004) [0x0000000000000000]              
	int                                                MaxTrailCount;                                    		// 0x0080 (0x0004) [0x0000000000000000]              
	int                                                MaxParticleInTrailCount;                          		// 0x0084 (0x0004) [0x0000000000000000]              
	DWORD                                              bClipSourceSegement : 1;                          		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bClearTangents : 1;                               		// 0x0088 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              RenderGeometry : 1;                               		// 0x0088 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              RenderDirectLine : 1;                             		// 0x0088 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              RenderLines : 1;                                  		// 0x0088 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              RenderTessellation : 1;                           		// 0x0088 (0x0004) [0x0000000000000000] [0x00000020] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleTypeDataTrail2" );

		return pClassPointer;
	};

};

UClass* UParticleModuleTypeDataTrail2::pClassPointer = NULL;

// Class Engine.ParticleModuleUberBase
// 0x0010 (0x007C - 0x006C)
class UParticleModuleUberBase : public UParticleModule
{
public:
	TArray< struct FName >                             RequiredModules;                                  		// 0x006C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleUberBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleUberBase::pClassPointer = NULL;

// Class Engine.ParticleModuleUberLTISIVCL
// 0x00D8 (0x0154 - 0x007C)
class UParticleModuleUberLTISIVCL : public UParticleModuleUberBase
{
public:
	struct FRawDistributionFloat                       Lifetime;                                         		// 0x007C (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartSize;                                        		// 0x00A0 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartVelocity;                                    		// 0x00C4 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       StartVelocityRadial;                              		// 0x00E8 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      ColorOverLife;                                    		// 0x010C (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       AlphaOverLife;                                    		// 0x0130 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleUberLTISIVCL" );

		return pClassPointer;
	};

};

UClass* UParticleModuleUberLTISIVCL::pClassPointer = NULL;

// Class Engine.ParticleModuleUberLTISIVCLIL
// 0x00FC (0x0178 - 0x007C)
class UParticleModuleUberLTISIVCLIL : public UParticleModuleUberBase
{
public:
	struct FRawDistributionFloat                       Lifetime;                                         		// 0x007C (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartSize;                                        		// 0x00A0 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartVelocity;                                    		// 0x00C4 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       StartVelocityRadial;                              		// 0x00E8 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      ColorOverLife;                                    		// 0x010C (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       AlphaOverLife;                                    		// 0x0130 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartLocation;                                    		// 0x0154 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleUberLTISIVCLIL" );

		return pClassPointer;
	};

};

UClass* UParticleModuleUberLTISIVCLIL::pClassPointer = NULL;

// Class Engine.ParticleModuleUberLTISIVCLILIRSSBLIRR
// 0x016C (0x01E8 - 0x007C)
class UParticleModuleUberLTISIVCLILIRSSBLIRR : public UParticleModuleUberBase
{
public:
	struct FRawDistributionFloat                       Lifetime;                                         		// 0x007C (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartSize;                                        		// 0x00A0 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartVelocity;                                    		// 0x00C4 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       StartVelocityRadial;                              		// 0x00E8 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      ColorOverLife;                                    		// 0x010C (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       AlphaOverLife;                                    		// 0x0130 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartLocation;                                    		// 0x0154 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       StartRotation;                                    		// 0x0178 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      SizeLifeMultiplier;                               		// 0x019C (0x0024) [0x0000000000000000]              
	DWORD                                              SizeMultiplyX : 1;                                		// 0x01C0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              SizeMultiplyY : 1;                                		// 0x01C0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              SizeMultiplyZ : 1;                                		// 0x01C0 (0x0004) [0x0000000000000000] [0x00000004] 
	struct FRawDistributionFloat                       StartRotationRate;                                		// 0x01C4 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleUberLTISIVCLILIRSSBLIRR" );

		return pClassPointer;
	};

};

UClass* UParticleModuleUberLTISIVCLILIRSSBLIRR::pClassPointer = NULL;

// Class Engine.ParticleModuleUberRainDrops
// 0x0088 (0x0104 - 0x007C)
class UParticleModuleUberRainDrops : public UParticleModuleUberBase
{
public:
	float                                              LifetimeMin;                                      		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              LifetimeMax;                                      		// 0x0080 (0x0004) [0x0000000000000000]              
	struct FVector                                     StartSizeMin;                                     		// 0x0084 (0x000C) [0x0000000000000000]              
	struct FVector                                     StartSizeMax;                                     		// 0x0090 (0x000C) [0x0000000000000000]              
	struct FVector                                     StartVelocityMin;                                 		// 0x009C (0x000C) [0x0000000000000000]              
	struct FVector                                     StartVelocityMax;                                 		// 0x00A8 (0x000C) [0x0000000000000000]              
	float                                              StartVelocityRadialMin;                           		// 0x00B4 (0x0004) [0x0000000000000000]              
	float                                              StartVelocityRadialMax;                           		// 0x00B8 (0x0004) [0x0000000000000000]              
	struct FVector                                     ColorOverLife;                                    		// 0x00BC (0x000C) [0x0000000000000000]              
	float                                              AlphaOverLife;                                    		// 0x00C8 (0x0004) [0x0000000000000000]              
	DWORD                                              bIsUsingCylinder : 1;                             		// 0x00CC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPositive_X : 1;                                  		// 0x00CC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bPositive_Y : 1;                                  		// 0x00CC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bPositive_Z : 1;                                  		// 0x00CC (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bNegative_X : 1;                                  		// 0x00CC (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bNegative_Y : 1;                                  		// 0x00CC (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bNegative_Z : 1;                                  		// 0x00CC (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bSurfaceOnly : 1;                                 		// 0x00CC (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bVelocity : 1;                                    		// 0x00CC (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bRadialVelocity : 1;                              		// 0x00CC (0x0004) [0x0000000000000000] [0x00000200] 
	float                                              PC_VelocityScale;                                 		// 0x00D0 (0x0004) [0x0000000000000000]              
	struct FVector                                     PC_StartLocation;                                 		// 0x00D4 (0x000C) [0x0000000000000000]              
	float                                              PC_StartRadius;                                   		// 0x00E0 (0x0004) [0x0000000000000000]              
	float                                              PC_StartHeight;                                   		// 0x00E4 (0x0004) [0x0000000000000000]              
	unsigned char                                      PC_HeightAxis;                                    		// 0x00E8 (0x0001) [0x0000000000000000]              
	struct FVector                                     StartLocationMin;                                 		// 0x00EC (0x000C) [0x0000000000000000]              
	struct FVector                                     StartLocationMax;                                 		// 0x00F8 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleUberRainDrops" );

		return pClassPointer;
	};

};

UClass* UParticleModuleUberRainDrops::pClassPointer = NULL;

// Class Engine.ParticleModuleUberRainImpacts
// 0x0170 (0x01EC - 0x007C)
class UParticleModuleUberRainImpacts : public UParticleModuleUberBase
{
public:
	struct FRawDistributionFloat                       Lifetime;                                         		// 0x007C (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartSize;                                        		// 0x00A0 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartRotation;                                    		// 0x00C4 (0x0024) [0x0000000000000000]              
	DWORD                                              bInheritParent : 1;                               		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              MultiplyX : 1;                                    		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              MultiplyY : 1;                                    		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              MultiplyZ : 1;                                    		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bIsUsingCylinder : 1;                             		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bPositive_X : 1;                                  		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bPositive_Y : 1;                                  		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bPositive_Z : 1;                                  		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bNegative_X : 1;                                  		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bNegative_Y : 1;                                  		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bNegative_Z : 1;                                  		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bSurfaceOnly : 1;                                 		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bVelocity : 1;                                    		// 0x00E8 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bRadialVelocity : 1;                              		// 0x00E8 (0x0004) [0x0000000000000000] [0x00002000] 
	struct FRawDistributionVector                      LifeMultiplier;                                   		// 0x00EC (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       PC_VelocityScale;                                 		// 0x0110 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      PC_StartLocation;                                 		// 0x0134 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       PC_StartRadius;                                   		// 0x0158 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       PC_StartHeight;                                   		// 0x017C (0x0024) [0x0000000000000000]              
	unsigned char                                      PC_HeightAxis;                                    		// 0x01A0 (0x0001) [0x0000000000000000]              
	struct FRawDistributionVector                      ColorOverLife;                                    		// 0x01A4 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       AlphaOverLife;                                    		// 0x01C8 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleUberRainImpacts" );

		return pClassPointer;
	};

};

UClass* UParticleModuleUberRainImpacts::pClassPointer = NULL;

// Class Engine.ParticleModuleUberRainSplashA
// 0x00DC (0x0158 - 0x007C)
class UParticleModuleUberRainSplashA : public UParticleModuleUberBase
{
public:
	struct FRawDistributionFloat                       Lifetime;                                         		// 0x007C (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartSize;                                        		// 0x00A0 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartRotation;                                    		// 0x00C4 (0x0024) [0x0000000000000000]              
	DWORD                                              bInheritParent : 1;                               		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              MultiplyX : 1;                                    		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              MultiplyY : 1;                                    		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              MultiplyZ : 1;                                    		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000008] 
	struct FRawDistributionVector                      LifeMultiplier;                                   		// 0x00EC (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      ColorOverLife;                                    		// 0x0110 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       AlphaOverLife;                                    		// 0x0134 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleUberRainSplashA" );

		return pClassPointer;
	};

};

UClass* UParticleModuleUberRainSplashA::pClassPointer = NULL;

// Class Engine.ParticleModuleUberRainSplashB
// 0x00DC (0x0158 - 0x007C)
class UParticleModuleUberRainSplashB : public UParticleModuleUberBase
{
public:
	struct FRawDistributionFloat                       Lifetime;                                         		// 0x007C (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      StartSize;                                        		// 0x00A0 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      ColorOverLife;                                    		// 0x00C4 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       AlphaOverLife;                                    		// 0x00E8 (0x0024) [0x0000000000000000]              
	struct FRawDistributionVector                      LifeMultiplier;                                   		// 0x010C (0x0024) [0x0000000000000000]              
	DWORD                                              MultiplyX : 1;                                    		// 0x0130 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              MultiplyY : 1;                                    		// 0x0130 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              MultiplyZ : 1;                                    		// 0x0130 (0x0004) [0x0000000000000000] [0x00000004] 
	struct FRawDistributionFloat                       StartRotationRate;                                		// 0x0134 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleUberRainSplashB" );

		return pClassPointer;
	};

};

UClass* UParticleModuleUberRainSplashB::pClassPointer = NULL;

// Class Engine.ParticleModuleVelocityBase
// 0x0004 (0x0070 - 0x006C)
class UParticleModuleVelocityBase : public UParticleModule
{
public:
	DWORD                                              bInWorldSpace : 1;                                		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bApplyOwnerScale : 1;                             		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleVelocityBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleVelocityBase::pClassPointer = NULL;

// Class Engine.ParticleModuleVelocity
// 0x0048 (0x00B8 - 0x0070)
class UParticleModuleVelocity : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionVector                      StartVelocity;                                    		// 0x0070 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       StartVelocityRadial;                              		// 0x0094 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleVelocity" );

		return pClassPointer;
	};

};

UClass* UParticleModuleVelocity::pClassPointer = NULL;

// Class Engine.ParticleModuleVelocity_Seeded
// 0x001C (0x00D4 - 0x00B8)
class UParticleModuleVelocity_Seeded : public UParticleModuleVelocity
{
public:
	struct FParticleRandomSeedInfo                     RandomSeedInfo;                                   		// 0x00B8 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleVelocity_Seeded" );

		return pClassPointer;
	};

};

UClass* UParticleModuleVelocity_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleVelocityCone
// 0x0054 (0x00C4 - 0x0070)
class UParticleModuleVelocityCone : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionFloat                       Angle;                                            		// 0x0070 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Velocity;                                         		// 0x0094 (0x0024) [0x0000000000000000]              
	struct FVector                                     Direction;                                        		// 0x00B8 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleVelocityCone" );

		return pClassPointer;
	};

};

UClass* UParticleModuleVelocityCone::pClassPointer = NULL;

// Class Engine.ParticleModuleVelocityInheritParent
// 0x0024 (0x0094 - 0x0070)
class UParticleModuleVelocityInheritParent : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionVector                      Scale;                                            		// 0x0070 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleVelocityInheritParent" );

		return pClassPointer;
	};

};

UClass* UParticleModuleVelocityInheritParent::pClassPointer = NULL;

// Class Engine.ParticleModuleVelocityOverLifetime
// 0x0028 (0x0098 - 0x0070)
class UParticleModuleVelocityOverLifetime : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionVector                      VelOverLife;                                      		// 0x0070 (0x0024) [0x0000000000000000]              
	DWORD                                              Absolute : 1;                                     		// 0x0094 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleVelocityOverLifetime" );

		return pClassPointer;
	};

};

UClass* UParticleModuleVelocityOverLifetime::pClassPointer = NULL;

// Class Engine.ParticleModuleWorldForcesBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleWorldForcesBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleWorldForcesBase" );

		return pClassPointer;
	};

};

UClass* UParticleModuleWorldForcesBase::pClassPointer = NULL;

// Class Engine.ParticleModulePhysicsVolumes
// 0x0025 (0x0091 - 0x006C)
class UParticleModulePhysicsVolumes : public UParticleModuleWorldForcesBase
{
public:
	struct FRawDistributionFloat                       GlobalInfluence;                                  		// 0x006C (0x0024) [0x0000000000000000]              
	unsigned char                                      LevelInfluenceType;                               		// 0x0090 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModulePhysicsVolumes" );

		return pClassPointer;
	};

};

UClass* UParticleModulePhysicsVolumes::pClassPointer = NULL;

// Class Engine.ParticleModuleWorldAttractor
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleWorldAttractor : public UParticleModuleWorldForcesBase
{
public:
	DWORD                                              bParticleLifeRelative : 1;                        		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	struct FRawDistributionFloat                       AttractorInfluence;                               		// 0x0070 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleWorldAttractor" );

		return pClassPointer;
	};

};

UClass* UParticleModuleWorldAttractor::pClassPointer = NULL;

// Class Engine.ParticleModuleEventSendToGame
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleEventSendToGame : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleEventSendToGame" );

		return pClassPointer;
	};

	void DoEvent ( );
};

UClass* UParticleModuleEventSendToGame::pClassPointer = NULL;

// Class Engine.ParticleSystemReplay
// 0x0014 (0x0074 - 0x0060)
class UParticleSystemReplay : public UObject
{
public:
	int                                                ClipIDNumber;                                     		// 0x0060 (0x0004) [0x0000000000000000]              
	TArray< struct FParticleSystemReplayFrame >        Frames;                                           		// 0x0064 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleSystemReplay" );

		return pClassPointer;
	};

};

UClass* UParticleSystemReplay::pClassPointer = NULL;

// Class Engine.PhysXParticleSystem
// 0x008C (0x00EC - 0x0060)
class UPhysXParticleSystem : public UObject
{
public:
	int                                                MaxParticles;                                     		// 0x0060 (0x0004) [0x0000000000000000]              
	int                                                ParticleSpawnReserve;                             		// 0x0064 (0x0004) [0x0000000000000000]              
	unsigned char                                      RBChannel;                                        		// 0x0068 (0x0001) [0x0000000000000000]              
	unsigned char                                      SimulationMethod;                                 		// 0x0069 (0x0001) [0x0000000000000000]              
	unsigned char                                      PacketSizeMultiplier;                             		// 0x006A (0x0001) [0x0000000000000000]              
	struct FRBCollisionChannelContainer                RBCollideWithChannels;                            		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              CollisionDistance;                                		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              RestitutionWithStaticShapes;                      		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              RestitutionWithDynamicShapes;                     		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              FrictionWithStaticShapes;                         		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              FrictionWithDynamicShapes;                        		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              StaticFrictionWithStaticShapes;                   		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              StaticFrictionWithDynamicShapes;                  		// 0x0088 (0x0004) [0x0000000000000000]              
	DWORD                                              bDynamicCollision : 1;                            		// 0x008C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDisableGravity : 1;                              		// 0x008C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUseGPU : 1;                                      		// 0x008C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bStaticCollision : 1;                             		// 0x008C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bTwoWayCollision : 1;                             		// 0x008C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bDestroy : 1;                                     		// 0x008C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bSyncFailed : 1;                                  		// 0x008C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bIsInGame : 1;                                    		// 0x008C (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bProcessImpactEffects : 1;                        		// 0x008C (0x0004) [0x0000000000000000] [0x00000100] 
	float                                              MaxMotionDistance;                                		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              Damping;                                          		// 0x0094 (0x0004) [0x0000000000000000]              
	struct FVector                                     ExternalAcceleration;                             		// 0x0098 (0x000C) [0x0000000000000000]              
	float                                              RestParticleDistance;                             		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              RestDensity;                                      		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              KernelRadiusMultiplier;                           		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              Stiffness;                                        		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              Viscosity;                                        		// 0x00B4 (0x0004) [0x0000000000000000]              
	float                                              CollisionResponseCoefficient;                     		// 0x00B8 (0x0004) [0x0000000000000000]              
	struct FPointer                                    CascadeScene;                                     		// 0x00BC (0x0008) [0x0000000000000000]              
	struct FPointer                                    PSys;                                             		// 0x00C4 (0x0008) [0x0000000000000000]              
	float                                              ImpactThreshold;                                  		// 0x00CC (0x0004) [0x0000000000000000]              
	class UAkBaseSoundObject*                          ImpactSound;                                      		// 0x00D0 (0x0008) [0x0000000000000000]              
	TArray< struct FPhysXParticleImpactInfo >          MaterialImpactSounds;                             		// 0x00D8 (0x0010) [0x0000000000000000]              
	float                                              PhysMaterialFrequency;                            		// 0x00E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PhysXParticleSystem" );

		return pClassPointer;
	};

};

UClass* UPhysXParticleSystem::pClassPointer = NULL;

// Class Engine.KActor
// 0x00E4 (0x0378 - 0x0294)
class AKActor : public ADynamicSMActor
{
public:
	DWORD                                              bDamageAppliesImpulse : 1;                        		// 0x0294 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bWakeOnLevelStart : 1;                            		// 0x0294 (0x0004) [0x00000000001C0020] [0x00000002] ( CPF_Net | CPF_GlobalConfig | CPF_Component )
	DWORD                                              bCurrentSlide : 1;                                		// 0x0294 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bSlideActive : 1;                                 		// 0x0294 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bEnableStayUprightSpring : 1;                     		// 0x0294 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bLimitMaxPhysicsVelocity : 1;                     		// 0x0294 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bNeedsRBStateReplication : 1;                     		// 0x0294 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bDisableClientSidePawnInteractions : 1;           		// 0x0294 (0x0004) [0x0000000000000000] [0x00000080] 
	class UParticleSystemComponent*                    ImpactEffectComponent;                            		// 0x0298 (0x0008) [0x0000000000000000]              
	class UAudioComponent*                             ImpactSoundComponent;                             		// 0x02A0 (0x0008) [0x0000000000000000]              
	class UAudioComponent*                             ImpactSoundComponent2;                            		// 0x02A8 (0x0008) [0x0000000000000000]              
	float                                              LastImpactTime;                                   		// 0x02B0 (0x0004) [0x0000000000000000]              
	struct FPhysEffectInfo                             ImpactEffectInfo;                                 		// 0x02B4 (0x0018) [0x0000000000000000]              
	class UParticleSystemComponent*                    SlideEffectComponent;                             		// 0x02CC (0x0008) [0x0000000000000000]              
	class UAudioComponent*                             SlideSoundComponent;                              		// 0x02D4 (0x0008) [0x0000000000000000]              
	float                                              LastSlideTime;                                    		// 0x02DC (0x0004) [0x0000000000000000]              
	struct FPhysEffectInfo                             SlideEffectInfo;                                  		// 0x02E0 (0x0018) [0x0000000000000000]              
	float                                              StayUprightTorqueFactor;                          		// 0x02F8 (0x0004) [0x0000000000000000]              
	float                                              StayUprightMaxTorque;                             		// 0x02FC (0x0004) [0x0000000000000000]              
	float                                              MaxPhysicsVelocity;                               		// 0x0300 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0xC ];                             		// 0x0304 (0x000C) MISSED OFFSET
	struct FRigidBodyState                             RBState;                                          		// 0x0310 (0x0040) [0x00000000001D0000]              ( CPF_Travel | CPF_GlobalConfig | CPF_Component )
	float                                              AngErrorAccumulator;                              		// 0x0350 (0x0004) [0x0000000000000000]              
	struct FVector                                     ReplicatedDrawScale3D;                            		// 0x0354 (0x000C) [0x00000000001E0020]              ( CPF_Net | CPF_EditConst | CPF_GlobalConfig | CPF_Component )
	struct FVector                                     InitialLocation;                                  		// 0x0360 (0x000C) [0x0000000000000000]              
	struct FRotator                                    InitialRotation;                                  		// 0x036C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.KActor" );

		return pClassPointer;
	};

	void Reset ( );
	void OnTeleport ( );
	void OnToggle ( );
	void TakeRadiusDamage ( );
	void eventTakeDamage ( );
	void eventApplyImpulse ( );
	void eventReplicatedEvent ( );
	void eventSpawnedByKismet ( );
	void SetPhysicalCollisionProperties ( );
	void eventDestroyed ( );
	void eventFellOutOfWorld ( );
	void eventPostBeginPlay ( );
	void ResolveRBState ( );
	void GetKActorPhysMaterial ( );
};

UClass* AKActor::pClassPointer = NULL;

// Class Engine.KActorFromStatic
// 0x000C (0x0384 - 0x0378)
class AKActorFromStatic : public AKActor
{
public:
	class AActor*                                      MyStaticMeshActor;                                		// 0x0378 (0x0008) [0x0000000000000000]              
	float                                              MaxImpulseSpeed;                                  		// 0x0380 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.KActorFromStatic" );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void Reset ( );
	void TakeRadiusDamage ( );
	void eventTouch ( );
	void eventBump ( );
	void ReceiveImpulse ( );
	void eventApplyImpulse ( );
	void MakeDynamic ( );
	void MakeStatic ( );
	void BecomeStatic ( );
	void eventOnWakeRBPhysics ( );
	void eventOnSleepRBPhysics ( );
	void DisablePrecomputedLighting ( );
};

UClass* AKActorFromStatic::pClassPointer = NULL;

// Class Engine.KActorSpawnable
// 0x0004 (0x037C - 0x0378)
class AKActorSpawnable : public AKActor
{
public:
	DWORD                                              bRecycleScaleToZero : 1;                          		// 0x0378 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bScalingToZero : 1;                               		// 0x0378 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.KActorSpawnable" );

		return pClassPointer;
	};

	void ResetComponents ( );
	void eventRecycleInternal ( );
	void Recycle ( );
	void Initialize ( );
};

UClass* AKActorSpawnable::pClassPointer = NULL;

// Class Engine.FlexForceFieldActor
// 0x0008 (0x024C - 0x0244)
class AFlexForceFieldActor : public AActor
{
public:
	class UFlexForceFieldComponent*                    ForceFieldComponent;                              		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FlexForceFieldActor" );

		return pClassPointer;
	};

	void OnToggle ( );
};

UClass* AFlexForceFieldActor::pClassPointer = NULL;

// Class Engine.KAsset
// 0x001C (0x0260 - 0x0244)
class AKAsset : public AActor
{
public:
	class USkeletalMeshComponent*                      SkeletalMeshComponent;                            		// 0x0244 (0x0008) [0x0000000000000000]              
	DWORD                                              bDamageAppliesImpulse : 1;                        		// 0x024C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bWakeOnLevelStart : 1;                            		// 0x024C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bBlockPawns : 1;                                  		// 0x024C (0x0004) [0x0000000000000000] [0x00000004] 
	class USkeletalMesh*                               ReplicatedMesh;                                   		// 0x0250 (0x0008) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )
	class UPhysicsAsset*                               ReplicatedPhysAsset;                              		// 0x0258 (0x0008) [0x0000000000160000]              ( CPF_EditConst | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.KAsset" );

		return pClassPointer;
	};

	void DoKismetAttachment ( );
	void OnTeleport ( );
	void OnToggle ( );
	void TakeRadiusDamage ( );
	void eventTakeDamage ( );
	void eventReplicatedEvent ( );
	void SetMeshAndPhysAsset ( );
	void eventPostBeginPlay ( );
};

UClass* AKAsset::pClassPointer = NULL;

// Class Engine.Pawn
// 0x0314 (0x0558 - 0x0244)
class APawn : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_Speaker;                       		// 0x0244 (0x0008) [0x0000000000000000]              
	float                                              MaxStepHeight;                                    		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              MaxJumpHeight;                                    		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              WalkableFloorZ;                                   		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              LedgeCheckThreshold;                              		// 0x0258 (0x0004) [0x0000000000000000]              
	struct FVector                                     PartialLedgeMoveDir;                              		// 0x025C (0x000C) [0x0000000000000000]              
	class AController*                                 Controller;                                       		// 0x0268 (0x0008) [0x0000000000150032]              ( CPF_Const | CPF_OptionalParm | CPF_Net | CPF_Travel | CPF_GlobalConfig )
	class APawn*                                       NextPawn;                                         		// 0x0270 (0x0008) [0x0000000000000000]              
	float                                              NetRelevancyTime;                                 		// 0x0278 (0x0004) [0x0000000000000000]              
	class APlayerController*                           LastRealViewer;                                   		// 0x027C (0x0008) [0x0000000000000000]              
	class AActor*                                      LastViewer;                                       		// 0x0284 (0x0008) [0x0000000000000000]              
	DWORD                                              bScriptTickSpecial : 1;                           		// 0x028C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUpAndOut : 1;                                    		// 0x028C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIsWalking : 1;                                   		// 0x028C (0x0004) [0x0000000000160000] [0x00000004] ( CPF_EditConst | CPF_GlobalConfig )
	DWORD                                              bWantsToCrouch : 1;                               		// 0x028C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bIsCrouched : 1;                                  		// 0x028C (0x0004) [0x0000000000170073] [0x00000010] ( CPF_Edit | CPF_Const | CPF_OptionalParm | CPF_Net | CPF_EditConstArray | CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
	DWORD                                              bTryToUncrouch : 1;                               		// 0x028C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bCanCrouch : 1;                                   		// 0x028C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bCrawler : 1;                                     		// 0x028C (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bReducedSpeed : 1;                                		// 0x028C (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bJumpCapable : 1;                                 		// 0x028C (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bCanJump : 1;                                     		// 0x028C (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bCanWalk : 1;                                     		// 0x028C (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bCanSwim : 1;                                     		// 0x028C (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bCanFly : 1;                                      		// 0x028C (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bCanClimbLadders : 1;                             		// 0x028C (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bCanStrafe : 1;                                   		// 0x028C (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bAvoidLedges : 1;                                 		// 0x028C (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bStopAtLedges : 1;                                		// 0x028C (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bAllowLedgeOverhang : 1;                          		// 0x028C (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bPartiallyOverLedge : 1;                          		// 0x028C (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bSimulateGravity : 1;                             		// 0x028C (0x0004) [0x0000000000180000] [0x00100000] ( CPF_Component )
	DWORD                                              bIgnoreForces : 1;                                		// 0x028C (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bCanWalkOffLedges : 1;                            		// 0x028C (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bCanBeBaseForPawns : 1;                           		// 0x028C (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bSimGravityDisabled : 1;                          		// 0x028C (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bDirectHitWall : 1;                               		// 0x028C (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bPushesRigidBodies : 1;                           		// 0x028C (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bForceFloorCheck : 1;                             		// 0x028C (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bForceKeepAnchor : 1;                             		// 0x028C (0x0004) [0x0000000000000000] [0x10000000] 
	DWORD                                              bCanMantle : 1;                                   		// 0x028C (0x0004) [0x0000000000000000] [0x20000000] 
	DWORD                                              bCanClimbUp : 1;                                  		// 0x028C (0x0004) [0x0000000000000000] [0x40000000] 
	DWORD                                              bCanClimbCeilings : 1;                            		// 0x028C (0x0004) [0x0000000000000000] [0x80000000] 
	DWORD                                              bCanSwatTurn : 1;                                 		// 0x0290 (0x0004) [0x000000000019004B] [0x00000001] ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConstArray | CPF_Travel | CPF_Component )
	DWORD                                              bCanLeap : 1;                                     		// 0x0290 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCanCoverSlip : 1;                                		// 0x0290 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bDisplayPathErrors : 1;                           		// 0x0290 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bCanPickupInventory : 1;                          		// 0x0290 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bAmbientCreature : 1;                             		// 0x0290 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bLOSHearing : 1;                                  		// 0x0290 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bMuffledHearing : 1;                              		// 0x0290 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bDontPossess : 1;                                 		// 0x0290 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bRollToDesired : 1;                               		// 0x0290 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bStationary : 1;                                  		// 0x0290 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bCachedRelevant : 1;                              		// 0x0290 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bNoWeaponFiring : 1;                              		// 0x0290 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bModifyReachSpecCost : 1;                         		// 0x0290 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bModifyNavPointDest : 1;                          		// 0x0290 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bPathfindsAsVehicle : 1;                          		// 0x0290 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bPrevBypassSimulatedClientPhysics : 1;            		// 0x0290 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bRunPhysicsWithNoController : 1;                  		// 0x0290 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bForceMaxAccel : 1;                               		// 0x0290 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bLimitFallAccel : 1;                              		// 0x0290 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bReplicateHealthToAll : 1;                        		// 0x0290 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bForceRMVelocity : 1;                             		// 0x0290 (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bForceRegularVelocity : 1;                        		// 0x0290 (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bPlayedDeath : 1;                                 		// 0x0290 (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bDesiredRotationSet : 1;                          		// 0x0290 (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bLockDesiredRotation : 1;                         		// 0x0290 (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bUnlockWhenReached : 1;                           		// 0x0290 (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bNeedsBaseTickedFirst : 1;                        		// 0x0290 (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bUsedByMatinee : 1;                               		// 0x0290 (0x0004) [0x00000000001A0000] [0x10000000] ( CPF_EditConst | CPF_Component )
	DWORD                                              bRootMotionFromInterpCurve : 1;                   		// 0x0290 (0x0004) [0x00000000001B00D1] [0x20000000] ( CPF_Edit | CPF_OptionalParm | CPF_EditConstArray | CPF_Parm | CPF_Travel | CPF_EditConst | CPF_Component )
	DWORD                                              bDebugShowCameraLocation : 1;                     		// 0x0290 (0x0004) [0x0000000000000000] [0x40000000] 
	DWORD                                              bFastAttachedMove : 1;                            		// 0x0290 (0x0004) [0x00000000001C0000] [0x80000000] ( CPF_GlobalConfig | CPF_Component )
	DWORD                                              bCanJumpOverWalls : 1;                            		// 0x0294 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDebugCrawlerPhysics : 1;                         		// 0x0294 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned char                                      WalkingPhysics;                                   		// 0x0298 (0x0001) [0x0000000000000000]              
	unsigned char                                      PathSearchType;                                   		// 0x0299 (0x0001) [0x0000000000000000]              
	unsigned char                                      RemoteViewPitch;                                  		// 0x029A (0x0001) [0x00000000001D00B6]              ( CPF_Const | CPF_Input | CPF_OptionalParm | CPF_Net | CPF_Parm | CPF_Travel | CPF_GlobalConfig | CPF_Component )
	unsigned char                                      FlashCount;                                       		// 0x029B (0x0001) [0x00000000001E0073]              ( CPF_Edit | CPF_Const | CPF_OptionalParm | CPF_Net | CPF_EditConstArray | CPF_EditConst | CPF_GlobalConfig | CPF_Component )
	unsigned char                                      FiringMode;                                       		// 0x029C (0x0001) [0x00000000001F0073]              ( CPF_Edit | CPF_Const | CPF_OptionalParm | CPF_Net | CPF_EditConstArray | CPF_Travel | CPF_EditConst | CPF_GlobalConfig | CPF_Component )
	unsigned char                                      LightingVolumeEnterCount;                         		// 0x029D (0x0001) [0x0000000000000000]              
	float                                              UncrouchTime;                                     		// 0x02A0 (0x0004) [0x0000000000000000]              
	float                                              CrouchHeight;                                     		// 0x02A4 (0x0004) [0x0000000000000000]              
	float                                              CrouchRadius;                                     		// 0x02A8 (0x0004) [0x0000000000000000]              
	int                                                FullHeight;                                       		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              NonPreferredVehiclePathMultiplier;                		// 0x02B0 (0x0004) [0x0000000000000000]              
	class UPathConstraint*                             PathConstraintList;                               		// 0x02B4 (0x0008) [0x0000000000000000]              
	class UPathGoalEvaluator*                          PathGoalList;                                     		// 0x02BC (0x0008) [0x0000000000000000]              
	float                                              DesiredSpeed;                                     		// 0x02C4 (0x0004) [0x0000000000000000]              
	float                                              MaxDesiredSpeed;                                  		// 0x02C8 (0x0004) [0x0000000000000000]              
	float                                              HearingThreshold;                                 		// 0x02CC (0x0004) [0x0000000000000000]              
	float                                              Alertness;                                        		// 0x02D0 (0x0004) [0x0000000000000000]              
	float                                              SightRadius;                                      		// 0x02D4 (0x0004) [0x0000000000000000]              
	float                                              PeripheralVision;                                 		// 0x02D8 (0x0004) [0x0000000000000000]              
	float                                              AvgPhysicsTime;                                   		// 0x02DC (0x0004) [0x0000000000000000]              
	float                                              Mass;                                             		// 0x02E0 (0x0004) [0x0000000000000000]              
	float                                              Buoyancy;                                         		// 0x02E4 (0x0004) [0x0000000000000000]              
	float                                              MeleeRange;                                       		// 0x02E8 (0x0004) [0x0000000000000000]              
	class ANavigationPoint*                            Anchor;                                           		// 0x02EC (0x0008) [0x0000000000000000]              
	int                                                AnchorItem;                                       		// 0x02F4 (0x0004) [0x0000000000000000]              
	class ANavigationPoint*                            LastAnchor;                                       		// 0x02F8 (0x0008) [0x0000000000000000]              
	float                                              FindAnchorFailedTime;                             		// 0x0300 (0x0004) [0x0000000000000000]              
	float                                              LastValidAnchorTime;                              		// 0x0304 (0x0004) [0x0000000000000000]              
	float                                              DestinationOffset;                                		// 0x0308 (0x0004) [0x0000000000000000]              
	float                                              NextPathRadius;                                   		// 0x030C (0x0004) [0x0000000000000000]              
	struct FVector                                     SerpentineDir;                                    		// 0x0310 (0x000C) [0x0000000000000000]              
	float                                              SerpentineDist;                                   		// 0x031C (0x0004) [0x0000000000000000]              
	float                                              SerpentineTime;                                   		// 0x0320 (0x0004) [0x0000000000000000]              
	float                                              SpawnTime;                                        		// 0x0324 (0x0004) [0x0000000000000000]              
	int                                                MaxPitchLimit;                                    		// 0x0328 (0x0004) [0x0000000000000000]              
	float                                              GroundSpeed;                                      		// 0x032C (0x0004) [0x0000000000200032]              ( CPF_Const | CPF_OptionalParm | CPF_Net )
	float                                              WaterSpeed;                                       		// 0x0330 (0x0004) [0x0000000000210032]              ( CPF_Const | CPF_OptionalParm | CPF_Net | CPF_Travel )
	float                                              AirSpeed;                                         		// 0x0334 (0x0004) [0x0000000000220032]              ( CPF_Const | CPF_OptionalParm | CPF_Net | CPF_EditConst )
	float                                              LadderSpeed;                                      		// 0x0338 (0x0004) [0x0000000000000000]              
	float                                              AccelRate;                                        		// 0x033C (0x0004) [0x0000000000230032]              ( CPF_Const | CPF_OptionalParm | CPF_Net | CPF_Travel | CPF_EditConst )
	float                                              JumpZ;                                            		// 0x0340 (0x0004) [0x0000000000240032]              ( CPF_Const | CPF_OptionalParm | CPF_Net | CPF_GlobalConfig )
	float                                              OutofWaterZ;                                      		// 0x0344 (0x0004) [0x0000000000000000]              
	float                                              MaxOutOfWaterStepHeight;                          		// 0x0348 (0x0004) [0x0000000000000000]              
	float                                              AirControl;                                       		// 0x034C (0x0004) [0x0000000000250032]              ( CPF_Const | CPF_OptionalParm | CPF_Net | CPF_Travel | CPF_GlobalConfig )
	float                                              WalkingPct;                                       		// 0x0350 (0x0004) [0x0000000000000000]              
	float                                              MovementSpeedModifier;                            		// 0x0354 (0x0004) [0x0000000000000000]              
	float                                              CrouchedPct;                                      		// 0x0358 (0x0004) [0x0000000000000000]              
	float                                              MaxFallSpeed;                                     		// 0x035C (0x0004) [0x0000000000000000]              
	float                                              AIMaxFallSpeedFactor;                             		// 0x0360 (0x0004) [0x0000000000000000]              
	float                                              BaseEyeHeight;                                    		// 0x0364 (0x0004) [0x0000000000000000]              
	float                                              EyeHeight;                                        		// 0x0368 (0x0004) [0x0000000000000000]              
	struct FVector                                     Floor;                                            		// 0x036C (0x000C) [0x0000000000000000]              
	float                                              SplashTime;                                       		// 0x0378 (0x0004) [0x0000000000000000]              
	class APhysicsVolume*                              HeadVolume;                                       		// 0x037C (0x0008) [0x0000000000000000]              
	int                                                Health;                                           		// 0x0384 (0x0004) [0x000000000026000A]              ( CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_GlobalConfig )
	int                                                HealthMax;                                        		// 0x0388 (0x0004) [0x0000000000270116]              ( CPF_Const | CPF_Input | CPF_OptionalParm | CPF_OutParm | CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
	float                                              BreathTime;                                       		// 0x038C (0x0004) [0x0000000000000000]              
	float                                              UnderWaterTime;                                   		// 0x0390 (0x0004) [0x0000000000000000]              
	float                                              LastPainTime;                                     		// 0x0394 (0x0004) [0x0000000000000000]              
	float                                              KismetDeathDelayTime;                             		// 0x0398 (0x0004) [0x0000000000000000]              
	struct FVector                                     RMVelocity;                                       		// 0x039C (0x000C) [0x0000000000000000]              
	struct FVector                                     noise1spot;                                       		// 0x03A8 (0x000C) [0x0000000000000000]              
	float                                              noise1time;                                       		// 0x03B4 (0x0004) [0x0000000000000000]              
	class APawn*                                       noise1other;                                      		// 0x03B8 (0x0008) [0x0000000000000000]              
	float                                              noise1loudness;                                   		// 0x03C0 (0x0004) [0x0000000000000000]              
	struct FVector                                     noise2spot;                                       		// 0x03C4 (0x000C) [0x0000000000000000]              
	float                                              noise2time;                                       		// 0x03D0 (0x0004) [0x0000000000000000]              
	class APawn*                                       noise2other;                                      		// 0x03D4 (0x0008) [0x0000000000000000]              
	float                                              noise2loudness;                                   		// 0x03DC (0x0004) [0x0000000000000000]              
	float                                              SoundDampening;                                   		// 0x03E0 (0x0004) [0x0000000000000000]              
	float                                              DamageScaling;                                    		// 0x03E4 (0x0004) [0x0000000000000000]              
	struct FString                                     MenuName;                                         		// 0x03E8 (0x0010) [0x0000000000000000]              
	class UClass*                                      ControllerClass;                                  		// 0x03F8 (0x0008) [0x0000000000000000]              
	class APlayerReplicationInfo*                      PlayerReplicationInfo;                            		// 0x0400 (0x0008) [0x0000000000280000]              ( CPF_Component )
	class ALadderVolume*                               OnLadder;                                         		// 0x0408 (0x0008) [0x0000000000000000]              
	struct FName                                       LandMovementState;                                		// 0x0410 (0x0008) [0x0000000000000000]              
	struct FName                                       WaterMovementState;                               		// 0x0418 (0x0008) [0x0000000000000000]              
	class APlayerStart*                                LastStartSpot;                                    		// 0x0420 (0x0008) [0x0000000000000000]              
	float                                              LastStartTime;                                    		// 0x0428 (0x0004) [0x0000000000000000]              
	struct FVector                                     TakeHitLocation;                                  		// 0x042C (0x000C) [0x0000000000290000]              ( CPF_Travel | CPF_Component )
	class UClass*                                      HitDamageType;                                    		// 0x0438 (0x0008) [0x00000000002A0000]              ( CPF_EditConst | CPF_Component )
	struct FVector                                     TearOffMomentum;                                  		// 0x0440 (0x000C) [0x00000000002B009D]              ( CPF_Edit | CPF_Input | CPF_ExportObject | CPF_OptionalParm | CPF_Parm | CPF_Travel | CPF_EditConst | CPF_Component )
	class USkeletalMeshComponent*                      Mesh;                                             		// 0x044C (0x0008) [0x0000000000000000]              
	class UCylinderComponent*                          CylinderComponent;                                		// 0x0454 (0x0008) [0x0000000000000000]              
	float                                              RBPushRadius;                                     		// 0x045C (0x0004) [0x0000000000000000]              
	float                                              RBPushStrength;                                   		// 0x0460 (0x0004) [0x0000000000000000]              
	class AVehicle*                                    DrivenVehicle;                                    		// 0x0464 (0x0008) [0x00000000002C0000]              ( CPF_GlobalConfig | CPF_Component )
	float                                              AlwaysRelevantDistanceSquared;                    		// 0x046C (0x0004) [0x0000000000000000]              
	float                                              VehicleCheckRadius;                               		// 0x0470 (0x0004) [0x0000000000000000]              
	class AController*                                 LastHitBy;                                        		// 0x0474 (0x0008) [0x0000000000000000]              
	float                                              ViewPitchMin;                                     		// 0x047C (0x0004) [0x0000000000000000]              
	float                                              ViewPitchMax;                                     		// 0x0480 (0x0004) [0x0000000000000000]              
	int                                                AllowedYawError;                                  		// 0x0484 (0x0004) [0x0000000000000000]              
	struct FRotator                                    DesiredRotation;                                  		// 0x0488 (0x000C) [0x0000000000000000]              
	class UClass*                                      InventoryManagerClass;                            		// 0x0494 (0x0008) [0x0000000000000000]              
	class AInventoryManager*                           InvManager;                                       		// 0x049C (0x0008) [0x00000000002D0032]              ( CPF_Const | CPF_OptionalParm | CPF_Net | CPF_Travel | CPF_GlobalConfig | CPF_Component )
	class AWeapon*                                     Weapon;                                           		// 0x04A4 (0x0008) [0x0000000000000000]              
	struct FVector                                     FlashLocation;                                    		// 0x04AC (0x000C) [0x00000000002E0000]              ( CPF_EditConst | CPF_GlobalConfig | CPF_Component )
	struct FVector                                     LastFiringFlashLocation;                          		// 0x04B8 (0x000C) [0x0000000000000000]              
	int                                                ShotCount;                                        		// 0x04C4 (0x0004) [0x0000000000000000]              
	class UPrimitiveComponent*                         PreRagdollCollisionComponent;                     		// 0x04C8 (0x0008) [0x0000000000000000]              
	class URB_BodyInstance*                            PhysicsPushBody;                                  		// 0x04D0 (0x0008) [0x0000000000000000]              
	int                                                FailedLandingCount;                               		// 0x04D8 (0x0004) [0x0000000000000000]              
	TArray< class UAnimNodeSlot* >                     SlotNodes;                                        		// 0x04DC (0x0010) [0x0000000000000000]              
	TArray< class UInterpGroup* >                      InterpGroupList;                                  		// 0x04EC (0x0010) [0x0000000000000000]              
	class UAudioComponent*                             FacialAudioComp;                                  		// 0x04FC (0x0008) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   MIC_PawnMat;                                      		// 0x0504 (0x0008) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   MIC_PawnHair;                                     		// 0x050C (0x0008) [0x0000000000000000]              
	TArray< struct FScalarParameterInterpStruct >      ScalarParameterInterpArray;                       		// 0x0514 (0x0010) [0x0000000000000000]              
	struct FRootMotionCurve                            RootMotionInterpCurve;                            		// 0x0524 (0x0020) [0x0000000000000000]              
	float                                              RootMotionInterpRate;                             		// 0x0544 (0x0004) [0x00000000002F00EC]              ( CPF_Input | CPF_ExportObject | CPF_Net | CPF_EditConstArray | CPF_Parm | CPF_Travel | CPF_EditConst | CPF_GlobalConfig | CPF_Component )
	float                                              RootMotionInterpCurrentTime;                      		// 0x0548 (0x0004) [0x00000000003000EC]              ( CPF_Input | CPF_ExportObject | CPF_Net | CPF_EditConstArray | CPF_Parm )
	struct FVector                                     RootMotionInterpCurveLastValue;                   		// 0x054C (0x000C) [0x00000000003100EC]              ( CPF_Input | CPF_ExportObject | CPF_Net | CPF_EditConstArray | CPF_Parm | CPF_Travel )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Pawn" );

		return pClassPointer;
	};

	void SetMeshLightingChannels ( );
	void OnSetVelocity ( );
	void eventSpeak ( );
	void SetScalarParameterInterp ( );
	void SetRootMotionInterpCurrentTime ( );
	void SetCinematicMode ( );
	void ZeroMovementVariables ( );
	void ClearPathStep ( );
	void DrawPathStep ( );
	void IncrementPathChild ( );
	void IncrementPathStep ( );
	void CreatePathGoalEvaluator ( );
	void CreatePathConstraint ( );
	void AddGoalEvaluator ( );
	void AddPathConstraint ( );
	void ClearConstraints ( );
	void eventSoakPause ( );
	void eventBecomeViewTarget ( );
	void eventMessagePlayer ( );
	void HandleTeleport ( );
	void OnTeleport ( );
	void OnSetMaterial ( );
	void GetDamageScaling ( );
	void DoKismetAttachment ( );
	void eventSpawnedByKismet ( );
	void IsStationary ( );
	void GetCollisionExtent ( );
	void GetCollisionHeight ( );
	void GetCollisionRadius ( );
	void CheatFly ( );
	void CheatGhost ( );
	void CheatWalk ( );
	void PlayWeaponSwitch ( );
	void SetActiveWeapon ( );
	void TossInventory ( );
	void ThrowActiveWeapon ( );
	void DrawHUD ( );
	void FindInventoryType ( );
	void eventCreateInventory ( );
	void AddDefaultInventory ( );
	void eventStopDriving ( );
	void eventStartDriving ( );
	void CanThrowWeapon ( );
	void Suicide ( );
	void GetVehicleBase ( );
	void PlayLanded ( );
	void CannotJumpNow ( );
	void eventPlayFootStepSound ( );
	void eventTornOff ( );
	void PlayDying ( );
	void SetDyingPhysics ( );
	void TurnOff ( );
	void PlayHit ( );
	void PlayDyingSound ( );
	void DoJump ( );
	void CheckWaterJump ( );
	void TakeDrowningDamage ( );
	void eventBreathTimer ( );
	void TouchingWaterVolume ( );
	void eventHeadVolumeChange ( );
	void eventTickSpecial ( );
	void eventLanded ( );
	void eventFalling ( );
	void DelayTriggerDeath ( );
	void Died ( );
	void ThrowWeaponOnDeath ( );
	void eventIsSameTeam ( );
	void GetTeam ( );
	void GetTeamNum ( );
	void eventTakeDamage ( );
	void SetKillInstigator ( );
	void NotifyTakeHit ( );
	void eventTakeRadiusDamageOnBones ( );
	void PruneDamagedBoneList ( );
	void eventHealDamage ( );
	void AdjustDamage ( );
	void SetMovementPhysics ( );
	void Gasp ( );
	void OnGiveInventory ( );
	void OnAssignController ( );
	void eventReceivedNewEvent ( );
	void SpawnDefaultController ( );
	void eventPostBeginPlay ( );
	void eventPreBeginPlay ( );
	void eventDestroyed ( );
	void DetachFromController ( );
	void CrushedBy ( );
	void CanBeBaseForPawn ( );
	void eventBaseChange ( );
	void eventStuckOnPawn ( );
	void JumpOffPawn ( );
	void gibbedBy ( );
	void eventEncroachedBy ( );
	void eventEncroachingOn ( );
	void FaceRotation ( );
	void eventUpdatePawnRotation ( );
	void ClientSetRotation ( );
	void ClientRestart ( );
	void Restart ( );
	void TakeFallingDamage ( );
	void KilledBy ( );
	void AddVelocity ( );
	void HandleMomentum ( );
	void eventStartCrouch ( );
	void eventEndCrouch ( );
	void ShouldCrouch ( );
	void UnCrouch ( );
	void eventOutsideWorldBounds ( );
	void eventFellOutOfWorld ( );
	void eventClientMessage ( );
	void HandlePickup ( );
	void LineOfSightTo ( );
	void SetMoveTarget ( );
	void InGodMode ( );
	void SetViewRotation ( );
	void GetAdjustedAimFor ( );
	void eventInFreeCam ( );
	void eventGetBaseAimRotation ( );
	void eventGetWeaponStartTraceLocation ( );
	void eventGetPawnViewLocation ( );
	void eventGetViewRotation ( );
	void eventGetActorEyesViewPoint ( );
	void ProcessViewRotation ( );
	void IsFirstPerson ( );
	void IsPlayerPawn ( );
	void IsLocallyControlled ( );
	void IsHumanControlled ( );
	void DisplayDebug ( );
	void ClimbLadder ( );
	void EndClimbLadder ( );
	void CanSplash ( );
	void eventSetWalking ( );
	void RangedAttackTime ( );
	void RecommendLongRangedAttack ( );
	void CanGrabLadder ( );
	void DropToGround ( );
	void GetDefaultCameraMode ( );
	void UnPossessed ( );
	void UpdateControllerOnPossess ( );
	void PossessedBy ( );
	void NotifyTeamChanged ( );
	void PlayTeleportEffect ( );
	void GetHumanReadableName ( );
	void NeedToTurn ( );
	void IsFiring ( );
	void HasRangedAttack ( );
	void FireOnRelease ( );
	void TooCloseToAttack ( );
	void CanAttack ( );
	void BotFire ( );
	void WeaponStoppedFiring ( );
	void WeaponFired ( );
	void FlashLocationUpdated ( );
	void ClearFlashLocation ( );
	void SetFlashLocation ( );
	void ClearFlashCount ( );
	void FlashCountUpdated ( );
	void IncrementFlashCount ( );
	void FiringModeUpdated ( );
	void SetFiringMode ( );
	void GetWeaponFiringMode ( );
	void StopFire ( );
	void StartFire ( );
	void StopFiring ( );
	void Reset ( );
	void PlayerChangedTeam ( );
	void SetBaseEyeheight ( );
	void eventSpecialMoveThruEdge ( );
	void SpecialMoveTo ( );
	void TermRagdoll ( );
	void InitRagdoll ( );
	void GetBoundingCylinder ( );
	void ReachedDesiredRotation ( );
	void SetPushesRigidBodies ( );
	void ForceCrouch ( );
	void ReachedPoint ( );
	void ReachedDestination ( );
	void GetBestAnchor ( );
	void SetAnchor ( );
	void SetRemoteViewPitch ( );
	void IsInvisible ( );
	void CanAITargetThisPawn ( );
	void IsValidTeamTargetFor ( );
	void IsValidEnemyTargetFor ( );
	void GetFallDuration ( );
	void SuggestJumpVelocity ( );
	void ValidAnchor ( );
	void AdjustDestination ( );
	void IsAliveAndWell ( );
	void eventReplicatedEvent ( );
	void eventSetSkelControlScale ( );
	void eventSetMorphWeight ( );
	void eventGetActorFaceFXAsset ( );
	void FaceFXAudioFinished ( );
	void OnPlayFaceFXAnim ( );
	void CanActorPlayFaceFXAnim ( );
	void IsActorPlayingFaceFXAnim ( );
	void eventGetFaceFXAudioComponent ( );
	void eventStopActorFaceFXAnim ( );
	void eventPlayActorFaceFXAnim ( );
	void eventMAT_FinishAIGroup ( );
	void eventMAT_BeginAIGroup ( );
	void FinishAIGroup ( );
	void BeginAIGroup ( );
	void eventInterpolationFinished ( );
	void eventInterpolationStarted ( );
	void MAT_SetSkelControlStrength ( );
	void MAT_SetSkelControlScale ( );
	void MAT_SetMorphWeight ( );
	void MAT_SetAnimWeights ( );
	void MAT_SetAnimPosition ( );
	void eventSetAnimPosition ( );
	void MAT_FinishAnimControl ( );
	void eventFinishAnimControl ( );
	void MAT_BeginAnimControl ( );
	void eventBeginAnimControl ( );
	void eventRestoreAnimSetsToDefault ( );
	void eventAnimSetListUpdated ( );
	void AddAnimSets ( );
	void eventBuildScriptAnimSetList ( );
	void UpdateAnimSetList ( );
	void ClearAnimNodes ( );
	void eventCacheAnimNodes ( );
	void eventPostInitAnimTree ( );
	void ReachedMyDestination ( );
	void IsDesiredRotationLocked ( );
	void IsDesiredRotationInUse ( );
	void CheckDesiredRotation ( );
	void ResetDesiredRotation ( );
	void LockDesiredRotation ( );
	void SetDesiredRotation ( );
	void PickWallAdjust ( );
};

UClass* APawn::pClassPointer = NULL;

// Class Engine.Vehicle
// 0x0080 (0x05D8 - 0x0558)
class AVehicle : public APawn
{
public:
	class APawn*                                       Driver;                                           		// 0x0558 (0x0008) [0x0000000000320020]              ( CPF_Net | CPF_EditConst )
	DWORD                                              bDriving : 1;                                     		// 0x0560 (0x0004) [0x0000000000330000] [0x00000001] ( CPF_Travel | CPF_EditConst )
	DWORD                                              bDriverIsVisible : 1;                             		// 0x0560 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAttachDriver : 1;                                		// 0x0560 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bTurnInPlace : 1;                                 		// 0x0560 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bSeparateTurretFocus : 1;                         		// 0x0560 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bFollowLookDir : 1;                               		// 0x0560 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bHasHandbrake : 1;                                		// 0x0560 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bScriptedRise : 1;                                		// 0x0560 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bDuckObstacles : 1;                               		// 0x0560 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bAvoidReversing : 1;                              		// 0x0560 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bRetryPathfindingWithDriver : 1;                  		// 0x0560 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bIgnoreStallZ : 1;                                		// 0x0560 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bDoExtraNetRelevancyTraces : 1;                   		// 0x0560 (0x0004) [0x0000000000000000] [0x00001000] 
	TArray< struct FVector >                           ExitPositions;                                    		// 0x0564 (0x0010) [0x0000000000000000]              
	float                                              ExitRadius;                                       		// 0x0574 (0x0004) [0x0000000000000000]              
	struct FVector                                     ExitOffset;                                       		// 0x0578 (0x000C) [0x0000000000000000]              
	float                                              Steering;                                         		// 0x0584 (0x0004) [0x0000000000000000]              
	float                                              Throttle;                                         		// 0x0588 (0x0004) [0x0000000000000000]              
	float                                              Rise;                                             		// 0x058C (0x0004) [0x0000000000000000]              
	struct FVector                                     TargetLocationAdjustment;                         		// 0x0590 (0x000C) [0x0000000000000000]              
	float                                              DriverDamageMult;                                 		// 0x059C (0x0004) [0x0000000000000000]              
	float                                              MomentumMult;                                     		// 0x05A0 (0x0004) [0x0000000000000000]              
	class UClass*                                      CrushedDamageType;                                		// 0x05A4 (0x0008) [0x0000000000000000]              
	float                                              MinCrushSpeed;                                    		// 0x05AC (0x0004) [0x0000000000000000]              
	float                                              ForceCrushPenetration;                            		// 0x05B0 (0x0004) [0x0000000000000000]              
	unsigned char                                      StuckCount;                                       		// 0x05B4 (0x0001) [0x0000000000000000]              
	float                                              ThrottleTime;                                     		// 0x05B8 (0x0004) [0x0000000000000000]              
	float                                              StuckTime;                                        		// 0x05BC (0x0004) [0x0000000000000000]              
	float                                              OldSteering;                                      		// 0x05C0 (0x0004) [0x0000000000000000]              
	float                                              OnlySteeringStartTime;                            		// 0x05C4 (0x0004) [0x0000000000000000]              
	float                                              OldThrottle;                                      		// 0x05C8 (0x0004) [0x0000000000000000]              
	float                                              AIMoveCheckTime;                                  		// 0x05CC (0x0004) [0x0000000000000000]              
	float                                              VehicleMovingTime;                                		// 0x05D0 (0x0004) [0x0000000000000000]              
	float                                              TurnTime;                                         		// 0x05D4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Vehicle" );

		return pClassPointer;
	};

	void ZeroMovementVariables ( );
	void NotifyDriverTakeHit ( );
	void eventReplicatedEvent ( );
	void DrivingStatusChanged ( );
	void SetDriving ( );
	void eventGetEntryLocation ( );
	void CrushedBy ( );
	void PancakeOther ( );
	void eventEncroachingOn ( );
	void GetCollisionDamageInstigator ( );
	void eventEncroachedBy ( );
	void FaceRotation ( );
	void GetDefaultCameraMode ( );
	void PlayDying ( );
	void DriverDied ( );
	void Died ( );
	void ThrowActiveWeapon ( );
	void AdjustDriverDamage ( );
	void eventTakeDamage ( );
	void SetKillInstigator ( );
	void UnPossessed ( );
	void TryExitPos ( );
	void FindAutoExit ( );
	void PlaceExitingDriver ( );
	void DriverLeft ( );
	void SetInputs ( );
	void eventDriverLeave ( );
	void GetExitRotation ( );
	void eventContinueOnFoot ( );
	void DetachDriver ( );
	void AttachDriver ( );
	void EntryAnnouncement ( );
	void PossessedBy ( );
	void DriverEnter ( );
	void TryToDrive ( );
	void AnySeatAvailable ( );
	void CanEnterVehicle ( );
	void Destroyed_HandleDriver ( );
	void eventDestroyed ( );
	void CheatFly ( );
	void CheatGhost ( );
	void CheatWalk ( );
	void eventPostBeginPlay ( );
	void SetBaseEyeheight ( );
	void PlayerChangedTeam ( );
	void DriverRadiusDamage ( );
	void TakeRadiusDamage ( );
	void GetTargetLocation ( );
	void GetMaxRiseForce ( );
	void Suicide ( );
	void DisplayDebug ( );
	void NotifyTeamChanged ( );
};

UClass* AVehicle::pClassPointer = NULL;

// Class Engine.SVehicle
// 0x0160 (0x0738 - 0x05D8)
class ASVehicle : public AVehicle
{
public:
	struct FPointer                                    PVehicle;                                         		// 0x05D8 (0x0008) [0x0000000000000000]              
	struct FPointer                                    MyVehicleManager;                                 		// 0x05E0 (0x0008) [0x0000000000000000]              
	float                                              ChassisMass;                                      		// 0x05E8 (0x0004) [0x0000000000000000]              
	DWORD                                              bIsTank : 1;                                      		// 0x05EC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnableDebugRendering : 1;                        		// 0x05EC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bInReverseMode : 1;                               		// 0x05EC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bStayUpright : 1;                                 		// 0x05EC (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bUseSuspensionAxis : 1;                           		// 0x05EC (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bUpdateWheelShapes : 1;                           		// 0x05EC (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bVehicleOnGround : 1;                             		// 0x05EC (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bVehicleOnWater : 1;                              		// 0x05EC (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bIsInverted : 1;                                  		// 0x05EC (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bChassisTouchingGround : 1;                       		// 0x05EC (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bWasChassisTouchingGroundLastTick : 1;            		// 0x05EC (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bCanFlip : 1;                                     		// 0x05EC (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bFlipRight : 1;                                   		// 0x05EC (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bIsUprighting : 1;                                		// 0x05EC (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bOutputHandbrake : 1;                             		// 0x05EC (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bHoldingDownHandbrake : 1;                        		// 0x05EC (0x0004) [0x0000000000000000] [0x00008000] 
	int                                                DebugRenderActiveGraphChannelWheel;               		// 0x05F0 (0x0004) [0x0000000000000000]              
	int                                                DebugRenderActiveGraphChannelEngine;              		// 0x05F4 (0x0004) [0x0000000000000000]              
	class USVehicleSimBase*                            SimObj;                                           		// 0x05F8 (0x0008) [0x0000000000000000]              
	TArray< class USVehicleWheel* >                    Wheels;                                           		// 0x0600 (0x0010) [0x0000000000000000]              
	struct FVector                                     COMOffset;                                        		// 0x0610 (0x000C) [0x0000000000000000]              
	struct FVector                                     InertiaTensorMultiplier;                          		// 0x061C (0x000C) [0x0000000000000000]              
	float                                              StayUprightRollResistAngle;                       		// 0x0628 (0x0004) [0x0000000000000000]              
	float                                              StayUprightPitchResistAngle;                      		// 0x062C (0x0004) [0x0000000000000000]              
	float                                              StayUprightStiffness;                             		// 0x0630 (0x0004) [0x0000000000000000]              
	float                                              StayUprightDamping;                               		// 0x0634 (0x0004) [0x0000000000000000]              
	class URB_StayUprightSetup*                        StayUprightConstraintSetup;                       		// 0x0638 (0x0008) [0x0000000000000000]              
	class URB_ConstraintInstance*                      StayUprightConstraintInstance;                    		// 0x0640 (0x0008) [0x0000000000000000]              
	float                                              HeavySuspensionShiftPercent;                      		// 0x0648 (0x0004) [0x0000000000000000]              
	float                                              MaxSpeed;                                         		// 0x064C (0x0004) [0x0000000000340000]              ( CPF_GlobalConfig )
	float                                              MaxAngularVelocity;                               		// 0x0650 (0x0004) [0x0000000000000000]              
	float                                              TimeOffGround;                                    		// 0x0654 (0x0004) [0x0000000000000000]              
	float                                              UprightLiftStrength;                              		// 0x0658 (0x0004) [0x0000000000000000]              
	float                                              UprightTorqueStrength;                            		// 0x065C (0x0004) [0x0000000000000000]              
	float                                              UprightTime;                                      		// 0x0660 (0x0004) [0x0000000000000000]              
	float                                              UprightStartTime;                                 		// 0x0664 (0x0004) [0x0000000000000000]              
	class UAudioComponent*                             EngineSound;                                      		// 0x0668 (0x0008) [0x0000000000000000]              
	class UAudioComponent*                             SquealSound;                                      		// 0x0670 (0x0008) [0x0000000000000000]              
	class USoundCue*                                   CollisionSound;                                   		// 0x0678 (0x0008) [0x0000000000000000]              
	class USoundCue*                                   EnterVehicleSound;                                		// 0x0680 (0x0008) [0x0000000000000000]              
	class USoundCue*                                   ExitVehicleSound;                                 		// 0x0688 (0x0008) [0x0000000000000000]              
	float                                              CollisionIntervalSecs;                            		// 0x0690 (0x0004) [0x0000000000000000]              
	float                                              SquealThreshold;                                  		// 0x0694 (0x0004) [0x0000000000000000]              
	float                                              SquealLatThreshold;                               		// 0x0698 (0x0004) [0x0000000000000000]              
	float                                              LatAngleVolumeMult;                               		// 0x069C (0x0004) [0x0000000000000000]              
	float                                              EngineStartOffsetSecs;                            		// 0x06A0 (0x0004) [0x0000000000000000]              
	float                                              EngineStopOffsetSecs;                             		// 0x06A4 (0x0004) [0x0000000000000000]              
	float                                              LastCollisionSoundTime;                           		// 0x06A8 (0x0004) [0x0000000000000000]              
	float                                              OutputBrake;                                      		// 0x06AC (0x0004) [0x0000000000000000]              
	float                                              OutputGas;                                        		// 0x06B0 (0x0004) [0x0000000000000000]              
	float                                              OutputSteering;                                   		// 0x06B4 (0x0004) [0x0000000000000000]              
	float                                              OutputRise;                                       		// 0x06B8 (0x0004) [0x0000000000000000]              
	float                                              ForwardVel;                                       		// 0x06BC (0x0004) [0x0000000000000000]              
	int                                                NumPoweredWheels;                                 		// 0x06C0 (0x0004) [0x0000000000000000]              
	struct FVector                                     BaseOffset;                                       		// 0x06C4 (0x000C) [0x0000000000000000]              
	float                                              CamDist;                                          		// 0x06D0 (0x0004) [0x0000000000000000]              
	int                                                DriverViewPitch;                                  		// 0x06D4 (0x0004) [0x0000000000000000]              
	int                                                DriverViewYaw;                                    		// 0x06D8 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x06DC (0x0004) MISSED OFFSET
	struct FVehicleState                               VState;                                           		// 0x06E0 (0x0050) [0x0000000000350000]              ( CPF_Travel | CPF_GlobalConfig )
	float                                              AngErrorAccumulator;                              		// 0x0730 (0x0004) [0x0000000000000000]              
	float                                              RadialImpulseScaling;                             		// 0x0734 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SVehicle" );

		return pClassPointer;
	};

	void GetSVehicleDebug ( );
	void HermiteEval ( );
	void DisplayWheelsDebug ( );
	void DisplayDebug ( );
	void PostTeleport ( );
	void eventSuspensionHeavyShift ( );
	void eventRigidBodyCollision ( );
	void DrivingStatusChanged ( );
	void VehiclePlayExitSound ( );
	void VehiclePlayEnterSound ( );
	void StopEngineSoundTimed ( );
	void StopEngineSound ( );
	void StartEngineSoundTimed ( );
	void StartEngineSound ( );
	void HasWheelsOnGround ( );
	void TryToDrive ( );
	void GetDefaultCameraMode ( );
	void CalcCamera ( );
	void Died ( );
	void AddVelocity ( );
	void InitVehicleRagdoll ( );
	void TakeRadiusDamage ( );
	void StopVehicleSounds ( );
	void TurnOff ( );
	void eventDestroyed ( );
	void eventPostInitAnimTree ( );
	void eventPostBeginPlay ( );
	void SetWheelCollision ( );
	void DrawGraphsAndPrintTireSurfaceTypes ( );
	void IsSleeping ( );
	void AddTorque ( );
	void AddImpulse ( );
	void AddForce ( );
};

UClass* ASVehicle::pClassPointer = NULL;

// Class Engine.RB_ConstraintActor
// 0x0034 (0x0278 - 0x0244)
class ARB_ConstraintActor : public ARigidBodyBase
{
public:
	class AActor*                                      ConstraintActor1;                                 		// 0x0244 (0x0008) [0x0000000000000000]              
	class AActor*                                      ConstraintActor2;                                 		// 0x024C (0x0008) [0x0000000000000000]              
	class URB_ConstraintSetup*                         ConstraintSetup;                                  		// 0x0254 (0x0008) [0x0000000000000000]              
	class URB_ConstraintInstance*                      ConstraintInstance;                               		// 0x025C (0x0008) [0x0000000000000000]              
	DWORD                                              bDisableCollision : 1;                            		// 0x0264 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUpdateActor1RefFrame : 1;                        		// 0x0264 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUpdateActor2RefFrame : 1;                        		// 0x0264 (0x0004) [0x0000000000000000] [0x00000004] 
	class AActor*                                      PulleyPivotActor1;                                		// 0x0268 (0x0008) [0x0000000000000000]              
	class AActor*                                      PulleyPivotActor2;                                		// 0x0270 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_ConstraintActor" );

		return pClassPointer;
	};

	void OnToggleConstraintDrive ( );
	void OnToggle ( );
	void OnDestroy ( );
	void TermConstraint ( );
	void InitConstraint ( );
	void SetDisableCollision ( );
};

UClass* ARB_ConstraintActor::pClassPointer = NULL;

// Class Engine.RB_LineImpulseActor
// 0x0015 (0x0259 - 0x0244)
class ARB_LineImpulseActor : public ARigidBodyBase
{
public:
	float                                              ImpulseStrength;                                  		// 0x0244 (0x0004) [0x0000000000000000]              
	float                                              ImpulseRange;                                     		// 0x0248 (0x0004) [0x0000000000000000]              
	DWORD                                              bVelChange : 1;                                   		// 0x024C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bStopAtFirstHit : 1;                              		// 0x024C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCauseFracture : 1;                               		// 0x024C (0x0004) [0x0000000000000000] [0x00000004] 
	class UArrowComponent*                             Arrow;                                            		// 0x0250 (0x0008) [0x0000000000000000]              
	unsigned char                                      ImpulseCount;                                     		// 0x0258 (0x0001) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_LineImpulseActor" );

		return pClassPointer;
	};

	void eventReplicatedEvent ( );
	void OnToggle ( );
	void FireLineImpulse ( );
};

UClass* ARB_LineImpulseActor::pClassPointer = NULL;

// Class Engine.RB_RadialImpulseActor
// 0x0011 (0x0255 - 0x0244)
class ARB_RadialImpulseActor : public ARigidBodyBase
{
public:
	class UDrawSphereComponent*                        RenderComponent;                                  		// 0x0244 (0x0008) [0x0000000000000000]              
	class URB_RadialImpulseComponent*                  ImpulseComponent;                                 		// 0x024C (0x0008) [0x0000000000000000]              
	unsigned char                                      ImpulseCount;                                     		// 0x0254 (0x0001) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_RadialImpulseActor" );

		return pClassPointer;
	};

	void eventReplicatedEvent ( );
	void OnToggle ( );
};

UClass* ARB_RadialImpulseActor::pClassPointer = NULL;

// Class Engine.RB_Thruster
// 0x0008 (0x024C - 0x0244)
class ARB_Thruster : public ARigidBodyBase
{
public:
	DWORD                                              bThrustEnabled : 1;                               		// 0x0244 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              ThrustStrength;                                   		// 0x0248 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_Thruster" );

		return pClassPointer;
	};

	void OnToggle ( );
};

UClass* ARB_Thruster::pClassPointer = NULL;

// Class Engine.WorldAttractor
// 0x00F0 (0x0334 - 0x0244)
class AWorldAttractor : public AActor
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x0244 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              LoopDuration;                                     		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              CurrentTime;                                      		// 0x024C (0x0004) [0x0000000000000000]              
	unsigned char                                      FalloffType;                                      		// 0x0250 (0x0001) [0x0000000000000000]              
	struct FMatineeRawDistributionFloat                FalloffExponent;                                  		// 0x0254 (0x002C) [0x0000000000000000]              
	struct FMatineeRawDistributionFloat                Range;                                            		// 0x0280 (0x002C) [0x0000000000000000]              
	struct FMatineeRawDistributionFloat                Strength;                                         		// 0x02AC (0x002C) [0x0000000000000000]              
	float                                              CollisionRadius;                                  		// 0x02D8 (0x0004) [0x0000000000000000]              
	struct FMatineeRawDistributionFloat                DragCoefficient;                                  		// 0x02DC (0x002C) [0x0000000000000000]              
	struct FMatineeRawDistributionFloat                DragRadius;                                       		// 0x0308 (0x002C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.WorldAttractor" );

		return pClassPointer;
	};

	void OnSetWorldAttractorParam ( );
};

UClass* AWorldAttractor::pClassPointer = NULL;

// Class Engine.FlexForceFieldComponent
// 0x0034 (0x026C - 0x0238)
class UFlexForceFieldComponent : public UPrimitiveComponent
{
public:
	float                                              RotationalFieldStrength;                          		// 0x0238 (0x0004) [0x0000000000000000]              
	float                                              RadialFieldStrength;                              		// 0x023C (0x0004) [0x0000000000000000]              
	float                                              LiftFieldStrength;                                		// 0x0240 (0x0004) [0x0000000000000000]              
	float                                              CapsuleFieldHeight;                               		// 0x0244 (0x0004) [0x0000000000000000]              
	float                                              CapsuleFieldBottomRadius;                         		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              CapsuleFieldTopRadius;                            		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              BoundaryFadePercentage;                           		// 0x0250 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x0254 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FRBCollisionChannelContainer                CollideWithChannels;                              		// 0x0258 (0x0004) [0x0000000000000000]              
	unsigned char                                      CollisionChannel;                                 		// 0x025C (0x0001) [0x0000000000000000]              
	float                                              Duration;                                         		// 0x0260 (0x0004) [0x0000000000000000]              
	float                                              NoiseStrength;                                    		// 0x0264 (0x0004) [0x0000000000000000]              
	float                                              ElapsedTime;                                      		// 0x0268 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FlexForceFieldComponent" );

		return pClassPointer;
	};

	void SetEnabled ( );
	void DoInitRBPhys ( );
};

UClass* UFlexForceFieldComponent::pClassPointer = NULL;

// Class Engine.RB_ConstraintDrawComponent
// 0x0008 (0x0240 - 0x0238)
class URB_ConstraintDrawComponent : public UPrimitiveComponent
{
public:
	class UMaterialInterface*                          LimitMaterial;                                    		// 0x0238 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_ConstraintDrawComponent" );

		return pClassPointer;
	};

};

UClass* URB_ConstraintDrawComponent::pClassPointer = NULL;

// Class Engine.RB_RadialImpulseComponent
// 0x0018 (0x0250 - 0x0238)
class URB_RadialImpulseComponent : public UPrimitiveComponent
{
public:
	unsigned char                                      ImpulseFalloff;                                   		// 0x0238 (0x0001) [0x0000000000000000]              
	float                                              ImpulseStrength;                                  		// 0x023C (0x0004) [0x0000000000000000]              
	float                                              ImpulseRadius;                                    		// 0x0240 (0x0004) [0x0000000000000000]              
	DWORD                                              bVelChange : 1;                                   		// 0x0244 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bCauseFracture : 1;                               		// 0x0244 (0x0004) [0x0000000000000000] [0x00000002] 
	class UDrawSphereComponent*                        PreviewSphere;                                    		// 0x0248 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_RadialImpulseComponent" );

		return pClassPointer;
	};

	void FireImpulse ( );
};

UClass* URB_RadialImpulseComponent::pClassPointer = NULL;

// Class Engine.RB_Handle
// 0x007B (0x0100 - 0x0085)
class URB_Handle : public UActorComponent
{
public:
	class UPrimitiveComponent*                         GrabbedComponent;                                 		// 0x0088 (0x0008) [0x0000000000000000]              
	struct FName                                       GrabbedBoneName;                                  		// 0x0090 (0x0008) [0x0000000000000000]              
	int                                                SceneIndex;                                       		// 0x0098 (0x0004) [0x0000000000000000]              
	DWORD                                              bInHardware : 1;                                  		// 0x009C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bRotationConstrained : 1;                         		// 0x009C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bInterpolating : 1;                               		// 0x009C (0x0004) [0x0000000000000000] [0x00000004] 
	struct FPointer                                    HandleData;                                       		// 0x00A0 (0x0008) [0x0000000000000000]              
	struct FPointer                                    KinActorData;                                     		// 0x00A8 (0x0008) [0x0000000000000000]              
	float                                              LinearDamping;                                    		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              LinearStiffness;                                  		// 0x00B4 (0x0004) [0x0000000000000000]              
	struct FVector                                     LinearStiffnessScale3D;                           		// 0x00B8 (0x000C) [0x0000000000000000]              
	struct FVector                                     LinearDampingScale3D;                             		// 0x00C4 (0x000C) [0x0000000000000000]              
	float                                              AngularDamping;                                   		// 0x00D0 (0x0004) [0x0000000000000000]              
	float                                              AngularStiffness;                                 		// 0x00D4 (0x0004) [0x0000000000000000]              
	float                                              AngularForceLimit;                                		// 0x00D8 (0x0004) [0x0000000000000000]              
	struct FVector                                     Destination;                                      		// 0x00DC (0x000C) [0x0000000000000000]              
	struct FVector                                     StepSize;                                         		// 0x00E8 (0x000C) [0x0000000000000000]              
	struct FVector                                     Location;                                         		// 0x00F4 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_Handle" );

		return pClassPointer;
	};

	void GetOrientation ( );
	void SetOrientation ( );
	void UpdateSmoothLocation ( );
	void SetSmoothLocation ( );
	void SetLocation ( );
	void ReleaseComponent ( );
	void GrabComponent ( );
};

UClass* URB_Handle::pClassPointer = NULL;

// Class Engine.RB_Spring
// 0x0063 (0x00E8 - 0x0085)
class URB_Spring : public UActorComponent
{
public:
	class UPrimitiveComponent*                         Component1;                                       		// 0x0088 (0x0008) [0x0000000000000000]              
	struct FName                                       BoneName1;                                        		// 0x0090 (0x0008) [0x0000000000000000]              
	class UPrimitiveComponent*                         Component2;                                       		// 0x0098 (0x0008) [0x0000000000000000]              
	struct FName                                       BoneName2;                                        		// 0x00A0 (0x0008) [0x0000000000000000]              
	int                                                SceneIndex;                                       		// 0x00A8 (0x0004) [0x0000000000000000]              
	DWORD                                              bInHardware : 1;                                  		// 0x00AC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnableForceMassRatio : 1;                        		// 0x00AC (0x0004) [0x0000000000000000] [0x00000002] 
	struct FPointer                                    SpringData;                                       		// 0x00B0 (0x0008) [0x0000000000000000]              
	float                                              TimeSinceActivation;                              		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              MinBodyMass;                                      		// 0x00BC (0x0004) [0x0000000000000000]              
	float                                              SpringSaturateDist;                               		// 0x00C0 (0x0004) [0x0000000000000000]              
	float                                              SpringMaxForce;                                   		// 0x00C4 (0x0004) [0x0000000000000000]              
	float                                              MaxForceMassRatio;                                		// 0x00C8 (0x0004) [0x0000000000000000]              
	struct FInterpCurveFloat                           SpringMaxForceTimeScale;                          		// 0x00CC (0x0014) [0x0000000000000000]              
	float                                              DampSaturateVel;                                  		// 0x00E0 (0x0004) [0x0000000000000000]              
	float                                              DampMaxForce;                                     		// 0x00E4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_Spring" );

		return pClassPointer;
	};

	void Clear ( );
	void SetComponents ( );
};

UClass* URB_Spring::pClassPointer = NULL;

// Class Engine.SVehicleSimBase
// 0x0043 (0x00C8 - 0x0085)
class USVehicleSimBase : public UActorComponent
{
public:
	float                                              EnginePeakTorque;                                 		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              EngineMaxRPM;                                     		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              WheelSuspensionStiffness;                         		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              WheelSuspensionDamping;                           		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              WheelSuspensionBias;                              		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              WheelLongExtremumSlip;                            		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              WheelLongExtremumValue;                           		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              WheelLongAsymptoteSlip;                           		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              WheelLongAsymptoteValue;                          		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              WheelLatExtremumSlip;                             		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              WheelLatExtremumValue;                            		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              WheelLatAsymptoteSlip;                            		// 0x00B4 (0x0004) [0x0000000000000000]              
	float                                              WheelLatAsymptoteValue;                           		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              WheelInertia;                                     		// 0x00BC (0x0004) [0x0000000000000000]              
	DWORD                                              bWheelSpeedOverride : 1;                          		// 0x00C0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bClampedFrictionModel : 1;                        		// 0x00C0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAutoDrive : 1;                                   		// 0x00C0 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              AutoDriveSteer;                                   		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SVehicleSimBase" );

		return pClassPointer;
	};

};

UClass* USVehicleSimBase::pClassPointer = NULL;

// Class Engine.SVehicleSimCar
// 0x0038 (0x0100 - 0x00C8)
class USVehicleSimCar : public USVehicleSimBase
{
public:
	float                                              ChassisTorqueScale;                               		// 0x00C8 (0x0004) [0x0000000000000000]              
	struct FInterpCurveFloat                           MaxSteerAngleCurve;                               		// 0x00CC (0x0014) [0x0000000000000000]              
	float                                              SteerSpeed;                                       		// 0x00E0 (0x0004) [0x0000000000000000]              
	float                                              ReverseThrottle;                                  		// 0x00E4 (0x0004) [0x0000000000000000]              
	float                                              EngineBrakeFactor;                                		// 0x00E8 (0x0004) [0x0000000000000000]              
	float                                              MaxBrakeTorque;                                   		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              StopThreshold;                                    		// 0x00F0 (0x0004) [0x0000000000000000]              
	DWORD                                              bIsDriving : 1;                                   		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              ActualSteering;                                   		// 0x00F8 (0x0004) [0x0000000000000000]              
	float                                              TimeSinceThrottle;                                		// 0x00FC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SVehicleSimCar" );

		return pClassPointer;
	};

};

UClass* USVehicleSimCar::pClassPointer = NULL;

// Class Engine.SVehicleSimTank
// 0x0030 (0x0130 - 0x0100)
class USVehicleSimTank : public USVehicleSimCar
{
public:
	float                                              LeftTrackVel;                                     		// 0x0100 (0x0004) [0x0000000000000000]              
	float                                              RightTrackVel;                                    		// 0x0104 (0x0004) [0x0000000000000000]              
	float                                              LeftTrackTorque;                                  		// 0x0108 (0x0004) [0x0000000000000000]              
	float                                              RightTrackTorque;                                 		// 0x010C (0x0004) [0x0000000000000000]              
	float                                              MaxEngineTorque;                                  		// 0x0110 (0x0004) [0x0000000000000000]              
	float                                              EngineDamping;                                    		// 0x0114 (0x0004) [0x0000000000000000]              
	float                                              InsideTrackTorqueFactor;                          		// 0x0118 (0x0004) [0x0000000000000000]              
	float                                              SteeringLatStiffnessFactor;                       		// 0x011C (0x0004) [0x0000000000000000]              
	float                                              TurnInPlaceThrottle;                              		// 0x0120 (0x0004) [0x0000000000000000]              
	float                                              TurnMaxGripReduction;                             		// 0x0124 (0x0004) [0x0000000000000000]              
	float                                              TurnGripScaleRate;                                		// 0x0128 (0x0004) [0x0000000000000000]              
	DWORD                                              bTurnInPlaceOnSteer : 1;                          		// 0x012C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SVehicleSimTank" );

		return pClassPointer;
	};

};

UClass* USVehicleSimTank::pClassPointer = NULL;

// Class Engine.ActorFactoryFlexForceField
// 0x0020 (0x00BC - 0x009C)
class UActorFactoryFlexForceField : public UActorFactory
{
public:
	float                                              RotationalFieldStrength;                          		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              RadialFieldStrength;                              		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              LiftFieldStrength;                                		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              CapsuleFieldHeight;                               		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              CapsuleFieldBottomRadius;                         		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              CapsuleFieldTopRadius;                            		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              BoundaryFadePercentage;                           		// 0x00B4 (0x0004) [0x0000000000000000]              
	float                                              Noise;                                            		// 0x00B8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryFlexForceField" );

		return pClassPointer;
	};

};

UClass* UActorFactoryFlexForceField::pClassPointer = NULL;

// Class Engine.ActorFactoryApexClothing
// 0x003C (0x00F0 - 0x00B4)
class UActorFactoryApexClothing : public UActorFactorySkeletalMesh
{
public:
	TArray< class UApexClothingAsset* >                ClothingAssets;                                   		// 0x00B4 (0x0010) [0x0000000000000000]              
	unsigned char                                      ClothingRBChannel;                                		// 0x00C4 (0x0001) [0x0000000000000000]              
	struct FRBCollisionChannelContainer                ClothingRBCollideWithChannels;                    		// 0x00C8 (0x0004) [0x0000000000000000]              
	DWORD                                              bLocalSpaceWind : 1;                              		// 0x00CC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bWindStrengthNoiseCentered : 1;                   		// 0x00CC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bWindDirNoiseCentered : 1;                        		// 0x00CC (0x0004) [0x0000000000000000] [0x00000004] 
	struct FVector                                     WindVelocity;                                     		// 0x00D0 (0x000C) [0x0000000000000000]              
	float                                              WindVelocityBlendTime;                            		// 0x00DC (0x0004) [0x0000000000000000]              
	float                                              WindStrengthNoiseBounds;                          		// 0x00E0 (0x0004) [0x0000000000000000]              
	float                                              WindStrengthNoiseStepSize;                        		// 0x00E4 (0x0004) [0x0000000000000000]              
	float                                              WindDirNoiseBounds;                               		// 0x00E8 (0x0004) [0x0000000000000000]              
	float                                              WindDirNoiseStepSize;                             		// 0x00EC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryApexClothing" );

		return pClassPointer;
	};

};

UClass* UActorFactoryApexClothing::pClassPointer = NULL;

// Class Engine.ApexDestructibleDamageParameters
// 0x0010 (0x0070 - 0x0060)
class UApexDestructibleDamageParameters : public UObject
{
public:
	TArray< struct FDamagePair >                       DamageMap;                                        		// 0x0060 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ApexDestructibleDamageParameters" );

		return pClassPointer;
	};

};

UClass* UApexDestructibleDamageParameters::pClassPointer = NULL;

// Class Engine.FlexContainer
// 0x00B0 (0x0110 - 0x0060)
class UFlexContainer : public UObject
{
public:
	float                                              Radius;                                           		// 0x0060 (0x0004) [0x0000000000000000]              
	TArray< struct FParticleInfo >                     MaxParticlesAtPhysXLevel;                         		// 0x0064 (0x0010) [0x0000000000000000]              
	DWORD                                              bDebugDrawPoints : 1;                             		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFixedTimeStep : 1;                               		// 0x0074 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bEnableCCD : 1;                                   		// 0x0074 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bComplexCollision : 1;                            		// 0x0074 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bFluid : 1;                                       		// 0x0074 (0x0004) [0x0000000000000000] [0x00000010] 
	float                                              DebugDrawSpheres;                                 		// 0x0078 (0x0004) [0x0000000000000000]              
	int                                                NumIterations;                                    		// 0x007C (0x0004) [0x0000000000000000]              
	int                                                NumSubsteps;                                      		// 0x0080 (0x0004) [0x0000000000000000]              
	int                                                MinFrameRate;                                     		// 0x0084 (0x0004) [0x0000000000000000]              
	struct FVector                                     Gravity;                                          		// 0x0088 (0x000C) [0x0000000000000000]              
	float                                              SleepThreshold;                                   		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              MaxVelocity;                                      		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              MaxContainerBound;                                		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              RelaxationFactor;                                 		// 0x00A0 (0x0004) [0x0000000000000000]              
	unsigned char                                      Mode;                                             		// 0x00A4 (0x0001) [0x0000000000000000]              
	unsigned char                                      RBChannel;                                        		// 0x00A5 (0x0001) [0x0000000000000000]              
	struct FRBCollisionChannelContainer                RBCollideWithChannels;                            		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              CellSizeFactor;                                   		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              CollisionMargin;                                  		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              CollisionMarginShapes;                            		// 0x00B4 (0x0004) [0x0000000000000000]              
	float                                              CollisionDistance;                                		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              Friction;                                         		// 0x00BC (0x0004) [0x0000000000000000]              
	float                                              ParticleFriction;                                 		// 0x00C0 (0x0004) [0x0000000000000000]              
	float                                              StaticFriction;                                   		// 0x00C4 (0x0004) [0x0000000000000000]              
	float                                              Restitution;                                      		// 0x00C8 (0x0004) [0x0000000000000000]              
	float                                              ShockPropagation;                                 		// 0x00CC (0x0004) [0x0000000000000000]              
	float                                              Dissipation;                                      		// 0x00D0 (0x0004) [0x0000000000000000]              
	struct FVector                                     Wind;                                             		// 0x00D4 (0x000C) [0x0000000000000000]              
	float                                              Drag;                                             		// 0x00E0 (0x0004) [0x0000000000000000]              
	float                                              Lift;                                             		// 0x00E4 (0x0004) [0x0000000000000000]              
	float                                              RestDistance;                                     		// 0x00E8 (0x0004) [0x0000000000000000]              
	float                                              Adhesion;                                         		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              Cohesion;                                         		// 0x00F0 (0x0004) [0x0000000000000000]              
	float                                              SurfaceTension;                                   		// 0x00F4 (0x0004) [0x0000000000000000]              
	float                                              Viscosity;                                        		// 0x00F8 (0x0004) [0x0000000000000000]              
	float                                              VorticityConfinement;                             		// 0x00FC (0x0004) [0x0000000000000000]              
	float                                              SolidPressure;                                    		// 0x0100 (0x0004) [0x0000000000000000]              
	float                                              FreeSurfaceDrag;                                  		// 0x0104 (0x0004) [0x0000000000000000]              
	float                                              PlasticThreshold;                                 		// 0x0108 (0x0004) [0x0000000000000000]              
	float                                              PlasticCreep;                                     		// 0x010C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FlexContainer" );

		return pClassPointer;
	};

};

UClass* UFlexContainer::pClassPointer = NULL;

// Class Engine.FractureMaterial
// 0x0010 (0x0070 - 0x0060)
class UFractureMaterial : public UObject
{
public:
	class UParticleSystem*                             FractureEffect;                                   		// 0x0060 (0x0008) [0x0000000000000000]              
	class USoundCue*                                   FractureSound;                                    		// 0x0068 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FractureMaterial" );

		return pClassPointer;
	};

};

UClass* UFractureMaterial::pClassPointer = NULL;

// Class Engine.PhysicalMaterial
// 0x008C (0x00EC - 0x0060)
class UPhysicalMaterial : public UObject
{
public:
	struct FPointer                                    PhysXMaterial;                                    		// 0x0060 (0x0008) [0x0000000000000000]              
	int                                                MaterialIndex;                                    		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              Friction;                                         		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              Restitution;                                      		// 0x0070 (0x0004) [0x0000000000000000]              
	DWORD                                              bForceConeFriction : 1;                           		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnableAnisotropicFriction : 1;                   		// 0x0074 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCanSeeThrough : 1;                               		// 0x0074 (0x0004) [0x0000000000000000] [0x00000004] 
	struct FVector                                     AnisoFrictionDir;                                 		// 0x0078 (0x000C) [0x0000000000000000]              
	float                                              FrictionV;                                        		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              Density;                                          		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              AngularDamping;                                   		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              LinearDamping;                                    		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              MagneticResponse;                                 		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              WindResponse;                                     		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              ImpactThreshold;                                  		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              ImpactReFireDelay;                                		// 0x00A0 (0x0004) [0x0000000000000000]              
	class UParticleSystem*                             ImpactEffect;                                     		// 0x00A4 (0x0008) [0x0000000000000000]              
	class UAkBaseSoundObject*                          ImpactSound;                                      		// 0x00AC (0x0008) [0x0000000000000000]              
	float                                              SlideThreshold;                                   		// 0x00B4 (0x0004) [0x0000000000000000]              
	float                                              SlideReFireDelay;                                 		// 0x00B8 (0x0004) [0x0000000000000000]              
	class UParticleSystem*                             SlideEffect;                                      		// 0x00BC (0x0008) [0x0000000000000000]              
	class UAkBaseSoundObject*                          SlideSound;                                       		// 0x00C4 (0x0008) [0x0000000000000000]              
	class UAkBaseSoundObject*                          FractureSoundExplosion;                           		// 0x00CC (0x0008) [0x0000000000000000]              
	class UAkBaseSoundObject*                          FractureSoundSingle;                              		// 0x00D4 (0x0008) [0x0000000000000000]              
	class UPhysicalMaterial*                           Parent;                                           		// 0x00DC (0x0008) [0x0000000000000000]              
	class UPhysicalMaterialPropertyBase*               PhysicalMaterialProperty;                         		// 0x00E4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PhysicalMaterial" );

		return pClassPointer;
	};

	void GetPhysicalMaterialProperty ( );
	void FindFractureSounds ( );
	void FindPhysEffectInfo ( );
};

UClass* UPhysicalMaterial::pClassPointer = NULL;

// Class Engine.PhysicalMaterialPropertyBase
// 0x0001 (0x0061 - 0x0060)
class UPhysicalMaterialPropertyBase : public UObject
{
public:
	unsigned char                                      MaterialType;                                     		// 0x0060 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PhysicalMaterialPropertyBase" );

		return pClassPointer;
	};

};

UClass* UPhysicalMaterialPropertyBase::pClassPointer = NULL;

// Class Engine.PhysicsAsset
// 0x0088 (0x00E8 - 0x0060)
class UPhysicsAsset : public UObject
{
public:
	class USkeletalMesh*                               DefaultSkelMesh;                                  		// 0x0060 (0x0008) [0x0000000000000000]              
	TArray< class URB_BodySetup* >                     BodySetup;                                        		// 0x0068 (0x0010) [0x0000000000000000]              
	struct FMap_Mirror                                 BodySetupIndexMap;                                		// 0x0078 (0x0048) [0x0000000000000000]              
	TArray< int >                                      BoundsBodies;                                     		// 0x00C0 (0x0010) [0x0000000000000000]              
	TArray< class URB_ConstraintSetup* >               ConstraintSetup;                                  		// 0x00D0 (0x0010) [0x0000000000000000]              
	class UPhysicsAssetInstance*                       DefaultInstance;                                  		// 0x00E0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PhysicsAsset" );

		return pClassPointer;
	};

	void FindBodyIndex ( );
};

UClass* UPhysicsAsset::pClassPointer = NULL;

// Class Engine.PhysicsAssetInstance
// 0x0090 (0x00F0 - 0x0060)
class UPhysicsAssetInstance : public UObject
{
public:
	class AActor*                                      Owner;                                            		// 0x0060 (0x0008) [0x0000000000000000]              
	int                                                RootBodyIndex;                                    		// 0x0068 (0x0004) [0x0000000000000000]              
	TArray< class URB_BodyInstance* >                  Bodies;                                           		// 0x006C (0x0010) [0x0000000000000000]              
	TArray< class URB_ConstraintInstance* >            Constraints;                                      		// 0x007C (0x0010) [0x0000000000000000]              
	struct FMap_Mirror                                 CollisionDisableTable;                            		// 0x008C (0x0048) [0x0000000000000000]              
	float                                              LinearSpringScale;                                		// 0x00D4 (0x0004) [0x0000000000000000]              
	float                                              LinearDampingScale;                               		// 0x00D8 (0x0004) [0x0000000000000000]              
	float                                              LinearForceLimitScale;                            		// 0x00DC (0x0004) [0x0000000000000000]              
	float                                              AngularSpringScale;                               		// 0x00E0 (0x0004) [0x0000000000000000]              
	float                                              AngularDampingScale;                              		// 0x00E4 (0x0004) [0x0000000000000000]              
	float                                              AngularForceLimitScale;                           		// 0x00E8 (0x0004) [0x0000000000000000]              
	DWORD                                              bInitBodies : 1;                                  		// 0x00EC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PhysicsAssetInstance" );

		return pClassPointer;
	};

	void FindConstraintInstance ( );
	void FindBodyInstance ( );
	void SetFullAnimWeightBonesFixed ( );
	void SetFullAnimWeightBlockRigidBody ( );
	void SetNamedBodiesBlockRigidBody ( );
	void SetNamedRBBoneSprings ( );
	void SetNamedMotorsAngularVelocityDrive ( );
	void SetNamedMotorsAngularPositionDrive ( );
	void SetAllMotorsAngularDriveParams ( );
	void SetAllMotorsAngularVelocityDrive ( );
	void SetAllMotorsAngularPositionDrive ( );
	void ForceAllBodiesBelowUnfixed ( );
	void SetNamedBodiesFixed ( );
	void SetAllBodiesFixed ( );
	void GetTotalMassBelowBone ( );
	void SetAngularDriveScale ( );
	void SetLinearDriveScale ( );
};

UClass* UPhysicsAssetInstance::pClassPointer = NULL;

// Class Engine.PhysicsLODVerticalEmitter
// 0x0004 (0x0064 - 0x0060)
class UPhysicsLODVerticalEmitter : public UObject
{
public:
	int                                                ParticlePercentage;                               		// 0x0060 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PhysicsLODVerticalEmitter" );

		return pClassPointer;
	};

};

UClass* UPhysicsLODVerticalEmitter::pClassPointer = NULL;

// Class Engine.RB_BodyInstance
// 0x0074 (0x00D4 - 0x0060)
class URB_BodyInstance : public UObject
{
public:
	class UPrimitiveComponent*                         OwnerComponent;                                   		// 0x0060 (0x0008) [0x0000000000000000]              
	int                                                BodyIndex;                                        		// 0x0068 (0x0004) [0x0000000000000000]              
	struct FVector                                     Velocity;                                         		// 0x006C (0x000C) [0x0000000000000000]              
	struct FVector                                     PreviousVelocity;                                 		// 0x0078 (0x000C) [0x0000000000000000]              
	int                                                SceneIndex;                                       		// 0x0084 (0x0004) [0x0000000000000000]              
	struct FPointer                                    BodyData;                                         		// 0x0088 (0x0008) [0x0000000000000000]              
	struct FPointer                                    BoneSpring;                                       		// 0x0090 (0x0008) [0x0000000000000000]              
	struct FPointer                                    BoneSpringKinActor;                               		// 0x0098 (0x0008) [0x0000000000000000]              
	DWORD                                              bEnableBoneSpringLinear : 1;                      		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnableBoneSpringAngular : 1;                     		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDisableOnOverextension : 1;                      		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bNotifyOwnerOnOverextension : 1;                  		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bTeleportOnOverextension : 1;                     		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bUseKinActorForBoneSpring : 1;                    		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bMakeSpringToBaseCollisionComponent : 1;          		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bOnlyCollideWithPawns : 1;                        		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bEnableCollisionResponse : 1;                     		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bPushBody : 1;                                    		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bForceUnfixed : 1;                                		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bInstanceAlwaysFullAnimWeight : 1;                		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000800] 
	float                                              BoneLinearSpring;                                 		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              BoneLinearDamping;                                		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              BoneAngularSpring;                                		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              BoneAngularDamping;                               		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              OverextensionThreshold;                           		// 0x00B4 (0x0004) [0x0000000000000000]              
	float                                              CustomGravityFactor;                              		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              LastEffectPlayedTime;                             		// 0x00BC (0x0004) [0x0000000000000000]              
	class UPhysicalMaterial*                           PhysMaterialOverride;                             		// 0x00C0 (0x0008) [0x0000000000000000]              
	float                                              ContactReportForceThreshold;                      		// 0x00C8 (0x0004) [0x0000000000000000]              
	float                                              InstanceMassScale;                                		// 0x00CC (0x0004) [0x0000000000000000]              
	float                                              InstanceDampingScale;                             		// 0x00D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_BodyInstance" );

		return pClassPointer;
	};

	void UpdateDampingProperties ( );
	void UpdateMassProperties ( );
	void SetContactReportForceThreshold ( );
	void EnableCollisionResponse ( );
	void SetPhysMaterialOverride ( );
	void SetBlockRigidBody ( );
	void SetBoneSpringTarget ( );
	void SetBoneSpringParams ( );
	void EnableBoneSpring ( );
	void GetUnrealWorldVelocityAtPoint ( );
	void GetUnrealWorldAngularVelocity ( );
	void GetUnrealWorldVelocity ( );
	void GetUnrealWorldTM ( );
	void GetPhysicsAssetInstance ( );
	void IsValidBodyInstance ( );
	void IsFixed ( );
	void SetFixed ( );
	void GetBodyMass ( );
};

UClass* URB_BodyInstance::pClassPointer = NULL;

// Class Engine.RB_ConstraintInstance
// 0x0080 (0x00E0 - 0x0060)
class URB_ConstraintInstance : public UObject
{
public:
	class AActor*                                      Owner;                                            		// 0x0060 (0x0008) [0x0000000000000000]              
	class UPrimitiveComponent*                         OwnerComponent;                                   		// 0x0068 (0x0008) [0x0000000000000000]              
	int                                                ConstraintIndex;                                  		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                SceneIndex;                                       		// 0x0074 (0x0004) [0x0000000000000000]              
	DWORD                                              bInHardware : 1;                                  		// 0x0078 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLinearXPositionDrive : 1;                        		// 0x0078 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bLinearXVelocityDrive : 1;                        		// 0x0078 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bLinearYPositionDrive : 1;                        		// 0x0078 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bLinearYVelocityDrive : 1;                        		// 0x0078 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bLinearZPositionDrive : 1;                        		// 0x0078 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bLinearZVelocityDrive : 1;                        		// 0x0078 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bSwingPositionDrive : 1;                          		// 0x0078 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bSwingVelocityDrive : 1;                          		// 0x0078 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bTwistPositionDrive : 1;                          		// 0x0078 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bTwistVelocityDrive : 1;                          		// 0x0078 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bAngularSlerpDrive : 1;                           		// 0x0078 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bTerminated : 1;                                  		// 0x0078 (0x0004) [0x0000000000000000] [0x00001000] 
	struct FPointer                                    ConstraintData;                                   		// 0x007C (0x0008) [0x0000000000000000]              
	struct FPointer                                    PulleyJoint;                                      		// 0x0084 (0x0008) [0x0000000000000000]              
	struct FVector                                     LinearPositionTarget;                             		// 0x008C (0x000C) [0x0000000000000000]              
	struct FVector                                     LinearVelocityTarget;                             		// 0x0098 (0x000C) [0x0000000000000000]              
	float                                              LinearDriveSpring;                                		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              LinearDriveDamping;                               		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              LinearDriveForceLimit;                            		// 0x00AC (0x0004) [0x0000000000000000]              
	struct FQuat                                       AngularPositionTarget;                            		// 0x00B0 (0x0010) [0x0000000000000000]              
	struct FVector                                     AngularVelocityTarget;                            		// 0x00C0 (0x000C) [0x0000000000000000]              
	float                                              AngularDriveSpring;                               		// 0x00CC (0x0004) [0x0000000000000000]              
	float                                              AngularDriveDamping;                              		// 0x00D0 (0x0004) [0x0000000000000000]              
	float                                              AngularDriveForceLimit;                           		// 0x00D4 (0x0004) [0x0000000000000000]              
	struct FPointer                                    DummyKinActor;                                    		// 0x00D8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_ConstraintInstance" );

		return pClassPointer;
	};

	void MoveKinActorTransform ( );
	void SetLinearLimitSize ( );
	void SetAngularDOFLimitScale ( );
	void SetAngularDriveParams ( );
	void SetAngularVelocityTarget ( );
	void SetAngularPositionTarget ( );
	void SetLinearDriveParams ( );
	void SetLinearVelocityTarget ( );
	void SetLinearPositionTarget ( );
	void SetAngularVelocityDrive ( );
	void SetAngularPositionDrive ( );
	void SetLinearVelocityDrive ( );
	void SetLinearPositionDrive ( );
	void GetConstraintLocation ( );
	void GetPhysicsAssetInstance ( );
	void TermConstraint ( );
	void InitConstraint ( );
};

UClass* URB_ConstraintInstance::pClassPointer = NULL;

// Class Engine.RB_ConstraintSetup
// 0x00C4 (0x0124 - 0x0060)
class URB_ConstraintSetup : public UObject
{
public:
	struct FName                                       JointName;                                        		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FName                                       ConstraintBone1;                                  		// 0x0068 (0x0008) [0x0000000000000000]              
	struct FName                                       ConstraintBone2;                                  		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FVector                                     Pos1;                                             		// 0x0078 (0x000C) [0x0000000000000000]              
	struct FVector                                     PriAxis1;                                         		// 0x0084 (0x000C) [0x0000000000000000]              
	struct FVector                                     SecAxis1;                                         		// 0x0090 (0x000C) [0x0000000000000000]              
	struct FVector                                     Pos2;                                             		// 0x009C (0x000C) [0x0000000000000000]              
	struct FVector                                     PriAxis2;                                         		// 0x00A8 (0x000C) [0x0000000000000000]              
	struct FVector                                     SecAxis2;                                         		// 0x00B4 (0x000C) [0x0000000000000000]              
	struct FVector                                     PulleyPivot1;                                     		// 0x00C0 (0x000C) [0x0000000000000000]              
	struct FVector                                     PulleyPivot2;                                     		// 0x00CC (0x000C) [0x0000000000000000]              
	DWORD                                              bEnableProjection : 1;                            		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLinearLimitSoft : 1;                             		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bLinearBreakable : 1;                             		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bSwingLimited : 1;                                		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bTwistLimited : 1;                                		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bSwingLimitSoft : 1;                              		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bTwistLimitSoft : 1;                              		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bAngularBreakable : 1;                            		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bIsPulley : 1;                                    		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bMaintainMinDistance : 1;                         		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000200] 
	struct FLinearDOFSetup                             LinearXSetup;                                     		// 0x00DC (0x0008) [0x0000000000000000]              
	struct FLinearDOFSetup                             LinearYSetup;                                     		// 0x00E4 (0x0008) [0x0000000000000000]              
	struct FLinearDOFSetup                             LinearZSetup;                                     		// 0x00EC (0x0008) [0x0000000000000000]              
	float                                              LinearLimitStiffness;                             		// 0x00F4 (0x0004) [0x0000000000000000]              
	float                                              LinearLimitDamping;                               		// 0x00F8 (0x0004) [0x0000000000000000]              
	float                                              LinearBreakThreshold;                             		// 0x00FC (0x0004) [0x0000000000000000]              
	float                                              Swing1LimitAngle;                                 		// 0x0100 (0x0004) [0x0000000000000000]              
	float                                              Swing2LimitAngle;                                 		// 0x0104 (0x0004) [0x0000000000000000]              
	float                                              TwistLimitAngle;                                  		// 0x0108 (0x0004) [0x0000000000000000]              
	float                                              SwingLimitStiffness;                              		// 0x010C (0x0004) [0x0000000000000000]              
	float                                              SwingLimitDamping;                                		// 0x0110 (0x0004) [0x0000000000000000]              
	float                                              TwistLimitStiffness;                              		// 0x0114 (0x0004) [0x0000000000000000]              
	float                                              TwistLimitDamping;                                		// 0x0118 (0x0004) [0x0000000000000000]              
	float                                              AngularBreakThreshold;                            		// 0x011C (0x0004) [0x0000000000000000]              
	float                                              PulleyRatio;                                      		// 0x0120 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_ConstraintSetup" );

		return pClassPointer;
	};

};

UClass* URB_ConstraintSetup::pClassPointer = NULL;

// Class Engine.RB_BSJointSetup
// 0x0000 (0x0124 - 0x0124)
class URB_BSJointSetup : public URB_ConstraintSetup
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_BSJointSetup" );

		return pClassPointer;
	};

};

UClass* URB_BSJointSetup::pClassPointer = NULL;

// Class Engine.RB_DistanceJointSetup
// 0x0000 (0x0124 - 0x0124)
class URB_DistanceJointSetup : public URB_ConstraintSetup
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_DistanceJointSetup" );

		return pClassPointer;
	};

};

UClass* URB_DistanceJointSetup::pClassPointer = NULL;

// Class Engine.RB_HingeSetup
// 0x0000 (0x0124 - 0x0124)
class URB_HingeSetup : public URB_ConstraintSetup
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_HingeSetup" );

		return pClassPointer;
	};

};

UClass* URB_HingeSetup::pClassPointer = NULL;

// Class Engine.RB_PrismaticSetup
// 0x0000 (0x0124 - 0x0124)
class URB_PrismaticSetup : public URB_ConstraintSetup
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_PrismaticSetup" );

		return pClassPointer;
	};

};

UClass* URB_PrismaticSetup::pClassPointer = NULL;

// Class Engine.RB_PulleyJointSetup
// 0x0000 (0x0124 - 0x0124)
class URB_PulleyJointSetup : public URB_ConstraintSetup
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_PulleyJointSetup" );

		return pClassPointer;
	};

};

UClass* URB_PulleyJointSetup::pClassPointer = NULL;

// Class Engine.RB_SkelJointSetup
// 0x0000 (0x0124 - 0x0124)
class URB_SkelJointSetup : public URB_ConstraintSetup
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_SkelJointSetup" );

		return pClassPointer;
	};

};

UClass* URB_SkelJointSetup::pClassPointer = NULL;

// Class Engine.RB_StayUprightSetup
// 0x0000 (0x0124 - 0x0124)
class URB_StayUprightSetup : public URB_ConstraintSetup
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_StayUprightSetup" );

		return pClassPointer;
	};

};

UClass* URB_StayUprightSetup::pClassPointer = NULL;

// Class Engine.SVehicleWheel
// 0x00E8 (0x0158 - 0x0070)
class USVehicleWheel : public UComponent
{
public:
	float                                              Steer;                                            		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              MotorTorque;                                      		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              BrakeTorque;                                      		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              ChassisTorque;                                    		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              HandBrakeTorque;                                  		// 0x0080 (0x0004) [0x0000000000000000]              
	DWORD                                              bPoweredWheel : 1;                                		// 0x0084 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bHoverWheel : 1;                                  		// 0x0084 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCollidesVehicles : 1;                            		// 0x0084 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bCollidesPawns : 1;                               		// 0x0084 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bIsSquealing : 1;                                 		// 0x0084 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bWheelOnGround : 1;                               		// 0x0084 (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              SteerFactor;                                      		// 0x0088 (0x0004) [0x0000000000000000]              
	struct FName                                       SkelControlName;                                  		// 0x008C (0x0008) [0x0000000000000000]              
	class USkelControlWheel*                           WheelControl;                                     		// 0x0094 (0x0008) [0x0000000000000000]              
	struct FName                                       BoneName;                                         		// 0x009C (0x0008) [0x0000000000000000]              
	struct FVector                                     BoneOffset;                                       		// 0x00A4 (0x000C) [0x0000000000000000]              
	float                                              WheelRadius;                                      		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              WheelWidth;                                       		// 0x00B4 (0x0004) [0x0000000000000000]              
	float                                              SuspensionTravel;                                 		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              SuspensionSpeed;                                  		// 0x00BC (0x0004) [0x0000000000000000]              
	class UParticleSystem*                             WheelParticleSystem;                              		// 0x00C0 (0x0008) [0x0000000000000000]              
	unsigned char                                      Side;                                             		// 0x00C8 (0x0001) [0x0000000000000000]              
	float                                              LongSlipFactor;                                   		// 0x00CC (0x0004) [0x0000000000000000]              
	float                                              LatSlipFactor;                                    		// 0x00D0 (0x0004) [0x0000000000000000]              
	float                                              HandbrakeLongSlipFactor;                          		// 0x00D4 (0x0004) [0x0000000000000000]              
	float                                              HandbrakeLatSlipFactor;                           		// 0x00D8 (0x0004) [0x0000000000000000]              
	float                                              ParkedSlipFactor;                                 		// 0x00DC (0x0004) [0x0000000000000000]              
	struct FVector                                     WheelPosition;                                    		// 0x00E0 (0x000C) [0x0000000000000000]              
	float                                              SpinVel;                                          		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              LongSlipRatio;                                    		// 0x00F0 (0x0004) [0x0000000000000000]              
	float                                              LatSlipAngle;                                     		// 0x00F4 (0x0004) [0x0000000000000000]              
	struct FVector                                     ContactNormal;                                    		// 0x00F8 (0x000C) [0x0000000000000000]              
	struct FVector                                     LongDirection;                                    		// 0x0104 (0x000C) [0x0000000000000000]              
	struct FVector                                     LatDirection;                                     		// 0x0110 (0x000C) [0x0000000000000000]              
	float                                              ContactForce;                                     		// 0x011C (0x0004) [0x0000000000000000]              
	float                                              LongImpulse;                                      		// 0x0120 (0x0004) [0x0000000000000000]              
	float                                              LatImpulse;                                       		// 0x0124 (0x0004) [0x0000000000000000]              
	float                                              DesiredSuspensionPosition;                        		// 0x0128 (0x0004) [0x0000000000000000]              
	float                                              SuspensionPosition;                               		// 0x012C (0x0004) [0x0000000000000000]              
	float                                              CurrentRotation;                                  		// 0x0130 (0x0004) [0x0000000000000000]              
	struct FPointer                                    WheelShape;                                       		// 0x0134 (0x0008) [0x0000000000000000]              
	int                                                WheelMaterialIndex;                               		// 0x013C (0x0004) [0x0000000000000000]              
	class UClass*                                      WheelPSCClass;                                    		// 0x0140 (0x0008) [0x0000000000000000]              
	class UParticleSystemComponent*                    WheelParticleComp;                                		// 0x0148 (0x0008) [0x0000000000000000]              
	struct FName                                       SlipParticleParamName;                            		// 0x0150 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SVehicleWheel" );

		return pClassPointer;
	};

};

UClass* USVehicleWheel::pClassPointer = NULL;

// Class Engine.NxGenericForceFieldBrush
// 0x00E0 (0x0360 - 0x0280)
class ANxGenericForceFieldBrush : public AVolume
{
public:
	int                                                ExcludeChannel;                                   		// 0x0280 (0x0004) [0x0000000000000000]              
	struct FRBCollisionChannelContainer                CollideWithChannels;                              		// 0x0284 (0x0004) [0x0000000000000000]              
	unsigned char                                      RBChannel;                                        		// 0x0288 (0x0001) [0x0000000000000000]              
	unsigned char                                      Coordinates;                                      		// 0x0289 (0x0001) [0x0000000000000000]              
	struct FVector                                     Constant;                                         		// 0x028C (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionMultiplierX;                              		// 0x0298 (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionMultiplierY;                              		// 0x02A4 (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionMultiplierZ;                              		// 0x02B0 (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionTarget;                                   		// 0x02BC (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityMultiplierX;                              		// 0x02C8 (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityMultiplierY;                              		// 0x02D4 (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityMultiplierZ;                              		// 0x02E0 (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityTarget;                                   		// 0x02EC (0x000C) [0x0000000000000000]              
	struct FVector                                     Noise;                                            		// 0x02F8 (0x000C) [0x0000000000000000]              
	struct FVector                                     FalloffLinear;                                    		// 0x0304 (0x000C) [0x0000000000000000]              
	struct FVector                                     FalloffQuadratic;                                 		// 0x0310 (0x000C) [0x0000000000000000]              
	float                                              TorusRadius;                                      		// 0x031C (0x0004) [0x0000000000000000]              
	struct FPointer                                    ForceField;                                       		// 0x0320 (0x0008) [0x0000000000000000]              
	TArray< struct FPointer >                          ConvexMeshes;                                     		// 0x0328 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          ExclusionShapes;                                  		// 0x0338 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          ExclusionShapePoses;                              		// 0x0348 (0x0010) [0x0000000000000000]              
	struct FPointer                                    LinearKernel;                                     		// 0x0358 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxGenericForceFieldBrush" );

		return pClassPointer;
	};

	void StopsProjectile ( );
	void eventPostBeginPlay ( );
};

UClass* ANxGenericForceFieldBrush::pClassPointer = NULL;

// Class Engine.RB_ForceFieldExcludeVolume
// 0x0008 (0x0288 - 0x0280)
class ARB_ForceFieldExcludeVolume : public AVolume
{
public:
	int                                                ForceFieldChannel;                                		// 0x0280 (0x0004) [0x0000000000000000]              
	int                                                SceneIndex;                                       		// 0x0284 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_ForceFieldExcludeVolume" );

		return pClassPointer;
	};

};

UClass* ARB_ForceFieldExcludeVolume::pClassPointer = NULL;

// Class Engine.NxForceField
// 0x0054 (0x0298 - 0x0244)
class ANxForceField : public AActor
{
public:
	int                                                ExcludeChannel;                                   		// 0x0244 (0x0004) [0x0000000000000000]              
	DWORD                                              bForceActive : 1;                                 		// 0x0248 (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )
	struct FRBCollisionChannelContainer                CollideWithChannels;                              		// 0x024C (0x0004) [0x0000000000000000]              
	unsigned char                                      RBChannel;                                        		// 0x0250 (0x0001) [0x0000000000000000]              
	struct FPointer                                    ForceField;                                       		// 0x0254 (0x0008) [0x0000000000000000]              
	TArray< struct FPointer >                          ConvexMeshes;                                     		// 0x025C (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          ExclusionShapes;                                  		// 0x026C (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          ExclusionShapePoses;                              		// 0x027C (0x0010) [0x0000000000000000]              
	struct FPointer                                    U2NRotation;                                      		// 0x028C (0x0008) [0x0000000000000000]              
	int                                                SceneIndex;                                       		// 0x0294 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxForceField" );

		return pClassPointer;
	};

	void OnToggle ( );
	void DoInitRBPhys ( );
};

UClass* ANxForceField::pClassPointer = NULL;

// Class Engine.NxCylindricalForceField
// 0x0030 (0x02C8 - 0x0298)
class ANxCylindricalForceField : public ANxForceField
{
public:
	float                                              RadialStrength;                                   		// 0x0298 (0x0004) [0x0000000000000000]              
	float                                              RotationalStrength;                               		// 0x029C (0x0004) [0x0000000000000000]              
	float                                              LiftStrength;                                     		// 0x02A0 (0x0004) [0x0000000000000000]              
	float                                              ForceRadius;                                      		// 0x02A4 (0x0004) [0x0000000000000000]              
	float                                              ForceTopRadius;                                   		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              LiftFalloffHeight;                                		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              EscapeVelocity;                                   		// 0x02B0 (0x0004) [0x0000000000000000]              
	float                                              ForceHeight;                                      		// 0x02B4 (0x0004) [0x0000000000000000]              
	float                                              HeightOffset;                                     		// 0x02B8 (0x0004) [0x0000000000000000]              
	DWORD                                              UseSpecialRadialForce : 1;                        		// 0x02BC (0x0004) [0x0000000000000000] [0x00000001] 
	struct FPointer                                    Kernel;                                           		// 0x02C0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxCylindricalForceField" );

		return pClassPointer;
	};

};

UClass* ANxCylindricalForceField::pClassPointer = NULL;

// Class Engine.NxCylindricalForceFieldCapsule
// 0x0008 (0x02D0 - 0x02C8)
class ANxCylindricalForceFieldCapsule : public ANxCylindricalForceField
{
public:
	class UDrawCapsuleComponent*                       RenderComponent;                                  		// 0x02C8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxCylindricalForceFieldCapsule" );

		return pClassPointer;
	};

	void DoInitRBPhys ( );
};

UClass* ANxCylindricalForceFieldCapsule::pClassPointer = NULL;

// Class Engine.NxForceFieldGeneric
// 0x00BC (0x0354 - 0x0298)
class ANxForceFieldGeneric : public ANxForceField
{
public:
	class UForceFieldShape*                            Shape;                                            		// 0x0298 (0x0008) [0x0000000000000000]              
	class UActorComponent*                             DrawComponent;                                    		// 0x02A0 (0x0008) [0x0000000000000000]              
	float                                              RoughExtentX;                                     		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              RoughExtentY;                                     		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              RoughExtentZ;                                     		// 0x02B0 (0x0004) [0x0000000000000000]              
	unsigned char                                      Coordinates;                                      		// 0x02B4 (0x0001) [0x0000000000000000]              
	struct FVector                                     Constant;                                         		// 0x02B8 (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionMultiplierX;                              		// 0x02C4 (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionMultiplierY;                              		// 0x02D0 (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionMultiplierZ;                              		// 0x02DC (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionTarget;                                   		// 0x02E8 (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityMultiplierX;                              		// 0x02F4 (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityMultiplierY;                              		// 0x0300 (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityMultiplierZ;                              		// 0x030C (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityTarget;                                   		// 0x0318 (0x000C) [0x0000000000000000]              
	struct FVector                                     Noise;                                            		// 0x0324 (0x000C) [0x0000000000000000]              
	struct FVector                                     FalloffLinear;                                    		// 0x0330 (0x000C) [0x0000000000000000]              
	struct FVector                                     FalloffQuadratic;                                 		// 0x033C (0x000C) [0x0000000000000000]              
	float                                              TorusRadius;                                      		// 0x0348 (0x0004) [0x0000000000000000]              
	struct FPointer                                    LinearKernel;                                     		// 0x034C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxForceFieldGeneric" );

		return pClassPointer;
	};

	void DoInitRBPhys ( );
};

UClass* ANxForceFieldGeneric::pClassPointer = NULL;

// Class Engine.NxForceFieldRadial
// 0x0028 (0x02C0 - 0x0298)
class ANxForceFieldRadial : public ANxForceField
{
public:
	class UForceFieldShape*                            Shape;                                            		// 0x0298 (0x0008) [0x0000000000000000]              
	class UActorComponent*                             DrawComponent;                                    		// 0x02A0 (0x0008) [0x0000000000000000]              
	float                                              ForceStrength;                                    		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              ForceRadius;                                      		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              SelfRotationStrength;                             		// 0x02B0 (0x0004) [0x0000000000000000]              
	unsigned char                                      ForceFalloff;                                     		// 0x02B4 (0x0001) [0x0000000000000000]              
	struct FPointer                                    Kernel;                                           		// 0x02B8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxForceFieldRadial" );

		return pClassPointer;
	};

	void DoInitRBPhys ( );
};

UClass* ANxForceFieldRadial::pClassPointer = NULL;

// Class Engine.NxForceFieldTornado
// 0x0044 (0x02DC - 0x0298)
class ANxForceFieldTornado : public ANxForceField
{
public:
	class UForceFieldShape*                            Shape;                                            		// 0x0298 (0x0008) [0x0000000000000000]              
	class UActorComponent*                             DrawComponent;                                    		// 0x02A0 (0x0008) [0x0000000000000000]              
	float                                              RadialStrength;                                   		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              RotationalStrength;                               		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              LiftStrength;                                     		// 0x02B0 (0x0004) [0x0000000000000000]              
	float                                              ForceRadius;                                      		// 0x02B4 (0x0004) [0x0000000000000000]              
	float                                              ForceTopRadius;                                   		// 0x02B8 (0x0004) [0x0000000000000000]              
	float                                              LiftFalloffHeight;                                		// 0x02BC (0x0004) [0x0000000000000000]              
	float                                              EscapeVelocity;                                   		// 0x02C0 (0x0004) [0x0000000000000000]              
	float                                              ForceHeight;                                      		// 0x02C4 (0x0004) [0x0000000000000000]              
	float                                              HeightOffset;                                     		// 0x02C8 (0x0004) [0x0000000000000000]              
	DWORD                                              BSpecialRadialForceMode : 1;                      		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              SelfRotationStrength;                             		// 0x02D0 (0x0004) [0x0000000000000000]              
	struct FPointer                                    Kernel;                                           		// 0x02D4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxForceFieldTornado" );

		return pClassPointer;
	};

	void DoInitRBPhys ( );
};

UClass* ANxForceFieldTornado::pClassPointer = NULL;

// Class Engine.NxGenericForceField
// 0x00A0 (0x0338 - 0x0298)
class ANxGenericForceField : public ANxForceField
{
public:
	unsigned char                                      Coordinates;                                      		// 0x0298 (0x0001) [0x0000000000000000]              
	struct FVector                                     Constant;                                         		// 0x029C (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionMultiplierX;                              		// 0x02A8 (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionMultiplierY;                              		// 0x02B4 (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionMultiplierZ;                              		// 0x02C0 (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionTarget;                                   		// 0x02CC (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityMultiplierX;                              		// 0x02D8 (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityMultiplierY;                              		// 0x02E4 (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityMultiplierZ;                              		// 0x02F0 (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityTarget;                                   		// 0x02FC (0x000C) [0x0000000000000000]              
	struct FVector                                     Noise;                                            		// 0x0308 (0x000C) [0x0000000000000000]              
	struct FVector                                     FalloffLinear;                                    		// 0x0314 (0x000C) [0x0000000000000000]              
	struct FVector                                     FalloffQuadratic;                                 		// 0x0320 (0x000C) [0x0000000000000000]              
	float                                              TorusRadius;                                      		// 0x032C (0x0004) [0x0000000000000000]              
	struct FPointer                                    LinearKernel;                                     		// 0x0330 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxGenericForceField" );

		return pClassPointer;
	};

};

UClass* ANxGenericForceField::pClassPointer = NULL;

// Class Engine.NxGenericForceFieldBox
// 0x0014 (0x034C - 0x0338)
class ANxGenericForceFieldBox : public ANxGenericForceField
{
public:
	class UDrawBoxComponent*                           RenderComponent;                                  		// 0x0338 (0x0008) [0x0000000000000000]              
	struct FVector                                     BoxExtent;                                        		// 0x0340 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxGenericForceFieldBox" );

		return pClassPointer;
	};

	void DoInitRBPhys ( );
};

UClass* ANxGenericForceFieldBox::pClassPointer = NULL;

// Class Engine.NxGenericForceFieldCapsule
// 0x0010 (0x0348 - 0x0338)
class ANxGenericForceFieldCapsule : public ANxGenericForceField
{
public:
	class UDrawCapsuleComponent*                       RenderComponent;                                  		// 0x0338 (0x0008) [0x0000000000000000]              
	float                                              CapsuleHeight;                                    		// 0x0340 (0x0004) [0x0000000000000000]              
	float                                              CapsuleRadius;                                    		// 0x0344 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxGenericForceFieldCapsule" );

		return pClassPointer;
	};

};

UClass* ANxGenericForceFieldCapsule::pClassPointer = NULL;

// Class Engine.NxRadialForceField
// 0x001C (0x02B4 - 0x0298)
class ANxRadialForceField : public ANxForceField
{
public:
	class UDrawSphereComponent*                        RenderComponent;                                  		// 0x0298 (0x0008) [0x0000000000000000]              
	float                                              ForceStrength;                                    		// 0x02A0 (0x0004) [0x0000000000000000]              
	float                                              ForceRadius;                                      		// 0x02A4 (0x0004) [0x0000000000000000]              
	unsigned char                                      ForceFalloff;                                     		// 0x02A8 (0x0001) [0x0000000000000000]              
	struct FPointer                                    LinearKernel;                                     		// 0x02AC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxRadialForceField" );

		return pClassPointer;
	};

};

UClass* ANxRadialForceField::pClassPointer = NULL;

// Class Engine.NxRadialCustomForceField
// 0x000C (0x02C0 - 0x02B4)
class ANxRadialCustomForceField : public ANxRadialForceField
{
public:
	float                                              SelfRotationStrength;                             		// 0x02B4 (0x0004) [0x0000000000000000]              
	struct FPointer                                    Kernel;                                           		// 0x02B8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxRadialCustomForceField" );

		return pClassPointer;
	};

};

UClass* ANxRadialCustomForceField::pClassPointer = NULL;

// Class Engine.NxTornadoAngularForceField
// 0x0034 (0x02CC - 0x0298)
class ANxTornadoAngularForceField : public ANxForceField
{
public:
	float                                              RadialStrength;                                   		// 0x0298 (0x0004) [0x0000000000000000]              
	float                                              RotationalStrength;                               		// 0x029C (0x0004) [0x0000000000000000]              
	float                                              LiftStrength;                                     		// 0x02A0 (0x0004) [0x0000000000000000]              
	float                                              ForceRadius;                                      		// 0x02A4 (0x0004) [0x0000000000000000]              
	float                                              ForceTopRadius;                                   		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              LiftFalloffHeight;                                		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              EscapeVelocity;                                   		// 0x02B0 (0x0004) [0x0000000000000000]              
	float                                              ForceHeight;                                      		// 0x02B4 (0x0004) [0x0000000000000000]              
	float                                              HeightOffset;                                     		// 0x02B8 (0x0004) [0x0000000000000000]              
	DWORD                                              BSpecialRadialForceMode : 1;                      		// 0x02BC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              SelfRotationStrength;                             		// 0x02C0 (0x0004) [0x0000000000000000]              
	struct FPointer                                    Kernel;                                           		// 0x02C4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxTornadoAngularForceField" );

		return pClassPointer;
	};

};

UClass* ANxTornadoAngularForceField::pClassPointer = NULL;

// Class Engine.NxTornadoAngularForceFieldCapsule
// 0x0008 (0x02D4 - 0x02CC)
class ANxTornadoAngularForceFieldCapsule : public ANxTornadoAngularForceField
{
public:
	class UDrawCapsuleComponent*                       RenderComponent;                                  		// 0x02CC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxTornadoAngularForceFieldCapsule" );

		return pClassPointer;
	};

};

UClass* ANxTornadoAngularForceFieldCapsule::pClassPointer = NULL;

// Class Engine.NxTornadoForceField
// 0x0030 (0x02C8 - 0x0298)
class ANxTornadoForceField : public ANxForceField
{
public:
	float                                              RadialStrength;                                   		// 0x0298 (0x0004) [0x0000000000000000]              
	float                                              RotationalStrength;                               		// 0x029C (0x0004) [0x0000000000000000]              
	float                                              LiftStrength;                                     		// 0x02A0 (0x0004) [0x0000000000000000]              
	float                                              ForceRadius;                                      		// 0x02A4 (0x0004) [0x0000000000000000]              
	float                                              ForceTopRadius;                                   		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              LiftFalloffHeight;                                		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              EscapeVelocity;                                   		// 0x02B0 (0x0004) [0x0000000000000000]              
	float                                              ForceHeight;                                      		// 0x02B4 (0x0004) [0x0000000000000000]              
	float                                              HeightOffset;                                     		// 0x02B8 (0x0004) [0x0000000000000000]              
	DWORD                                              BSpecialRadialForceMode : 1;                      		// 0x02BC (0x0004) [0x0000000000000000] [0x00000001] 
	struct FPointer                                    Kernel;                                           		// 0x02C0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxTornadoForceField" );

		return pClassPointer;
	};

};

UClass* ANxTornadoForceField::pClassPointer = NULL;

// Class Engine.NxTornadoForceFieldCapsule
// 0x0008 (0x02D0 - 0x02C8)
class ANxTornadoForceFieldCapsule : public ANxTornadoForceField
{
public:
	class UDrawCapsuleComponent*                       RenderComponent;                                  		// 0x02C8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxTornadoForceFieldCapsule" );

		return pClassPointer;
	};

};

UClass* ANxTornadoForceFieldCapsule::pClassPointer = NULL;

// Class Engine.NxForceFieldSpawnable
// 0x0008 (0x024C - 0x0244)
class ANxForceFieldSpawnable : public AActor
{
public:
	class UNxForceFieldComponent*                      ForceFieldComponent;                              		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxForceFieldSpawnable" );

		return pClassPointer;
	};

	void OnToggle ( );
};

UClass* ANxForceFieldSpawnable::pClassPointer = NULL;

// Class Engine.RB_CylindricalForceActor
// 0x0034 (0x0278 - 0x0244)
class ARB_CylindricalForceActor : public ARigidBodyBase
{
public:
	class UDrawCylinderComponent*                      RenderComponent;                                  		// 0x0244 (0x0008) [0x0000000000000000]              
	float                                              RadialStrength;                                   		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              RotationalStrength;                               		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              LiftStrength;                                     		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              LiftFalloffHeight;                                		// 0x0258 (0x0004) [0x0000000000000000]              
	float                                              EscapeVelocity;                                   		// 0x025C (0x0004) [0x0000000000000000]              
	float                                              ForceRadius;                                      		// 0x0260 (0x0004) [0x0000000000000000]              
	float                                              ForceTopRadius;                                   		// 0x0264 (0x0004) [0x0000000000000000]              
	float                                              ForceHeight;                                      		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              HeightOffset;                                     		// 0x026C (0x0004) [0x0000000000000000]              
	DWORD                                              bForceActive : 1;                                 		// 0x0270 (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )
	DWORD                                              bForceApplyToCloth : 1;                           		// 0x0270 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bForceApplyToFluid : 1;                           		// 0x0270 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bForceApplyToRigidBodies : 1;                     		// 0x0270 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bForceApplyToProjectiles : 1;                     		// 0x0270 (0x0004) [0x0000000000000000] [0x00000010] 
	struct FRBCollisionChannelContainer                CollideWithChannels;                              		// 0x0274 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_CylindricalForceActor" );

		return pClassPointer;
	};

	void OnToggle ( );
};

UClass* ARB_CylindricalForceActor::pClassPointer = NULL;

// Class Engine.RB_RadialForceActor
// 0x0024 (0x0268 - 0x0244)
class ARB_RadialForceActor : public ARigidBodyBase
{
public:
	class UDrawSphereComponent*                        RenderComponent;                                  		// 0x0244 (0x0008) [0x0000000000000000]              
	float                                              ForceStrength;                                    		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              ForceRadius;                                      		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              SwirlStrength;                                    		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              SpinTorque;                                       		// 0x0258 (0x0004) [0x0000000000000000]              
	unsigned char                                      ForceFalloff;                                     		// 0x025C (0x0001) [0x0000000000000000]              
	unsigned char                                      RadialForceMode;                                  		// 0x025D (0x0001) [0x0000000000000000]              
	DWORD                                              bForceActive : 1;                                 		// 0x0260 (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )
	DWORD                                              bForceApplyToCloth : 1;                           		// 0x0260 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bForceApplyToFluid : 1;                           		// 0x0260 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bForceApplyToRigidBodies : 1;                     		// 0x0260 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bForceApplyToProjectiles : 1;                     		// 0x0260 (0x0004) [0x0000000000000000] [0x00000010] 
	struct FRBCollisionChannelContainer                CollideWithChannels;                              		// 0x0264 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_RadialForceActor" );

		return pClassPointer;
	};

	void OnToggle ( );
};

UClass* ARB_RadialForceActor::pClassPointer = NULL;

// Class Engine.NxForceFieldComponent
// 0x0070 (0x02A8 - 0x0238)
class UNxForceFieldComponent : public UPrimitiveComponent
{
public:
	class UForceFieldShape*                            Shape;                                            		// 0x0238 (0x0008) [0x0000000000000000]              
	class UActorComponent*                             DrawComponent;                                    		// 0x0240 (0x0008) [0x0000000000000000]              
	int                                                ExcludeChannel;                                   		// 0x0248 (0x0004) [0x0000000000000000]              
	DWORD                                              bForceActive : 1;                                 		// 0x024C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDestroyWhenInactive : 1;                         		// 0x024C (0x0004) [0x0000000000000000] [0x00000002] 
	struct FRBCollisionChannelContainer                CollideWithChannels;                              		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              Duration;                                         		// 0x0254 (0x0004) [0x0000000000000000]              
	struct FPointer                                    ForceField;                                       		// 0x0258 (0x0008) [0x0000000000000000]              
	TArray< struct FPointer >                          ConvexMeshes;                                     		// 0x0260 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          ExclusionShapes;                                  		// 0x0270 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          ExclusionShapePoses;                              		// 0x0280 (0x0010) [0x0000000000000000]              
	int                                                SceneIndex;                                       		// 0x0290 (0x0004) [0x0000000000000000]              
	float                                              ElapsedTime;                                      		// 0x0294 (0x0004) [0x0000000000000000]              
	class UPrimitiveComponent*                         RenderComponent;                                  		// 0x0298 (0x0008) [0x0000000000000000]              
	struct FPointer                                    RBPhysScene;                                      		// 0x02A0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxForceFieldComponent" );

		return pClassPointer;
	};

	void DoInitRBPhys ( );
};

UClass* UNxForceFieldComponent::pClassPointer = NULL;

// Class Engine.NxForceFieldCylindricalComponent
// 0x0030 (0x02D8 - 0x02A8)
class UNxForceFieldCylindricalComponent : public UNxForceFieldComponent
{
public:
	float                                              RadialStrength;                                   		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              RotationalStrength;                               		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              LiftStrength;                                     		// 0x02B0 (0x0004) [0x0000000000000000]              
	float                                              ForceRadius;                                      		// 0x02B4 (0x0004) [0x0000000000000000]              
	float                                              ForceTopRadius;                                   		// 0x02B8 (0x0004) [0x0000000000000000]              
	float                                              LiftFalloffHeight;                                		// 0x02BC (0x0004) [0x0000000000000000]              
	float                                              EscapeVelocity;                                   		// 0x02C0 (0x0004) [0x0000000000000000]              
	float                                              ForceHeight;                                      		// 0x02C4 (0x0004) [0x0000000000000000]              
	float                                              HeightOffset;                                     		// 0x02C8 (0x0004) [0x0000000000000000]              
	DWORD                                              UseSpecialRadialForce : 1;                        		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	struct FPointer                                    Kernel;                                           		// 0x02D0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxForceFieldCylindricalComponent" );

		return pClassPointer;
	};

};

UClass* UNxForceFieldCylindricalComponent::pClassPointer = NULL;

// Class Engine.NxForceFieldGenericComponent
// 0x00AC (0x0354 - 0x02A8)
class UNxForceFieldGenericComponent : public UNxForceFieldComponent
{
public:
	float                                              RoughExtentX;                                     		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              RoughExtentY;                                     		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              RoughExtentZ;                                     		// 0x02B0 (0x0004) [0x0000000000000000]              
	unsigned char                                      Coordinates;                                      		// 0x02B4 (0x0001) [0x0000000000000000]              
	struct FVector                                     Constant;                                         		// 0x02B8 (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionMultiplierX;                              		// 0x02C4 (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionMultiplierY;                              		// 0x02D0 (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionMultiplierZ;                              		// 0x02DC (0x000C) [0x0000000000000000]              
	struct FVector                                     PositionTarget;                                   		// 0x02E8 (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityMultiplierX;                              		// 0x02F4 (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityMultiplierY;                              		// 0x0300 (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityMultiplierZ;                              		// 0x030C (0x000C) [0x0000000000000000]              
	struct FVector                                     VelocityTarget;                                   		// 0x0318 (0x000C) [0x0000000000000000]              
	struct FVector                                     Noise;                                            		// 0x0324 (0x000C) [0x0000000000000000]              
	struct FVector                                     FalloffLinear;                                    		// 0x0330 (0x000C) [0x0000000000000000]              
	struct FVector                                     FalloffQuadratic;                                 		// 0x033C (0x000C) [0x0000000000000000]              
	float                                              TorusRadius;                                      		// 0x0348 (0x0004) [0x0000000000000000]              
	struct FPointer                                    Kernel;                                           		// 0x034C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxForceFieldGenericComponent" );

		return pClassPointer;
	};

};

UClass* UNxForceFieldGenericComponent::pClassPointer = NULL;

// Class Engine.NxForceFieldRadialComponent
// 0x0018 (0x02C0 - 0x02A8)
class UNxForceFieldRadialComponent : public UNxForceFieldComponent
{
public:
	float                                              ForceStrength;                                    		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              ForceRadius;                                      		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              SelfRotationStrength;                             		// 0x02B0 (0x0004) [0x0000000000000000]              
	unsigned char                                      ForceFalloff;                                     		// 0x02B4 (0x0001) [0x0000000000000000]              
	struct FPointer                                    Kernel;                                           		// 0x02B8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxForceFieldRadialComponent" );

		return pClassPointer;
	};

};

UClass* UNxForceFieldRadialComponent::pClassPointer = NULL;

// Class Engine.NxForceFieldTornadoComponent
// 0x0034 (0x02DC - 0x02A8)
class UNxForceFieldTornadoComponent : public UNxForceFieldComponent
{
public:
	float                                              RadialStrength;                                   		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              RotationalStrength;                               		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              LiftStrength;                                     		// 0x02B0 (0x0004) [0x0000000000000000]              
	float                                              ForceRadius;                                      		// 0x02B4 (0x0004) [0x0000000000000000]              
	float                                              ForceTopRadius;                                   		// 0x02B8 (0x0004) [0x0000000000000000]              
	float                                              LiftFalloffHeight;                                		// 0x02BC (0x0004) [0x0000000000000000]              
	float                                              EscapeVelocity;                                   		// 0x02C0 (0x0004) [0x0000000000000000]              
	float                                              ForceHeight;                                      		// 0x02C4 (0x0004) [0x0000000000000000]              
	float                                              HeightOffset;                                     		// 0x02C8 (0x0004) [0x0000000000000000]              
	DWORD                                              BSpecialRadialForceMode : 1;                      		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              SelfRotationStrength;                             		// 0x02D0 (0x0004) [0x0000000000000000]              
	struct FPointer                                    Kernel;                                           		// 0x02D4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NxForceFieldTornadoComponent" );

		return pClassPointer;
	};

};

UClass* UNxForceFieldTornadoComponent::pClassPointer = NULL;

// Class Engine.ForceFieldShape
// 0x0000 (0x0060 - 0x0060)
class UForceFieldShape : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ForceFieldShape" );

		return pClassPointer;
	};

	void eventGetDrawComponent ( );
	void eventFillByCylinder ( );
	void eventFillByCapsule ( );
	void eventFillByBox ( );
	void eventFillBySphere ( );
};

UClass* UForceFieldShape::pClassPointer = NULL;

// Class Engine.ForceFieldShapeBox
// 0x0008 (0x0068 - 0x0060)
class UForceFieldShapeBox : public UForceFieldShape
{
public:
	class UDrawBoxComponent*                           Shape;                                            		// 0x0060 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ForceFieldShapeBox" );

		return pClassPointer;
	};

	void eventGetDrawComponent ( );
	void eventFillByCylinder ( );
	void eventFillByCapsule ( );
	void eventFillByBox ( );
	void eventFillBySphere ( );
	void eventGetRadii ( );
};

UClass* UForceFieldShapeBox::pClassPointer = NULL;

// Class Engine.ForceFieldShapeCapsule
// 0x0008 (0x0068 - 0x0060)
class UForceFieldShapeCapsule : public UForceFieldShape
{
public:
	class UDrawCapsuleComponent*                       Shape;                                            		// 0x0060 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ForceFieldShapeCapsule" );

		return pClassPointer;
	};

	void eventGetDrawComponent ( );
	void eventFillByCylinder ( );
	void eventFillByCapsule ( );
	void eventFillByBox ( );
	void eventFillBySphere ( );
	void eventGetRadius ( );
	void eventGetHeight ( );
};

UClass* UForceFieldShapeCapsule::pClassPointer = NULL;

// Class Engine.ForceFieldShapeSphere
// 0x0008 (0x0068 - 0x0060)
class UForceFieldShapeSphere : public UForceFieldShape
{
public:
	class UDrawSphereComponent*                        Shape;                                            		// 0x0060 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ForceFieldShapeSphere" );

		return pClassPointer;
	};

	void eventGetDrawComponent ( );
	void eventFillByCylinder ( );
	void eventFillByCapsule ( );
	void eventFillByBox ( );
	void eventFillBySphere ( );
	void eventGetRadius ( );
};

UClass* UForceFieldShapeSphere::pClassPointer = NULL;

// Class Engine.PrefabInstance
// 0x00EC (0x0330 - 0x0244)
class APrefabInstance : public AActor
{
public:
	class UPrefab*                                     TemplatePrefab;                                   		// 0x0244 (0x0008) [0x0000000000000000]              
	int                                                TemplateVersion;                                  		// 0x024C (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x0250 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.PrefabInstance.ArchetypeToInstanceMap
	class UPrefabSequence*                             SequenceInstance;                                 		// 0x0298 (0x0008) [0x0000000000000000]              
	int                                                PI_PackageVersion;                                		// 0x02A0 (0x0004) [0x0000000000000000]              
	int                                                PI_LicenseePackageVersion;                        		// 0x02A4 (0x0004) [0x0000000000000000]              
	TArray< unsigned char >                            PI_Bytes;                                         		// 0x02A8 (0x0010) [0x0000000000000000]              
	TArray< class UObject* >                           PI_CompleteObjects;                               		// 0x02B8 (0x0010) [0x0000000000000000]              
	TArray< class UObject* >                           PI_ReferencedObjects;                             		// 0x02C8 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           PI_SavedNames;                                    		// 0x02D8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x48 ];                            		// 0x02E8 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.PrefabInstance.PI_ObjectMap

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PrefabInstance" );

		return pClassPointer;
	};

};

UClass* APrefabInstance::pClassPointer = NULL;

// Class Engine.Prefab
// 0x0034 (0x0094 - 0x0060)
class UPrefab : public UObject
{
public:
	int                                                PrefabVersion;                                    		// 0x0060 (0x0004) [0x0000000000000000]              
	TArray< class UObject* >                           PrefabArchetypes;                                 		// 0x0064 (0x0010) [0x0000000000000000]              
	TArray< class UObject* >                           RemovedArchetypes;                                		// 0x0074 (0x0010) [0x0000000000000000]              
	class UPrefabSequence*                             PrefabSequence;                                   		// 0x0084 (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  PrefabPreview;                                    		// 0x008C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Prefab" );

		return pClassPointer;
	};

};

UClass* UPrefab::pClassPointer = NULL;

// Class Engine.SequenceObject
// 0x006C (0x00CC - 0x0060)
class USequenceObject : public UObject
{
public:
	int                                                ObjInstanceVersion;                               		// 0x0060 (0x0004) [0x0000000000000000]              
	class USequence*                                   ParentSequence;                                   		// 0x0064 (0x0008) [0x0000000000000000]              
	int                                                ObjPosX;                                          		// 0x006C (0x0004) [0x0000000000000000]              
	int                                                ObjPosY;                                          		// 0x0070 (0x0004) [0x0000000000000000]              
	struct FString                                     ObjName;                                          		// 0x0074 (0x0010) [0x0000000000000000]              
	struct FString                                     ObjCategory;                                      		// 0x0084 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           ObjRemoveInProject;                               		// 0x0094 (0x0010) [0x0000000000000000]              
	struct FColor                                      ObjColor;                                         		// 0x00A4 (0x0004) [0x0000000000000000]              
	struct FString                                     ObjComment;                                       		// 0x00A8 (0x0010) [0x0000000000000000]              
	DWORD                                              bDeletable : 1;                                   		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDrawFirst : 1;                                   		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDrawLast : 1;                                    		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bOutputObjCommentToScreen : 1;                    		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bSuppressAutoComment : 1;                         		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000010] 
	int                                                DrawWidth;                                        		// 0x00BC (0x0004) [0x0000000000000000]              
	int                                                DrawHeight;                                       		// 0x00C0 (0x0004) [0x0000000000000000]              
	class USequenceObject*                             PIESequenceObject;                                		// 0x00C4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SequenceObject" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
	void eventShouldClearNameOnPasting ( );
	void eventIsPastingIntoLevelSequenceAllowed ( );
	void eventIsValidLevelSequenceObject ( );
	void GetWorldInfo ( );
	void ScriptLog ( );
};

UClass* USequenceObject::pClassPointer = NULL;

// Class Engine.SequenceFrame
// 0x0028 (0x00F4 - 0x00CC)
class USequenceFrame : public USequenceObject
{
public:
	int                                                SizeX;                                            		// 0x00CC (0x0004) [0x0000000000000000]              
	int                                                SizeY;                                            		// 0x00D0 (0x0004) [0x0000000000000000]              
	int                                                BorderWidth;                                      		// 0x00D4 (0x0004) [0x0000000000000000]              
	DWORD                                              bDrawBox : 1;                                     		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFilled : 1;                                      		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bTileFill : 1;                                    		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000004] 
	struct FColor                                      BorderColor;                                      		// 0x00DC (0x0004) [0x0000000000000000]              
	struct FColor                                      FillColor;                                        		// 0x00E0 (0x0004) [0x0000000000000000]              
	class UTexture2D*                                  FillTexture;                                      		// 0x00E4 (0x0008) [0x0000000000000000]              
	class UMaterial*                                   FillMaterial;                                     		// 0x00EC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SequenceFrame" );

		return pClassPointer;
	};

};

UClass* USequenceFrame::pClassPointer = NULL;

// Class Engine.SequenceFrameWrapped
// 0x0000 (0x00F4 - 0x00F4)
class USequenceFrameWrapped : public USequenceFrame
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SequenceFrameWrapped" );

		return pClassPointer;
	};

};

UClass* USequenceFrameWrapped::pClassPointer = NULL;

// Class Engine.SequenceOp
// 0x0068 (0x0134 - 0x00CC)
class USequenceOp : public USequenceObject
{
public:
	DWORD                                              bIsActivated : 1;                                 		// 0x00CC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIsCurrentDebuggerOp : 1;                         		// 0x00CC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bActive : 1;                                      		// 0x00CC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bLatentExecution : 1;                             		// 0x00CC (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bAutoActivateOutputLinks : 1;                     		// 0x00CC (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bHaveMovingVarConnector : 1;                      		// 0x00CC (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bHaveMovingInputConnector : 1;                    		// 0x00CC (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bHaveMovingOutputConnector : 1;                   		// 0x00CC (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bPendingVarConnectorRecalc : 1;                   		// 0x00CC (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bPendingInputConnectorRecalc : 1;                 		// 0x00CC (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bPendingOutputConnectorRecalc : 1;                		// 0x00CC (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bIsBreakpointSet : 1;                             		// 0x00CC (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bIsHiddenBreakpointSet : 1;                       		// 0x00CC (0x0004) [0x0000000000000000] [0x00001000] 
	float                                              PIEActivationTime;                                		// 0x00D0 (0x0004) [0x0000000000000000]              
	class USequenceOp*                                 ActivatorSeqOp;                                   		// 0x00D4 (0x0008) [0x0000000000000000]              
	int                                                LastActivatedInputLink;                           		// 0x00DC (0x0004) [0x0000000000000000]              
	int                                                LastActivatedOutputLink;                          		// 0x00E0 (0x0004) [0x0000000000000000]              
	TArray< struct FSeqOpInputLink >                   InputLinks;                                       		// 0x00E4 (0x0010) [0x0000000000000000]              
	TArray< struct FSeqOpOutputLink >                  OutputLinks;                                      		// 0x00F4 (0x0010) [0x0000000000000000]              
	TArray< struct FSeqVarLink >                       VariableLinks;                                    		// 0x0104 (0x0010) [0x0000000000000000]              
	TArray< struct FSeqEventLink >                     EventLinks;                                       		// 0x0114 (0x0010) [0x0000000000000000]              
	int                                                PlayerIndex;                                      		// 0x0124 (0x0004) [0x0000000000000000]              
	unsigned char                                      GamepadID;                                        		// 0x0128 (0x0001) [0x0000000000000000]              
	int                                                ActivateCount;                                    		// 0x012C (0x0004) [0x0000000000000000]              
	int                                                SearchTag;                                        		// 0x0130 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SequenceOp" );

		return pClassPointer;
	};

	void ForceActivateOutput ( );
	void ForceActivateInput ( );
	void GetController ( );
	void GetPawn ( );
	void Reset ( );
	void PublishLinkedVariableValues ( );
	void PopulateLinkedVariableValues ( );
	void eventVersionUpdated ( );
	void eventDeactivated ( );
	void eventActivated ( );
	void ActivateNamedOutputLink ( );
	void ActivateOutputLink ( );
	void LinkedVariables ( );
	void GetBoolVars ( );
	void GetInterpDataVars ( );
	void GetObjectVars ( );
	void GetLinkedObjects ( );
	void HasLinkedOps ( );
};

UClass* USequenceOp::pClassPointer = NULL;

// Class Engine.Sequence
// 0x0088 (0x01BC - 0x0134)
class USequence : public USequenceOp
{
public:
	struct FPointer                                    LogFile;                                          		// 0x0134 (0x0008) [0x0000000000000000]              
	TArray< class USequenceObject* >                   SequenceObjects;                                  		// 0x013C (0x0010) [0x0000000000000000]              
	TArray< class USequenceOp* >                       ActiveSequenceOps;                                		// 0x014C (0x0010) [0x0000000000000000]              
	TArray< class USequence* >                         NestedSequences;                                  		// 0x015C (0x0010) [0x0000000000000000]              
	TArray< class USequenceEvent* >                    UnregisteredEvents;                               		// 0x016C (0x0010) [0x0000000000000000]              
	TArray< struct FActivateOp >                       DelayedActivatedOps;                              		// 0x017C (0x0010) [0x0000000000000000]              
	TArray< class USequenceOp* >                       DelayedLatentOps;                                 		// 0x018C (0x0010) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x019C (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< struct FQueuedActivationInfo >             QueuedActivations;                                		// 0x01A0 (0x0010) [0x0000000000000000]              
	int                                                DefaultViewX;                                     		// 0x01B0 (0x0004) [0x0000000000000000]              
	int                                                DefaultViewY;                                     		// 0x01B4 (0x0004) [0x0000000000000000]              
	float                                              DefaultViewZoom;                                  		// 0x01B8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Sequence" );

		return pClassPointer;
	};

	void SetEnabled ( );
	void Reset ( );
	void FindSeqObjectsByName ( );
	void FindSeqObjectsByClass ( );
};

UClass* USequence::pClassPointer = NULL;

// Class Engine.PrefabSequence
// 0x0008 (0x01C4 - 0x01BC)
class UPrefabSequence : public USequence
{
public:
	class APrefabInstance*                             OwnerPrefab;                                      		// 0x01BC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PrefabSequence" );

		return pClassPointer;
	};

	void GetOwnerPrefab ( );
	void SetOwnerPrefab ( );
};

UClass* UPrefabSequence::pClassPointer = NULL;

// Class Engine.PrefabSequenceContainer
// 0x0000 (0x01BC - 0x01BC)
class UPrefabSequenceContainer : public USequence
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PrefabSequenceContainer" );

		return pClassPointer;
	};

};

UClass* UPrefabSequenceContainer::pClassPointer = NULL;

// Class Engine.SequenceAction
// 0x001C (0x0150 - 0x0134)
class USequenceAction : public USequenceOp
{
public:
	struct FName                                       HandlerName;                                      		// 0x0134 (0x0008) [0x0000000000000000]              
	DWORD                                              bCallHandler : 1;                                 		// 0x013C (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class UObject* >                           Targets;                                          		// 0x0140 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SequenceAction" );

		return pClassPointer;
	};

};

UClass* USequenceAction::pClassPointer = NULL;

// Class Engine.SeqAct_ActivateRemoteEvent
// 0x0014 (0x0164 - 0x0150)
class USeqAct_ActivateRemoteEvent : public USequenceAction
{
public:
	class AActor*                                      Instigator;                                       		// 0x0150 (0x0008) [0x0000000000000000]              
	struct FName                                       EventName;                                        		// 0x0158 (0x0008) [0x0000000000000000]              
	DWORD                                              bStatusIsOk : 1;                                  		// 0x0160 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ActivateRemoteEvent" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_ActivateRemoteEvent::pClassPointer = NULL;

// Class Engine.SeqAct_AndGate
// 0x0024 (0x0174 - 0x0150)
class USeqAct_AndGate : public USequenceAction
{
public:
	DWORD                                              bOpen : 1;                                        		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< DWORD >                                    LinkedOutputFiredStatus;                          		// 0x0154 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          LinkedOutputs;                                    		// 0x0164 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_AndGate" );

		return pClassPointer;
	};

};

UClass* USeqAct_AndGate::pClassPointer = NULL;

// Class Engine.SeqAct_ApplySoundNode
// 0x0010 (0x0160 - 0x0150)
class USeqAct_ApplySoundNode : public USequenceAction
{
public:
	class USoundCue*                                   PlaySound;                                        		// 0x0150 (0x0008) [0x0000000000000000]              
	class USoundNode*                                  ApplyNode;                                        		// 0x0158 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ApplySoundNode" );

		return pClassPointer;
	};

};

UClass* USeqAct_ApplySoundNode::pClassPointer = NULL;

// Class Engine.SeqAct_AttachToEvent
// 0x0004 (0x0154 - 0x0150)
class USeqAct_AttachToEvent : public USequenceAction
{
public:
	DWORD                                              bPreferController : 1;                            		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_AttachToEvent" );

		return pClassPointer;
	};

};

UClass* USeqAct_AttachToEvent::pClassPointer = NULL;

// Class Engine.SeqAct_CameraFade
// 0x002C (0x017C - 0x0150)
class USeqAct_CameraFade : public USequenceAction
{
public:
	struct FColor                                      FadeColor;                                        		// 0x0150 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   FadeAlpha;                                        		// 0x0154 (0x0008) [0x0000000000000000]              
	float                                              FadeOpacity;                                      		// 0x015C (0x0004) [0x0000000000000000]              
	float                                              FadeTime;                                         		// 0x0160 (0x0004) [0x0000000000000000]              
	DWORD                                              bPersistFade : 1;                                 		// 0x0164 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFadeAudio : 1;                                   		// 0x0164 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              FadeTimeRemaining;                                		// 0x0168 (0x0004) [0x0000000000000000]              
	TArray< class APlayerController* >                 CachedPCs;                                        		// 0x016C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_CameraFade" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_CameraFade::pClassPointer = NULL;

// Class Engine.SeqAct_CameraLookAt
// 0x0038 (0x0188 - 0x0150)
class USeqAct_CameraLookAt : public USequenceAction
{
public:
	DWORD                                              bAffectCamera : 1;                                		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAlwaysFocus : 1;                                 		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAdjustCamera : 1;                                		// 0x0150 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bTurnInPlace : 1;                                 		// 0x0150 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bIgnoreTrace : 1;                                 		// 0x0150 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bAffectHead : 1;                                  		// 0x0150 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bRotatePlayerWithCamera : 1;                      		// 0x0150 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bToggleGodMode : 1;                               		// 0x0150 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bLeaveCameraRotation : 1;                         		// 0x0150 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bDisableInput : 1;                                		// 0x0150 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bUsedTimer : 1;                                   		// 0x0150 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bCheckLineOfSight : 1;                            		// 0x0150 (0x0004) [0x0000000000000000] [0x00000800] 
	struct FVector2D                                   InterpSpeedRange;                                 		// 0x0154 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   InFocusFOV;                                       		// 0x015C (0x0008) [0x0000000000000000]              
	struct FName                                       FocusBoneName;                                    		// 0x0164 (0x0008) [0x0000000000000000]              
	struct FString                                     TextDisplay;                                      		// 0x016C (0x0010) [0x0000000000000000]              
	float                                              TotalTime;                                        		// 0x017C (0x0004) [0x0000000000000000]              
	float                                              CameraFOV;                                        		// 0x0180 (0x0004) [0x0000000000000000]              
	float                                              RemainingTime;                                    		// 0x0184 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_CameraLookAt" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_CameraLookAt::pClassPointer = NULL;

// Class Engine.SeqAct_CameraShake
// 0x0028 (0x0178 - 0x0150)
class USeqAct_CameraShake : public USequenceAction
{
public:
	class UCameraShake*                                Shake;                                            		// 0x0150 (0x0008) [0x0000000000000000]              
	float                                              ShakeScale;                                       		// 0x0158 (0x0004) [0x0000000000000000]              
	DWORD                                              bDoControllerVibration : 1;                       		// 0x015C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bRadialShake : 1;                                 		// 0x015C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bOrientTowardRadialEpicenter : 1;                 		// 0x015C (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              RadialShake_InnerRadius;                          		// 0x0160 (0x0004) [0x0000000000000000]              
	float                                              RadialShake_OuterRadius;                          		// 0x0164 (0x0004) [0x0000000000000000]              
	float                                              RadialShake_Falloff;                              		// 0x0168 (0x0004) [0x0000000000000000]              
	unsigned char                                      PlaySpace;                                        		// 0x016C (0x0001) [0x0000000000000000]              
	class AActor*                                      LocationActor;                                    		// 0x0170 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_CameraShake" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_CameraShake::pClassPointer = NULL;

// Class Engine.SeqAct_ChangeCollision
// 0x0005 (0x0155 - 0x0150)
class USeqAct_ChangeCollision : public USequenceAction
{
public:
	DWORD                                              bCollideActors : 1;                               		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bBlockActors : 1;                                 		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIgnoreEncroachers : 1;                           		// 0x0150 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned char                                      CollisionType;                                    		// 0x0154 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ChangeCollision" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_ChangeCollision::pClassPointer = NULL;

// Class Engine.SeqAct_CommitMapChange
// 0x0000 (0x0150 - 0x0150)
class USeqAct_CommitMapChange : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_CommitMapChange" );

		return pClassPointer;
	};

};

UClass* USeqAct_CommitMapChange::pClassPointer = NULL;

// Class Engine.SeqAct_ConvertToString
// 0x0018 (0x0168 - 0x0150)
class USeqAct_ConvertToString : public USequenceAction
{
public:
	DWORD                                              bIncludeVarComment : 1;                           		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FString                                     VarSeparator;                                     		// 0x0154 (0x0010) [0x0000000000000000]              
	int                                                NumberOfInputs;                                   		// 0x0164 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ConvertToString" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_ConvertToString::pClassPointer = NULL;

// Class Engine.SeqAct_DrawText
// 0x0048 (0x0198 - 0x0150)
class USeqAct_DrawText : public USequenceAction
{
public:
	float                                              DisplayTimeSeconds;                               		// 0x0150 (0x0004) [0x0000000000000000]              
	DWORD                                              bDisplayOnObject : 1;                             		// 0x0154 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FKismetDrawTextInfo                         DrawTextInfo;                                     		// 0x0158 (0x0040) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_DrawText" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_DrawText::pClassPointer = NULL;

// Class Engine.SeqAct_FinishSequence
// 0x0010 (0x0160 - 0x0150)
class USeqAct_FinishSequence : public USequenceAction
{
public:
	struct FString                                     OutputLabel;                                      		// 0x0150 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_FinishSequence" );

		return pClassPointer;
	};

};

UClass* USeqAct_FinishSequence::pClassPointer = NULL;

// Class Engine.SeqAct_Gate
// 0x000C (0x015C - 0x0150)
class USeqAct_Gate : public USequenceAction
{
public:
	DWORD                                              bOpen : 1;                                        		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                AutoCloseCount;                                   		// 0x0154 (0x0004) [0x0000000000000000]              
	int                                                CurrentCloseCount;                                		// 0x0158 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_Gate" );

		return pClassPointer;
	};

};

UClass* USeqAct_Gate::pClassPointer = NULL;

// Class Engine.SeqAct_GetDistance
// 0x0004 (0x0154 - 0x0150)
class USeqAct_GetDistance : public USequenceAction
{
public:
	float                                              Distance;                                         		// 0x0150 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_GetDistance" );

		return pClassPointer;
	};

};

UClass* USeqAct_GetDistance::pClassPointer = NULL;

// Class Engine.SeqAct_GetLocationAndRotation
// 0x002C (0x017C - 0x0150)
class USeqAct_GetLocationAndRotation : public USequenceAction
{
public:
	struct FVector                                     Location;                                         		// 0x0150 (0x000C) [0x0000000000000000]              
	struct FVector                                     RotationVector;                                   		// 0x015C (0x000C) [0x0000000000000000]              
	struct FVector                                     Rotation;                                         		// 0x0168 (0x000C) [0x0000000000000000]              
	struct FName                                       SocketOrBoneName;                                 		// 0x0174 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_GetLocationAndRotation" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_GetLocationAndRotation::pClassPointer = NULL;

// Class Engine.SeqAct_GetProperty
// 0x0008 (0x0158 - 0x0150)
class USeqAct_GetProperty : public USequenceAction
{
public:
	struct FName                                       PropertyName;                                     		// 0x0150 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_GetProperty" );

		return pClassPointer;
	};

};

UClass* USeqAct_GetProperty::pClassPointer = NULL;

// Class Engine.SeqAct_GetVectorComponents
// 0x0018 (0x0168 - 0x0150)
class USeqAct_GetVectorComponents : public USequenceAction
{
public:
	struct FVector                                     InVector;                                         		// 0x0150 (0x000C) [0x0000000000000000]              
	float                                              X;                                                		// 0x015C (0x0004) [0x0000000000000000]              
	float                                              Y;                                                		// 0x0160 (0x0004) [0x0000000000000000]              
	float                                              Z;                                                		// 0x0164 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_GetVectorComponents" );

		return pClassPointer;
	};

};

UClass* USeqAct_GetVectorComponents::pClassPointer = NULL;

// Class Engine.SeqAct_GetVelocity
// 0x0010 (0x0160 - 0x0150)
class USeqAct_GetVelocity : public USequenceAction
{
public:
	float                                              VelocityMag;                                      		// 0x0150 (0x0004) [0x0000000000000000]              
	struct FVector                                     VelocityVect;                                     		// 0x0154 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_GetVelocity" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_GetVelocity::pClassPointer = NULL;

// Class Engine.SeqAct_HeadTrackingControl
// 0x009C (0x01EC - 0x0150)
class USeqAct_HeadTrackingControl : public USequenceAction
{
public:
	TArray< struct FName >                             TrackControllerName;                              		// 0x0150 (0x0010) [0x0000000000000000]              
	float                                              LookAtActorRadius;                                		// 0x0160 (0x0004) [0x0000000000000000]              
	DWORD                                              bDisableBeyondLimit : 1;                          		// 0x0164 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLookAtPawns : 1;                                 		// 0x0164 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              MaxLookAtTime;                                    		// 0x0168 (0x0004) [0x0000000000000000]              
	float                                              MinLookAtTime;                                    		// 0x016C (0x0004) [0x0000000000000000]              
	float                                              MaxInterestTime;                                  		// 0x0170 (0x0004) [0x0000000000000000]              
	TArray< class UClass* >                            ActorClassesToLookAt;                             		// 0x0174 (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             TargetBoneNames;                                  		// 0x0184 (0x0010) [0x0000000000000000]              
	TArray< class UObject* >                           LookAtTargets;                                    		// 0x0194 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x01A4 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.SeqAct_HeadTrackingControl.ActorToComponentMap

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_HeadTrackingControl" );

		return pClassPointer;
	};

	void eventActivated ( );
	void eventGetObjClassVersion ( );
};

UClass* USeqAct_HeadTrackingControl::pClassPointer = NULL;

// Class Engine.SeqAct_IsInObjectList
// 0x0004 (0x0154 - 0x0150)
class USeqAct_IsInObjectList : public USequenceAction
{
public:
	DWORD                                              bCheckForAllObjects : 1;                          		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bObjectFound : 1;                                 		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_IsInObjectList" );

		return pClassPointer;
	};

};

UClass* USeqAct_IsInObjectList::pClassPointer = NULL;

// Class Engine.SeqAct_Latent
// 0x0018 (0x0168 - 0x0150)
class USeqAct_Latent : public USequenceAction
{
public:
	TArray< class AActor* >                            LatentActors;                                     		// 0x0150 (0x0010) [0x0000000000000000]              
	DWORD                                              bAborted : 1;                                     		// 0x0160 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              LatentActivationTime;                             		// 0x0164 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_Latent" );

		return pClassPointer;
	};

	void eventUpdate ( );
	void AbortFor ( );
};

UClass* USeqAct_Latent::pClassPointer = NULL;

// Class Engine.SeqAct_ActorFactory
// 0x0058 (0x01C0 - 0x0168)
class USeqAct_ActorFactory : public USeqAct_Latent
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x0168 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIsSpawning : 1;                                  		// 0x0168 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCheckSpawnCollision : 1;                         		// 0x0168 (0x0004) [0x0000000000000000] [0x00000004] 
	class UActorFactory*                               Factory;                                          		// 0x016C (0x0008) [0x0000000000000000]              
	unsigned char                                      PointSelection;                                   		// 0x0174 (0x0001) [0x0000000000000000]              
	TArray< class AActor* >                            SpawnPoints;                                      		// 0x0178 (0x0010) [0x0000000000000000]              
	TArray< struct FVector >                           SpawnLocations;                                   		// 0x0188 (0x0010) [0x0000000000000000]              
	TArray< struct FVector >                           SpawnOrientations;                                		// 0x0198 (0x0010) [0x0000000000000000]              
	int                                                SpawnCount;                                       		// 0x01A8 (0x0004) [0x0000000000000000]              
	float                                              SpawnDelay;                                       		// 0x01AC (0x0004) [0x0000000000000000]              
	int                                                LastSpawnIdx;                                     		// 0x01B0 (0x0004) [0x0000000000000000]              
	int                                                CurrentSpawnIdx;                                  		// 0x01B4 (0x0004) [0x0000000000000000]              
	int                                                SpawnedCount;                                     		// 0x01B8 (0x0004) [0x0000000000000000]              
	float                                              RemainingDelay;                                   		// 0x01BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ActorFactory" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_ActorFactory::pClassPointer = NULL;

// Class Engine.SeqAct_ActorFactoryEx
// 0x0000 (0x01C0 - 0x01C0)
class USeqAct_ActorFactoryEx : public USeqAct_ActorFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ActorFactoryEx" );

		return pClassPointer;
	};

};

UClass* USeqAct_ActorFactoryEx::pClassPointer = NULL;

// Class Engine.SeqAct_ProjectileFactory
// 0x0018 (0x01D8 - 0x01C0)
class USeqAct_ProjectileFactory : public USeqAct_ActorFactory
{
public:
	class UParticleSystem*                             PSTemplate;                                       		// 0x01C0 (0x0008) [0x0000000000000000]              
	struct FName                                       SocketName;                                       		// 0x01C8 (0x0008) [0x0000000000000000]              
	struct FName                                       BoneName;                                         		// 0x01D0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ProjectileFactory" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_ProjectileFactory::pClassPointer = NULL;

// Class Engine.SeqAct_AIMoveToActor
// 0x0024 (0x018C - 0x0168)
class USeqAct_AIMoveToActor : public USeqAct_Latent
{
public:
	DWORD                                              bInterruptable : 1;                               		// 0x0168 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPickClosest : 1;                                 		// 0x0168 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< class AActor* >                            Destination;                                      		// 0x016C (0x0010) [0x0000000000000000]              
	float                                              MovementSpeedModifier;                            		// 0x017C (0x0004) [0x0000000000000000]              
	class AActor*                                      LookAt;                                           		// 0x0180 (0x0008) [0x0000000000000000]              
	int                                                LastDestinationChoice;                            		// 0x0188 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_AIMoveToActor" );

		return pClassPointer;
	};

	void PickDestination ( );
	void eventGetObjClassVersion ( );
};

UClass* USeqAct_AIMoveToActor::pClassPointer = NULL;

// Class Engine.SeqAct_Delay
// 0x0014 (0x017C - 0x0168)
class USeqAct_Delay : public USeqAct_Latent
{
public:
	DWORD                                              bDelayActive : 1;                                 		// 0x0168 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bStartWillRestart : 1;                            		// 0x0168 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              DefaultDuration;                                  		// 0x016C (0x0004) [0x0000000000000000]              
	float                                              Duration;                                         		// 0x0170 (0x0004) [0x0000000000000000]              
	float                                              LastUpdateTime;                                   		// 0x0174 (0x0004) [0x0000000000000000]              
	float                                              RemainingTime;                                    		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_Delay" );

		return pClassPointer;
	};

	void ResetDelayActive ( );
	void Reset ( );
};

UClass* USeqAct_Delay::pClassPointer = NULL;

// Class Engine.SeqAct_DelaySwitch
// 0x0010 (0x0178 - 0x0168)
class USeqAct_DelaySwitch : public USeqAct_Latent
{
public:
	int                                                LinkCount;                                        		// 0x0168 (0x0004) [0x0000000000000000]              
	int                                                CurrentIdx;                                       		// 0x016C (0x0004) [0x0000000000000000]              
	float                                              SwitchDelay;                                      		// 0x0170 (0x0004) [0x0000000000000000]              
	float                                              NextLinkTime;                                     		// 0x0174 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_DelaySwitch" );

		return pClassPointer;
	};

};

UClass* USeqAct_DelaySwitch::pClassPointer = NULL;

// Class Engine.SeqAct_ForceGarbageCollection
// 0x0000 (0x0168 - 0x0168)
class USeqAct_ForceGarbageCollection : public USeqAct_Latent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ForceGarbageCollection" );

		return pClassPointer;
	};

};

UClass* USeqAct_ForceGarbageCollection::pClassPointer = NULL;

// Class Engine.SeqAct_Interp
// 0x00FC (0x0264 - 0x0168)
class USeqAct_Interp : public USeqAct_Latent
{
public:
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x0168 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.SeqAct_Interp.SavedActorTransforms
	unsigned char                                      UnknownData01[ 0x48 ];                            		// 0x01B0 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.SeqAct_Interp.SavedActorVisibilities
	float                                              PlayRate;                                         		// 0x01F8 (0x0004) [0x0000000000000000]              
	float                                              Position;                                         		// 0x01FC (0x0004) [0x0000000000000000]              
	float                                              ForceStartPosition;                               		// 0x0200 (0x0004) [0x0000000000000000]              
	DWORD                                              bIsPlaying : 1;                                   		// 0x0204 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPaused : 1;                                      		// 0x0204 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIsBeingEdited : 1;                               		// 0x0204 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bLooping : 1;                                     		// 0x0204 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bRewindOnPlay : 1;                                		// 0x0204 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bNoResetOnRewind : 1;                             		// 0x0204 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bRewindIfAlreadyPlaying : 1;                      		// 0x0204 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bReversePlayback : 1;                             		// 0x0204 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bInterpForPathBuilding : 1;                       		// 0x0204 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bForceStartPos : 1;                               		// 0x0204 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bDisableRadioFilter : 1;                          		// 0x0204 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bClientSideOnly : 1;                              		// 0x0204 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bSkipUpdateIfNotVisible : 1;                      		// 0x0204 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bIsSkippable : 1;                                 		// 0x0204 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bShouldShowGore : 1;                              		// 0x0204 (0x0004) [0x0000000000000000] [0x00004000] 
	TArray< class ACoverLink* >                        LinkedCover;                                      		// 0x0208 (0x0010) [0x0000000000000000]              
	class UInterpData*                                 InterpData;                                       		// 0x0218 (0x0008) [0x0000000000000000]              
	TArray< class UInterpGroupInst* >                  GroupInst;                                        		// 0x0220 (0x0010) [0x0000000000000000]              
	class UClass*                                      ReplicatedActorClass;                             		// 0x0230 (0x0008) [0x0000000000000000]              
	class AMatineeActor*                               ReplicatedActor;                                  		// 0x0238 (0x0008) [0x0000000000000000]              
	int                                                PreferredSplitScreenNum;                          		// 0x0240 (0x0004) [0x0000000000000000]              
	TArray< struct FCameraCutInfo >                    CameraCuts;                                       		// 0x0244 (0x0010) [0x0000000000000000]              
	float                                              TerminationTime;                                  		// 0x0254 (0x0004) [0x0000000000000000]              
	struct FRenderingPerformanceOverrides              RenderingOverrides;                               		// 0x0258 (0x0004) [0x0000000000000000]              
	unsigned char                                      ConstantCameraAnim;                               		// 0x025C (0x0001) [0x0000000000000000]              
	float                                              ConstantCameraAnimRate;                           		// 0x0260 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_Interp" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
	void Reset ( );
	void AddPlayerToDirectorTracks ( );
	void Stop ( );
	void SetPosition ( );
};

UClass* USeqAct_Interp::pClassPointer = NULL;

// Class Engine.SeqAct_LevelStreamingBase
// 0x0004 (0x016C - 0x0168)
class USeqAct_LevelStreamingBase : public USeqAct_Latent
{
public:
	DWORD                                              bMakeVisibleAfterLoad : 1;                        		// 0x0168 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bShouldBlockOnLoad : 1;                           		// 0x0168 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_LevelStreamingBase" );

		return pClassPointer;
	};

};

UClass* USeqAct_LevelStreamingBase::pClassPointer = NULL;

// Class Engine.SeqAct_LevelStreaming
// 0x0014 (0x0180 - 0x016C)
class USeqAct_LevelStreaming : public USeqAct_LevelStreamingBase
{
public:
	class ULevelStreaming*                             Level;                                            		// 0x016C (0x0008) [0x0000000000000000]              
	struct FName                                       LevelName;                                        		// 0x0174 (0x0008) [0x0000000000000000]              
	DWORD                                              bStatusIsOk : 1;                                  		// 0x017C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_LevelStreaming" );

		return pClassPointer;
	};

};

UClass* USeqAct_LevelStreaming::pClassPointer = NULL;

// Class Engine.SeqAct_MultiLevelStreaming
// 0x0014 (0x0180 - 0x016C)
class USeqAct_MultiLevelStreaming : public USeqAct_LevelStreamingBase
{
public:
	TArray< struct FLevelStreamingNameCombo >          Levels;                                           		// 0x016C (0x0010) [0x0000000000000000]              
	DWORD                                              bUnloadAllOtherLevels : 1;                        		// 0x017C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bStatusIsOk : 1;                                  		// 0x017C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_MultiLevelStreaming" );

		return pClassPointer;
	};

};

UClass* USeqAct_MultiLevelStreaming::pClassPointer = NULL;

// Class Engine.SeqAct_LevelVisibility
// 0x0014 (0x017C - 0x0168)
class USeqAct_LevelVisibility : public USeqAct_Latent
{
public:
	class ULevelStreaming*                             Level;                                            		// 0x0168 (0x0008) [0x0000000000000000]              
	struct FName                                       LevelName;                                        		// 0x0170 (0x0008) [0x0000000000000000]              
	DWORD                                              bStatusIsOk : 1;                                  		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_LevelVisibility" );

		return pClassPointer;
	};

};

UClass* USeqAct_LevelVisibility::pClassPointer = NULL;

// Class Engine.SeqAct_PlaySound
// 0x0028 (0x0190 - 0x0168)
class USeqAct_PlaySound : public USeqAct_Latent
{
public:
	class USoundCue*                                   PlaySound;                                        		// 0x0168 (0x0008) [0x0000000000000000]              
	float                                              ExtraDelay;                                       		// 0x0170 (0x0004) [0x0000000000000000]              
	DWORD                                              bDelayReached : 1;                                		// 0x0174 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSuppressSubtitles : 1;                           		// 0x0174 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bStopped : 1;                                     		// 0x0174 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              SoundDuration;                                    		// 0x0178 (0x0004) [0x0000000000000000]              
	float                                              FadeInTime;                                       		// 0x017C (0x0004) [0x0000000000000000]              
	float                                              FadeOutTime;                                      		// 0x0180 (0x0004) [0x0000000000000000]              
	float                                              VolumeMultiplier;                                 		// 0x0184 (0x0004) [0x0000000000000000]              
	float                                              PitchMultiplier;                                  		// 0x0188 (0x0004) [0x0000000000000000]              
	float                                              BeforeEndTime;                                    		// 0x018C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_PlaySound" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_PlaySound::pClassPointer = NULL;

// Class Engine.SeqAct_PrepareMapChange
// 0x001C (0x0184 - 0x0168)
class USeqAct_PrepareMapChange : public USeqAct_Latent
{
public:
	struct FName                                       MainLevelName;                                    		// 0x0168 (0x0008) [0x0000000000000000]              
	TArray< struct FName >                             InitiallyLoadedSecondaryLevelNames;               		// 0x0170 (0x0010) [0x0000000000000000]              
	DWORD                                              bIsHighPriority : 1;                              		// 0x0180 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bStatusIsOk : 1;                                  		// 0x0180 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_PrepareMapChange" );

		return pClassPointer;
	};

};

UClass* USeqAct_PrepareMapChange::pClassPointer = NULL;

// Class Engine.SeqAct_SetDOFParams
// 0x0058 (0x01C0 - 0x0168)
class USeqAct_SetDOFParams : public USeqAct_Latent
{
public:
	float                                              FalloffExponent;                                  		// 0x0168 (0x0004) [0x0000000000000000]              
	float                                              BlurKernelSize;                                   		// 0x016C (0x0004) [0x0000000000000000]              
	float                                              MaxNearBlurAmount;                                		// 0x0170 (0x0004) [0x0000000000000000]              
	float                                              MinBlurAmount;                                    		// 0x0174 (0x0004) [0x0000000000000000]              
	float                                              MaxFarBlurAmount;                                 		// 0x0178 (0x0004) [0x0000000000000000]              
	float                                              FocusInnerRadius;                                 		// 0x017C (0x0004) [0x0000000000000000]              
	float                                              FocusDistance;                                    		// 0x0180 (0x0004) [0x0000000000000000]              
	struct FVector                                     FocusPosition;                                    		// 0x0184 (0x000C) [0x0000000000000000]              
	float                                              InterpolateSeconds;                               		// 0x0190 (0x0004) [0x0000000000000000]              
	float                                              InterpolateElapsed;                               		// 0x0194 (0x0004) [0x0000000000000000]              
	float                                              OldFalloffExponent;                               		// 0x0198 (0x0004) [0x0000000000000000]              
	float                                              OldBlurKernelSize;                                		// 0x019C (0x0004) [0x0000000000000000]              
	float                                              OldMaxNearBlurAmount;                             		// 0x01A0 (0x0004) [0x0000000000000000]              
	float                                              OldMinBlurAmount;                                 		// 0x01A4 (0x0004) [0x0000000000000000]              
	float                                              OldMaxFarBlurAmount;                              		// 0x01A8 (0x0004) [0x0000000000000000]              
	float                                              OldFocusInnerRadius;                              		// 0x01AC (0x0004) [0x0000000000000000]              
	float                                              OldFocusDistance;                                 		// 0x01B0 (0x0004) [0x0000000000000000]              
	struct FVector                                     OldFocusPosition;                                 		// 0x01B4 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetDOFParams" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetDOFParams::pClassPointer = NULL;

// Class Engine.SeqAct_SetMotionBlurParams
// 0x0010 (0x0178 - 0x0168)
class USeqAct_SetMotionBlurParams : public USeqAct_Latent
{
public:
	float                                              MotionBlurAmount;                                 		// 0x0168 (0x0004) [0x0000000000000000]              
	float                                              InterpolateSeconds;                               		// 0x016C (0x0004) [0x0000000000000000]              
	float                                              InterpolateElapsed;                               		// 0x0170 (0x0004) [0x0000000000000000]              
	float                                              OldMotionBlurAmount;                              		// 0x0174 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetMotionBlurParams" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetMotionBlurParams::pClassPointer = NULL;

// Class Engine.SeqAct_StreamInTextures
// 0x0040 (0x01A8 - 0x0168)
class USeqAct_StreamInTextures : public USeqAct_Latent
{
public:
	DWORD                                              bLocationBased : 1;                               		// 0x0168 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bStreamingActive : 1;                             		// 0x0168 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bHasTriggeredAllLoaded : 1;                       		// 0x0168 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              Seconds;                                          		// 0x016C (0x0004) [0x0000000000000000]              
	float                                              StreamingDistanceMultiplier;                      		// 0x0170 (0x0004) [0x0000000000000000]              
	int                                                NumWantingResourcesID;                            		// 0x0174 (0x0004) [0x0000000000000000]              
	float                                              StopTimestamp;                                    		// 0x0178 (0x0004) [0x0000000000000000]              
	TArray< class UObject* >                           LocationActors;                                   		// 0x017C (0x0010) [0x0000000000000000]              
	TArray< class UMaterialInterface* >                ForceMaterials;                                   		// 0x018C (0x0010) [0x0000000000000000]              
	struct FTextureGroupContainer                      CinematicTextureGroups;                           		// 0x019C (0x0008) [0x0000000000000000]              
	int                                                SelectedCinematicTextureGroups;                   		// 0x01A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_StreamInTextures" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_StreamInTextures::pClassPointer = NULL;

// Class Engine.SeqAct_WaitForLevelsVisible
// 0x0014 (0x017C - 0x0168)
class USeqAct_WaitForLevelsVisible : public USeqAct_Latent
{
public:
	TArray< struct FName >                             LevelNames;                                       		// 0x0168 (0x0010) [0x0000000000000000]              
	DWORD                                              bShouldBlockOnLoad : 1;                           		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_WaitForLevelsVisible" );

		return pClassPointer;
	};

	void eventActivated ( );
	void CheckLevelsVisible ( );
};

UClass* USeqAct_WaitForLevelsVisible::pClassPointer = NULL;

// Class Engine.SeqAct_Log
// 0x0024 (0x0174 - 0x0150)
class USeqAct_Log : public USequenceAction
{
public:
	DWORD                                              bOutputToScreen : 1;                              		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIncludeObjComment : 1;                           		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              TargetDuration;                                   		// 0x0154 (0x0004) [0x0000000000000000]              
	struct FVector                                     TargetOffset;                                     		// 0x0158 (0x000C) [0x0000000000000000]              
	struct FString                                     LogMessage;                                       		// 0x0164 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_Log" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_Log::pClassPointer = NULL;

// Class Engine.SeqAct_FeatureTest
// 0x0028 (0x019C - 0x0174)
class USeqAct_FeatureTest : public USeqAct_Log
{
public:
	struct FString                                     FreezeAtParameters;                               		// 0x0174 (0x0010) [0x0000000000000000]              
	float                                              ScreenShotDelay;                                  		// 0x0184 (0x0004) [0x0000000000000000]              
	struct FString                                     ScreenShotName;                                   		// 0x0188 (0x0010) [0x0000000000000000]              
	float                                              RemainingScreenShotDelay;                         		// 0x0198 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_FeatureTest" );

		return pClassPointer;
	};

};

UClass* USeqAct_FeatureTest::pClassPointer = NULL;

// Class Engine.SeqAct_ModifyCover
// 0x0018 (0x0168 - 0x0150)
class USeqAct_ModifyCover : public USequenceAction
{
public:
	TArray< int >                                      Slots;                                            		// 0x0150 (0x0010) [0x0000000000000000]              
	unsigned char                                      ManualCoverType;                                  		// 0x0160 (0x0001) [0x0000000000000000]              
	DWORD                                              bManualAdjustPlayersOnly : 1;                     		// 0x0164 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ModifyCover" );

		return pClassPointer;
	};

};

UClass* USeqAct_ModifyCover::pClassPointer = NULL;

// Class Engine.SeqAct_ModifyHealth
// 0x0020 (0x0170 - 0x0150)
class USeqAct_ModifyHealth : public USequenceAction
{
public:
	class UClass*                                      DamageType;                                       		// 0x0150 (0x0008) [0x0000000000000000]              
	float                                              Momentum;                                         		// 0x0158 (0x0004) [0x0000000000000000]              
	float                                              Amount;                                           		// 0x015C (0x0004) [0x0000000000000000]              
	float                                              Radius;                                           		// 0x0160 (0x0004) [0x0000000000000000]              
	DWORD                                              bHeal : 1;                                        		// 0x0164 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bRadial : 1;                                      		// 0x0164 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bFalloff : 1;                                     		// 0x0164 (0x0004) [0x0000000000000000] [0x00000004] 
	class AActor*                                      Instigator;                                       		// 0x0168 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ModifyHealth" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_ModifyHealth::pClassPointer = NULL;

// Class Engine.SeqAct_ParticleEventGenerator
// 0x0050 (0x01A0 - 0x0150)
class USeqAct_ParticleEventGenerator : public USequenceAction
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseEmitterLocation : 1;                          		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 
	class AActor*                                      Instigator;                                       		// 0x0154 (0x0008) [0x0000000000000000]              
	TArray< struct FString >                           EventNames;                                       		// 0x015C (0x0010) [0x0000000000000000]              
	float                                              EventTime;                                        		// 0x016C (0x0004) [0x0000000000000000]              
	struct FVector                                     EventLocation;                                    		// 0x0170 (0x000C) [0x0000000000000000]              
	struct FVector                                     EventDirection;                                   		// 0x017C (0x000C) [0x0000000000000000]              
	struct FVector                                     EventVelocity;                                    		// 0x0188 (0x000C) [0x0000000000000000]              
	struct FVector                                     EventNormal;                                      		// 0x0194 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ParticleEventGenerator" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_ParticleEventGenerator::pClassPointer = NULL;

// Class Engine.SeqAct_PhysXSwitch
// 0x0000 (0x0150 - 0x0150)
class USeqAct_PhysXSwitch : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_PhysXSwitch" );

		return pClassPointer;
	};

};

UClass* USeqAct_PhysXSwitch::pClassPointer = NULL;

// Class Engine.SeqAct_PlayCameraAnim
// 0x0028 (0x0178 - 0x0150)
class USeqAct_PlayCameraAnim : public USequenceAction
{
public:
	class UCameraAnim*                                 CameraAnim;                                       		// 0x0150 (0x0008) [0x0000000000000000]              
	DWORD                                              bLoop : 1;                                        		// 0x0158 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bRandomStartTime : 1;                             		// 0x0158 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              BlendInTime;                                      		// 0x015C (0x0004) [0x0000000000000000]              
	float                                              BlendOutTime;                                     		// 0x0160 (0x0004) [0x0000000000000000]              
	float                                              Rate;                                             		// 0x0164 (0x0004) [0x0000000000000000]              
	float                                              IntensityScale;                                   		// 0x0168 (0x0004) [0x0000000000000000]              
	unsigned char                                      PlaySpace;                                        		// 0x016C (0x0001) [0x0000000000000000]              
	class AActor*                                      UserDefinedSpaceActor;                            		// 0x0170 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_PlayCameraAnim" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_PlayCameraAnim::pClassPointer = NULL;

// Class Engine.SeqAct_PlayFaceFXAnim
// 0x0038 (0x0188 - 0x0150)
class USeqAct_PlayFaceFXAnim : public USequenceAction
{
public:
	class UFaceFXAnimSet*                              FaceFXAnimSetRef;                                 		// 0x0150 (0x0008) [0x0000000000000000]              
	struct FString                                     FaceFXGroupName;                                  		// 0x0158 (0x0010) [0x0000000000000000]              
	struct FString                                     FaceFXAnimName;                                   		// 0x0168 (0x0010) [0x0000000000000000]              
	class USoundCue*                                   SoundCueToPlay;                                   		// 0x0178 (0x0008) [0x0000000000000000]              
	class UAkEvent*                                    AkEventToPlay;                                    		// 0x0180 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_PlayFaceFXAnim" );

		return pClassPointer;
	};

};

UClass* USeqAct_PlayFaceFXAnim::pClassPointer = NULL;

// Class Engine.SeqAct_PlayMusicTrack
// 0x002C (0x017C - 0x0150)
class USeqAct_PlayMusicTrack : public USequenceAction
{
public:
	struct FMusicTrackStruct                           MusicTrack;                                       		// 0x0150 (0x002C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_PlayMusicTrack" );

		return pClassPointer;
	};

};

UClass* USeqAct_PlayMusicTrack::pClassPointer = NULL;

// Class Engine.SeqAct_Possess
// 0x000C (0x015C - 0x0150)
class USeqAct_Possess : public USequenceAction
{
public:
	class APawn*                                       PawnToPossess;                                    		// 0x0150 (0x0008) [0x0000000000000000]              
	DWORD                                              bKillOldPawn : 1;                                 		// 0x0158 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bTryToLeaveVehicle : 1;                           		// 0x0158 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_Possess" );

		return pClassPointer;
	};

};

UClass* USeqAct_Possess::pClassPointer = NULL;

// Class Engine.SeqAct_RangeSwitch
// 0x0010 (0x0160 - 0x0150)
class USeqAct_RangeSwitch : public USequenceAction
{
public:
	TArray< struct FSwitchRange >                      Ranges;                                           		// 0x0150 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_RangeSwitch" );

		return pClassPointer;
	};

};

UClass* USeqAct_RangeSwitch::pClassPointer = NULL;

// Class Engine.SeqAct_SetActiveAnimChild
// 0x0010 (0x0160 - 0x0150)
class USeqAct_SetActiveAnimChild : public USequenceAction
{
public:
	struct FName                                       NodeName;                                         		// 0x0150 (0x0008) [0x0000000000000000]              
	int                                                ChildIndex;                                       		// 0x0158 (0x0004) [0x0000000000000000]              
	float                                              BlendTime;                                        		// 0x015C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetActiveAnimChild" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetActiveAnimChild::pClassPointer = NULL;

// Class Engine.SeqAct_SetApexClothingParam
// 0x0004 (0x0154 - 0x0150)
class USeqAct_SetApexClothingParam : public USequenceAction
{
public:
	DWORD                                              bEnableApexClothingSimulation : 1;                		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetApexClothingParam" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetApexClothingParam::pClassPointer = NULL;

// Class Engine.SeqAct_SetBlockRigidBody
// 0x0000 (0x0150 - 0x0150)
class USeqAct_SetBlockRigidBody : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetBlockRigidBody" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetBlockRigidBody::pClassPointer = NULL;

// Class Engine.SeqAct_SetCameraTarget
// 0x0018 (0x0168 - 0x0150)
class USeqAct_SetCameraTarget : public USequenceAction
{
public:
	class AActor*                                      CameraTarget;                                     		// 0x0150 (0x0008) [0x0000000000000000]              
	struct FViewTargetTransitionParams                 TransitionParams;                                 		// 0x0158 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetCameraTarget" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_SetCameraTarget::pClassPointer = NULL;

// Class Engine.SeqAct_SetMaterial
// 0x000C (0x015C - 0x0150)
class USeqAct_SetMaterial : public USequenceAction
{
public:
	class UMaterialInterface*                          NewMaterial;                                      		// 0x0150 (0x0008) [0x0000000000000000]              
	int                                                MaterialIndex;                                    		// 0x0158 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetMaterial" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetMaterial::pClassPointer = NULL;

// Class Engine.SeqAct_SetMatInstScalarParam
// 0x0014 (0x0164 - 0x0150)
class USeqAct_SetMatInstScalarParam : public USequenceAction
{
public:
	class UMaterialInstanceConstant*                   MatInst;                                          		// 0x0150 (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName;                                        		// 0x0158 (0x0008) [0x0000000000000000]              
	float                                              ScalarValue;                                      		// 0x0160 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetMatInstScalarParam" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetMatInstScalarParam::pClassPointer = NULL;

// Class Engine.SeqAct_SetMesh
// 0x0018 (0x0168 - 0x0150)
class USeqAct_SetMesh : public USequenceAction
{
public:
	class USkeletalMesh*                               NewSkeletalMesh;                                  		// 0x0150 (0x0008) [0x0000000000000000]              
	class UStaticMesh*                                 NewStaticMesh;                                    		// 0x0158 (0x0008) [0x0000000000000000]              
	unsigned char                                      MeshType;                                         		// 0x0160 (0x0001) [0x0000000000000000]              
	DWORD                                              bIsAllowedToMove : 1;                             		// 0x0164 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAllowDecalsToReattach : 1;                       		// 0x0164 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetMesh" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetMesh::pClassPointer = NULL;

// Class Engine.SeqAct_SetPhysics
// 0x0001 (0x0151 - 0x0150)
class USeqAct_SetPhysics : public USequenceAction
{
public:
	unsigned char                                      newPhysics;                                       		// 0x0150 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetPhysics" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetPhysics::pClassPointer = NULL;

// Class Engine.SeqAct_SetRigidBodyIgnoreVehicles
// 0x0000 (0x0150 - 0x0150)
class USeqAct_SetRigidBodyIgnoreVehicles : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetRigidBodyIgnoreVehicles" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetRigidBodyIgnoreVehicles::pClassPointer = NULL;

// Class Engine.SeqAct_SetSequenceVariable
// 0x0000 (0x0150 - 0x0150)
class USeqAct_SetSequenceVariable : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetSequenceVariable" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetSequenceVariable::pClassPointer = NULL;

// Class Engine.SeqAct_AccessObjectList
// 0x000C (0x015C - 0x0150)
class USeqAct_AccessObjectList : public USeqAct_SetSequenceVariable
{
public:
	class UObject*                                     OutputObject;                                     		// 0x0150 (0x0008) [0x0000000000000000]              
	int                                                ObjectIndex;                                      		// 0x0158 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_AccessObjectList" );

		return pClassPointer;
	};

};

UClass* USeqAct_AccessObjectList::pClassPointer = NULL;

// Class Engine.SeqAct_AddFloat
// 0x0010 (0x0160 - 0x0150)
class USeqAct_AddFloat : public USeqAct_SetSequenceVariable
{
public:
	float                                              ValueA;                                           		// 0x0150 (0x0004) [0x0000000000000000]              
	float                                              ValueB;                                           		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              FloatResult;                                      		// 0x0158 (0x0004) [0x0000000000000000]              
	int                                                IntResult;                                        		// 0x015C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_AddFloat" );

		return pClassPointer;
	};

};

UClass* USeqAct_AddFloat::pClassPointer = NULL;

// Class Engine.SeqAct_AddInt
// 0x0010 (0x0160 - 0x0150)
class USeqAct_AddInt : public USeqAct_SetSequenceVariable
{
public:
	int                                                ValueA;                                           		// 0x0150 (0x0004) [0x0000000000000000]              
	int                                                ValueB;                                           		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              FloatResult;                                      		// 0x0158 (0x0004) [0x0000000000000000]              
	int                                                IntResult;                                        		// 0x015C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_AddInt" );

		return pClassPointer;
	};

};

UClass* USeqAct_AddInt::pClassPointer = NULL;

// Class Engine.SeqAct_CastToFloat
// 0x0008 (0x0158 - 0x0150)
class USeqAct_CastToFloat : public USeqAct_SetSequenceVariable
{
public:
	int                                                Value;                                            		// 0x0150 (0x0004) [0x0000000000000000]              
	float                                              FloatResult;                                      		// 0x0154 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_CastToFloat" );

		return pClassPointer;
	};

};

UClass* USeqAct_CastToFloat::pClassPointer = NULL;

// Class Engine.SeqAct_CastToInt
// 0x000C (0x015C - 0x0150)
class USeqAct_CastToInt : public USeqAct_SetSequenceVariable
{
public:
	DWORD                                              bTruncate : 1;                                    		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              Value;                                            		// 0x0154 (0x0004) [0x0000000000000000]              
	int                                                IntResult;                                        		// 0x0158 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_CastToInt" );

		return pClassPointer;
	};

};

UClass* USeqAct_CastToInt::pClassPointer = NULL;

// Class Engine.SeqAct_DivideFloat
// 0x0010 (0x0160 - 0x0150)
class USeqAct_DivideFloat : public USeqAct_SetSequenceVariable
{
public:
	float                                              ValueA;                                           		// 0x0150 (0x0004) [0x0000000000000000]              
	float                                              ValueB;                                           		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              FloatResult;                                      		// 0x0158 (0x0004) [0x0000000000000000]              
	int                                                IntResult;                                        		// 0x015C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_DivideFloat" );

		return pClassPointer;
	};

};

UClass* USeqAct_DivideFloat::pClassPointer = NULL;

// Class Engine.SeqAct_DivideInt
// 0x0010 (0x0160 - 0x0150)
class USeqAct_DivideInt : public USeqAct_SetSequenceVariable
{
public:
	int                                                ValueA;                                           		// 0x0150 (0x0004) [0x0000000000000000]              
	int                                                ValueB;                                           		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              FloatResult;                                      		// 0x0158 (0x0004) [0x0000000000000000]              
	int                                                IntResult;                                        		// 0x015C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_DivideInt" );

		return pClassPointer;
	};

};

UClass* USeqAct_DivideInt::pClassPointer = NULL;

// Class Engine.SeqAct_ModifyObjectList
// 0x0004 (0x0154 - 0x0150)
class USeqAct_ModifyObjectList : public USeqAct_SetSequenceVariable
{
public:
	int                                                ListEntriesCount;                                 		// 0x0150 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ModifyObjectList" );

		return pClassPointer;
	};

};

UClass* USeqAct_ModifyObjectList::pClassPointer = NULL;

// Class Engine.SeqAct_MultiplyFloat
// 0x0010 (0x0160 - 0x0150)
class USeqAct_MultiplyFloat : public USeqAct_SetSequenceVariable
{
public:
	float                                              ValueA;                                           		// 0x0150 (0x0004) [0x0000000000000000]              
	float                                              ValueB;                                           		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              FloatResult;                                      		// 0x0158 (0x0004) [0x0000000000000000]              
	int                                                IntResult;                                        		// 0x015C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_MultiplyFloat" );

		return pClassPointer;
	};

};

UClass* USeqAct_MultiplyFloat::pClassPointer = NULL;

// Class Engine.SeqAct_MultiplyInt
// 0x0010 (0x0160 - 0x0150)
class USeqAct_MultiplyInt : public USeqAct_SetSequenceVariable
{
public:
	int                                                ValueA;                                           		// 0x0150 (0x0004) [0x0000000000000000]              
	int                                                ValueB;                                           		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              FloatResult;                                      		// 0x0158 (0x0004) [0x0000000000000000]              
	int                                                IntResult;                                        		// 0x015C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_MultiplyInt" );

		return pClassPointer;
	};

};

UClass* USeqAct_MultiplyInt::pClassPointer = NULL;

// Class Engine.SeqAct_SetBool
// 0x0004 (0x0154 - 0x0150)
class USeqAct_SetBool : public USeqAct_SetSequenceVariable
{
public:
	DWORD                                              DefaultValue : 1;                                 		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetBool" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetBool::pClassPointer = NULL;

// Class Engine.SeqAct_SetFloat
// 0x0014 (0x0164 - 0x0150)
class USeqAct_SetFloat : public USeqAct_SetSequenceVariable
{
public:
	float                                              Target;                                           		// 0x0150 (0x0004) [0x0000000000000000]              
	TArray< float >                                    Value;                                            		// 0x0154 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetFloat" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_SetFloat::pClassPointer = NULL;

// Class Engine.SeqAct_SetInt
// 0x0014 (0x0164 - 0x0150)
class USeqAct_SetInt : public USeqAct_SetSequenceVariable
{
public:
	int                                                Target;                                           		// 0x0150 (0x0004) [0x0000000000000000]              
	TArray< int >                                      Value;                                            		// 0x0154 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetInt" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_SetInt::pClassPointer = NULL;

// Class Engine.SeqAct_SetLocation
// 0x0024 (0x0174 - 0x0150)
class USeqAct_SetLocation : public USeqAct_SetSequenceVariable
{
public:
	DWORD                                              bSetLocation : 1;                                 		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSetRotation : 1;                                 		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FVector                                     LocationValue;                                    		// 0x0154 (0x000C) [0x0000000000000000]              
	struct FRotator                                    RotationValue;                                    		// 0x0160 (0x000C) [0x0000000000000000]              
	class UObject*                                     Target;                                           		// 0x016C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetLocation" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_SetLocation::pClassPointer = NULL;

// Class Engine.SeqAct_SetObject
// 0x0010 (0x0160 - 0x0150)
class USeqAct_SetObject : public USeqAct_SetSequenceVariable
{
public:
	class UObject*                                     DefaultValue;                                     		// 0x0150 (0x0008) [0x0000000000000000]              
	class UObject*                                     Value;                                            		// 0x0158 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetObject" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_SetObject::pClassPointer = NULL;

// Class Engine.SeqAct_SetString
// 0x0020 (0x0170 - 0x0150)
class USeqAct_SetString : public USeqAct_SetSequenceVariable
{
public:
	struct FString                                     Target;                                           		// 0x0150 (0x0010) [0x0000000000000000]              
	struct FString                                     Value;                                            		// 0x0160 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetString" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_SetString::pClassPointer = NULL;

// Class Engine.SeqAct_SubtractFloat
// 0x0010 (0x0160 - 0x0150)
class USeqAct_SubtractFloat : public USeqAct_SetSequenceVariable
{
public:
	float                                              ValueA;                                           		// 0x0150 (0x0004) [0x0000000000000000]              
	float                                              ValueB;                                           		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              FloatResult;                                      		// 0x0158 (0x0004) [0x0000000000000000]              
	int                                                IntResult;                                        		// 0x015C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SubtractFloat" );

		return pClassPointer;
	};

};

UClass* USeqAct_SubtractFloat::pClassPointer = NULL;

// Class Engine.SeqAct_SubtractInt
// 0x0010 (0x0160 - 0x0150)
class USeqAct_SubtractInt : public USeqAct_SetSequenceVariable
{
public:
	int                                                ValueA;                                           		// 0x0150 (0x0004) [0x0000000000000000]              
	int                                                ValueB;                                           		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              FloatResult;                                      		// 0x0158 (0x0004) [0x0000000000000000]              
	int                                                IntResult;                                        		// 0x015C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SubtractInt" );

		return pClassPointer;
	};

};

UClass* USeqAct_SubtractInt::pClassPointer = NULL;

// Class Engine.SeqAct_SetVectorComponents
// 0x0018 (0x0168 - 0x0150)
class USeqAct_SetVectorComponents : public USequenceAction
{
public:
	struct FVector                                     OutVector;                                        		// 0x0150 (0x000C) [0x0000000000000000]              
	float                                              X;                                                		// 0x015C (0x0004) [0x0000000000000000]              
	float                                              Y;                                                		// 0x0160 (0x0004) [0x0000000000000000]              
	float                                              Z;                                                		// 0x0164 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetVectorComponents" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetVectorComponents::pClassPointer = NULL;

// Class Engine.SeqAct_SetWorldAttractorParam
// 0x0084 (0x01D4 - 0x0150)
class USeqAct_SetWorldAttractorParam : public USequenceAction
{
public:
	TArray< class AWorldAttractor* >                   Attractor;                                        		// 0x0150 (0x0010) [0x0000000000000000]              
	DWORD                                              bEnabledField : 1;                                		// 0x0160 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFalloffTypeField : 1;                            		// 0x0160 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bFalloffExponentField : 1;                        		// 0x0160 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bRangeField : 1;                                  		// 0x0160 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bStrengthField : 1;                               		// 0x0160 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bEnabled : 1;                                     		// 0x0160 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned char                                      FalloffType;                                      		// 0x0164 (0x0001) [0x0000000000000000]              
	struct FRawDistributionFloat                       FalloffExponent;                                  		// 0x0168 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Range;                                            		// 0x018C (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Strength;                                         		// 0x01B0 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetWorldAttractorParam" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetWorldAttractorParam::pClassPointer = NULL;

// Class Engine.SeqAct_Switch
// 0x001C (0x016C - 0x0150)
class USeqAct_Switch : public USequenceAction
{
public:
	int                                                LinkCount;                                        		// 0x0150 (0x0004) [0x0000000000000000]              
	int                                                IncrementAmount;                                  		// 0x0154 (0x0004) [0x0000000000000000]              
	DWORD                                              bLooping : 1;                                     		// 0x0158 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAutoDisableLinks : 1;                            		// 0x0158 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< int >                                      Indices;                                          		// 0x015C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_Switch" );

		return pClassPointer;
	};

};

UClass* USeqAct_Switch::pClassPointer = NULL;

// Class Engine.SeqAct_RandomSwitch
// 0x0010 (0x017C - 0x016C)
class USeqAct_RandomSwitch : public USeqAct_Switch
{
public:
	TArray< int >                                      AutoDisabledIndices;                              		// 0x016C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_RandomSwitch" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_RandomSwitch::pClassPointer = NULL;

// Class Engine.SeqAct_Timer
// 0x0008 (0x0158 - 0x0150)
class USeqAct_Timer : public USequenceAction
{
public:
	float                                              ActivationTime;                                   		// 0x0150 (0x0004) [0x0000000000000000]              
	float                                              Time;                                             		// 0x0154 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_Timer" );

		return pClassPointer;
	};

};

UClass* USeqAct_Timer::pClassPointer = NULL;

// Class Engine.SeqAct_Toggle
// 0x0000 (0x0150 - 0x0150)
class USeqAct_Toggle : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_Toggle" );

		return pClassPointer;
	};

};

UClass* USeqAct_Toggle::pClassPointer = NULL;

// Class Engine.SeqAct_Trace
// 0x0040 (0x0190 - 0x0150)
class USeqAct_Trace : public USequenceAction
{
public:
	DWORD                                              bTraceActors : 1;                                 		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bTraceWorld : 1;                                  		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FVector                                     TraceExtent;                                      		// 0x0154 (0x000C) [0x0000000000000000]              
	struct FVector                                     StartOffset;                                      		// 0x0160 (0x000C) [0x0000000000000000]              
	struct FVector                                     EndOffset;                                        		// 0x016C (0x000C) [0x0000000000000000]              
	class UObject*                                     HitObject;                                        		// 0x0178 (0x0008) [0x0000000000000000]              
	float                                              Distance;                                         		// 0x0180 (0x0004) [0x0000000000000000]              
	struct FVector                                     HitLocation;                                      		// 0x0184 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_Trace" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_Trace::pClassPointer = NULL;

// Class Engine.SequenceCondition
// 0x0000 (0x0134 - 0x0134)
class USequenceCondition : public USequenceOp
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SequenceCondition" );

		return pClassPointer;
	};

};

UClass* USequenceCondition::pClassPointer = NULL;

// Class Engine.SeqCond_CompareBool
// 0x0004 (0x0138 - 0x0134)
class USeqCond_CompareBool : public USequenceCondition
{
public:
	DWORD                                              bResult : 1;                                      		// 0x0134 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_CompareBool" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqCond_CompareBool::pClassPointer = NULL;

// Class Engine.SeqCond_CompareFloat
// 0x0008 (0x013C - 0x0134)
class USeqCond_CompareFloat : public USequenceCondition
{
public:
	float                                              ValueA;                                           		// 0x0134 (0x0004) [0x0000000000000000]              
	float                                              ValueB;                                           		// 0x0138 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_CompareFloat" );

		return pClassPointer;
	};

};

UClass* USeqCond_CompareFloat::pClassPointer = NULL;

// Class Engine.SeqCond_CompareInt
// 0x0008 (0x013C - 0x0134)
class USeqCond_CompareInt : public USequenceCondition
{
public:
	int                                                ValueA;                                           		// 0x0134 (0x0004) [0x0000000000000000]              
	int                                                ValueB;                                           		// 0x0138 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_CompareInt" );

		return pClassPointer;
	};

};

UClass* USeqCond_CompareInt::pClassPointer = NULL;

// Class Engine.SeqCond_CompareObject
// 0x0000 (0x0134 - 0x0134)
class USeqCond_CompareObject : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_CompareObject" );

		return pClassPointer;
	};

};

UClass* USeqCond_CompareObject::pClassPointer = NULL;

// Class Engine.SeqCond_GetServerType
// 0x0000 (0x0134 - 0x0134)
class USeqCond_GetServerType : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_GetServerType" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqCond_GetServerType::pClassPointer = NULL;

// Class Engine.SeqCond_Increment
// 0x000C (0x0140 - 0x0134)
class USeqCond_Increment : public USequenceCondition
{
public:
	int                                                IncrementAmount;                                  		// 0x0134 (0x0004) [0x0000000000000000]              
	int                                                ValueA;                                           		// 0x0138 (0x0004) [0x0000000000000000]              
	int                                                ValueB;                                           		// 0x013C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_Increment" );

		return pClassPointer;
	};

};

UClass* USeqCond_Increment::pClassPointer = NULL;

// Class Engine.SeqCond_IncrementFloat
// 0x000C (0x0140 - 0x0134)
class USeqCond_IncrementFloat : public USequenceCondition
{
public:
	float                                              IncrementAmount;                                  		// 0x0134 (0x0004) [0x0000000000000000]              
	float                                              ValueA;                                           		// 0x0138 (0x0004) [0x0000000000000000]              
	float                                              ValueB;                                           		// 0x013C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_IncrementFloat" );

		return pClassPointer;
	};

};

UClass* USeqCond_IncrementFloat::pClassPointer = NULL;

// Class Engine.SeqCond_IsAlive
// 0x0000 (0x0134 - 0x0134)
class USeqCond_IsAlive : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_IsAlive" );

		return pClassPointer;
	};

};

UClass* USeqCond_IsAlive::pClassPointer = NULL;

// Class Engine.SeqCond_IsBenchmarking
// 0x0000 (0x0134 - 0x0134)
class USeqCond_IsBenchmarking : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_IsBenchmarking" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqCond_IsBenchmarking::pClassPointer = NULL;

// Class Engine.SeqCond_IsConsole
// 0x0000 (0x0134 - 0x0134)
class USeqCond_IsConsole : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_IsConsole" );

		return pClassPointer;
	};

};

UClass* USeqCond_IsConsole::pClassPointer = NULL;

// Class Engine.SeqCond_IsInCombat
// 0x0000 (0x0134 - 0x0134)
class USeqCond_IsInCombat : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_IsInCombat" );

		return pClassPointer;
	};

};

UClass* USeqCond_IsInCombat::pClassPointer = NULL;

// Class Engine.SeqCond_IsLoggedIn
// 0x0004 (0x0138 - 0x0134)
class USeqCond_IsLoggedIn : public USequenceCondition
{
public:
	int                                                NumNeededLoggedIn;                                		// 0x0134 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_IsLoggedIn" );

		return pClassPointer;
	};

	void eventCheckLogins ( );
};

UClass* USeqCond_IsLoggedIn::pClassPointer = NULL;

// Class Engine.SeqCond_IsPIE
// 0x0000 (0x0134 - 0x0134)
class USeqCond_IsPIE : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_IsPIE" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqCond_IsPIE::pClassPointer = NULL;

// Class Engine.SeqCond_IsSameTeam
// 0x0000 (0x0134 - 0x0134)
class USeqCond_IsSameTeam : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_IsSameTeam" );

		return pClassPointer;
	};

};

UClass* USeqCond_IsSameTeam::pClassPointer = NULL;

// Class Engine.SeqCond_MatureLanguage
// 0x0000 (0x0134 - 0x0134)
class USeqCond_MatureLanguage : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_MatureLanguage" );

		return pClassPointer;
	};

};

UClass* USeqCond_MatureLanguage::pClassPointer = NULL;

// Class Engine.SeqCond_ShowGore
// 0x0000 (0x0134 - 0x0134)
class USeqCond_ShowGore : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_ShowGore" );

		return pClassPointer;
	};

};

UClass* USeqCond_ShowGore::pClassPointer = NULL;

// Class Engine.SeqCond_SwitchBase
// 0x0000 (0x0134 - 0x0134)
class USeqCond_SwitchBase : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_SwitchBase" );

		return pClassPointer;
	};

	void eventRemoveValueEntry ( );
	void eventInsertValueEntry ( );
	void eventIsFallThruEnabled ( );
	void eventVerifyDefaultCaseValue ( );
};

UClass* USeqCond_SwitchBase::pClassPointer = NULL;

// Class Engine.SeqCond_SwitchClass
// 0x0010 (0x0144 - 0x0134)
class USeqCond_SwitchClass : public USeqCond_SwitchBase
{
public:
	TArray< struct FSwitchClassInfo >                  ClassArray;                                       		// 0x0134 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_SwitchClass" );

		return pClassPointer;
	};

	void eventRemoveValueEntry ( );
	void eventInsertValueEntry ( );
	void eventIsFallThruEnabled ( );
	void eventVerifyDefaultCaseValue ( );
};

UClass* USeqCond_SwitchClass::pClassPointer = NULL;

// Class Engine.SeqCond_SwitchObject
// 0x0010 (0x0144 - 0x0134)
class USeqCond_SwitchObject : public USeqCond_SwitchBase
{
public:
	TArray< struct FSwitchObjectCase >                 SupportedValues;                                  		// 0x0134 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_SwitchObject" );

		return pClassPointer;
	};

	void eventRemoveValueEntry ( );
	void eventInsertValueEntry ( );
	void eventIsFallThruEnabled ( );
	void eventVerifyDefaultCaseValue ( );
};

UClass* USeqCond_SwitchObject::pClassPointer = NULL;

// Class Engine.SeqCond_SwitchPlatform
// 0x0000 (0x0134 - 0x0134)
class USeqCond_SwitchPlatform : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqCond_SwitchPlatform" );

		return pClassPointer;
	};

};

UClass* USeqCond_SwitchPlatform::pClassPointer = NULL;

// Class Engine.SequenceEvent
// 0x003C (0x0170 - 0x0134)
class USequenceEvent : public USequenceOp
{
public:
	TArray< class USequenceEvent* >                    DuplicateEvts;                                    		// 0x0134 (0x0010) [0x0000000000000000]              
	class AActor*                                      Originator;                                       		// 0x0144 (0x0008) [0x0000000000000000]              
	class AActor*                                      Instigator;                                       		// 0x014C (0x0008) [0x0000000000000000]              
	float                                              ActivationTime;                                   		// 0x0154 (0x0004) [0x0000000000000000]              
	int                                                TriggerCount;                                     		// 0x0158 (0x0004) [0x0000000000000000]              
	int                                                MaxTriggerCount;                                  		// 0x015C (0x0004) [0x0000000000000000]              
	float                                              ReTriggerDelay;                                   		// 0x0160 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x0164 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPlayerOnly : 1;                                  		// 0x0164 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bRegistered : 1;                                  		// 0x0164 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bClientSideOnly : 1;                              		// 0x0164 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned char                                      Priority;                                         		// 0x0168 (0x0001) [0x0000000000000000]              
	int                                                MaxWidth;                                         		// 0x016C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SequenceEvent" );

		return pClassPointer;
	};

	void eventToggled ( );
	void Reset ( );
	void CheckActivate ( );
	void eventRegisterEvent ( );
};

UClass* USequenceEvent::pClassPointer = NULL;

// Class Engine.SeqEvent_AISeeEnemy
// 0x0004 (0x0174 - 0x0170)
class USeqEvent_AISeeEnemy : public USequenceEvent
{
public:
	float                                              MaxSightDistance;                                 		// 0x0170 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_AISeeEnemy" );

		return pClassPointer;
	};

};

UClass* USeqEvent_AISeeEnemy::pClassPointer = NULL;

// Class Engine.SeqEvent_AnalogInput
// 0x0018 (0x0188 - 0x0170)
class USeqEvent_AnalogInput : public USequenceEvent
{
public:
	DWORD                                              bTrapInput : 1;                                   		// 0x0170 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                AllowedPlayerIndex;                               		// 0x0174 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             InputNames;                                       		// 0x0178 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_AnalogInput" );

		return pClassPointer;
	};

};

UClass* USeqEvent_AnalogInput::pClassPointer = NULL;

// Class Engine.SeqEvent_AnimNotify
// 0x0008 (0x0178 - 0x0170)
class USeqEvent_AnimNotify : public USequenceEvent
{
public:
	struct FName                                       NotifyName;                                       		// 0x0170 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_AnimNotify" );

		return pClassPointer;
	};

};

UClass* USeqEvent_AnimNotify::pClassPointer = NULL;

// Class Engine.SeqEvent_Console
// 0x0018 (0x0188 - 0x0170)
class USeqEvent_Console : public USequenceEvent
{
public:
	struct FName                                       ConsoleEventName;                                 		// 0x0170 (0x0008) [0x0000000000000000]              
	struct FString                                     EventDesc;                                        		// 0x0178 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_Console" );

		return pClassPointer;
	};

};

UClass* USeqEvent_Console::pClassPointer = NULL;

// Class Engine.SeqEvent_ConstraintBroken
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_ConstraintBroken : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_ConstraintBroken" );

		return pClassPointer;
	};

};

UClass* USeqEvent_ConstraintBroken::pClassPointer = NULL;

// Class Engine.SeqEvent_Destroyed
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_Destroyed : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_Destroyed" );

		return pClassPointer;
	};

};

UClass* USeqEvent_Destroyed::pClassPointer = NULL;

// Class Engine.SeqEvent_GetInventory
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_GetInventory : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_GetInventory" );

		return pClassPointer;
	};

};

UClass* USeqEvent_GetInventory::pClassPointer = NULL;

// Class Engine.SeqEvent_Input
// 0x0018 (0x0188 - 0x0170)
class USeqEvent_Input : public USequenceEvent
{
public:
	DWORD                                              bTrapInput : 1;                                   		// 0x0170 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                AllowedPlayerIndex;                               		// 0x0174 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             InputNames;                                       		// 0x0178 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_Input" );

		return pClassPointer;
	};

};

UClass* USeqEvent_Input::pClassPointer = NULL;

// Class Engine.SeqEvent_LevelBeginning
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_LevelBeginning : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_LevelBeginning" );

		return pClassPointer;
	};

};

UClass* USeqEvent_LevelBeginning::pClassPointer = NULL;

// Class Engine.SeqEvent_LevelLoaded
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_LevelLoaded : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_LevelLoaded" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqEvent_LevelLoaded::pClassPointer = NULL;

// Class Engine.SeqEvent_LevelStartup
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_LevelStartup : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_LevelStartup" );

		return pClassPointer;
	};

};

UClass* USeqEvent_LevelStartup::pClassPointer = NULL;

// Class Engine.SeqEvent_Mover
// 0x0004 (0x0174 - 0x0170)
class USeqEvent_Mover : public USequenceEvent
{
public:
	float                                              StayOpenTime;                                     		// 0x0170 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_Mover" );

		return pClassPointer;
	};

	void NotifyFinishedOpen ( );
	void NotifyDetached ( );
	void NotifyAttached ( );
	void NotifyEncroachingOn ( );
	void eventRegisterEvent ( );
};

UClass* USeqEvent_Mover::pClassPointer = NULL;

// Class Engine.SeqEvent_ParticleEvent
// 0x0034 (0x01A4 - 0x0170)
class USeqEvent_ParticleEvent : public USequenceEvent
{
public:
	unsigned char                                      EventType;                                        		// 0x0170 (0x0001) [0x0000000000000000]              
	struct FVector                                     EventPosition;                                    		// 0x0174 (0x000C) [0x0000000000000000]              
	float                                              EventEmitterTime;                                 		// 0x0180 (0x0004) [0x0000000000000000]              
	struct FVector                                     EventVelocity;                                    		// 0x0184 (0x000C) [0x0000000000000000]              
	float                                              EventParticleTime;                                		// 0x0190 (0x0004) [0x0000000000000000]              
	struct FVector                                     EventNormal;                                      		// 0x0194 (0x000C) [0x0000000000000000]              
	DWORD                                              UseRelfectedImpactVector : 1;                     		// 0x01A0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_ParticleEvent" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqEvent_ParticleEvent::pClassPointer = NULL;

// Class Engine.SeqEvent_ProjectileLanded
// 0x0004 (0x0174 - 0x0170)
class USeqEvent_ProjectileLanded : public USequenceEvent
{
public:
	float                                              MaxDistance;                                      		// 0x0170 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_ProjectileLanded" );

		return pClassPointer;
	};

};

UClass* USeqEvent_ProjectileLanded::pClassPointer = NULL;

// Class Engine.SeqEvent_RemoteEvent
// 0x000C (0x017C - 0x0170)
class USeqEvent_RemoteEvent : public USequenceEvent
{
public:
	struct FName                                       EventName;                                        		// 0x0170 (0x0008) [0x0000000000000000]              
	DWORD                                              bStatusIsOk : 1;                                  		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_RemoteEvent" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqEvent_RemoteEvent::pClassPointer = NULL;

// Class Engine.SeqEvent_RigidBodyCollision
// 0x0004 (0x0174 - 0x0170)
class USeqEvent_RigidBodyCollision : public USequenceEvent
{
public:
	float                                              MinCollisionVelocity;                             		// 0x0170 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_RigidBodyCollision" );

		return pClassPointer;
	};

};

UClass* USeqEvent_RigidBodyCollision::pClassPointer = NULL;

// Class Engine.SeqEvent_SeeDeath
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_SeeDeath : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_SeeDeath" );

		return pClassPointer;
	};

};

UClass* USeqEvent_SeeDeath::pClassPointer = NULL;

// Class Engine.SeqEvent_SequenceActivated
// 0x0010 (0x0180 - 0x0170)
class USeqEvent_SequenceActivated : public USequenceEvent
{
public:
	struct FString                                     InputLabel;                                       		// 0x0170 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_SequenceActivated" );

		return pClassPointer;
	};

};

UClass* USeqEvent_SequenceActivated::pClassPointer = NULL;

// Class Engine.SeqEvent_TakeDamage
// 0x0030 (0x01A0 - 0x0170)
class USeqEvent_TakeDamage : public USequenceEvent
{
public:
	float                                              MinDamageAmount;                                  		// 0x0170 (0x0004) [0x0000000000000000]              
	float                                              DamageThreshold;                                  		// 0x0174 (0x0004) [0x0000000000000000]              
	TArray< class UClass* >                            DamageTypes;                                      		// 0x0178 (0x0010) [0x0000000000000000]              
	TArray< class UClass* >                            IgnoreDamageTypes;                                		// 0x0188 (0x0010) [0x0000000000000000]              
	float                                              CurrentDamage;                                    		// 0x0198 (0x0004) [0x0000000000000000]              
	DWORD                                              bResetDamageOnToggle : 1;                         		// 0x019C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_TakeDamage" );

		return pClassPointer;
	};

	void eventToggled ( );
	void eventGetObjClassVersion ( );
	void Reset ( );
	void HandleDamage ( );
	void IsValidDamageType ( );
};

UClass* USeqEvent_TakeDamage::pClassPointer = NULL;

// Class Engine.SeqEvent_Touch
// 0x0034 (0x01A4 - 0x0170)
class USeqEvent_Touch : public USequenceEvent
{
public:
	TArray< class UClass* >                            ClassProximityTypes;                              		// 0x0170 (0x0010) [0x0000000000000000]              
	TArray< class UClass* >                            IgnoredClassProximityTypes;                       		// 0x0180 (0x0010) [0x0000000000000000]              
	DWORD                                              bForceOverlapping : 1;                            		// 0x0190 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseInstigator : 1;                               		// 0x0190 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAllowDeadPawns : 1;                              		// 0x0190 (0x0004) [0x0000000000000000] [0x00000004] 
	TArray< class AActor* >                            TouchedList;                                      		// 0x0194 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_Touch" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
	void NotifyTouchingPawnDied ( );
	void eventToggled ( );
	void CheckUnTouchActivate ( );
	void CheckTouchActivate ( );
};

UClass* USeqEvent_Touch::pClassPointer = NULL;

// Class Engine.SeqEvent_TouchInput
// 0x0010 (0x0180 - 0x0170)
class USeqEvent_TouchInput : public USequenceEvent
{
public:
	DWORD                                              bTrapInput : 1;                                   		// 0x0170 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                AllowedPlayerIndex;                               		// 0x0174 (0x0004) [0x0000000000000000]              
	int                                                AllowedTouchIndex;                                		// 0x0178 (0x0004) [0x0000000000000000]              
	int                                                AllowedTouchpadIndex;                             		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_TouchInput" );

		return pClassPointer;
	};

};

UClass* USeqEvent_TouchInput::pClassPointer = NULL;

// Class Engine.SeqEvent_Used
// 0x0040 (0x01B0 - 0x0170)
class USeqEvent_Used : public USequenceEvent
{
public:
	DWORD                                              bAimToInteract : 1;                               		// 0x0170 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseLineCheck : 1;                                		// 0x0170 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              InteractDistance;                                 		// 0x0174 (0x0004) [0x0000000000000000]              
	struct FString                                     InteractText;                                     		// 0x0178 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  InteractIcon;                                     		// 0x0188 (0x0008) [0x0000000000000000]              
	TArray< class UClass* >                            ClassProximityTypes;                              		// 0x0190 (0x0010) [0x0000000000000000]              
	TArray< class UClass* >                            IgnoredClassProximityTypes;                       		// 0x01A0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_Used" );

		return pClassPointer;
	};

};

UClass* USeqEvent_Used::pClassPointer = NULL;

// Class Engine.SequenceVariable
// 0x0008 (0x00D4 - 0x00CC)
class USequenceVariable : public USequenceObject
{
public:
	struct FName                                       VarName;                                          		// 0x00CC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SequenceVariable" );

		return pClassPointer;
	};

};

UClass* USequenceVariable::pClassPointer = NULL;

// Class Engine.InterpData
// 0x006C (0x0140 - 0x00D4)
class UInterpData : public USequenceVariable
{
public:
	float                                              InterpLength;                                     		// 0x00D4 (0x0004) [0x0000000000000000]              
	float                                              PathBuildTime;                                    		// 0x00D8 (0x0004) [0x0000000000000000]              
	TArray< class UInterpGroup* >                      InterpGroups;                                     		// 0x00DC (0x0010) [0x0000000000000000]              
	class UInterpCurveEdSetup*                         CurveEdSetup;                                     		// 0x00EC (0x0008) [0x0000000000000000]              
	TArray< class UInterpFilter* >                     InterpFilters;                                    		// 0x00F4 (0x0010) [0x0000000000000000]              
	class UInterpFilter*                               SelectedFilter;                                   		// 0x0104 (0x0008) [0x0000000000000000]              
	TArray< class UInterpFilter* >                     DefaultFilters;                                   		// 0x010C (0x0010) [0x0000000000000000]              
	float                                              EdSectionStart;                                   		// 0x011C (0x0004) [0x0000000000000000]              
	float                                              EdSectionEnd;                                     		// 0x0120 (0x0004) [0x0000000000000000]              
	DWORD                                              bShouldBakeAndPrune : 1;                          		// 0x0124 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< struct FAnimSetBakeAndPruneStatus >        BakeAndPruneStatus;                               		// 0x0128 (0x0010) [0x0000000000000000]              
	class UInterpGroupDirector*                        CachedDirectorGroup;                              		// 0x0138 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpData" );

		return pClassPointer;
	};

};

UClass* UInterpData::pClassPointer = NULL;

// Class Engine.SeqVar_Bool
// 0x0004 (0x00D8 - 0x00D4)
class USeqVar_Bool : public USequenceVariable
{
public:
	int                                                bValue;                                           		// 0x00D4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_Bool" );

		return pClassPointer;
	};

};

UClass* USeqVar_Bool::pClassPointer = NULL;

// Class Engine.SeqVar_External
// 0x0018 (0x00EC - 0x00D4)
class USeqVar_External : public USequenceVariable
{
public:
	class UClass*                                      ExpectedType;                                     		// 0x00D4 (0x0008) [0x0000000000000000]              
	struct FString                                     VariableLabel;                                    		// 0x00DC (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_External" );

		return pClassPointer;
	};

};

UClass* USeqVar_External::pClassPointer = NULL;

// Class Engine.SeqVar_Float
// 0x0004 (0x00D8 - 0x00D4)
class USeqVar_Float : public USequenceVariable
{
public:
	float                                              FloatValue;                                       		// 0x00D4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_Float" );

		return pClassPointer;
	};

};

UClass* USeqVar_Float::pClassPointer = NULL;

// Class Engine.SeqVar_RandomFloat
// 0x0008 (0x00E0 - 0x00D8)
class USeqVar_RandomFloat : public USeqVar_Float
{
public:
	float                                              Min;                                              		// 0x00D8 (0x0004) [0x0000000000000000]              
	float                                              Max;                                              		// 0x00DC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_RandomFloat" );

		return pClassPointer;
	};

};

UClass* USeqVar_RandomFloat::pClassPointer = NULL;

// Class Engine.SeqVar_Int
// 0x0004 (0x00D8 - 0x00D4)
class USeqVar_Int : public USequenceVariable
{
public:
	int                                                IntValue;                                         		// 0x00D4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_Int" );

		return pClassPointer;
	};

};

UClass* USeqVar_Int::pClassPointer = NULL;

// Class Engine.SeqVar_RandomInt
// 0x0008 (0x00E0 - 0x00D8)
class USeqVar_RandomInt : public USeqVar_Int
{
public:
	int                                                Min;                                              		// 0x00D8 (0x0004) [0x0000000000000000]              
	int                                                Max;                                              		// 0x00DC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_RandomInt" );

		return pClassPointer;
	};

};

UClass* USeqVar_RandomInt::pClassPointer = NULL;

// Class Engine.SeqVar_Named
// 0x0014 (0x00E8 - 0x00D4)
class USeqVar_Named : public USequenceVariable
{
public:
	class UClass*                                      ExpectedType;                                     		// 0x00D4 (0x0008) [0x0000000000000000]              
	struct FName                                       FindVarName;                                      		// 0x00DC (0x0008) [0x0000000000000000]              
	DWORD                                              bStatusIsOk : 1;                                  		// 0x00E4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_Named" );

		return pClassPointer;
	};

};

UClass* USeqVar_Named::pClassPointer = NULL;

// Class Engine.SeqVar_Object
// 0x0024 (0x00F8 - 0x00D4)
class USeqVar_Object : public USequenceVariable
{
public:
	class UObject*                                     ObjValue;                                         		// 0x00D4 (0x0008) [0x0000000000000000]              
	struct FVector                                     ActorLocation;                                    		// 0x00DC (0x000C) [0x0000000000000000]              
	TArray< class UClass* >                            SupportedClasses;                                 		// 0x00E8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_Object" );

		return pClassPointer;
	};

	void SetObjectValue ( );
	void GetObjectValue ( );
};

UClass* USeqVar_Object::pClassPointer = NULL;

// Class Engine.SeqVar_Character
// 0x0008 (0x0100 - 0x00F8)
class USeqVar_Character : public USeqVar_Object
{
public:
	class UClass*                                      PawnClass;                                        		// 0x00F8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_Character" );

		return pClassPointer;
	};

};

UClass* USeqVar_Character::pClassPointer = NULL;

// Class Engine.SeqVar_Group
// 0x001C (0x0114 - 0x00F8)
class USeqVar_Group : public USeqVar_Object
{
public:
	struct FName                                       GroupName;                                        		// 0x00F8 (0x0008) [0x0000000000000000]              
	DWORD                                              bCachedList : 1;                                  		// 0x0100 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class UObject* >                           Actors;                                           		// 0x0104 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_Group" );

		return pClassPointer;
	};

};

UClass* USeqVar_Group::pClassPointer = NULL;

// Class Engine.SeqVar_ObjectList
// 0x0010 (0x0108 - 0x00F8)
class USeqVar_ObjectList : public USeqVar_Object
{
public:
	TArray< class UObject* >                           ObjList;                                          		// 0x00F8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_ObjectList" );

		return pClassPointer;
	};

	void SetObjectValue ( );
	void GetObjectValue ( );
};

UClass* USeqVar_ObjectList::pClassPointer = NULL;

// Class Engine.SeqVar_ObjectVolume
// 0x0028 (0x0120 - 0x00F8)
class USeqVar_ObjectVolume : public USeqVar_Object
{
public:
	float                                              LastUpdateTime;                                   		// 0x00F8 (0x0004) [0x0000000000000000]              
	TArray< class UObject* >                           ContainedObjects;                                 		// 0x00FC (0x0010) [0x0000000000000000]              
	TArray< class UClass* >                            ExcludeClassList;                                 		// 0x010C (0x0010) [0x0000000000000000]              
	DWORD                                              bCollidingOnly : 1;                               		// 0x011C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_ObjectVolume" );

		return pClassPointer;
	};

};

UClass* USeqVar_ObjectVolume::pClassPointer = NULL;

// Class Engine.SeqVar_Player
// 0x0018 (0x0110 - 0x00F8)
class USeqVar_Player : public USeqVar_Object
{
public:
	TArray< class UObject* >                           Players;                                          		// 0x00F8 (0x0010) [0x0000000000000000]              
	DWORD                                              bAllPlayers : 1;                                  		// 0x0108 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                PlayerIdx;                                        		// 0x010C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_Player" );

		return pClassPointer;
	};

	void GetObjectValue ( );
	void UpdatePlayersList ( );
};

UClass* USeqVar_Player::pClassPointer = NULL;

// Class Engine.SeqVar_String
// 0x0010 (0x00E4 - 0x00D4)
class USeqVar_String : public USequenceVariable
{
public:
	struct FString                                     StrValue;                                         		// 0x00D4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_String" );

		return pClassPointer;
	};

};

UClass* USeqVar_String::pClassPointer = NULL;

// Class Engine.SeqVar_Vector
// 0x000C (0x00E0 - 0x00D4)
class USeqVar_Vector : public USequenceVariable
{
public:
	struct FVector                                     VectValue;                                        		// 0x00D4 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_Vector" );

		return pClassPointer;
	};

};

UClass* USeqVar_Vector::pClassPointer = NULL;

// Class Engine.AmbientSound
// 0x000C (0x0258 - 0x024C)
class AAmbientSound : public AKeypoint
{
public:
	DWORD                                              bAutoPlay : 1;                                    		// 0x024C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIsPlaying : 1;                                   		// 0x024C (0x0004) [0x0000000000000000] [0x00000002] 
	class UAudioComponent*                             AudioComponent;                                   		// 0x0250 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AmbientSound" );

		return pClassPointer;
	};

};

UClass* AAmbientSound::pClassPointer = NULL;

// Class Engine.AmbientSoundMovable
// 0x0000 (0x0258 - 0x0258)
class AAmbientSoundMovable : public AAmbientSound
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AmbientSoundMovable" );

		return pClassPointer;
	};

};

UClass* AAmbientSoundMovable::pClassPointer = NULL;

// Class Engine.AmbientSoundSimple
// 0x0018 (0x0270 - 0x0258)
class AAmbientSoundSimple : public AAmbientSound
{
public:
	class USoundNodeAmbient*                           AmbientProperties;                                		// 0x0258 (0x0008) [0x0000000000000000]              
	class USoundCue*                                   SoundCueInstance;                                 		// 0x0260 (0x0008) [0x0000000000000000]              
	class USoundNodeAmbient*                           SoundNodeInstance;                                		// 0x0268 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AmbientSoundSimple" );

		return pClassPointer;
	};

};

UClass* AAmbientSoundSimple::pClassPointer = NULL;

// Class Engine.AmbientSoundNonLoop
// 0x0000 (0x0270 - 0x0270)
class AAmbientSoundNonLoop : public AAmbientSoundSimple
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AmbientSoundNonLoop" );

		return pClassPointer;
	};

};

UClass* AAmbientSoundNonLoop::pClassPointer = NULL;

// Class Engine.AmbientSoundSimpleToggleable
// 0x0014 (0x0284 - 0x0270)
class AAmbientSoundSimpleToggleable : public AAmbientSoundSimple
{
public:
	DWORD                                              bCurrentlyPlaying : 1;                            		// 0x0270 (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )
	DWORD                                              bFadeOnToggle : 1;                                		// 0x0270 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIgnoreAutoPlay : 1;                              		// 0x0270 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              FadeInDuration;                                   		// 0x0274 (0x0004) [0x0000000000000000]              
	float                                              FadeInVolumeLevel;                                		// 0x0278 (0x0004) [0x0000000000000000]              
	float                                              FadeOutDuration;                                  		// 0x027C (0x0004) [0x0000000000000000]              
	float                                              FadeOutVolumeLevel;                               		// 0x0280 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AmbientSoundSimpleToggleable" );

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void OnToggle ( );
	void StopPlaying ( );
	void StartPlaying ( );
	void eventReplicatedEvent ( );
	void eventPostBeginPlay ( );
};

UClass* AAmbientSoundSimpleToggleable::pClassPointer = NULL;

// Class Engine.AmbientSoundNonLoopingToggleable
// 0x0000 (0x0284 - 0x0284)
class AAmbientSoundNonLoopingToggleable : public AAmbientSoundSimpleToggleable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AmbientSoundNonLoopingToggleable" );

		return pClassPointer;
	};

};

UClass* AAmbientSoundNonLoopingToggleable::pClassPointer = NULL;

// Class Engine.AmbientSoundSpline
// 0x0018 (0x0270 - 0x0258)
class AAmbientSoundSpline : public AAmbientSound
{
public:
	float                                              DistanceBetweenPoints;                            		// 0x0258 (0x0004) [0x0000000000000000]              
	class USplineComponent*                            SplineComponent;                                  		// 0x025C (0x0008) [0x0000000000000000]              
	struct FVector                                     TestPoint;                                        		// 0x0264 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AmbientSoundSpline" );

		return pClassPointer;
	};

};

UClass* AAmbientSoundSpline::pClassPointer = NULL;

// Class Engine.AmbientSoundSimpleSpline
// 0x0004 (0x0274 - 0x0270)
class AAmbientSoundSimpleSpline : public AAmbientSoundSpline
{
public:
	int                                                EditedSlot;                                       		// 0x0270 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AmbientSoundSimpleSpline" );

		return pClassPointer;
	};

};

UClass* AAmbientSoundSimpleSpline::pClassPointer = NULL;

// Class Engine.AmbientSoundSplineMultiCue
// 0x0004 (0x0274 - 0x0270)
class AAmbientSoundSplineMultiCue : public AAmbientSoundSpline
{
public:
	int                                                EditedSlot;                                       		// 0x0270 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AmbientSoundSplineMultiCue" );

		return pClassPointer;
	};

};

UClass* AAmbientSoundSplineMultiCue::pClassPointer = NULL;

// Class Engine.DistributionFloatSoundParameter
// 0x0003 (0x009C - 0x0099)
class UDistributionFloatSoundParameter : public UDistributionFloatParameterBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DistributionFloatSoundParameter" );

		return pClassPointer;
	};

};

UClass* UDistributionFloatSoundParameter::pClassPointer = NULL;

// Class Engine.SoundNode
// 0x0014 (0x0074 - 0x0060)
class USoundNode : public UObject
{
public:
	int                                                NodeUpdateHint;                                   		// 0x0060 (0x0004) [0x0000000000000000]              
	TArray< class USoundNode* >                        ChildNodes;                                       		// 0x0064 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNode" );

		return pClassPointer;
	};

};

UClass* USoundNode::pClassPointer = NULL;

// Class Engine.ForcedLoopSoundNode
// 0x0000 (0x0074 - 0x0074)
class UForcedLoopSoundNode : public USoundNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ForcedLoopSoundNode" );

		return pClassPointer;
	};

};

UClass* UForcedLoopSoundNode::pClassPointer = NULL;

// Class Engine.SoundNodeAmbient
// 0x003C (0x00B0 - 0x0074)
class USoundNodeAmbient : public USoundNode
{
public:
	DWORD                                              bAttenuate : 1;                                   		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSpatialize : 1;                                  		// 0x0074 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAttenuateWithLPF : 1;                            		// 0x0074 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              dBAttenuationAtMax;                               		// 0x0078 (0x0004) [0x0000000000000000]              
	unsigned char                                      DistanceModel;                                    		// 0x007C (0x0001) [0x0000000000000000]              
	float                                              RadiusMin;                                        		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              RadiusMax;                                        		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              LPFRadiusMin;                                     		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              LPFRadiusMax;                                     		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              PitchMin;                                         		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              PitchMax;                                         		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              VolumeMin;                                        		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              VolumeMax;                                        		// 0x009C (0x0004) [0x0000000000000000]              
	TArray< struct FAmbientSoundSlot >                 SoundSlots;                                       		// 0x00A0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeAmbient" );

		return pClassPointer;
	};

};

UClass* USoundNodeAmbient::pClassPointer = NULL;

// Class Engine.SoundNodeAmbientNonLoop
// 0x002C (0x00DC - 0x00B0)
class USoundNodeAmbientNonLoop : public USoundNodeAmbient
{
public:
	float                                              DelayMin;                                         		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              DelayMax;                                         		// 0x00B4 (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       DelayTime;                                        		// 0x00B8 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeAmbientNonLoop" );

		return pClassPointer;
	};

};

UClass* USoundNodeAmbientNonLoop::pClassPointer = NULL;

// Class Engine.SoundNodeAmbientNonLoopToggle
// 0x0000 (0x00DC - 0x00DC)
class USoundNodeAmbientNonLoopToggle : public USoundNodeAmbientNonLoop
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeAmbientNonLoopToggle" );

		return pClassPointer;
	};

};

UClass* USoundNodeAmbientNonLoopToggle::pClassPointer = NULL;

// Class Engine.SoundNodeAttenuation
// 0x0020 (0x0094 - 0x0074)
class USoundNodeAttenuation : public USoundNode
{
public:
	DWORD                                              bAttenuate : 1;                                   		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSpatialize : 1;                                  		// 0x0074 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAttenuateWithLPF : 1;                            		// 0x0074 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              dBAttenuationAtMax;                               		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              OmniRadius;                                       		// 0x007C (0x0004) [0x0000000000000000]              
	unsigned char                                      DistanceAlgorithm;                                		// 0x0080 (0x0001) [0x0000000000000000]              
	unsigned char                                      DistanceType;                                     		// 0x0081 (0x0001) [0x0000000000000000]              
	float                                              RadiusMin;                                        		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              RadiusMax;                                        		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              LPFRadiusMin;                                     		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              LPFRadiusMax;                                     		// 0x0090 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeAttenuation" );

		return pClassPointer;
	};

};

UClass* USoundNodeAttenuation::pClassPointer = NULL;

// Class Engine.SoundNodeAttenuationAndGain
// 0x0030 (0x00A4 - 0x0074)
class USoundNodeAttenuationAndGain : public USoundNode
{
public:
	DWORD                                              bAttenuate : 1;                                   		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSpatialize : 1;                                  		// 0x0074 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAttenuateWithLPF : 1;                            		// 0x0074 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              dBAttenuationAtMax;                               		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              OmniRadius;                                       		// 0x007C (0x0004) [0x0000000000000000]              
	unsigned char                                      GainDistanceAlgorithm;                            		// 0x0080 (0x0001) [0x0000000000000000]              
	unsigned char                                      AttenuateDistanceAlgorithm;                       		// 0x0081 (0x0001) [0x0000000000000000]              
	unsigned char                                      DistanceType;                                     		// 0x0082 (0x0001) [0x0000000000000000]              
	float                                              MinimalVolume;                                    		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              RadiusMin;                                        		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              RadiusPeak;                                       		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              RadiusMax;                                        		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              LPFMinimal;                                       		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              LPFRadiusMin;                                     		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              LPFRadiusPeak;                                    		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              LPFRadiusMax;                                     		// 0x00A0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeAttenuationAndGain" );

		return pClassPointer;
	};

};

UClass* USoundNodeAttenuationAndGain::pClassPointer = NULL;

// Class Engine.SoundNodeConcatenator
// 0x0010 (0x0084 - 0x0074)
class USoundNodeConcatenator : public USoundNode
{
public:
	TArray< float >                                    InputVolume;                                      		// 0x0074 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeConcatenator" );

		return pClassPointer;
	};

};

UClass* USoundNodeConcatenator::pClassPointer = NULL;

// Class Engine.SoundNodeConcatenatorRadio
// 0x0000 (0x0074 - 0x0074)
class USoundNodeConcatenatorRadio : public USoundNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeConcatenatorRadio" );

		return pClassPointer;
	};

};

UClass* USoundNodeConcatenatorRadio::pClassPointer = NULL;

// Class Engine.SoundNodeDelay
// 0x002C (0x00A0 - 0x0074)
class USoundNodeDelay : public USoundNode
{
public:
	float                                              DelayMin;                                         		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              DelayMax;                                         		// 0x0078 (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       DelayDuration;                                    		// 0x007C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeDelay" );

		return pClassPointer;
	};

};

UClass* USoundNodeDelay::pClassPointer = NULL;

// Class Engine.SoundNodeDistanceCrossFade
// 0x0010 (0x0084 - 0x0074)
class USoundNodeDistanceCrossFade : public USoundNode
{
public:
	TArray< struct FDistanceDatum >                    CrossFadeInput;                                   		// 0x0074 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeDistanceCrossFade" );

		return pClassPointer;
	};

};

UClass* USoundNodeDistanceCrossFade::pClassPointer = NULL;

// Class Engine.SoundNodeDoppler
// 0x0004 (0x0078 - 0x0074)
class USoundNodeDoppler : public USoundNode
{
public:
	float                                              DopplerIntensity;                                 		// 0x0074 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeDoppler" );

		return pClassPointer;
	};

};

UClass* USoundNodeDoppler::pClassPointer = NULL;

// Class Engine.SoundNodeEnveloper
// 0x0024 (0x0098 - 0x0074)
class USoundNodeEnveloper : public USoundNode
{
public:
	float                                              LoopStart;                                        		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              LoopEnd;                                          		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              DurationAfterLoop;                                		// 0x007C (0x0004) [0x0000000000000000]              
	int                                                LoopCount;                                        		// 0x0080 (0x0004) [0x0000000000000000]              
	DWORD                                              bLoopIndefinitely : 1;                            		// 0x0084 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLoop : 1;                                        		// 0x0084 (0x0004) [0x0000000000000000] [0x00000002] 
	class UDistributionFloatConstantCurve*             VolumeInterpCurve;                                		// 0x0088 (0x0008) [0x0000000000000000]              
	class UDistributionFloatConstantCurve*             PitchInterpCurve;                                 		// 0x0090 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeEnveloper" );

		return pClassPointer;
	};

};

UClass* USoundNodeEnveloper::pClassPointer = NULL;

// Class Engine.SoundNodeLooping
// 0x0030 (0x00A4 - 0x0074)
class USoundNodeLooping : public USoundNode
{
public:
	DWORD                                              bLoopIndefinitely : 1;                            		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              LoopCountMin;                                     		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              LoopCountMax;                                     		// 0x007C (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       LoopCount;                                        		// 0x0080 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeLooping" );

		return pClassPointer;
	};

};

UClass* USoundNodeLooping::pClassPointer = NULL;

// Class Engine.SoundNodeMature
// 0x0000 (0x0074 - 0x0074)
class USoundNodeMature : public USoundNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeMature" );

		return pClassPointer;
	};

};

UClass* USoundNodeMature::pClassPointer = NULL;

// Class Engine.SoundNodeMixer
// 0x0010 (0x0084 - 0x0074)
class USoundNodeMixer : public USoundNode
{
public:
	TArray< float >                                    InputVolume;                                      		// 0x0074 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeMixer" );

		return pClassPointer;
	};

};

UClass* USoundNodeMixer::pClassPointer = NULL;

// Class Engine.SoundNodeModulator
// 0x0058 (0x00CC - 0x0074)
class USoundNodeModulator : public USoundNode
{
public:
	float                                              PitchMin;                                         		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              PitchMax;                                         		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              VolumeMin;                                        		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              VolumeMax;                                        		// 0x0080 (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       PitchModulation;                                  		// 0x0084 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       VolumeModulation;                                 		// 0x00A8 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeModulator" );

		return pClassPointer;
	};

};

UClass* USoundNodeModulator::pClassPointer = NULL;

// Class Engine.SoundNodeModulatorContinuous
// 0x0048 (0x00BC - 0x0074)
class USoundNodeModulatorContinuous : public USoundNode
{
public:
	struct FRawDistributionFloat                       PitchModulation;                                  		// 0x0074 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       VolumeModulation;                                 		// 0x0098 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeModulatorContinuous" );

		return pClassPointer;
	};

};

UClass* USoundNodeModulatorContinuous::pClassPointer = NULL;

// Class Engine.SoundNodeOscillator
// 0x00B4 (0x0128 - 0x0074)
class USoundNodeOscillator : public USoundNode
{
public:
	DWORD                                              bModulateVolume : 1;                              		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bModulatePitch : 1;                               		// 0x0074 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              AmplitudeMin;                                     		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              AmplitudeMax;                                     		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              FrequencyMin;                                     		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              FrequencyMax;                                     		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              OffsetMin;                                        		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              OffsetMax;                                        		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              CenterMin;                                        		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              CenterMax;                                        		// 0x0094 (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       Amplitude;                                        		// 0x0098 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Frequency;                                        		// 0x00BC (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Offset;                                           		// 0x00E0 (0x0024) [0x0000000000000000]              
	struct FRawDistributionFloat                       Center;                                           		// 0x0104 (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeOscillator" );

		return pClassPointer;
	};

};

UClass* USoundNodeOscillator::pClassPointer = NULL;

// Class Engine.SoundNodeRandom
// 0x002C (0x00A0 - 0x0074)
class USoundNodeRandom : public USoundNode
{
public:
	TArray< float >                                    Weights;                                          		// 0x0074 (0x0010) [0x0000000000000000]              
	int                                                PreselectAtLevelLoad;                             		// 0x0084 (0x0004) [0x0000000000000000]              
	DWORD                                              bRandomizeWithoutReplacement : 1;                 		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< DWORD >                                    HasBeenUsed;                                      		// 0x008C (0x0010) [0x0000000000000000]              
	int                                                NumRandomUsed;                                    		// 0x009C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeRandom" );

		return pClassPointer;
	};

};

UClass* USoundNodeRandom::pClassPointer = NULL;

// Class Engine.SoundNodeWave
// 0x0304 (0x0378 - 0x0074)
class USoundNodeWave : public USoundNode
{
public:
	int                                                CompressionQuality;                               		// 0x0074 (0x0004) [0x0000000000000000]              
	DWORD                                              bForceRealTimeDecompression : 1;                  		// 0x0078 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLoopingSound : 1;                                		// 0x0078 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bDynamicResource : 1;                             		// 0x0078 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUseTTS : 1;                                      		// 0x0078 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bProcedural : 1;                                  		// 0x0078 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bMature : 1;                                      		// 0x0078 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bManualWordWrap : 1;                              		// 0x0078 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bSingleLine : 1;                                  		// 0x0078 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bIsVoIP : 1;                                      		// 0x0078 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned char                                      TTSSpeaker;                                       		// 0x007C (0x0001) [0x0000000000000000]              
	unsigned char                                      DecompressionType;                                		// 0x007D (0x0001) [0x0000000000000000]              
	unsigned char                                      MobileDetailMode;                                 		// 0x007E (0x0001) [0x0000000000000000]              
	struct FString                                     SpokenText;                                       		// 0x0080 (0x0010) [0x0000000000000000]              
	float                                              Volume;                                           		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              Pitch;                                            		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              Duration;                                         		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                NumChannels;                                      		// 0x009C (0x0004) [0x0000000000000000]              
	int                                                SampleRate;                                       		// 0x00A0 (0x0004) [0x0000000000000000]              
	TArray< int >                                      ChannelOffsets;                                   		// 0x00A4 (0x0010) [0x0000000000000000]              
	TArray< int >                                      ChannelSizes;                                     		// 0x00B4 (0x0010) [0x0000000000000000]              
	struct FUntypedBulkData_Mirror                     RawData;                                          		// 0x00C4 (0x0040) [0x0000000000000000]              
	struct FPointer                                    VorbisDecompressor;                               		// 0x0104 (0x0008) [0x0000000000000000]              
	struct FPointer                                    RawPCMData;                                       		// 0x010C (0x0008) [0x0000000000000000]              
	int                                                RawPCMDataSize;                                   		// 0x0114 (0x0004) [0x0000000000000000]              
	struct FUntypedBulkData_Mirror                     CompressedPCData;                                 		// 0x0118 (0x0040) [0x0000000000000000]              
	struct FUntypedBulkData_Mirror                     CompressedXbox360Data;                            		// 0x0158 (0x0040) [0x0000000000000000]              
	struct FUntypedBulkData_Mirror                     CompressedDingoData;                              		// 0x0198 (0x0040) [0x0000000000000000]              
	struct FUntypedBulkData_Mirror                     CompressedPS3Data;                                		// 0x01D8 (0x0040) [0x0000000000000000]              
	struct FUntypedBulkData_Mirror                     CompressedWiiUData;                               		// 0x0218 (0x0040) [0x0000000000000000]              
	struct FUntypedBulkData_Mirror                     CompressedIPhoneData;                             		// 0x0258 (0x0040) [0x0000000000000000]              
	struct FUntypedBulkData_Mirror                     CompressedFlashData;                              		// 0x0298 (0x0040) [0x0000000000000000]              
	struct FUntypedBulkData_Mirror                     CompressedOrbisData;                              		// 0x02D8 (0x0040) [0x0000000000000000]              
	int                                                ResourceID;                                       		// 0x0318 (0x0004) [0x0000000000000000]              
	int                                                ResourceSize;                                     		// 0x031C (0x0004) [0x0000000000000000]              
	struct FPointer                                    ResourceData;                                     		// 0x0320 (0x0008) [0x0000000000000000]              
	TArray< struct FSubtitleCue >                      Subtitles;                                        		// 0x0328 (0x0010) [0x0000000000000000]              
	struct FString                                     Comment;                                          		// 0x0338 (0x0010) [0x0000000000000000]              
	TArray< struct FLocalizedSubtitle >                LocalizedSubtitles;                               		// 0x0348 (0x0010) [0x0000000000000000]              
	struct FString                                     SourceFilePath;                                   		// 0x0358 (0x0010) [0x0000000000000000]              
	struct FString                                     SourceFileTimestamp;                              		// 0x0368 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeWave" );

		return pClassPointer;
	};

	void eventGeneratePCMData ( );
};

UClass* USoundNodeWave::pClassPointer = NULL;

// Class Engine.SoundNodeWaveStreaming
// 0x0014 (0x038C - 0x0378)
class USoundNodeWaveStreaming : public USoundNodeWave
{
public:
	TArray< unsigned char >                            QueuedAudio;                                      		// 0x0378 (0x0010) [0x0000000000000000]              
	float                                              InactiveDuration;                                 		// 0x0388 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeWaveStreaming" );

		return pClassPointer;
	};

	void eventGeneratePCMData ( );
	void eventAvailableAudioBytes ( );
	void eventResetAudio ( );
	void eventQueueSilence ( );
	void eventQueueAudio ( );
};

UClass* USoundNodeWaveStreaming::pClassPointer = NULL;

// Class Engine.SoundNodeWaveParam
// 0x0008 (0x007C - 0x0074)
class USoundNodeWaveParam : public USoundNode
{
public:
	struct FName                                       WaveParameterName;                                		// 0x0074 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundNodeWaveParam" );

		return pClassPointer;
	};

};

UClass* USoundNodeWaveParam::pClassPointer = NULL;

// Class Engine.LandscapeProxy
// 0x0134 (0x0378 - 0x0244)
class ALandscapeProxy : public AInfo
{
public:
	struct FGuid                                       LandscapeGuid;                                    		// 0x0244 (0x0010) [0x0000000000000000]              
	int                                                MaxLODLevel;                                      		// 0x0254 (0x0004) [0x0000000000000000]              
	class UPhysicalMaterial*                           DefaultPhysMaterial;                              		// 0x0258 (0x0008) [0x0000000000000000]              
	float                                              StreamingDistanceMultiplier;                      		// 0x0260 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          LandscapeMaterial;                                		// 0x0264 (0x0008) [0x0000000000000000]              
	float                                              LODDistanceFactor;                                		// 0x026C (0x0004) [0x0000000000000000]              
	TArray< class ULandscapeComponent* >               LandscapeComponents;                              		// 0x0270 (0x0010) [0x0000000000000000]              
	TArray< class ULandscapeHeightfieldCollisionComponent* > CollisionComponents;                              		// 0x0280 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x0290 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.LandscapeProxy.MaterialInstanceConstantMap
	unsigned char                                      UnknownData01[ 0x48 ];                            		// 0x02D8 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.LandscapeProxy.WeightmapUsageMap
	float                                              StaticLightingResolution;                         		// 0x0320 (0x0004) [0x0000000000000000]              
	float                                              SplatterMapResolution;                            		// 0x0324 (0x0004) [0x0000000000000000]              
	struct FLightingChannelContainer                   LightingChannels;                                 		// 0x0328 (0x0004) [0x0000000000000000]              
	class ALandscape*                                  LandscapeActor;                                   		// 0x032C (0x0008) [0x0000000000000000]              
	DWORD                                              bIsProxy : 1;                                     		// 0x0334 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIsSetup : 1;                                     		// 0x0334 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bResetup : 1;                                     		// 0x0334 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bIsMovingToLevel : 1;                             		// 0x0334 (0x0004) [0x0000000000000000] [0x00000008] 
	struct FLightmassPrimitiveSettings                 LightmassSettings;                                		// 0x0338 (0x001C) [0x0000000000000000]              
	int                                                CollisionMipLevel;                                		// 0x0354 (0x0004) [0x0000000000000000]              
	int                                                MobileLODBias;                                    		// 0x0358 (0x0004) [0x0000000000000000]              
	TArray< struct FLandscapeLayerStruct >             LayerInfoObjs;                                    		// 0x035C (0x0010) [0x0000000000000000]              
	int                                                ComponentSizeQuads;                               		// 0x036C (0x0004) [0x0000000000000000]              
	int                                                SubsectionSizeQuads;                              		// 0x0370 (0x0004) [0x0000000000000000]              
	int                                                NumSubsections;                                   		// 0x0374 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LandscapeProxy" );

		return pClassPointer;
	};

};

UClass* ALandscapeProxy::pClassPointer = NULL;

// Class Engine.Landscape
// 0x0020 (0x0398 - 0x0378)
class ALandscape : public ALandscapeProxy
{
public:
	TArray< struct FName >                             LayerNames;                                       		// 0x0378 (0x0010) [0x0000000000000000]              
	TArray< struct FLandscapeLayerInfo >               LayerInfos;                                       		// 0x0388 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Landscape" );

		return pClassPointer;
	};

};

UClass* ALandscape::pClassPointer = NULL;

// Class Engine.Terrain
// 0x0134 (0x0378 - 0x0244)
class ATerrain : public AInfo
{
public:
	TArray< struct FTerrainHeight >                    Heights;                                          		// 0x0244 (0x0010) [0x0000000000000000]              
	TArray< struct FTerrainInfoData >                  InfoData;                                         		// 0x0254 (0x0010) [0x0000000000000000]              
	TArray< struct FTerrainLayer >                     Layers;                                           		// 0x0264 (0x0010) [0x0000000000000000]              
	int                                                NormalMapLayer;                                   		// 0x0274 (0x0004) [0x0000000000000000]              
	TArray< struct FTerrainDecoLayer >                 DecoLayers;                                       		// 0x0278 (0x0010) [0x0000000000000000]              
	TArray< struct FAlphaMap >                         AlphaMaps;                                        		// 0x0288 (0x0010) [0x0000000000000000]              
	TArray< class UTerrainComponent* >                 TerrainComponents;                                		// 0x0298 (0x0010) [0x0000000000000000]              
	int                                                NumSectionsX;                                     		// 0x02A8 (0x0004) [0x0000000000000000]              
	int                                                NumSectionsY;                                     		// 0x02AC (0x0004) [0x0000000000000000]              
	TArray< struct ATerrain_FTerrainWeightedMaterial > WeightedMaterials;                                		// 0x02B0 (0x0010) [0x0000000000000000]              
	TArray< class UTerrainWeightMapTexture* >          WeightedTextureMaps;                              		// 0x02C0 (0x0010) [0x0000000000000000]              
	int                                                MaxTesselationLevel;                              		// 0x02D0 (0x0004) [0x0000000000000000]              
	int                                                MinTessellationLevel;                             		// 0x02D4 (0x0004) [0x0000000000000000]              
	float                                              TesselationDistanceScale;                         		// 0x02D8 (0x0004) [0x0000000000000000]              
	float                                              TessellationCheckDistance;                        		// 0x02DC (0x0004) [0x0000000000000000]              
	int                                                CollisionTesselationLevel;                        		// 0x02E0 (0x0004) [0x0000000000000000]              
	struct FCachedTerrainMaterialArray                 CachedTerrainMaterials[ 0x2 ];                    		// 0x02E4 (0x0020) [0x0000000000000000]              
	int                                                NumVerticesX;                                     		// 0x0304 (0x0004) [0x0000000000000000]              
	int                                                NumVerticesY;                                     		// 0x0308 (0x0004) [0x0000000000000000]              
	int                                                NumPatchesX;                                      		// 0x030C (0x0004) [0x0000000000000000]              
	int                                                NumPatchesY;                                      		// 0x0310 (0x0004) [0x0000000000000000]              
	int                                                MaxComponentSize;                                 		// 0x0314 (0x0004) [0x0000000000000000]              
	int                                                StaticLightingResolution;                         		// 0x0318 (0x0004) [0x0000000000000000]              
	DWORD                                              bIsOverridingLightResolution : 1;                 		// 0x031C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bBilinearFilterLightmapGeneration : 1;            		// 0x031C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCastShadow : 1;                                  		// 0x031C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bForceDirectLightMap : 1;                         		// 0x031C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bCastDynamicShadow : 1;                           		// 0x031C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bEnableSpecular : 1;                              		// 0x031C (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bBlockRigidBody : 1;                              		// 0x031C (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bAllowRigidBodyUnderneath : 1;                    		// 0x031C (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bAcceptsDynamicLights : 1;                        		// 0x031C (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bMorphingEnabled : 1;                             		// 0x031C (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bMorphingGradientsEnabled : 1;                    		// 0x031C (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bLocked : 1;                                      		// 0x031C (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bHeightmapLocked : 1;                             		// 0x031C (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bShowingCollision : 1;                            		// 0x031C (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bUseWorldOriginTextureUVs : 1;                    		// 0x031C (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bShowWireframe : 1;                               		// 0x031C (0x0004) [0x0000000000000000] [0x00008000] 
	class UPhysicalMaterial*                           TerrainPhysMaterialOverride;                      		// 0x0320 (0x0008) [0x0000000000000000]              
	struct FLightingChannelContainer                   LightingChannels;                                 		// 0x0328 (0x0004) [0x0000000000000000]              
	struct FLightmassPrimitiveSettings                 LightmassSettings;                                		// 0x032C (0x001C) [0x0000000000000000]              
	struct FPointer                                    ReleaseResourcesFence;                            		// 0x0348 (0x0008) [0x0000000000000000]              
	int                                                EditorTessellationLevel;                          		// 0x0350 (0x0004) [0x0000000000000000]              
	TArray< struct FSelectedTerrainVertex >            SelectedVertices;                                 		// 0x0354 (0x0010) [0x0000000000000000]              
	struct FColor                                      WireframeColor;                                   		// 0x0364 (0x0004) [0x0000000000000000]              
	struct FGuid                                       LightingGuid;                                     		// 0x0368 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Terrain" );

		return pClassPointer;
	};

	void eventPostBeginPlay ( );
	void CalcLayerBounds ( );
};

UClass* ATerrain::pClassPointer = NULL;

// Class Engine.LandscapeGizmoActor
// 0x0020 (0x0264 - 0x0244)
class ALandscapeGizmoActor : public AActor
{
public:
	float                                              Width;                                            		// 0x0244 (0x0004) [0x0000000000000000]              
	float                                              Height;                                           		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              LengthZ;                                          		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              MarginZ;                                          		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              MinRelativeZ;                                     		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              RelativeScaleZ;                                   		// 0x0258 (0x0004) [0x0000000000000000]              
	class ULandscapeInfo*                              TargetLandscapeInfo;                              		// 0x025C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LandscapeGizmoActor" );

		return pClassPointer;
	};

};

UClass* ALandscapeGizmoActor::pClassPointer = NULL;

// Class Engine.LandscapeGizmoActiveActor
// 0x0120 (0x0384 - 0x0264)
class ALandscapeGizmoActiveActor : public ALandscapeGizmoActor
{
public:
	unsigned char                                      DataType;                                         		// 0x0264 (0x0001) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x0268 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.LandscapeGizmoActiveActor.SelectedData
	class UTexture2D*                                  GizmoTexture;                                     		// 0x02B0 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   TextureScale;                                     		// 0x02B8 (0x0008) [0x0000000000000000]              
	TArray< struct FVector >                           SampledHeight;                                    		// 0x02C0 (0x0010) [0x0000000000000000]              
	TArray< struct FVector >                           SampledNormal;                                    		// 0x02D0 (0x0010) [0x0000000000000000]              
	int                                                SampleSizeX;                                      		// 0x02E0 (0x0004) [0x0000000000000000]              
	int                                                SampleSizeY;                                      		// 0x02E4 (0x0004) [0x0000000000000000]              
	float                                              CachedWidth;                                      		// 0x02E8 (0x0004) [0x0000000000000000]              
	float                                              CachedHeight;                                     		// 0x02EC (0x0004) [0x0000000000000000]              
	float                                              CachedScaleXY;                                    		// 0x02F0 (0x0004) [0x0000000000000000]              
	struct FVector                                     FrustumVerts[ 0x8 ];                              		// 0x02F4 (0x0060) [0x0000000000000000]              
	class UMaterial*                                   GizmoMaterial;                                    		// 0x0354 (0x0008) [0x0000000000000000]              
	class UMaterialInstance*                           GizmoDataMaterial;                                		// 0x035C (0x0008) [0x0000000000000000]              
	class UMaterial*                                   GizmoMeshMaterial;                                		// 0x0364 (0x0008) [0x0000000000000000]              
	class UMaterial*                                   GizmoMeshMaterial2;                               		// 0x036C (0x0008) [0x0000000000000000]              
	TArray< struct FName >                             LayerNames;                                       		// 0x0374 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LandscapeGizmoActiveActor" );

		return pClassPointer;
	};

};

UClass* ALandscapeGizmoActiveActor::pClassPointer = NULL;

// Class Engine.LandscapeComponent
// 0x0130 (0x0368 - 0x0238)
class ULandscapeComponent : public UPrimitiveComponent
{
public:
	int                                                SectionBaseX;                                     		// 0x0238 (0x0004) [0x0000000000000000]              
	int                                                SectionBaseY;                                     		// 0x023C (0x0004) [0x0000000000000000]              
	int                                                ComponentSizeQuads;                               		// 0x0240 (0x0004) [0x0000000000000000]              
	int                                                SubsectionSizeQuads;                              		// 0x0244 (0x0004) [0x0000000000000000]              
	int                                                NumSubsections;                                   		// 0x0248 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          OverrideMaterial;                                 		// 0x024C (0x0008) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   MaterialInstance;                                 		// 0x0254 (0x0008) [0x0000000000000000]              
	TArray< struct FWeightmapLayerAllocationInfo >     WeightmapLayerAllocations;                        		// 0x025C (0x0010) [0x0000000000000000]              
	TArray< class UTexture2D* >                        WeightmapTextures;                                		// 0x026C (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x027C (0x0004) MISSED OFFSET
	struct FVector4                                    WeightmapScaleBias;                               		// 0x0280 (0x0010) [0x0000000000000000]              
	float                                              WeightmapSubsectionOffset;                        		// 0x0290 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0xC ];                             		// 0x0294 (0x000C) MISSED OFFSET
	struct FVector4                                    HeightmapScaleBias;                               		// 0x02A0 (0x0010) [0x0000000000000000]              
	class UTexture2D*                                  HeightmapTexture;                                 		// 0x02B0 (0x0008) [0x0000000000000000]              
	struct FBoxSphereBounds                            CachedBoxSphereBounds;                            		// 0x02B8 (0x001C) [0x0000000000000000]              
	struct FBox                                        CachedLocalBox;                                   		// 0x02D4 (0x001C) [0x0000000000000000]              
	struct FGuid                                       LightingGuid;                                     		// 0x02F0 (0x0010) [0x0000000000000000]              
	TArray< class UShadowMap2D* >                      ShadowMaps;                                       		// 0x0300 (0x0010) [0x0000000000000000]              
	TArray< struct FGuid >                             IrrelevantLights;                                 		// 0x0310 (0x0010) [0x0000000000000000]              
	struct FLightMapRef                                LightMap;                                         		// 0x0320 (0x0008) [0x0000000000000000]              
	int                                                SplatterMapRes;                                   		// 0x0328 (0x0004) [0x0000000000000000]              
	class UTWSplatterMap2D*                            SplatterMap;                                      		// 0x032C (0x0008) [0x0000000000000000]              
	struct FPointer                                    EditToolRenderData;                               		// 0x0334 (0x0008) [0x0000000000000000]              
	int                                                CollisionMipLevel;                                		// 0x033C (0x0004) [0x0000000000000000]              
	struct FPointer                                    PlatformData;                                     		// 0x0340 (0x0008) [0x0000000000000000]              
	int                                                PlatformDataSize;                                 		// 0x0348 (0x0004) [0x0000000000000000]              
	DWORD                                              bNeedPostUndo : 1;                                		// 0x034C (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                ForcedLOD;                                        		// 0x0350 (0x0004) [0x0000000000000000]              
	unsigned char                                      NeighborLOD[ 0x8 ];                               		// 0x0354 (0x0008) [0x0000000000000000]              
	unsigned char                                      NeighborLODBias[ 0x8 ];                           		// 0x035C (0x0008) [0x0000000000000000]              
	int                                                LODBias;                                          		// 0x0364 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LandscapeComponent" );

		return pClassPointer;
	};

};

UClass* ULandscapeComponent::pClassPointer = NULL;

// Class Engine.LandscapeGizmoRenderComponent
// 0x0000 (0x0238 - 0x0238)
class ULandscapeGizmoRenderComponent : public UPrimitiveComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LandscapeGizmoRenderComponent" );

		return pClassPointer;
	};

};

UClass* ULandscapeGizmoRenderComponent::pClassPointer = NULL;

// Class Engine.LandscapeHeightfieldCollisionComponent
// 0x0100 (0x0338 - 0x0238)
class ULandscapeHeightfieldCollisionComponent : public UPrimitiveComponent
{
public:
	struct FUntypedBulkData_Mirror                     CollisionHeightData;                              		// 0x0238 (0x0040) [0x0000000000000000]              
	TArray< struct FName >                             ComponentLayers;                                  		// 0x0278 (0x0010) [0x0000000000000000]              
	struct FUntypedBulkData_Mirror                     DominantLayerData;                                		// 0x0288 (0x0040) [0x0000000000000000]              
	int                                                SectionBaseX;                                     		// 0x02C8 (0x0004) [0x0000000000000000]              
	int                                                SectionBaseY;                                     		// 0x02CC (0x0004) [0x0000000000000000]              
	int                                                CollisionSizeQuads;                               		// 0x02D0 (0x0004) [0x0000000000000000]              
	float                                              CollisionScale;                                   		// 0x02D4 (0x0004) [0x0000000000000000]              
	TArray< unsigned char >                            CollisionQuadFlags;                               		// 0x02D8 (0x0010) [0x0000000000000000]              
	TArray< class UPhysicalMaterial* >                 PhysicalMaterials;                                		// 0x02E8 (0x0010) [0x0000000000000000]              
	struct FPointer                                    RBHeightfield;                                    		// 0x02F8 (0x0008) [0x0000000000000000]              
	struct FBoxSphereBounds                            CachedBoxSphereBounds;                            		// 0x0300 (0x001C) [0x0000000000000000]              
	DWORD                                              bIncludeHoles : 1;                                		// 0x031C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bHeightFieldDataHasHole : 1;                      		// 0x031C (0x0004) [0x0000000000000000] [0x00000002] 
	struct FVector4                                    LandscapeLightmapScaleBias;                       		// 0x0320 (0x0010) [0x0000000000000000]              
	class UTWSplatterMap2D*                            SplatterMap;                                      		// 0x0330 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LandscapeHeightfieldCollisionComponent" );

		return pClassPointer;
	};

};

UClass* ULandscapeHeightfieldCollisionComponent::pClassPointer = NULL;

// Class Engine.TerrainComponent
// 0x0098 (0x02D0 - 0x0238)
class UTerrainComponent : public UPrimitiveComponent
{
public:
	TArray< class UShadowMap2D* >                      ShadowMaps;                                       		// 0x0238 (0x0010) [0x0000000000000000]              
	TArray< struct FGuid >                             IrrelevantLights;                                 		// 0x0248 (0x0010) [0x0000000000000000]              
	struct FPointer                                    TerrainObject;                                    		// 0x0258 (0x0008) [0x0000000000000000]              
	int                                                SectionBaseX;                                     		// 0x0260 (0x0004) [0x0000000000000000]              
	int                                                SectionBaseY;                                     		// 0x0264 (0x0004) [0x0000000000000000]              
	int                                                SectionSizeX;                                     		// 0x0268 (0x0004) [0x0000000000000000]              
	int                                                SectionSizeY;                                     		// 0x026C (0x0004) [0x0000000000000000]              
	int                                                TrueSectionSizeX;                                 		// 0x0270 (0x0004) [0x0000000000000000]              
	int                                                TrueSectionSizeY;                                 		// 0x0274 (0x0004) [0x0000000000000000]              
	struct FLightMapRef                                LightMap;                                         		// 0x0278 (0x0008) [0x0000000000000000]              
	TArray< struct FTerrainPatchBounds >               PatchBounds;                                      		// 0x0280 (0x0010) [0x0000000000000000]              
	TArray< struct FTerrainMaterialMask >              BatchMaterials;                                   		// 0x0290 (0x0010) [0x0000000000000000]              
	int                                                FullBatch;                                        		// 0x02A0 (0x0004) [0x0000000000000000]              
	struct FTerrainBVTree                              BVTree;                                           		// 0x02A4 (0x0010) [0x0000000000000000]              
	TArray< struct FVector >                           CollisionVertices;                                		// 0x02B4 (0x0010) [0x0000000000000000]              
	struct FPointer                                    RBHeightfield;                                    		// 0x02C4 (0x0008) [0x0000000000000000]              
	DWORD                                              bDisplayCollisionLevel : 1;                       		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TerrainComponent" );

		return pClassPointer;
	};

};

UClass* UTerrainComponent::pClassPointer = NULL;

// Class Engine.LandscapeInfo
// 0x02BC (0x031C - 0x0060)
class ULandscapeInfo : public UObject
{
public:
	struct FGuid                                       LandscapeGuid;                                    		// 0x0060 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x0070 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.LandscapeInfo.LayerInfoMap
	struct FPointer                                    DataInterface;                                    		// 0x00B8 (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x48 ];                            		// 0x00C0 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.LandscapeInfo.XYtoComponentMap
	unsigned char                                      UnknownData02[ 0x48 ];                            		// 0x0108 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.LandscapeInfo.XYtoCollisionComponentMap
	class ALandscapeProxy*                             LandscapeProxy;                                   		// 0x0150 (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData03[ 0x48 ];                            		// 0x0158 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.LandscapeInfo.XYtoAddCollisionMap
	struct FSet_Mirror                                 Proxies;                                          		// 0x01A0 (0x0048) [0x0000000000000000]              
	struct FSet_Mirror                                 SelectedComponents;                               		// 0x01E8 (0x0048) [0x0000000000000000]              
	struct FSet_Mirror                                 SelectedCollisionComponents;                      		// 0x0230 (0x0048) [0x0000000000000000]              
	struct FSet_Mirror                                 SelectedRegionComponents;                         		// 0x0278 (0x0048) [0x0000000000000000]              
	unsigned char                                      UnknownData04[ 0x48 ];                            		// 0x02C0 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.LandscapeInfo.SelectedRegion
	struct FString                                     HeightmapFilePath;                                		// 0x0308 (0x0010) [0x0000000000000000]              
	DWORD                                              bIsValid : 1;                                     		// 0x0318 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LandscapeInfo" );

		return pClassPointer;
	};

};

UClass* ULandscapeInfo::pClassPointer = NULL;

// Class Engine.LandscapeLayerInfoObject
// 0x0018 (0x0078 - 0x0060)
class ULandscapeLayerInfoObject : public UObject
{
public:
	struct FName                                       LayerName;                                        		// 0x0060 (0x0008) [0x0000000000000000]              
	class UPhysicalMaterial*                           PhysMaterial;                                     		// 0x0068 (0x0008) [0x0000000000000000]              
	float                                              Hardness;                                         		// 0x0070 (0x0004) [0x0000000000000000]              
	DWORD                                              bNoWeightBlend : 1;                               		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LandscapeLayerInfoObject" );

		return pClassPointer;
	};

};

UClass* ULandscapeLayerInfoObject::pClassPointer = NULL;

// Class Engine.TerrainWeightMapTexture
// 0x0018 (0x0258 - 0x0240)
class UTerrainWeightMapTexture : public UTexture2D
{
public:
	class ATerrain*                                    ParentTerrain;                                    		// 0x0240 (0x0008) [0x0000000000000000]              
	TArray< struct FPointer >                          WeightedMaterials;                                		// 0x0248 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TerrainWeightMapTexture" );

		return pClassPointer;
	};

};

UClass* UTerrainWeightMapTexture::pClassPointer = NULL;

// Class Engine.TerrainLayerSetup
// 0x0010 (0x0070 - 0x0060)
class UTerrainLayerSetup : public UObject
{
public:
	TArray< struct FTerrainFilteredMaterial >          Materials;                                        		// 0x0060 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TerrainLayerSetup" );

		return pClassPointer;
	};

	void PostBeginPlay ( );
};

UClass* UTerrainLayerSetup::pClassPointer = NULL;

// Class Engine.TerrainMaterial
// 0x0068 (0x00C8 - 0x0060)
class UTerrainMaterial : public UObject
{
public:
	struct FMatrix                                     LocalToMapping;                                   		// 0x0060 (0x0040) [0x0000000000000000]              
	unsigned char                                      MappingType;                                      		// 0x00A0 (0x0001) [0x0000000000000000]              
	float                                              MappingScale;                                     		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              MappingRotation;                                  		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              MappingPanU;                                      		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              MappingPanV;                                      		// 0x00B0 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          Material;                                         		// 0x00B4 (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  DisplacementMap;                                  		// 0x00BC (0x0008) [0x0000000000000000]              
	float                                              DisplacementScale;                                		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TerrainMaterial" );

		return pClassPointer;
	};

};

UClass* UTerrainMaterial::pClassPointer = NULL;

// Class Engine.DataStoreClient
// 0x0050 (0x00C0 - 0x0070)
class UDataStoreClient : public UUIRoot
{
public:
	TArray< struct FString >                           GlobalDataStoreClasses;                           		// 0x0070 (0x0010) [0x0000000000000000]              
	TArray< class UUIDataStore* >                      GlobalDataStores;                                 		// 0x0080 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           PlayerDataStoreClassNames;                        		// 0x0090 (0x0010) [0x0000000000000000]              
	TArray< class UClass* >                            PlayerDataStoreClasses;                           		// 0x00A0 (0x0010) [0x0000000000000000]              
	TArray< struct FPlayerDataStoreGroup >             PlayerDataStores;                                 		// 0x00B0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DataStoreClient" );

		return pClassPointer;
	};

	void DebugDumpDataStoreInfo ( );
	void eventNotifyGameSessionEnded ( );
	void FindDataStoreClass ( );
	void GetPlayerDataStoreClasses ( );
	void FindPlayerDataStoreIndex ( );
	void UnregisterDataStore ( );
	void RegisterDataStore ( );
	void CreateDataStore ( );
	void FindDataStore ( );
};

UClass* UDataStoreClient::pClassPointer = NULL;

// Class Engine.Console
// 0x01C0 (0x0270 - 0x00B0)
class UConsole : public UInteraction
{
public:
	class ULocalPlayer*                                ConsoleTargetPlayer;                              		// 0x00B0 (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  DefaultTexture_Black;                             		// 0x00B8 (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  DefaultTexture_White;                             		// 0x00C0 (0x0008) [0x0000000000000000]              
	struct FName                                       ConsoleKey;                                       		// 0x00C8 (0x0008) [0x0000000000000000]              
	struct FName                                       TypeKey;                                          		// 0x00D0 (0x0008) [0x0000000000000000]              
	int                                                MaxScrollbackSize;                                		// 0x00D8 (0x0004) [0x0000000000000000]              
	TArray< struct FString >                           Scrollback;                                       		// 0x00DC (0x0010) [0x0000000000000000]              
	int                                                SBHead;                                           		// 0x00EC (0x0004) [0x0000000000000000]              
	int                                                SBPos;                                            		// 0x00F0 (0x0004) [0x0000000000000000]              
	int                                                HistoryTop;                                       		// 0x00F4 (0x0004) [0x0000000000000000]              
	int                                                HistoryBot;                                       		// 0x00F8 (0x0004) [0x0000000000000000]              
	int                                                HistoryCur;                                       		// 0x00FC (0x0004) [0x0000000000000000]              
	struct FString                                     History[ 0x10 ];                                  		// 0x0100 (0x0100) [0x0000000000000000]              
	DWORD                                              bNavigatingHistory : 1;                           		// 0x0200 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bCaptureKeyInput : 1;                             		// 0x0200 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bCtrl : 1;                                        		// 0x0200 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bEnableUI : 1;                                    		// 0x0200 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bAutoCompleteLocked : 1;                          		// 0x0200 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bRequireCtrlToNavigateAutoComplete : 1;           		// 0x0200 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bIsRuntimeAutoCompleteUpToDate : 1;               		// 0x0200 (0x0004) [0x0000000000000000] [0x00000040] 
	struct FString                                     TypedStr;                                         		// 0x0204 (0x0010) [0x0000000000000000]              
	int                                                TypedStrPos;                                      		// 0x0214 (0x0004) [0x0000000000000000]              
	TArray< struct FAutoCompleteCommand >              ManualAutoCompleteList;                           		// 0x0218 (0x0010) [0x0000000000000000]              
	TArray< struct FAutoCompleteCommand >              AutoCompleteList;                                 		// 0x0228 (0x0010) [0x0000000000000000]              
	int                                                AutoCompleteIndex;                                		// 0x0238 (0x0004) [0x0000000000000000]              
	struct FAutoCompleteNode                           AutoCompleteTree;                                 		// 0x023C (0x0024) [0x0000000000000000]              
	TArray< int >                                      AutoCompleteIndices;                              		// 0x0260 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Console" );

		return pClassPointer;
	};

	void UpdateCompleteIndices ( );
	void BuildRuntimeAutoCompleteList ( );
	void AppendInputText ( );
	void ProcessControlKey ( );
	void FlushPlayerInput ( );
	void InputChar ( );
	void AttempDisconnect ( );
	void InputKey ( );
	void PostRender_Console ( );
	void StartTyping ( );
	void eventOutputText ( );
	void OutputTextLine ( );
	void ClearOutput ( );
	void ConsoleCommand ( );
	void PurgeCommandFromHistory ( );
	void SetCursorPos ( );
	void SetInputText ( );
	void Initialized ( );
};

UClass* UConsole::pClassPointer = NULL;

// Class Engine.Input
// 0x00C8 (0x0178 - 0x00B0)
class UInput : public UInteraction
{
public:
	TArray< struct FKeyBind >                          Bindings;                                         		// 0x00B0 (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             PressedKeys;                                      		// 0x00C0 (0x0010) [0x0000000000000000]              
	int                                                CurrentControllerId;                              		// 0x00D0 (0x0004) [0x0000000000000000]              
	unsigned char                                      CurrentEvent;                                     		// 0x00D4 (0x0001) [0x0000000000000000]              
	float                                              CurrentDelta;                                     		// 0x00D8 (0x0004) [0x0000000000000000]              
	float                                              CurrentDeltaTime;                                 		// 0x00DC (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x00E0 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.Input.NameToPtr
	TArray< struct FPointer >                          AxisArray;                                        		// 0x0128 (0x0010) [0x0000000000000000]              
	TArray< class USeqEvent_Input* >                   CachedInputEvents;                                		// 0x0138 (0x0010) [0x0000000000000000]              
	TArray< class USeqEvent_AnalogInput* >             CachedAnalogInputEvents;                          		// 0x0148 (0x0010) [0x0000000000000000]              
	TArray< class USeqEvent_TouchInput* >              CachedTouchInputEvents;                           		// 0x0158 (0x0010) [0x0000000000000000]              
	TArray< struct FTouchTracker >                     CurrentTouches;                                   		// 0x0168 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Input" );

		return pClassPointer;
	};

	void SetBind ( );
	void GetBind ( );
	void ResetInput ( );
};

UClass* UInput::pClassPointer = NULL;

// Class Engine.PlayerInput
// 0x0148 (0x02C0 - 0x0178)
class UPlayerInput : public UInput
{
public:
	DWORD                                              bUsingGamepad : 1;                                		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bInvertMouse : 1;                                 		// 0x0178 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bInvertTurn : 1;                                  		// 0x0178 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bWasForward : 1;                                  		// 0x0178 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bWasBack : 1;                                     		// 0x0178 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bWasLeft : 1;                                     		// 0x0178 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bWasRight : 1;                                    		// 0x0178 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bEdgeForward : 1;                                 		// 0x0178 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bEdgeBack : 1;                                    		// 0x0178 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bEdgeLeft : 1;                                    		// 0x0178 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bEdgeRight : 1;                                   		// 0x0178 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bEnableMouseSmoothing : 1;                        		// 0x0178 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bEnableFOVScaling : 1;                            		// 0x0178 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bLockTurnUntilRelease : 1;                        		// 0x0178 (0x0004) [0x0000000000000000] [0x00002000] 
	struct FName                                       LastAxisKeyName;                                  		// 0x017C (0x0008) [0x0000000000000000]              
	float                                              DoubleClickTimer;                                 		// 0x0184 (0x0004) [0x0000000000000000]              
	float                                              DoubleClickTime;                                  		// 0x0188 (0x0004) [0x0000000000000000]              
	float                                              MouseSensitivity;                                 		// 0x018C (0x0004) [0x0000000000000000]              
	float                                              aBaseX;                                           		// 0x0190 (0x0004) [0x0000000000000000]              
	float                                              aBaseY;                                           		// 0x0194 (0x0004) [0x0000000000000000]              
	float                                              aBaseZ;                                           		// 0x0198 (0x0004) [0x0000000000000000]              
	float                                              aMouseX;                                          		// 0x019C (0x0004) [0x0000000000000000]              
	float                                              aMouseY;                                          		// 0x01A0 (0x0004) [0x0000000000000000]              
	float                                              aForward;                                         		// 0x01A4 (0x0004) [0x0000000000000000]              
	float                                              aTurn;                                            		// 0x01A8 (0x0004) [0x0000000000000000]              
	float                                              aStrafe;                                          		// 0x01AC (0x0004) [0x0000000000000000]              
	float                                              aUp;                                              		// 0x01B0 (0x0004) [0x0000000000000000]              
	float                                              aLookUp;                                          		// 0x01B4 (0x0004) [0x0000000000000000]              
	float                                              aRightAnalogTrigger;                              		// 0x01B8 (0x0004) [0x0000000000000000]              
	float                                              aLeftAnalogTrigger;                               		// 0x01BC (0x0004) [0x0000000000000000]              
	float                                              aPS3AccelX;                                       		// 0x01C0 (0x0004) [0x0000000000000000]              
	float                                              aPS3AccelY;                                       		// 0x01C4 (0x0004) [0x0000000000000000]              
	float                                              aPS3AccelZ;                                       		// 0x01C8 (0x0004) [0x0000000000000000]              
	float                                              aPS3Gyro;                                         		// 0x01CC (0x0004) [0x0000000000000000]              
	float                                              aWiiUPointerX;                                    		// 0x01D0 (0x0004) [0x0000000000000000]              
	float                                              aWiiUPointerY;                                    		// 0x01D4 (0x0004) [0x0000000000000000]              
	struct FVector                                     aTilt;                                            		// 0x01D8 (0x000C) [0x0000000000000000]              
	struct FVector                                     aRotationRate;                                    		// 0x01E4 (0x000C) [0x0000000000000000]              
	struct FVector                                     aGravity;                                         		// 0x01F0 (0x000C) [0x0000000000000000]              
	struct FVector                                     aAcceleration;                                    		// 0x01FC (0x000C) [0x0000000000000000]              
	struct FVector                                     aTouch[ 0x5 ];                                    		// 0x0208 (0x003C) [0x0000000000000000]              
	struct FVector                                     aBackTouch[ 0x5 ];                                		// 0x0244 (0x003C) [0x0000000000000000]              
	float                                              RawJoyUp;                                         		// 0x0280 (0x0004) [0x0000000000000000]              
	float                                              RawJoyRight;                                      		// 0x0284 (0x0004) [0x0000000000000000]              
	float                                              RawJoyLookRight;                                  		// 0x0288 (0x0004) [0x0000000000000000]              
	float                                              RawJoyLookUp;                                     		// 0x028C (0x0004) [0x0000000000000000]              
	float                                              MoveForwardSpeed;                                 		// 0x0290 (0x0004) [0x0000000000000000]              
	float                                              MoveStrafeSpeed;                                  		// 0x0294 (0x0004) [0x0000000000000000]              
	float                                              LookRightScale;                                   		// 0x0298 (0x0004) [0x0000000000000000]              
	float                                              LookUpScale;                                      		// 0x029C (0x0004) [0x0000000000000000]              
	unsigned char                                      bStrafe;                                          		// 0x02A0 (0x0001) [0x0000000000000000]              
	unsigned char                                      bXAxis;                                           		// 0x02A1 (0x0001) [0x0000000000000000]              
	unsigned char                                      bYAxis;                                           		// 0x02A2 (0x0001) [0x0000000000000000]              
	float                                              ZeroTime[ 0x2 ];                                  		// 0x02A4 (0x0008) [0x0000000000000000]              
	float                                              SmoothedMouse[ 0x2 ];                             		// 0x02AC (0x0008) [0x0000000000000000]              
	int                                                MouseSamples;                                     		// 0x02B4 (0x0004) [0x0000000000000000]              
	float                                              MouseSamplingTotal;                               		// 0x02B8 (0x0004) [0x0000000000000000]              
	float                                              AutoUnlockTurnTime;                               		// 0x02BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PlayerInput" );

		return pClassPointer;
	};

	void PreClientTravel ( );
	void ClientInitInputSystem ( );
	void InitInputSystem ( );
	void SmoothMouse ( );
	void ClearSmoothing ( );
	void SmartJump ( );
	void Jump ( );
	void ProcessInputMatching ( );
	void CheckForDoubleClickMove ( );
	void CatchDoubleClickInput ( );
	void eventPlayerInput ( );
	void AdjustMouseSensitivity ( );
	void PostProcessInput ( );
	void PreProcessInput ( );
	void DrawHUD ( );
	void SetSensitivity ( );
	void InvertTurn ( );
	void InvertMouse ( );
	void CancelMobileInput ( );
};

UClass* UPlayerInput::pClassPointer = NULL;

// Class Engine.PlayerManagerInteraction
// 0x0000 (0x00B0 - 0x00B0)
class UPlayerManagerInteraction : public UInteraction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PlayerManagerInteraction" );

		return pClassPointer;
	};

};

UClass* UPlayerManagerInteraction::pClassPointer = NULL;

// Class Engine.UISceneClient
// 0x00AC (0x011C - 0x0070)
class UUISceneClient : public UUIRoot
{
public:
	struct FPointer                                    VfTable_FExec;                                    		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FPointer                                    RenderViewport;                                   		// 0x0078 (0x0008) [0x0000000000000000]              
	struct FIntPoint                                   MousePosition;                                    		// 0x0080 (0x0008) [0x0000000000000000]              
	class UDataStoreClient*                            DataStoreManager;                                 		// 0x0088 (0x0008) [0x0000000000000000]              
	struct FMatrix                                     CanvasToScreen;                                   		// 0x0090 (0x0040) [0x0000000000000000]              
	struct FMatrix                                     InvCanvasToScreen;                                		// 0x00D0 (0x0040) [0x0000000000000000]              
	class UPostProcessChain*                           UIScenePostProcess;                               		// 0x0110 (0x0008) [0x0000000000000000]              
	DWORD                                              bEnablePostProcess : 1;                           		// 0x0118 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UISceneClient" );

		return pClassPointer;
	};

	void eventInitializeSceneClient ( );
	void GetInverseCanvasToScreen ( );
	void GetCanvasToScreen ( );
	void IsUIActive ( );
};

UClass* UUISceneClient::pClassPointer = NULL;

// Class Engine.UISoundTheme
// 0x0010 (0x0070 - 0x0060)
class UUISoundTheme : public UObject
{
public:
	TArray< struct FSoundEventMapping >                SoundEventBindings;                               		// 0x0060 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UISoundTheme" );

		return pClassPointer;
	};

	void eventProcessSoundEvent ( );
};

UClass* UUISoundTheme::pClassPointer = NULL;

// Class Engine.UIDataStoreSubscriber
// 0x0000 (0x0060 - 0x0060)
class UUIDataStoreSubscriber : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStoreSubscriber" );

		return pClassPointer;
	};

	void ClearBoundDataStores ( );
	void GetBoundDataStores ( );
	void NotifyDataStoreValueUpdated ( );
	void RefreshSubscriberValue ( );
	void GetDataStoreBinding ( );
	void SetDataStoreBinding ( );
};

UClass* UUIDataStoreSubscriber::pClassPointer = NULL;

// Class Engine.UIDataStorePublisher
// 0x0000 (0x0060 - 0x0060)
class UUIDataStorePublisher : public UUIDataStoreSubscriber
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStorePublisher" );

		return pClassPointer;
	};

	void SaveSubscriberValue ( );
};

UClass* UUIDataStorePublisher::pClassPointer = NULL;

// Class Engine.UIDataProvider
// 0x0000 (0x0070 - 0x0070)
class UUIDataProvider : public UUIRoot
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataProvider" );

		return pClassPointer;
	};

};

UClass* UUIDataProvider::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlinePlayerDataBase
// 0x0004 (0x0074 - 0x0070)
class UUIDataProvider_OnlinePlayerDataBase : public UUIDataProvider
{
public:
	int                                                PlayerControllerId;                               		// 0x0070 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataProvider_OnlinePlayerDataBase" );

		return pClassPointer;
	};

	void eventOnUnregister ( );
	void eventOnRegister ( );
};

UClass* UUIDataProvider_OnlinePlayerDataBase::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlineFriendMessages
// 0x0070 (0x00E4 - 0x0074)
class UUIDataProvider_OnlineFriendMessages : public UUIDataProvider_OnlinePlayerDataBase
{
public:
	TArray< struct FOnlineFriendMessage >              Messages;                                         		// 0x0074 (0x0010) [0x0000000000000000]              
	struct FString                                     SendingPlayerNameCol;                             		// 0x0084 (0x0010) [0x0000000000000000]              
	struct FString                                     bIsFriendInviteCol;                               		// 0x0094 (0x0010) [0x0000000000000000]              
	struct FString                                     bWasAcceptedCol;                                  		// 0x00A4 (0x0010) [0x0000000000000000]              
	struct FString                                     bWasDeniedCol;                                    		// 0x00B4 (0x0010) [0x0000000000000000]              
	struct FString                                     MessageCol;                                       		// 0x00C4 (0x0010) [0x0000000000000000]              
	struct FString                                     LastInviteFrom;                                   		// 0x00D4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataProvider_OnlineFriendMessages" );

		return pClassPointer;
	};

	void OnGameInviteReceived ( );
	void OnLoginChange ( );
	void OnFriendMessageReceived ( );
	void OnFriendInviteReceived ( );
	void ReadMessages ( );
	void eventOnUnregister ( );
	void eventOnRegister ( );
};

UClass* UUIDataProvider_OnlineFriendMessages::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlineFriends
// 0x00F0 (0x0164 - 0x0074)
class UUIDataProvider_OnlineFriends : public UUIDataProvider_OnlinePlayerDataBase
{
public:
	TArray< struct FOnlineFriend >                     FriendsList;                                      		// 0x0074 (0x0010) [0x0000000000000000]              
	struct FString                                     NickNameCol;                                      		// 0x0084 (0x0010) [0x0000000000000000]              
	struct FString                                     PresenceInfoCol;                                  		// 0x0094 (0x0010) [0x0000000000000000]              
	struct FString                                     FriendStateCol;                                   		// 0x00A4 (0x0010) [0x0000000000000000]              
	struct FString                                     bIsOnlineCol;                                     		// 0x00B4 (0x0010) [0x0000000000000000]              
	struct FString                                     bIsPlayingCol;                                    		// 0x00C4 (0x0010) [0x0000000000000000]              
	struct FString                                     bIsPlayingThisGameCol;                            		// 0x00D4 (0x0010) [0x0000000000000000]              
	struct FString                                     bIsJoinableCol;                                   		// 0x00E4 (0x0010) [0x0000000000000000]              
	struct FString                                     bHasVoiceSupportCol;                              		// 0x00F4 (0x0010) [0x0000000000000000]              
	struct FString                                     bHaveInvitedCol;                                  		// 0x0104 (0x0010) [0x0000000000000000]              
	struct FString                                     bHasInvitedYouCol;                                		// 0x0114 (0x0010) [0x0000000000000000]              
	struct FString                                     OfflineText;                                      		// 0x0124 (0x0010) [0x0000000000000000]              
	struct FString                                     OnlineText;                                       		// 0x0134 (0x0010) [0x0000000000000000]              
	struct FString                                     AwayText;                                         		// 0x0144 (0x0010) [0x0000000000000000]              
	struct FString                                     BusyText;                                         		// 0x0154 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataProvider_OnlineFriends" );

		return pClassPointer;
	};

	void eventRefreshFriendsList ( );
	void OnLoginChange ( );
	void OnFriendsReadComplete ( );
	void eventOnUnregister ( );
	void eventOnRegister ( );
};

UClass* UUIDataProvider_OnlineFriends::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlinePartyChatList
// 0x0090 (0x0104 - 0x0074)
class UUIDataProvider_OnlinePartyChatList : public UUIDataProvider_OnlinePlayerDataBase
{
public:
	TArray< struct FOnlinePartyMember >                PartyMembersList;                                 		// 0x0074 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           NatTypes;                                         		// 0x0084 (0x0010) [0x0000000000000000]              
	struct FString                                     NickNameCol;                                      		// 0x0094 (0x0010) [0x0000000000000000]              
	struct FString                                     NatTypeCol;                                       		// 0x00A4 (0x0010) [0x0000000000000000]              
	struct FString                                     IsLocalCol;                                       		// 0x00B4 (0x0010) [0x0000000000000000]              
	struct FString                                     IsInPartyVoiceCol;                                		// 0x00C4 (0x0010) [0x0000000000000000]              
	struct FString                                     IsTalkingCol;                                     		// 0x00D4 (0x0010) [0x0000000000000000]              
	struct FString                                     IsInGameSessionCol;                               		// 0x00E4 (0x0010) [0x0000000000000000]              
	struct FString                                     IsPlayingThisGameCol;                             		// 0x00F4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataProvider_OnlinePartyChatList" );

		return pClassPointer;
	};

	void eventRefreshMembersList ( );
	void OnLoginChange ( );
	void eventOnUnregister ( );
	void eventOnRegister ( );
};

UClass* UUIDataProvider_OnlinePartyChatList::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlinePlayerStorage
// 0x0028 (0x009C - 0x0074)
class UUIDataProvider_OnlinePlayerStorage : public UUIDataProvider_OnlinePlayerDataBase
{
public:
	class UOnlinePlayerStorage*                        Profile;                                          		// 0x0074 (0x0008) [0x0000000000000000]              
	struct FName                                       ProviderName;                                     		// 0x007C (0x0008) [0x0000000000000000]              
	DWORD                                              bWasErrorLastRead : 1;                            		// 0x0084 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIsExternalUIOpen : 1;                            		// 0x0084 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bNeedsDeferredRefresh : 1;                        		// 0x0084 (0x0004) [0x0000000000000000] [0x00000004] 
	TArray< struct FPlayerStorageArrayProvider >       PlayerStorageArrayProviders;                      		// 0x0088 (0x0010) [0x0000000000000000]              
	int                                                DeviceStorageSizeNeeded;                          		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataProvider_OnlinePlayerStorage" );

		return pClassPointer;
	};

	void OnExternalUIChange ( );
	void OnStorageDeviceChange ( );
	void OnDeviceSelectionComplete ( );
	void ShowDeviceSelection ( );
	void RefreshStorageData ( );
	void OnLoginChange ( );
	void OnReadStorageComplete ( );
	void eventOnUnregister ( );
	void eventOnRegister ( );
	void ClearReadCompleteDelegate ( );
	void AddReadCompleteDelegate ( );
	void GetData ( );
	void WriteData ( );
	void ReadData ( );
};

UClass* UUIDataProvider_OnlinePlayerStorage::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlineProfileSettings
// 0x0000 (0x009C - 0x009C)
class UUIDataProvider_OnlineProfileSettings : public UUIDataProvider_OnlinePlayerStorage
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataProvider_OnlineProfileSettings" );

		return pClassPointer;
	};

	void OnStorageDeviceChange ( );
	void RefreshStorageData ( );
	void ClearReadCompleteDelegate ( );
	void AddReadCompleteDelegate ( );
	void GetData ( );
	void WriteData ( );
	void ReadData ( );
};

UClass* UUIDataProvider_OnlineProfileSettings::pClassPointer = NULL;

// Class Engine.UIDataProvider_PlayerAchievements
// 0x0010 (0x0084 - 0x0074)
class UUIDataProvider_PlayerAchievements : public UUIDataProvider_OnlinePlayerDataBase
{
public:
	TArray< struct FAchievementDetails >               Achievements;                                     		// 0x0074 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataProvider_PlayerAchievements" );

		return pClassPointer;
	};

	void UpdateAchievements ( );
	void OnLoginChange ( );
	void eventOnUnregister ( );
	void eventOnRegister ( );
	void OnPlayerAchievementUnlocked ( );
	void OnPlayerAchievementsChanged ( );
	void GetAchievementDetails ( );
	void GetAchievementIconPathName ( );
	void PopulateAchievementIcons ( );
	void GetMaxTotalGamerScore ( );
	void GetTotalGamerScore ( );
};

UClass* UUIDataProvider_PlayerAchievements::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlinePlayerStorageArray
// 0x002C (0x009C - 0x0070)
class UUIDataProvider_OnlinePlayerStorageArray : public UUIDataProvider
{
public:
	class UOnlinePlayerStorage*                        PlayerStorage;                                    		// 0x0070 (0x0008) [0x0000000000000000]              
	int                                                PlayerStorageId;                                  		// 0x0078 (0x0004) [0x0000000000000000]              
	struct FString                                     ColumnHeaderText;                                 		// 0x007C (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             Values;                                           		// 0x008C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataProvider_OnlinePlayerStorageArray" );

		return pClassPointer;
	};

};

UClass* UUIDataProvider_OnlinePlayerStorageArray::pClassPointer = NULL;

// Class Engine.UIDataProvider_SettingsArray
// 0x0034 (0x00A4 - 0x0070)
class UUIDataProvider_SettingsArray : public UUIDataProvider
{
public:
	class USettings*                                   Settings;                                         		// 0x0070 (0x0008) [0x0000000000000000]              
	int                                                SettingsId;                                       		// 0x0078 (0x0004) [0x0000000000000000]              
	struct FName                                       SettingsName;                                     		// 0x007C (0x0008) [0x0000000000000000]              
	struct FString                                     ColumnHeaderText;                                 		// 0x0084 (0x0010) [0x0000000000000000]              
	TArray< struct FIdToStringMapping >                Values;                                           		// 0x0094 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataProvider_SettingsArray" );

		return pClassPointer;
	};

};

UClass* UUIDataProvider_SettingsArray::pClassPointer = NULL;

// Class Engine.UIDataStore
// 0x0028 (0x0098 - 0x0070)
class UUIDataStore : public UUIDataProvider
{
public:
	struct FName                                       Tag;                                              		// 0x0070 (0x0008) [0x0000000000000000]              
	TArray< struct FScriptDelegate >                   RefreshSubscriberNotifies;                        		// 0x0078 (0x0010) [0x0000000000000000]              
	struct FScriptDelegate                             __OnDataStoreValueUpdated__Delegate;              		// 0x0088 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x008C (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore" );

		return pClassPointer;
	};

	void GetDataStoreClient ( );
	void eventRefreshSubscribers ( );
	void NotifyGameSessionEnded ( );
	void eventSubscriberDetached ( );
	void eventSubscriberAttached ( );
	void eventUnregistered ( );
	void eventRegistered ( );
	void OnDataStoreValueUpdated ( );
};

UClass* UUIDataStore::pClassPointer = NULL;

// Class Engine.UIDataStore_DynamicResource
// 0x0068 (0x0100 - 0x0098)
class UUIDataStore_DynamicResource : public UUIDataStore
{
public:
	class UUIDataProvider_OnlineProfileSettings*       ProfileProvider;                                  		// 0x0098 (0x0008) [0x0000000000000000]              
	class UUIDataStore_GameResource*                   GameResourceDataStore;                            		// 0x00A0 (0x0008) [0x0000000000000000]              
	TArray< struct FDynamicResourceProviderDefinition > ResourceProviderDefinitions;                      		// 0x00A8 (0x0010) [0x0000000000000000]              
	struct FMultiMap_Mirror                            ResourceProviders;                                		// 0x00B8 (0x0048) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_DynamicResource" );

		return pClassPointer;
	};

	void eventUnregistered ( );
	void eventRegistered ( );
	void OnLoginChange ( );
	void GetResourceProviders ( );
	void FindProviderTypeIndex ( );
};

UClass* UUIDataStore_DynamicResource::pClassPointer = NULL;

// Class Engine.UIDataStore_Fonts
// 0x0000 (0x0098 - 0x0098)
class UUIDataStore_Fonts : public UUIDataStore
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_Fonts" );

		return pClassPointer;
	};

};

UClass* UUIDataStore_Fonts::pClassPointer = NULL;

// Class Engine.UIDataStore_GameResource
// 0x0058 (0x00F0 - 0x0098)
class UUIDataStore_GameResource : public UUIDataStore
{
public:
	TArray< struct FGameResourceDataProvider >         ElementProviderTypes;                             		// 0x0098 (0x0010) [0x0000000000000000]              
	struct FMultiMap_Mirror                            ListElementProviders;                             		// 0x00A8 (0x0048) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_GameResource" );

		return pClassPointer;
	};

	void GetResourceProviders ( );
	void FindProviderTypeIndex ( );
};

UClass* UUIDataStore_GameResource::pClassPointer = NULL;

// Class Engine.UIDataStore_MenuItems
// 0x0060 (0x0150 - 0x00F0)
class UUIDataStore_MenuItems : public UUIDataStore_GameResource
{
public:
	struct FName                                       CurrentGameSettingsTag;                           		// 0x00F0 (0x0008) [0x0000000000000000]              
	struct FMultiMap_Mirror                            OptionProviders;                                  		// 0x00F8 (0x0048) [0x0000000000000000]              
	TArray< class UUIDataProvider_MenuItem* >          DynamicProviders;                                 		// 0x0140 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_MenuItems" );

		return pClassPointer;
	};

	void eventUnregistered ( );
	void eventRegistered ( );
	void OnGameSettingsChanged ( );
};

UClass* UUIDataStore_MenuItems::pClassPointer = NULL;

// Class Engine.UIDataStore_GameState
// 0x0010 (0x00A8 - 0x0098)
class UUIDataStore_GameState : public UUIDataStore
{
public:
	struct FScriptDelegate                             __OnRefreshDataFieldValue__Delegate;              		// 0x0098 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x009C (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_GameState" );

		return pClassPointer;
	};

	void NotifyGameSessionEnded ( );
	void OnRefreshDataFieldValue ( );
};

UClass* UUIDataStore_GameState::pClassPointer = NULL;

// Class Engine.UIDataStore_Registry
// 0x0010 (0x00A8 - 0x0098)
class UUIDataStore_Registry : public UUIDataStore
{
public:
	TArray< struct FRegistryKeyValuePair >             RegistryData;                                     		// 0x0098 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_Registry" );

		return pClassPointer;
	};

	void eventSetData ( );
	void eventGetData ( );
};

UClass* UUIDataStore_Registry::pClassPointer = NULL;

// Class Engine.UIDataStore_Remote
// 0x0000 (0x0098 - 0x0098)
class UUIDataStore_Remote : public UUIDataStore
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_Remote" );

		return pClassPointer;
	};

};

UClass* UUIDataStore_Remote::pClassPointer = NULL;

// Class Engine.UIDataStore_OnlineGameSearch
// 0x0038 (0x00D0 - 0x0098)
class UUIDataStore_OnlineGameSearch : public UUIDataStore_Remote
{
public:
	struct FName                                       SearchResultsName;                                		// 0x0098 (0x0008) [0x0000000000000000]              
	class UOnlineSubsystem*                            OnlineSub;                                        		// 0x00A0 (0x0008) [0x0000000000000000]              
	class UOnlineGameInterface*                        GameInterface;                                    		// 0x00A8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x00B0 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	TArray< struct FGameSearchCfg >                    GameSearchCfgList;                                		// 0x00B8 (0x0010) [0x0000000000000000]              
	int                                                SelectedIndex;                                    		// 0x00C8 (0x0004) [0x0000000000000000]              
	int                                                ActiveSearchIndex;                                		// 0x00CC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_OnlineGameSearch" );

		return pClassPointer;
	};

	void ClearAllSearchResults ( );
	void eventMoveToPrevious ( );
	void eventMoveToNext ( );
	void eventSetCurrentByName ( );
	void eventSetCurrentByIndex ( );
	void FindSearchConfigurationIndex ( );
	void eventGetActiveGameSearch ( );
	void eventGetCurrentGameSearch ( );
	void eventShowHostGamercard ( );
	void eventGetSearchResultFromIndex ( );
	void OnSearchComplete ( );
	void OverrideQuerySubmission ( );
	void eventSubmitGameSearch ( );
	void InvalidateCurrentSearchResults ( );
	void eventInit ( );
};

UClass* UUIDataStore_OnlineGameSearch::pClassPointer = NULL;

// Class Engine.UIDataStore_OnlinePlayerData
// 0x0104 (0x019C - 0x0098)
class UUIDataStore_OnlinePlayerData : public UUIDataStore_Remote
{
public:
	class UUIDataProvider_OnlineFriends*               FriendsProvider;                                  		// 0x0098 (0x0008) [0x0000000000000000]              
	int                                                PlayerControllerId;                               		// 0x00A0 (0x0004) [0x0000000000000000]              
	struct FString                                     PlayerNick;                                       		// 0x00A4 (0x0010) [0x0000000000000000]              
	struct FString                                     ProfileSettingsClassName;                         		// 0x00B4 (0x0010) [0x0000000000000000]              
	class UClass*                                      ProfileSettingsClass;                             		// 0x00C4 (0x0008) [0x0000000000000000]              
	class UUIDataProvider_OnlineProfileSettings*       ProfileProvider;                                  		// 0x00CC (0x0008) [0x0000000000000000]              
	struct FString                                     ProfileProviderClassName;                         		// 0x00D4 (0x0010) [0x0000000000000000]              
	class UClass*                                      ProfileProviderClass;                             		// 0x00E4 (0x0008) [0x0000000000000000]              
	struct FString                                     PlayerStorageClassName;                           		// 0x00EC (0x0010) [0x0000000000000000]              
	class UClass*                                      PlayerStorageClass;                               		// 0x00FC (0x0008) [0x0000000000000000]              
	class UUIDataProvider_OnlinePlayerStorage*         StorageProvider;                                  		// 0x0104 (0x0008) [0x0000000000000000]              
	struct FString                                     StorageProviderClassName;                         		// 0x010C (0x0010) [0x0000000000000000]              
	class UClass*                                      StorageProviderClass;                             		// 0x011C (0x0008) [0x0000000000000000]              
	class UUIDataProvider_OnlineFriendMessages*        FriendMessagesProvider;                           		// 0x0124 (0x0008) [0x0000000000000000]              
	class UUIDataProvider_PlayerAchievements*          AchievementsProvider;                             		// 0x012C (0x0008) [0x0000000000000000]              
	struct FString                                     FriendsProviderClassName;                         		// 0x0134 (0x0010) [0x0000000000000000]              
	class UClass*                                      FriendsProviderClass;                             		// 0x0144 (0x0008) [0x0000000000000000]              
	struct FString                                     FriendMessagesProviderClassName;                  		// 0x014C (0x0010) [0x0000000000000000]              
	class UClass*                                      FriendMessagesProviderClass;                      		// 0x015C (0x0008) [0x0000000000000000]              
	struct FString                                     AchievementsProviderClassName;                    		// 0x0164 (0x0010) [0x0000000000000000]              
	class UClass*                                      AchievementsProviderClass;                        		// 0x0174 (0x0008) [0x0000000000000000]              
	struct FString                                     PartyChatProviderClassName;                       		// 0x017C (0x0010) [0x0000000000000000]              
	class UClass*                                      PartyChatProviderClass;                           		// 0x018C (0x0008) [0x0000000000000000]              
	class UUIDataProvider_OnlinePartyChatList*         PartyChatProvider;                                		// 0x0194 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_OnlinePlayerData" );

		return pClassPointer;
	};

	void eventGetCachedPlayerStorage ( );
	void eventGetCachedPlayerProfile ( );
	void ClearDelegates ( );
	void RegisterDelegates ( );
	void OnPlayerDataChange ( );
	void OnLoginChange ( );
	void eventOnUnregister ( );
	void eventOnRegister ( );
};

UClass* UUIDataStore_OnlinePlayerData::pClassPointer = NULL;

// Class Engine.UIDataStore_OnlineStats
// 0x008C (0x0124 - 0x0098)
class UUIDataStore_OnlineStats : public UUIDataStore_Remote
{
public:
	TArray< class UClass* >                            StatsReadClasses;                                 		// 0x0098 (0x0010) [0x0000000000000000]              
	struct FName                                       StatsReadName;                                    		// 0x00A8 (0x0008) [0x0000000000000000]              
	struct FPlayerNickMetaData                         PlayerNickData;                                   		// 0x00B0 (0x0018) [0x0000000000000000]              
	struct FRankMetaData                               RankNameMetaData;                                 		// 0x00C8 (0x0018) [0x0000000000000000]              
	struct FName                                       TotalRowsName;                                    		// 0x00E0 (0x0008) [0x0000000000000000]              
	TArray< class UOnlineStatsRead* >                  StatsReadObjects;                                 		// 0x00E8 (0x0010) [0x0000000000000000]              
	class UOnlineStatsRead*                            StatsRead;                                        		// 0x00F8 (0x0008) [0x0000000000000000]              
	unsigned char                                      CurrentReadType;                                  		// 0x0100 (0x0001) [0x0000000000000000]              
	class UOnlineStatsInterface*                       StatsInterface;                                   		// 0x0104 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x010C (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UOnlinePlayerInterface*                      PlayerInterface;                                  		// 0x0114 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x8 ];                             		// 0x011C (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_OnlineStats" );

		return pClassPointer;
	};

	void SortResultsByRank ( );
	void OnReadComplete ( );
	void eventShowGamercard ( );
	void eventRefreshStats ( );
	void SetStatsReadInfo ( );
	void eventInit ( );
};

UClass* UUIDataStore_OnlineStats::pClassPointer = NULL;

// Class Engine.UIDataStore_Settings
// 0x0000 (0x0098 - 0x0098)
class UUIDataStore_Settings : public UUIDataStore
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_Settings" );

		return pClassPointer;
	};

};

UClass* UUIDataStore_Settings::pClassPointer = NULL;

// Class Engine.UIDataStore_OnlineGameSettings
// 0x001C (0x00B4 - 0x0098)
class UUIDataStore_OnlineGameSettings : public UUIDataStore_Settings
{
public:
	TArray< struct FGameSettingsCfg >                  GameSettingsCfgList;                              		// 0x0098 (0x0010) [0x0000000000000000]              
	class UClass*                                      SettingsProviderClass;                            		// 0x00A8 (0x0008) [0x0000000000000000]              
	int                                                SelectedIndex;                                    		// 0x00B0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_OnlineGameSettings" );

		return pClassPointer;
	};

	void eventUnregistered ( );
	void eventRegistered ( );
	void eventMoveToPrevious ( );
	void eventMoveToNext ( );
	void eventSetCurrentByName ( );
	void eventSetCurrentByIndex ( );
	void eventGetCurrentProvider ( );
	void eventGetCurrentGameSettings ( );
	void eventCreateGame ( );
};

UClass* UUIDataStore_OnlineGameSettings::pClassPointer = NULL;

// Class Engine.UIDataStore_StringBase
// 0x0000 (0x0098 - 0x0098)
class UUIDataStore_StringBase : public UUIDataStore
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_StringBase" );

		return pClassPointer;
	};

};

UClass* UUIDataStore_StringBase::pClassPointer = NULL;

// Class Engine.UIDataStore_InputAlias
// 0x0058 (0x00F0 - 0x0098)
class UUIDataStore_InputAlias : public UUIDataStore_StringBase
{
public:
	TArray< struct FUIDataStoreInputAlias >            InputAliases;                                     		// 0x0098 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x00A8 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.UIDataStore_InputAlias.InputAliasLookupMap

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_InputAlias" );

		return pClassPointer;
	};

	void HasAliasMappingForPlatform ( );
	void FindInputAliasIndex ( );
	void GetAliasInputKeyDataByIndex ( );
	void GetAliasInputKeyData ( );
	void GetAliasInputKeyNameByIndex ( );
	void GetAliasInputKeyName ( );
	void GetAliasFontMarkupByIndex ( );
	void GetAliasFontMarkup ( );
};

UClass* UUIDataStore_InputAlias::pClassPointer = NULL;

// Class Engine.UIDataStore_StringAliasMap
// 0x005C (0x00F4 - 0x0098)
class UUIDataStore_StringAliasMap : public UUIDataStore_StringBase
{
public:
	TArray< struct FUIMenuInputMap >                   MenuInputMapArray;                                		// 0x0098 (0x0010) [0x0000000000000000]              
	struct FMap_Mirror                                 MenuInputSets;                                    		// 0x00A8 (0x0048) [0x0000000000000000]              
	int                                                PlayerIndex;                                      		// 0x00F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataStore_StringAliasMap" );

		return pClassPointer;
	};

	void GetStringWithFieldName ( );
	void FindMappingWithFieldName ( );
	void GetPlayerOwner ( );
};

UClass* UUIDataStore_StringAliasMap::pClassPointer = NULL;

// Class Engine.UIPropertyDataProvider
// 0x0020 (0x0090 - 0x0070)
class UUIPropertyDataProvider : public UUIDataProvider
{
public:
	TArray< class UClass* >                            ComplexPropertyTypes;                             		// 0x0070 (0x0010) [0x0000000000000000]              
	struct FScriptDelegate                             __CanSupportComplexPropertyType__Delegate;        		// 0x0080 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0084 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIPropertyDataProvider" );

		return pClassPointer;
	};

	void CanSupportComplexPropertyType ( );
};

UClass* UUIPropertyDataProvider::pClassPointer = NULL;

// Class Engine.UIDataProvider_Settings
// 0x000C (0x009C - 0x0090)
class UUIDataProvider_Settings : public UUIPropertyDataProvider
{
public:
	class USettings*                                   Settings;                                         		// 0x0090 (0x0008) [0x0000000000000000]              
	DWORD                                              bIsAListRow : 1;                                  		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataProvider_Settings" );

		return pClassPointer;
	};

};

UClass* UUIDataProvider_Settings::pClassPointer = NULL;

// Class Engine.UIResourceDataProvider
// 0x0004 (0x0094 - 0x0090)
class UUIResourceDataProvider : public UUIPropertyDataProvider
{
public:
	DWORD                                              bSkipDuringEnumeration : 1;                       		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIResourceDataProvider" );

		return pClassPointer;
	};

	void eventInitializeProvider ( );
};

UClass* UUIResourceDataProvider::pClassPointer = NULL;

// Class Engine.UIDataProvider_MenuItem
// 0x00A8 (0x013C - 0x0094)
class UUIDataProvider_MenuItem : public UUIResourceDataProvider
{
public:
	unsigned char                                      OptionType;                                       		// 0x0094 (0x0001) [0x0000000000000000]              
	TArray< struct FName >                             OptionSet;                                        		// 0x0098 (0x0010) [0x0000000000000000]              
	struct FString                                     DataStoreMarkup;                                  		// 0x00A8 (0x0010) [0x0000000000000000]              
	struct FString                                     DescriptionMarkup;                                		// 0x00B8 (0x0010) [0x0000000000000000]              
	struct FName                                       RequiredGameMode;                                 		// 0x00C8 (0x0008) [0x0000000000000000]              
	struct FString                                     FriendlyName;                                     		// 0x00D0 (0x0010) [0x0000000000000000]              
	struct FString                                     CustomFriendlyName;                               		// 0x00E0 (0x0010) [0x0000000000000000]              
	struct FString                                     Description;                                      		// 0x00F0 (0x0010) [0x0000000000000000]              
	DWORD                                              bEditableCombo : 1;                               		// 0x0100 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bNumericCombo : 1;                                		// 0x0100 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bKeyboardOrMouseOption : 1;                       		// 0x0100 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bOnlineOnly : 1;                                  		// 0x0100 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bOfflineOnly : 1;                                 		// 0x0100 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bSearchAllInis : 1;                               		// 0x0100 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bRemoveOn360 : 1;                                 		// 0x0100 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bRemoveOnPC : 1;                                  		// 0x0100 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bRemoveOnPS3 : 1;                                 		// 0x0100 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bRemoveOnDingo : 1;                               		// 0x0100 (0x0004) [0x0000000000000000] [0x00000200] 
	int                                                EditBoxMaxLength;                                 		// 0x0104 (0x0004) [0x0000000000000000]              
	struct FUIRangeData                                RangeData;                                        		// 0x0108 (0x0014) [0x0000000000000000]              
	TArray< struct FName >                             SchemaCellFields;                                 		// 0x011C (0x0010) [0x0000000000000000]              
	struct FString                                     IniName;                                          		// 0x012C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIDataProvider_MenuItem" );

		return pClassPointer;
	};

};

UClass* UUIDataProvider_MenuItem::pClassPointer = NULL;

// Class Engine.UIResourceCombinationProvider
// 0x0010 (0x0080 - 0x0070)
class UUIResourceCombinationProvider : public UUIDataProvider
{
public:
	class UUIResourceDataProvider*                     StaticDataProvider;                               		// 0x0070 (0x0008) [0x0000000000000000]              
	class UUIDataProvider_OnlineProfileSettings*       ProfileProvider;                                  		// 0x0078 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIResourceCombinationProvider" );

		return pClassPointer;
	};

	void ClearProviderReferences ( );
	void eventInitializeProvider ( );
};

UClass* UUIResourceCombinationProvider::pClassPointer = NULL;

// Class Engine.GameUISceneClient
// 0x0080 (0x019C - 0x011C)
class UGameUISceneClient : public UUISceneClient
{
public:
	float                                              LatestDeltaTime;                                  		// 0x011C (0x0004) [0x0000000000000000]              
	struct FDouble                                     DoubleClickStartTime;                             		// 0x0120 (0x0008) [0x0000000000000000]              
	struct FIntPoint                                   DoubleClickStartPosition;                         		// 0x0128 (0x0008) [0x0000000000000000]              
	struct FMap_Mirror                                 InitialPressedKeys;                               		// 0x0130 (0x0048) [0x0000000000000000]              
	DWORD                                              bUpdateInputProcessingStatus : 1;                 		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUpdateSceneViewportSizes : 1;                    		// 0x0178 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bEnableDebugInput : 1;                            		// 0x0178 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bRenderDebugInfo : 1;                             		// 0x0178 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bCaptureUnprocessedInput : 1;                     		// 0x0178 (0x0004) [0x0000000000000000] [0x00000010] 
	TArray< struct FName >                             NavAliases;                                       		// 0x017C (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             AxisInputKeys;                                    		// 0x018C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GameUISceneClient" );

		return pClassPointer;
	};

	void FindLocalPlayerIndex ( );
	void NotifyPlayerRemoved ( );
	void NotifyPlayerAdded ( );
	void NotifyGameSessionEnded ( );
	void NotifyClientTravel ( );
	void eventPauseGame ( );
	void CanUnpauseInternalUI ( );
	void RequestInputProcessingUpdate ( );
	void GetCurrentNetMode ( );
};

UClass* UGameUISceneClient::pClassPointer = NULL;

// Class Engine.Scene
// 0x0000 (0x0060 - 0x0060)
class UScene : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Scene" );

		return pClassPointer;
	};

};

UClass* UScene::pClassPointer = NULL;

// Class Engine.InstancedFoliageActor
// 0x0060 (0x02A4 - 0x0244)
class AInstancedFoliageActor : public AActor
{
public:
	struct FMap_Mirror                                 FoliageMeshes;                                    		// 0x0244 (0x0048) [0x0000000000000000]              
	class UStaticMesh*                                 SelectedMesh;                                     		// 0x028C (0x0008) [0x0000000000000000]              
	TArray< class UInstancedStaticMeshComponent* >     InstancedStaticMeshComponents;                    		// 0x0294 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InstancedFoliageActor" );

		return pClassPointer;
	};

};

UClass* AInstancedFoliageActor::pClassPointer = NULL;

// Class Engine.InteractiveFoliageActor
// 0x005C (0x030C - 0x02B0)
class AInteractiveFoliageActor : public AStaticMeshActor
{
public:
	class UCylinderComponent*                          CylinderComponent;                                		// 0x02B0 (0x0008) [0x0000000000000000]              
	struct FVector                                     TouchingActorEntryPosition;                       		// 0x02B8 (0x000C) [0x0000000000000000]              
	struct FVector                                     FoliageVelocity;                                  		// 0x02C4 (0x000C) [0x0000000000000000]              
	struct FVector                                     FoliageForce;                                     		// 0x02D0 (0x000C) [0x0000000000000000]              
	struct FVector                                     FoliagePosition;                                  		// 0x02DC (0x000C) [0x0000000000000000]              
	float                                              FoliageDamageImpulseScale;                        		// 0x02E8 (0x0004) [0x0000000000000000]              
	float                                              FoliageTouchImpulseScale;                         		// 0x02EC (0x0004) [0x0000000000000000]              
	float                                              FoliageStiffness;                                 		// 0x02F0 (0x0004) [0x0000000000000000]              
	float                                              FoliageStiffnessQuadratic;                        		// 0x02F4 (0x0004) [0x0000000000000000]              
	float                                              FoliageDamping;                                   		// 0x02F8 (0x0004) [0x0000000000000000]              
	float                                              MaxDamageImpulse;                                 		// 0x02FC (0x0004) [0x0000000000000000]              
	float                                              MaxTouchImpulse;                                  		// 0x0300 (0x0004) [0x0000000000000000]              
	float                                              MaxForce;                                         		// 0x0304 (0x0004) [0x0000000000000000]              
	float                                              Mass;                                             		// 0x0308 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InteractiveFoliageActor" );

		return pClassPointer;
	};

	void eventTouch ( );
	void eventTakeDamage ( );
};

UClass* AInteractiveFoliageActor::pClassPointer = NULL;

// Class Engine.InteractiveFoliageComponent
// 0x0008 (0x02E4 - 0x02DC)
class UInteractiveFoliageComponent : public UStaticMeshComponent
{
public:
	struct FPointer                                    FoliageSceneProxy;                                		// 0x02DC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InteractiveFoliageComponent" );

		return pClassPointer;
	};

};

UClass* UInteractiveFoliageComponent::pClassPointer = NULL;

// Class Engine.ActorFactoryInteractiveFoliage
// 0x0000 (0x00B0 - 0x00B0)
class UActorFactoryInteractiveFoliage : public UActorFactoryStaticMesh
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactoryInteractiveFoliage" );

		return pClassPointer;
	};

};

UClass* UActorFactoryInteractiveFoliage::pClassPointer = NULL;

// Class Engine.FluidInfluenceActor
// 0x001C (0x0260 - 0x0244)
class AFluidInfluenceActor : public AActor
{
public:
	class UArrowComponent*                             FlowDirection;                                    		// 0x0244 (0x0008) [0x0000000000000000]              
	class USpriteComponent*                            Sprite;                                           		// 0x024C (0x0008) [0x0000000000000000]              
	class UFluidInfluenceComponent*                    InfluenceComponent;                               		// 0x0254 (0x0008) [0x0000000000000000]              
	DWORD                                              bActive : 1;                                      		// 0x025C (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )
	DWORD                                              bToggled : 1;                                     		// 0x025C (0x0004) [0x0000000000160000] [0x00000002] ( CPF_EditConst | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FluidInfluenceActor" );

		return pClassPointer;
	};

	void eventReplicatedEvent ( );
	void OnToggle ( );
};

UClass* AFluidInfluenceActor::pClassPointer = NULL;

// Class Engine.FluidSurfaceActor
// 0x0010 (0x0254 - 0x0244)
class AFluidSurfaceActor : public AActor
{
public:
	class UFluidSurfaceComponent*                      FluidComponent;                                   		// 0x0244 (0x0008) [0x0000000000000000]              
	class UParticleSystem*                             ProjectileEntryEffect;                            		// 0x024C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FluidSurfaceActor" );

		return pClassPointer;
	};

	void eventTouch ( );
	void eventTakeDamage ( );
};

UClass* AFluidSurfaceActor::pClassPointer = NULL;

// Class Engine.FluidSurfaceActorMovable
// 0x0000 (0x0254 - 0x0254)
class AFluidSurfaceActorMovable : public AFluidSurfaceActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FluidSurfaceActorMovable" );

		return pClassPointer;
	};

};

UClass* AFluidSurfaceActorMovable::pClassPointer = NULL;

// Class Engine.FluidInfluenceComponent
// 0x0068 (0x02A0 - 0x0238)
class UFluidInfluenceComponent : public UPrimitiveComponent
{
public:
	DWORD                                              bActive : 1;                                      		// 0x0238 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              RaindropFillEntireFluid : 1;                      		// 0x0238 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIsToggleTriggered : 1;                           		// 0x0238 (0x0004) [0x0000000000000000] [0x00000004] 
	class AFluidSurfaceActor*                          FluidActor;                                       		// 0x023C (0x0008) [0x0000000000000000]              
	unsigned char                                      InfluenceType;                                    		// 0x0244 (0x0001) [0x0000000000000000]              
	float                                              MaxDistance;                                      		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              WaveStrength;                                     		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              WaveFrequency;                                    		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              WavePhase;                                        		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              WaveRadius;                                       		// 0x0258 (0x0004) [0x0000000000000000]              
	float                                              RaindropAreaRadius;                               		// 0x025C (0x0004) [0x0000000000000000]              
	float                                              RaindropRadius;                                   		// 0x0260 (0x0004) [0x0000000000000000]              
	float                                              RaindropStrength;                                 		// 0x0264 (0x0004) [0x0000000000000000]              
	float                                              RaindropRate;                                     		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              FlowSpeed;                                        		// 0x026C (0x0004) [0x0000000000000000]              
	int                                                FlowNumRipples;                                   		// 0x0270 (0x0004) [0x0000000000000000]              
	float                                              FlowSideMotionRadius;                             		// 0x0274 (0x0004) [0x0000000000000000]              
	float                                              FlowWaveRadius;                                   		// 0x0278 (0x0004) [0x0000000000000000]              
	float                                              FlowStrength;                                     		// 0x027C (0x0004) [0x0000000000000000]              
	float                                              FlowFrequency;                                    		// 0x0280 (0x0004) [0x0000000000000000]              
	float                                              SphereOuterRadius;                                		// 0x0284 (0x0004) [0x0000000000000000]              
	float                                              SphereInnerRadius;                                		// 0x0288 (0x0004) [0x0000000000000000]              
	float                                              SphereStrength;                                   		// 0x028C (0x0004) [0x0000000000000000]              
	float                                              CurrentAngle;                                     		// 0x0290 (0x0004) [0x0000000000000000]              
	float                                              CurrentTimer;                                     		// 0x0294 (0x0004) [0x0000000000000000]              
	class AFluidSurfaceActor*                          CurrentFluidActor;                                		// 0x0298 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FluidInfluenceComponent" );

		return pClassPointer;
	};

};

UClass* UFluidInfluenceComponent::pClassPointer = NULL;

// Class Engine.FluidSurfaceComponent
// 0x00FC (0x0334 - 0x0238)
class UFluidSurfaceComponent : public UPrimitiveComponent
{
public:
	class UMaterialInterface*                          FluidMaterial;                                    		// 0x0238 (0x0008) [0x0000000000000000]              
	int                                                LightMapResolution;                               		// 0x0240 (0x0004) [0x0000000000000000]              
	struct FLightmassPrimitiveSettings                 LightmassSettings;                                		// 0x0244 (0x001C) [0x0000000000000000]              
	DWORD                                              EnableSimulation : 1;                             		// 0x0260 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              EnableDetail : 1;                                 		// 0x0260 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bTiling : 1;                                      		// 0x0260 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bPause : 1;                                       		// 0x0260 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bShowSimulationNormals : 1;                       		// 0x0260 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bShowSimulationPosition : 1;                      		// 0x0260 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bShowDetailNormals : 1;                           		// 0x0260 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bShowDetailPosition : 1;                          		// 0x0260 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bShowFluidSimulation : 1;                         		// 0x0260 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bShowFluidDetail : 1;                             		// 0x0260 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bTestRipple : 1;                                  		// 0x0260 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bTestRippleCenterOnDetail : 1;                    		// 0x0260 (0x0004) [0x0000000000000000] [0x00000800] 
	int                                                SimulationQuadsX;                                 		// 0x0264 (0x0004) [0x0000000000000000]              
	int                                                SimulationQuadsY;                                 		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              GridSpacing;                                      		// 0x026C (0x0004) [0x0000000000000000]              
	float                                              GridSpacingLowRes;                                		// 0x0270 (0x0004) [0x0000000000000000]              
	class AActor*                                      TargetSimulation;                                 		// 0x0274 (0x0008) [0x0000000000000000]              
	float                                              GPUTessellationFactor;                            		// 0x027C (0x0004) [0x0000000000000000]              
	float                                              FluidDamping;                                     		// 0x0280 (0x0004) [0x0000000000000000]              
	float                                              FluidTravelSpeed;                                 		// 0x0284 (0x0004) [0x0000000000000000]              
	float                                              FluidHeightScale;                                 		// 0x0288 (0x0004) [0x0000000000000000]              
	float                                              FluidUpdateRate;                                  		// 0x028C (0x0004) [0x0000000000000000]              
	float                                              ForceImpact;                                      		// 0x0290 (0x0004) [0x0000000000000000]              
	float                                              ForceContinuous;                                  		// 0x0294 (0x0004) [0x0000000000000000]              
	float                                              LightingContrast;                                 		// 0x0298 (0x0004) [0x0000000000000000]              
	class AActor*                                      TargetDetail;                                     		// 0x029C (0x0008) [0x0000000000000000]              
	float                                              DeactivationDistance;                             		// 0x02A4 (0x0004) [0x0000000000000000]              
	int                                                DetailResolution;                                 		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              DetailSize;                                       		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              DetailDamping;                                    		// 0x02B0 (0x0004) [0x0000000000000000]              
	float                                              DetailTravelSpeed;                                		// 0x02B4 (0x0004) [0x0000000000000000]              
	float                                              DetailTransfer;                                   		// 0x02B8 (0x0004) [0x0000000000000000]              
	float                                              DetailHeightScale;                                		// 0x02BC (0x0004) [0x0000000000000000]              
	float                                              DetailUpdateRate;                                 		// 0x02C0 (0x0004) [0x0000000000000000]              
	float                                              NormalLength;                                     		// 0x02C4 (0x0004) [0x0000000000000000]              
	float                                              TestRippleSpeed;                                  		// 0x02C8 (0x0004) [0x0000000000000000]              
	float                                              TestRippleFrequency;                              		// 0x02CC (0x0004) [0x0000000000000000]              
	float                                              TestRippleRadius;                                 		// 0x02D0 (0x0004) [0x0000000000000000]              
	float                                              FluidWidth;                                       		// 0x02D4 (0x0004) [0x0000000000000000]              
	float                                              FluidHeight;                                      		// 0x02D8 (0x0004) [0x0000000000000000]              
	float                                              TestRippleTime;                                   		// 0x02DC (0x0004) [0x0000000000000000]              
	float                                              TestRippleAngle;                                  		// 0x02E0 (0x0004) [0x0000000000000000]              
	float                                              DeactivationTimer;                                		// 0x02E4 (0x0004) [0x0000000000000000]              
	float                                              ViewDistance;                                     		// 0x02E8 (0x0004) [0x0000000000000000]              
	struct FVector                                     SimulationPosition;                               		// 0x02EC (0x000C) [0x0000000000000000]              
	struct FVector                                     DetailPosition;                                   		// 0x02F8 (0x000C) [0x0000000000000000]              
	TArray< unsigned char >                            ClampMap;                                         		// 0x0304 (0x0010) [0x0000000000000000]              
	TArray< class UShadowMap2D* >                      ShadowMaps;                                       		// 0x0314 (0x0010) [0x0000000000000000]              
	struct FLightMapRef                                LightMap;                                         		// 0x0324 (0x0008) [0x0000000000000000]              
	struct FPointer                                    FluidSimulation;                                  		// 0x032C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FluidSurfaceComponent" );

		return pClassPointer;
	};

	void SetSimulationPosition ( );
	void SetDetailPosition ( );
	void ApplyForce ( );
};

UClass* UFluidSurfaceComponent::pClassPointer = NULL;

// Class Engine.SpeedTreeActor
// 0x0008 (0x024C - 0x0244)
class ASpeedTreeActor : public AActor
{
public:
	class USpeedTreeComponent*                         SpeedTreeComponent;                               		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SpeedTreeActor" );

		return pClassPointer;
	};

};

UClass* ASpeedTreeActor::pClassPointer = NULL;

// Class Engine.SpeedTreeComponent
// 0x00F4 (0x032C - 0x0238)
class USpeedTreeComponent : public UPrimitiveComponent
{
public:
	class USpeedTree*                                  SpeedTree;                                        		// 0x0238 (0x0008) [0x0000000000000000]              
	DWORD                                              bUseLeafCards : 1;                                		// 0x0240 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseLeafMeshes : 1;                               		// 0x0240 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUseBranches : 1;                                 		// 0x0240 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUseFronds : 1;                                   		// 0x0240 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bUseBillboards : 1;                               		// 0x0240 (0x0004) [0x0000000000000000] [0x00000010] 
	float                                              Lod3DStart;                                       		// 0x0244 (0x0004) [0x0000000000000000]              
	float                                              Lod3DEnd;                                         		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              LodBillboardStart;                                		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              LodBillboardEnd;                                  		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              LodLevelOverride;                                 		// 0x0254 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          Branch1Material;                                  		// 0x0258 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          Branch2Material;                                  		// 0x0260 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          FrondMaterial;                                    		// 0x0268 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          LeafCardMaterial;                                 		// 0x0270 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          LeafMeshMaterial;                                 		// 0x0278 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          BillboardMaterial;                                		// 0x0280 (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  SpeedTreeIcon;                                    		// 0x0288 (0x0008) [0x0000000000000000]              
	TArray< struct FSpeedTreeStaticLight >             StaticLights;                                     		// 0x0290 (0x0010) [0x0000000000000000]              
	struct FLightMapRef                                BranchLightMap;                                   		// 0x02A0 (0x0008) [0x0000000000000000]              
	struct FLightMapRef                                FrondLightMap;                                    		// 0x02A8 (0x0008) [0x0000000000000000]              
	struct FLightMapRef                                LeafMeshLightMap;                                 		// 0x02B0 (0x0008) [0x0000000000000000]              
	struct FLightMapRef                                LeafCardLightMap;                                 		// 0x02B8 (0x0008) [0x0000000000000000]              
	struct FLightMapRef                                BillboardLightMap;                                		// 0x02C0 (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x02C8 (0x0008) MISSED OFFSET
	struct FMatrix                                     RotationOnlyMatrix;                               		// 0x02D0 (0x0040) [0x0000000000000000]              
	struct FLightmassPrimitiveSettings                 LightmassSettings;                                		// 0x0310 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SpeedTreeComponent" );

		return pClassPointer;
	};

	void SetMaterial ( );
	void GetMaterial ( );
};

UClass* USpeedTreeComponent::pClassPointer = NULL;

// Class Engine.SpeedTreeActorFactory
// 0x0008 (0x00A4 - 0x009C)
class USpeedTreeActorFactory : public UActorFactory
{
public:
	class USpeedTree*                                  SpeedTree;                                        		// 0x009C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SpeedTreeActorFactory" );

		return pClassPointer;
	};

};

UClass* USpeedTreeActorFactory::pClassPointer = NULL;

// Class Engine.SpeedTreeComponentFactory
// 0x0008 (0x006C - 0x0064)
class USpeedTreeComponentFactory : public UPrimitiveComponentFactory
{
public:
	class USpeedTreeComponent*                         SpeedTreeComponent;                               		// 0x0064 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SpeedTreeComponentFactory" );

		return pClassPointer;
	};

};

UClass* USpeedTreeComponentFactory::pClassPointer = NULL;

// Class Engine.SpeedTree
// 0x0060 (0x00C0 - 0x0060)
class USpeedTree : public UObject
{
public:
	DWORD                                              bLegacySpeedTree : 1;                             		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FPointer                                    SRH;                                              		// 0x0064 (0x0008) [0x0000000000000000]              
	float                                              LeafStaticShadowOpacity;                          		// 0x006C (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          Branch1Material;                                  		// 0x0070 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          Branch2Material;                                  		// 0x0078 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          FrondMaterial;                                    		// 0x0080 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          LeafCardMaterial;                                 		// 0x0088 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          LeafMeshMaterial;                                 		// 0x0090 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          BillboardMaterial;                                		// 0x0098 (0x0008) [0x0000000000000000]              
	float                                              WindStrength;                                     		// 0x00A0 (0x0004) [0x0000000000000000]              
	struct FVector                                     WindDirection;                                    		// 0x00A4 (0x000C) [0x0000000000000000]              
	struct FGuid                                       LightingGuid;                                     		// 0x00B0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SpeedTree" );

		return pClassPointer;
	};

};

UClass* USpeedTree::pClassPointer = NULL;

// Class Engine.LensFlareSource
// 0x000C (0x0250 - 0x0244)
class ALensFlareSource : public AActor
{
public:
	class ULensFlareComponent*                         LensFlareComp;                                    		// 0x0244 (0x0008) [0x0000000000000000]              
	DWORD                                              bCurrentlyActive : 1;                             		// 0x024C (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LensFlareSource" );

		return pClassPointer;
	};

	void SetActorParameter ( );
	void SetExtColorParameter ( );
	void SetColorParameter ( );
	void SetVectorParameter ( );
	void SetFloatParameter ( );
	void eventReplicatedEvent ( );
	void OnToggle ( );
	void eventPostBeginPlay ( );
	void SetTemplate ( );
};

UClass* ALensFlareSource::pClassPointer = NULL;

// Class Engine.LensFlareComponent
// 0x0064 (0x029C - 0x0238)
class ULensFlareComponent : public UPrimitiveComponent
{
public:
	class ULensFlare*                                  Template;                                         		// 0x0238 (0x0008) [0x0000000000000000]              
	class UDrawLightConeComponent*                     PreviewInnerCone;                                 		// 0x0240 (0x0008) [0x0000000000000000]              
	class UDrawLightConeComponent*                     PreviewOuterCone;                                 		// 0x0248 (0x0008) [0x0000000000000000]              
	class UDrawLightRadiusComponent*                   PreviewRadius;                                    		// 0x0250 (0x0008) [0x0000000000000000]              
	DWORD                                              bAutoActivate : 1;                                		// 0x0258 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIsActive : 1;                                    		// 0x0258 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bHasTranslucency : 1;                             		// 0x0258 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bHasUnlitTranslucency : 1;                        		// 0x0258 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bHasUnlitDistortion : 1;                          		// 0x0258 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bUsesSceneColor : 1;                              		// 0x0258 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bHasSeparateTranslucency : 1;                     		// 0x0258 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bUseTrueConeCalculation : 1;                      		// 0x0258 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bVisibleForMobile : 1;                            		// 0x0258 (0x0004) [0x0000000000000000] [0x00000100] 
	float                                              OuterCone;                                        		// 0x025C (0x0004) [0x0000000000000000]              
	float                                              InnerCone;                                        		// 0x0260 (0x0004) [0x0000000000000000]              
	float                                              ConeFudgeFactor;                                  		// 0x0264 (0x0004) [0x0000000000000000]              
	float                                              Radius;                                           		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              MinStrength;                                      		// 0x026C (0x0004) [0x0000000000000000]              
	struct FLinearColor                                SourceColor;                                      		// 0x0270 (0x0010) [0x0000000000000000]              
	TArray< struct FLensFlareElementMaterials >        Materials;                                        		// 0x0280 (0x0010) [0x0000000000000000]              
	struct FPointer                                    ReleaseResourcesFence;                            		// 0x0290 (0x0008) [0x0000000000000000]              
	float                                              NextTraceTime;                                    		// 0x0298 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LensFlareComponent" );

		return pClassPointer;
	};

	void CreateAndSetMaterialInstanceConstant ( );
	void GetNumMaterials ( );
	void SetMaterial ( );
	void GetMaterial ( );
	void SetIsActive ( );
	void SetSourceColor ( );
	void SetTemplate ( );
};

UClass* ULensFlareComponent::pClassPointer = NULL;

// Class Engine.LensFlare
// 0x0230 (0x0290 - 0x0060)
class ULensFlare : public UObject
{
public:
	struct FLensFlareElement                           SourceElement;                                    		// 0x0060 (0x0198) [0x0000000000000000]              
	class UStaticMesh*                                 SourceMesh;                                       		// 0x01F8 (0x0008) [0x0000000000000000]              
	unsigned char                                      SourceDPG;                                        		// 0x0200 (0x0001) [0x0000000000000000]              
	unsigned char                                      ReflectionsDPG;                                   		// 0x0201 (0x0001) [0x0000000000000000]              
	TArray< struct FLensFlareElement >                 Reflections;                                      		// 0x0204 (0x0010) [0x0000000000000000]              
	float                                              OuterCone;                                        		// 0x0214 (0x0004) [0x0000000000000000]              
	float                                              InnerCone;                                        		// 0x0218 (0x0004) [0x0000000000000000]              
	float                                              ConeFudgeFactor;                                  		// 0x021C (0x0004) [0x0000000000000000]              
	float                                              Radius;                                           		// 0x0220 (0x0004) [0x0000000000000000]              
	DWORD                                              bUseTrueConeCalculation : 1;                      		// 0x0224 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseFixedRelativeBoundingBox : 1;                 		// 0x0224 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bRenderDebugLines : 1;                            		// 0x0224 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              ThumbnailImageOutOfDate : 1;                      		// 0x0224 (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              MinStrength;                                      		// 0x0228 (0x0004) [0x0000000000000000]              
	struct FRawDistributionFloat                       ScreenPercentageMap;                              		// 0x022C (0x0024) [0x0000000000000000]              
	struct FBox                                        FixedRelativeBoundingBox;                         		// 0x0250 (0x001C) [0x0000000000000000]              
	class UInterpCurveEdSetup*                         CurveEdSetup;                                     		// 0x026C (0x0008) [0x0000000000000000]              
	int                                                ReflectionCount;                                  		// 0x0274 (0x0004) [0x0000000000000000]              
	struct FRotator                                    ThumbnailAngle;                                   		// 0x0278 (0x000C) [0x0000000000000000]              
	float                                              ThumbnailDistance;                                		// 0x0284 (0x0004) [0x0000000000000000]              
	class UTexture2D*                                  ThumbnailImage;                                   		// 0x0288 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LensFlare" );

		return pClassPointer;
	};

};

UClass* ULensFlare::pClassPointer = NULL;

// Class Engine.TextureFlipBook
// 0x0048 (0x0288 - 0x0240)
class UTextureFlipBook : public UTexture2D
{
public:
	struct FPointer                                    VfTable_FTickableObject;                          		// 0x0240 (0x0008) [0x0000000000000000]              
	float                                              TimeIntoMovie;                                    		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              TimeSinceLastFrame;                               		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              HorizontalScale;                                  		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              VerticalScale;                                    		// 0x0254 (0x0004) [0x0000000000000000]              
	DWORD                                              bPaused : 1;                                      		// 0x0258 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bStopped : 1;                                     		// 0x0258 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bLooping : 1;                                     		// 0x0258 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bAutoPlay : 1;                                    		// 0x0258 (0x0004) [0x0000000000000000] [0x00000008] 
	int                                                HorizontalImages;                                 		// 0x025C (0x0004) [0x0000000000000000]              
	int                                                VerticalImages;                                   		// 0x0260 (0x0004) [0x0000000000000000]              
	unsigned char                                      FBMethod;                                         		// 0x0264 (0x0001) [0x0000000000000000]              
	float                                              FrameRate;                                        		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              FrameTime;                                        		// 0x026C (0x0004) [0x0000000000000000]              
	int                                                CurrentRow;                                       		// 0x0270 (0x0004) [0x0000000000000000]              
	int                                                CurrentColumn;                                    		// 0x0274 (0x0004) [0x0000000000000000]              
	float                                              RenderOffsetU;                                    		// 0x0278 (0x0004) [0x0000000000000000]              
	float                                              RenderOffsetV;                                    		// 0x027C (0x0004) [0x0000000000000000]              
	struct FPointer                                    ReleaseResourcesFence;                            		// 0x0280 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TextureFlipBook" );

		return pClassPointer;
	};

	void SetCurrentFrame ( );
	void Stop ( );
	void Pause ( );
	void Play ( );
};

UClass* UTextureFlipBook::pClassPointer = NULL;

// Class Engine.Texture2DComposite
// 0x001C (0x014C - 0x0130)
class UTexture2DComposite : public UTexture
{
public:
	TArray< struct FSourceTexture2DRegion >            SourceRegions;                                    		// 0x0130 (0x0010) [0x0000000000000000]              
	int                                                MaxTextureSize;                                   		// 0x0140 (0x0004) [0x0000000000000000]              
	int                                                DestSizeX;                                        		// 0x0144 (0x0004) [0x0000000000000000]              
	int                                                DestSizeY;                                        		// 0x0148 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Texture2DComposite" );

		return pClassPointer;
	};

	void ResetSourceRegions ( );
	void UpdateCompositeTexture ( );
	void SourceTexturesFullyStreamedIn ( );
};

UClass* UTexture2DComposite::pClassPointer = NULL;

// Class Engine.Texture2DDynamic
// 0x0014 (0x0144 - 0x0130)
class UTexture2DDynamic : public UTexture
{
public:
	int                                                SizeX;                                            		// 0x0130 (0x0004) [0x0000000000000000]              
	int                                                SizeY;                                            		// 0x0134 (0x0004) [0x0000000000000000]              
	unsigned char                                      Format;                                           		// 0x0138 (0x0001) [0x0000000000000000]              
	int                                                NumMips;                                          		// 0x013C (0x0004) [0x0000000000000000]              
	DWORD                                              bIsResolveTarget : 1;                             		// 0x0140 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Texture2DDynamic" );

		return pClassPointer;
	};

	void Create ( );
	void UpdateMipFromPNG ( );
	void UpdateMipFromJPEG ( );
	void UpdateMip ( );
	void Init ( );
};

UClass* UTexture2DDynamic::pClassPointer = NULL;

// Class Engine.TextureCube
// 0x0044 (0x0174 - 0x0130)
class UTextureCube : public UTexture
{
public:
	int                                                SizeX;                                            		// 0x0130 (0x0004) [0x0000000000000000]              
	int                                                SizeY;                                            		// 0x0134 (0x0004) [0x0000000000000000]              
	unsigned char                                      Format;                                           		// 0x0138 (0x0001) [0x0000000000000000]              
	int                                                NumMips;                                          		// 0x013C (0x0004) [0x0000000000000000]              
	DWORD                                              bIsCubemapValid : 1;                              		// 0x0140 (0x0004) [0x0000000000000000] [0x00000001] 
	class UTexture2D*                                  FacePosX;                                         		// 0x0144 (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  FaceNegX;                                         		// 0x014C (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  FacePosY;                                         		// 0x0154 (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  FaceNegY;                                         		// 0x015C (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  FacePosZ;                                         		// 0x0164 (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  FaceNegZ;                                         		// 0x016C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TextureCube" );

		return pClassPointer;
	};

};

UClass* UTextureCube::pClassPointer = NULL;

// Class Engine.TextureMovie
// 0x0078 (0x01A8 - 0x0130)
class UTextureMovie : public UTexture
{
public:
	int                                                SizeX;                                            		// 0x0130 (0x0004) [0x0000000000000000]              
	int                                                SizeY;                                            		// 0x0134 (0x0004) [0x0000000000000000]              
	unsigned char                                      Format;                                           		// 0x0138 (0x0001) [0x0000000000000000]              
	unsigned char                                      AddressX;                                         		// 0x0139 (0x0001) [0x0000000000000000]              
	unsigned char                                      AddressY;                                         		// 0x013A (0x0001) [0x0000000000000000]              
	unsigned char                                      MovieStreamSource;                                		// 0x013B (0x0001) [0x0000000000000000]              
	class UClass*                                      DecoderClass;                                     		// 0x013C (0x0008) [0x0000000000000000]              
	class UCodecMovie*                                 Decoder;                                          		// 0x0144 (0x0008) [0x0000000000000000]              
	DWORD                                              Paused : 1;                                       		// 0x014C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              Stopped : 1;                                      		// 0x014C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              Looping : 1;                                      		// 0x014C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              ResetOnLastFrame : 1;                             		// 0x014C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              AutoPlay : 1;                                     		// 0x014C (0x0004) [0x0000000000000000] [0x00000010] 
	struct FUntypedBulkData_Mirror                     Data;                                             		// 0x0150 (0x0040) [0x0000000000000000]              
	struct FPointer                                    ReleaseCodecFence;                                		// 0x0190 (0x0008) [0x0000000000000000]              
	struct FString                                     MovieStreamFilename;                              		// 0x0198 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TextureMovie" );

		return pClassPointer;
	};

	void Stop ( );
	void Pause ( );
	void Play ( );
};

UClass* UTextureMovie::pClassPointer = NULL;

// Class Engine.TextureRenderTarget
// 0x0008 (0x0138 - 0x0130)
class UTextureRenderTarget : public UTexture
{
public:
	DWORD                                              bUpdateImmediate : 1;                             		// 0x0130 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bNeedsTwoCopies : 1;                              		// 0x0130 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bRenderOnce : 1;                                  		// 0x0130 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              TargetGamma;                                      		// 0x0134 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TextureRenderTarget" );

		return pClassPointer;
	};

};

UClass* UTextureRenderTarget::pClassPointer = NULL;

// Class Engine.TextureRenderTarget2D
// 0x0020 (0x0158 - 0x0138)
class UTextureRenderTarget2D : public UTextureRenderTarget
{
public:
	int                                                SizeX;                                            		// 0x0138 (0x0004) [0x0000000000000000]              
	int                                                SizeY;                                            		// 0x013C (0x0004) [0x0000000000000000]              
	unsigned char                                      Format;                                           		// 0x0140 (0x0001) [0x0000000000000000]              
	unsigned char                                      AddressX;                                         		// 0x0141 (0x0001) [0x0000000000000000]              
	unsigned char                                      AddressY;                                         		// 0x0142 (0x0001) [0x0000000000000000]              
	struct FLinearColor                                ClearColor;                                       		// 0x0144 (0x0010) [0x0000000000000000]              
	DWORD                                              bForceLinearGamma : 1;                            		// 0x0154 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TextureRenderTarget2D" );

		return pClassPointer;
	};

	void Create ( );
};

UClass* UTextureRenderTarget2D::pClassPointer = NULL;

// Class Engine.ScriptedTexture
// 0x0014 (0x016C - 0x0158)
class UScriptedTexture : public UTextureRenderTarget2D
{
public:
	DWORD                                              bNeedsUpdate : 1;                                 		// 0x0158 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSkipNextClear : 1;                               		// 0x0158 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FScriptDelegate                             __Render__Delegate;                               		// 0x015C (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0160 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ScriptedTexture" );

		return pClassPointer;
	};

	void Render ( );
};

UClass* UScriptedTexture::pClassPointer = NULL;

// Class Engine.TextureRenderTargetCube
// 0x0005 (0x013D - 0x0138)
class UTextureRenderTargetCube : public UTextureRenderTarget
{
public:
	int                                                SizeX;                                            		// 0x0138 (0x0004) [0x0000000000000000]              
	unsigned char                                      Format;                                           		// 0x013C (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TextureRenderTargetCube" );

		return pClassPointer;
	};

};

UClass* UTextureRenderTargetCube::pClassPointer = NULL;

// Class Engine.AudioDevice
// 0x0300 (0x0368 - 0x0068)
class UAudioDevice : public USubsystem
{
public:
	int                                                MaxChannels;                                      		// 0x0068 (0x0004) [0x0000000000000000]              
	int                                                CommonAudioPoolSize;                              		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              LowPassFilterResonance;                           		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              MinCompressedDurationEditor;                      		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              MinCompressedDurationGame;                        		// 0x0078 (0x0004) [0x0000000000000000]              
	struct FString                                     ChirpInSoundNodeWaveName;                         		// 0x007C (0x0010) [0x0000000000000000]              
	class USoundNodeWave*                              ChirpInSoundNodeWave;                             		// 0x008C (0x0008) [0x0000000000000000]              
	struct FString                                     ChirpOutSoundNodeWaveName;                        		// 0x0094 (0x0010) [0x0000000000000000]              
	class USoundNodeWave*                              ChirpOutSoundNodeWave;                            		// 0x00A4 (0x0008) [0x0000000000000000]              
	struct FPointer                                    CommonAudioPool;                                  		// 0x00AC (0x0008) [0x0000000000000000]              
	int                                                CommonAudioPoolFreeBytes;                         		// 0x00B4 (0x0004) [0x0000000000000000]              
	TArray< class UAudioComponent* >                   AudioComponents;                                  		// 0x00B8 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          Sources;                                          		// 0x00C8 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          FreeSources;                                      		// 0x00D8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x00E8 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.AudioDevice.WaveInstanceSourceMap
	DWORD                                              bGameWasTicking : 1;                              		// 0x0130 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSoundSpawningEnabled : 1;                        		// 0x0130 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< struct FListener >                         Listeners;                                        		// 0x0134 (0x0010) [0x0000000000000000]              
	struct FQWord                                      CurrentTick;                                      		// 0x0144 (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x48 ];                            		// 0x014C (0x0048) UNKNOWN PROPERTY: MapProperty Engine.AudioDevice.SoundClasses
	unsigned char                                      UnknownData02[ 0x48 ];                            		// 0x0194 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.AudioDevice.SourceSoundClasses
	unsigned char                                      UnknownData03[ 0x48 ];                            		// 0x01DC (0x0048) UNKNOWN PROPERTY: MapProperty Engine.AudioDevice.CurrentSoundClasses
	unsigned char                                      UnknownData04[ 0x48 ];                            		// 0x0224 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.AudioDevice.DestinationSoundClasses
	unsigned char                                      UnknownData05[ 0x48 ];                            		// 0x026C (0x0048) UNKNOWN PROPERTY: MapProperty Engine.AudioDevice.SoundModes
	struct FPointer                                    Effects;                                          		// 0x02B4 (0x0008) [0x0000000000000000]              
	struct FName                                       BaseSoundModeName;                                		// 0x02BC (0x0008) [0x0000000000000000]              
	class USoundMode*                                  CurrentMode;                                      		// 0x02C4 (0x0008) [0x0000000000000000]              
	struct FDouble                                     SoundModeStartTime;                               		// 0x02CC (0x0008) [0x0000000000000000]              
	struct FDouble                                     SoundModeFadeInStartTime;                         		// 0x02D4 (0x0008) [0x0000000000000000]              
	struct FDouble                                     SoundModeFadeInEndTime;                           		// 0x02DC (0x0008) [0x0000000000000000]              
	struct FDouble                                     SoundModeEndTime;                                 		// 0x02E4 (0x0008) [0x0000000000000000]              
	int                                                ListenerVolumeIndex;                              		// 0x02EC (0x0004) [0x0000000000000000]              
	struct FInteriorSettings                           ListenerInteriorSettings;                         		// 0x02F0 (0x0024) [0x0000000000000000]              
	struct FDouble                                     InteriorStartTime;                                		// 0x0314 (0x0008) [0x0000000000000000]              
	struct FDouble                                     InteriorEndTime;                                  		// 0x031C (0x0008) [0x0000000000000000]              
	struct FDouble                                     ExteriorEndTime;                                  		// 0x0324 (0x0008) [0x0000000000000000]              
	struct FDouble                                     InteriorLPFEndTime;                               		// 0x032C (0x0008) [0x0000000000000000]              
	struct FDouble                                     ExteriorLPFEndTime;                               		// 0x0334 (0x0008) [0x0000000000000000]              
	float                                              InteriorVolumeInterp;                             		// 0x033C (0x0004) [0x0000000000000000]              
	float                                              InteriorLPFInterp;                                		// 0x0340 (0x0004) [0x0000000000000000]              
	float                                              ExteriorVolumeInterp;                             		// 0x0344 (0x0004) [0x0000000000000000]              
	float                                              ExteriorLPFInterp;                                		// 0x0348 (0x0004) [0x0000000000000000]              
	class UAudioComponent*                             TestAudioComponent;                               		// 0x034C (0x0008) [0x0000000000000000]              
	struct FPointer                                    TextToSpeech;                                     		// 0x0354 (0x0008) [0x0000000000000000]              
	unsigned char                                      DebugState;                                       		// 0x035C (0x0001) [0x0000000000000000]              
	float                                              TransientMasterVolume;                            		// 0x0360 (0x0004) [0x0000000000000000]              
	float                                              LastUpdateTime;                                   		// 0x0364 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AudioDevice" );

		return pClassPointer;
	};

	void FindSoundClass ( );
	void SetSoundMode ( );
};

UClass* UAudioDevice::pClassPointer = NULL;

// Class Engine.SoundClass
// 0x0080 (0x00E0 - 0x0060)
class USoundClass : public UObject
{
public:
	struct FSoundClassProperties                       Properties;                                       		// 0x0060 (0x0020) [0x0000000000000000]              
	TArray< struct FName >                             ChildClassNames;                                  		// 0x0080 (0x0010) [0x0000000000000000]              
	DWORD                                              bIsChild : 1;                                     		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                MenuID;                                           		// 0x0094 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x0098 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.SoundClass.EditorData

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundClass" );

		return pClassPointer;
	};

};

UClass* USoundClass::pClassPointer = NULL;

// Class Engine.SoundMode
// 0x0048 (0x00A8 - 0x0060)
class USoundMode : public UObject
{
public:
	DWORD                                              bApplyEQ : 1;                                     		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FAudioEQEffect                              EQSettings;                                       		// 0x0064 (0x0024) [0x0000000000000000]              
	TArray< struct FSoundClassAdjuster >               SoundClassEffects;                                		// 0x0088 (0x0010) [0x0000000000000000]              
	float                                              InitialDelay;                                     		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              FadeInTime;                                       		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              Duration;                                         		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              FadeOutTime;                                      		// 0x00A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SoundMode" );

		return pClassPointer;
	};

};

UClass* USoundMode::pClassPointer = NULL;

// Class Engine.MatineePawn
// 0x0008 (0x0560 - 0x0558)
class AMatineePawn : public APawn
{
public:
	class USkeletalMesh*                               PreviewMesh;                                      		// 0x0558 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MatineePawn" );

		return pClassPointer;
	};

};

UClass* AMatineePawn::pClassPointer = NULL;

// Class Engine.Scout
// 0x0098 (0x05F0 - 0x0558)
class AScout : public APawn
{
public:
	TArray< struct FPathSizeInfo >                     PathSizes;                                        		// 0x0558 (0x0010) [0x0000000000000000]              
	float                                              TestJumpZ;                                        		// 0x0568 (0x0004) [0x0000000000000000]              
	float                                              TestGroundSpeed;                                  		// 0x056C (0x0004) [0x0000000000000000]              
	float                                              TestMaxFallSpeed;                                 		// 0x0570 (0x0004) [0x0000000000000000]              
	float                                              TestFallSpeed;                                    		// 0x0574 (0x0004) [0x0000000000000000]              
	float                                              MaxLandingVelocity;                               		// 0x0578 (0x0004) [0x0000000000000000]              
	int                                                MinNumPlayerStarts;                               		// 0x057C (0x0004) [0x0000000000000000]              
	class UClass*                                      DefaultReachSpecClass;                            		// 0x0580 (0x0008) [0x0000000000000000]              
	TArray< struct FColor >                            EdgePathColors;                                   		// 0x0588 (0x0010) [0x0000000000000000]              
	float                                              NavMeshGen_StepSize;                              		// 0x0598 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_EntityHalfHeight;                      		// 0x059C (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_StartingHeightOffset;                  		// 0x05A0 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_MaxDropHeight;                         		// 0x05A4 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_MaxStepHeight;                         		// 0x05A8 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_VertZDeltaSnapThresh;                  		// 0x05AC (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_MinPolyArea;                           		// 0x05B0 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_BorderBackfill_CheckDist;              		// 0x05B4 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_MinMergeDotAreaThreshold;              		// 0x05B8 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_MinMergeDotSmallArea;                  		// 0x05BC (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_MinMergeDotLargeArea;                  		// 0x05C0 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_MaxPolyHeight;                         		// 0x05C4 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_HeightMergeThreshold;                  		// 0x05C8 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_EdgeMaxDelta;                          		// 0x05CC (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_MaxGroundCheckSize;                    		// 0x05D0 (0x0004) [0x0000000000000000]              
	float                                              NavMeshGen_MinEdgeLength;                         		// 0x05D4 (0x0004) [0x0000000000000000]              
	DWORD                                              NavMeshGen_ExpansionDoObstacleMeshSimplification : 1;		// 0x05D8 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bHightlightOneWayReachSpecs : 1;                  		// 0x05D8 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              MinMantleFallDist;                                		// 0x05DC (0x0004) [0x0000000000000000]              
	float                                              MaxMantleFallDist;                                		// 0x05E0 (0x0004) [0x0000000000000000]              
	float                                              MinMantleLateralDist;                             		// 0x05E4 (0x0004) [0x0000000000000000]              
	float                                              MaxMantleLateralDist;                             		// 0x05E8 (0x0004) [0x0000000000000000]              
	float                                              MaxMantleFallTime;                                		// 0x05EC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Scout" );

		return pClassPointer;
	};

	void eventPreBeginPlay ( );
};

UClass* AScout::pClassPointer = NULL;

// Class Engine.Light
// 0x0064 (0x02A8 - 0x0244)
class ALight : public AActor
{
public:
	class ULightComponent*                             LightComponent;                                   		// 0x0244 (0x0008) [0x0000000000000000]              
	float                                              MaxBrightness;                                    		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              MinBrightness;                                    		// 0x0250 (0x0004) [0x0000000000000000]              
	unsigned char                                      AnimationType;                                    		// 0x0254 (0x0001) [0x0000000000000000]              
	float                                              AnimationFrequency;                               		// 0x0258 (0x0004) [0x0000000000000000]              
	float                                              AnimationTimeOffset;                              		// 0x025C (0x0004) [0x0000000000000000]              
	class UStaticMeshComponent*                        LightMesh;                                        		// 0x0260 (0x0008) [0x0000000000000000]              
	TArray< class UMaterialInstanceConstant* >         LightMeshMICs;                                    		// 0x0268 (0x0010) [0x0000000000000000]              
	TArray< class UMaterialInstanceConstant* >         BaseMeshMICs;                                     		// 0x0278 (0x0010) [0x0000000000000000]              
	class ULensFlareComponent*                         LensFlareComp;                                    		// 0x0288 (0x0008) [0x0000000000000000]              
	TArray< class UMaterialInstanceConstant* >         LensFlareMICs;                                    		// 0x0290 (0x0010) [0x0000000000000000]              
	float                                              CurveOutputValue;                                 		// 0x02A0 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x02A4 (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Light" );

		return pClassPointer;
	};

	void eventTriggerFlickerEvent ( );
	void eventPostBeginPlay ( );
	void HasVolumetricLightMesh ( );
	void OnToggle ( );
	void eventReplicatedEvent ( );
	void AreLightFunctionsSupported ( );
	void IsVolumetricLightingSupported ( );
};

UClass* ALight::pClassPointer = NULL;

// Class Engine.DirectionalLight
// 0x0000 (0x02A8 - 0x02A8)
class ADirectionalLight : public ALight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DirectionalLight" );

		return pClassPointer;
	};

};

UClass* ADirectionalLight::pClassPointer = NULL;

// Class Engine.DirectionalLightToggleable
// 0x0000 (0x02A8 - 0x02A8)
class ADirectionalLightToggleable : public ADirectionalLight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DirectionalLightToggleable" );

		return pClassPointer;
	};

};

UClass* ADirectionalLightToggleable::pClassPointer = NULL;

// Class Engine.DominantDirectionalLight
// 0x0000 (0x02A8 - 0x02A8)
class ADominantDirectionalLight : public ADirectionalLight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DominantDirectionalLight" );

		return pClassPointer;
	};

};

UClass* ADominantDirectionalLight::pClassPointer = NULL;

// Class Engine.DominantDirectionalLightMovable
// 0x0000 (0x02A8 - 0x02A8)
class ADominantDirectionalLightMovable : public ADominantDirectionalLight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DominantDirectionalLightMovable" );

		return pClassPointer;
	};

};

UClass* ADominantDirectionalLightMovable::pClassPointer = NULL;

// Class Engine.PointLight
// 0x0000 (0x02A8 - 0x02A8)
class APointLight : public ALight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PointLight" );

		return pClassPointer;
	};

};

UClass* APointLight::pClassPointer = NULL;

// Class Engine.DominantPointLight
// 0x0000 (0x02A8 - 0x02A8)
class ADominantPointLight : public APointLight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DominantPointLight" );

		return pClassPointer;
	};

};

UClass* ADominantPointLight::pClassPointer = NULL;

// Class Engine.PointLightMovable
// 0x0000 (0x02A8 - 0x02A8)
class APointLightMovable : public APointLight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PointLightMovable" );

		return pClassPointer;
	};

};

UClass* APointLightMovable::pClassPointer = NULL;

// Class Engine.PointLightToggleable
// 0x0000 (0x02A8 - 0x02A8)
class APointLightToggleable : public APointLight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PointLightToggleable" );

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void ShouldSaveForCheckpoint ( );
};

UClass* APointLightToggleable::pClassPointer = NULL;

// Class Engine.SkyLight
// 0x0000 (0x02A8 - 0x02A8)
class ASkyLight : public ALight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkyLight" );

		return pClassPointer;
	};

};

UClass* ASkyLight::pClassPointer = NULL;

// Class Engine.SkyLightToggleable
// 0x0000 (0x02A8 - 0x02A8)
class ASkyLightToggleable : public ASkyLight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkyLightToggleable" );

		return pClassPointer;
	};

};

UClass* ASkyLightToggleable::pClassPointer = NULL;

// Class Engine.SpotLight
// 0x0000 (0x02A8 - 0x02A8)
class ASpotLight : public ALight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SpotLight" );

		return pClassPointer;
	};

};

UClass* ASpotLight::pClassPointer = NULL;

// Class Engine.DominantSpotLight
// 0x0000 (0x02A8 - 0x02A8)
class ADominantSpotLight : public ASpotLight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DominantSpotLight" );

		return pClassPointer;
	};

};

UClass* ADominantSpotLight::pClassPointer = NULL;

// Class Engine.GeneratedMeshAreaLight
// 0x0000 (0x02A8 - 0x02A8)
class AGeneratedMeshAreaLight : public ASpotLight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GeneratedMeshAreaLight" );

		return pClassPointer;
	};

};

UClass* AGeneratedMeshAreaLight::pClassPointer = NULL;

// Class Engine.SpotLightMovable
// 0x0000 (0x02A8 - 0x02A8)
class ASpotLightMovable : public ASpotLight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SpotLightMovable" );

		return pClassPointer;
	};

};

UClass* ASpotLightMovable::pClassPointer = NULL;

// Class Engine.SpotLightToggleable
// 0x0000 (0x02A8 - 0x02A8)
class ASpotLightToggleable : public ASpotLight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SpotLightToggleable" );

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( );
	void CreateCheckpointRecord ( );
	void ShouldSaveForCheckpoint ( );
};

UClass* ASpotLightToggleable::pClassPointer = NULL;

// Class Engine.StaticLightCollectionActor
// 0x0014 (0x02BC - 0x02A8)
class AStaticLightCollectionActor : public ALight
{
public:
	TArray< class ULightComponent* >                   LightComponents;                                  		// 0x02A8 (0x0010) [0x0000000000000000]              
	int                                                MaxLightComponents;                               		// 0x02B8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.StaticLightCollectionActor" );

		return pClassPointer;
	};

};

UClass* AStaticLightCollectionActor::pClassPointer = NULL;

// Class Engine.LightComponent
// 0x013F (0x01C4 - 0x0085)
class ULightComponent : public UActorComponent
{
public:
	struct FPointer                                    SceneInfo;                                        		// 0x0088 (0x0008) [0x0000000000000000]              
	struct FMatrix                                     WorldToLight;                                     		// 0x0090 (0x0040) [0x0000000000000000]              
	struct FMatrix                                     LightToWorld;                                     		// 0x00D0 (0x0040) [0x0000000000000000]              
	struct FGuid                                       LightGuid;                                        		// 0x0110 (0x0010) [0x0000000000000000]              
	struct FGuid                                       LightmapGuid;                                     		// 0x0120 (0x0010) [0x0000000000000000]              
	float                                              Brightness;                                       		// 0x0130 (0x0004) [0x0000000000000000]              
	struct FColor                                      LightColor;                                       		// 0x0134 (0x0004) [0x0000000000000000]              
	float                                              Hardness;                                         		// 0x0138 (0x0004) [0x0000000000000000]              
	class ULightFunction*                              Function;                                         		// 0x013C (0x0008) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x0144 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              CastShadows : 1;                                  		// 0x0144 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              CastStaticShadows : 1;                            		// 0x0144 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              CastDynamicShadows : 1;                           		// 0x0144 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              ForceCastDynamicShadows : 1;                      		// 0x0144 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bCastCompositeShadow : 1;                         		// 0x0144 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bAffectCompositeShadowDirection : 1;              		// 0x0144 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bNonModulatedSelfShadowing : 1;                   		// 0x0144 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bSelfShadowOnly : 1;                              		// 0x0144 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bAllowPreShadow : 1;                              		// 0x0144 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bForceDynamicLight : 1;                           		// 0x0144 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              UseDirectLightMap : 1;                            		// 0x0144 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bHasLightEverBeenBuiltIntoLightMap : 1;           		// 0x0144 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bCanAffectDynamicPrimitivesOutsideDynamicChannel : 1;		// 0x0144 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bRenderLightShafts : 1;                           		// 0x0144 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bUseImageReflectionSpecular : 1;                  		// 0x0144 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bPrecomputedLightingIsValid : 1;                  		// 0x0144 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bExplicitlyAssignedLight : 1;                     		// 0x0144 (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bAllowCompositingIntoDLE : 1;                     		// 0x0144 (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bCastPerObjectShadows : 1;                        		// 0x0144 (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bOverrideAutoLightingChannels : 1;                		// 0x0144 (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bDisableSpecular : 1;                             		// 0x0144 (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bOverrideLightAnimTick : 1;                       		// 0x0144 (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bUpdateOwnerRenderTime : 1;                       		// 0x0144 (0x0004) [0x0000000000000000] [0x00800000] 
	class ULightEnvironmentComponent*                  LightEnvironment;                                 		// 0x0148 (0x0008) [0x0000000000000000]              
	struct FLightingChannelContainer                   LightingChannels;                                 		// 0x0150 (0x0004) [0x0000000000000000]              
	unsigned char                                      LightAffectsClassification;                       		// 0x0154 (0x0001) [0x0000000000000000]              
	unsigned char                                      LightShadowMode;                                  		// 0x0155 (0x0001) [0x0000000000000000]              
	struct FLinearColor                                ModShadowColor;                                   		// 0x0158 (0x0010) [0x0000000000000000]              
	float                                              ModShadowFadeoutTime;                             		// 0x0168 (0x0004) [0x0000000000000000]              
	float                                              ModShadowFadeoutExponent;                         		// 0x016C (0x0004) [0x0000000000000000]              
	int                                                LightListIndex;                                   		// 0x0170 (0x0004) [0x0000000000000000]              
	unsigned char                                      ShadowProjectionTechnique;                        		// 0x0174 (0x0001) [0x0000000000000000]              
	unsigned char                                      ShadowFilterQuality;                              		// 0x0175 (0x0001) [0x0000000000000000]              
	int                                                MinShadowResolution;                              		// 0x0178 (0x0004) [0x0000000000000000]              
	int                                                MaxShadowResolution;                              		// 0x017C (0x0004) [0x0000000000000000]              
	int                                                ShadowFadeResolution;                             		// 0x0180 (0x0004) [0x0000000000000000]              
	float                                              OcclusionDepthRange;                              		// 0x0184 (0x0004) [0x0000000000000000]              
	float                                              BloomScale;                                       		// 0x0188 (0x0004) [0x0000000000000000]              
	float                                              BloomThreshold;                                   		// 0x018C (0x0004) [0x0000000000000000]              
	float                                              BloomScreenBlendThreshold;                        		// 0x0190 (0x0004) [0x0000000000000000]              
	struct FColor                                      BloomTint;                                        		// 0x0194 (0x0004) [0x0000000000000000]              
	float                                              RadialBlurPercent;                                		// 0x0198 (0x0004) [0x0000000000000000]              
	float                                              OcclusionMaskDarkness;                            		// 0x019C (0x0004) [0x0000000000000000]              
	float                                              ReflectionSpecularBrightness;                     		// 0x01A0 (0x0004) [0x0000000000000000]              
	float                                              MaxDrawDistance;                                  		// 0x01A4 (0x0004) [0x0000000000000000]              
	float                                              MaxBrightness;                                    		// 0x01A8 (0x0004) [0x0000000000000000]              
	float                                              MinBrightness;                                    		// 0x01AC (0x0004) [0x0000000000000000]              
	unsigned char                                      AnimationType;                                    		// 0x01B0 (0x0001) [0x0000000000000000]              
	float                                              AnimationFrequency;                               		// 0x01B4 (0x0004) [0x0000000000000000]              
	float                                              AnimationTimeOffset;                              		// 0x01B8 (0x0004) [0x0000000000000000]              
	int                                                LightAnimFrameCount;                              		// 0x01BC (0x0004) [0x0000000000000000]              
	float                                              LastRenderTime;                                   		// 0x01C0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LightComponent" );

		return pClassPointer;
	};

	void OnUpdatePropertyLightColor ( );
	void OnUpdatePropertyBrightness ( );
	void OnUpdatePropertyOcclusionMaskDarkness ( );
	void OnUpdatePropertyBloomTint ( );
	void OnUpdatePropertyBloomScale ( );
	void UpdateLightShaftParameters ( );
	void UpdateColorAndBrightness ( );
	void GetDirection ( );
	void GetOrigin ( );
	void SetLightProperties ( );
	void SetEnabled ( );
};

UClass* ULightComponent::pClassPointer = NULL;

// Class Engine.DirectionalLightComponent
// 0x0020 (0x01E4 - 0x01C4)
class UDirectionalLightComponent : public ULightComponent
{
public:
	float                                              TraceDistance;                                    		// 0x01C4 (0x0004) [0x0000000000000000]              
	float                                              WholeSceneDynamicShadowRadius;                    		// 0x01C8 (0x0004) [0x0000000000000000]              
	int                                                NumWholeSceneDynamicShadowCascades;               		// 0x01CC (0x0004) [0x0000000000000000]              
	float                                              CascadeDistributionExponent;                      		// 0x01D0 (0x0004) [0x0000000000000000]              
	struct FLightmassDirectionalLightSettings          LightmassSettings;                                		// 0x01D4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DirectionalLightComponent" );

		return pClassPointer;
	};

	void OnUpdatePropertyBrightness ( );
	void OnUpdatePropertyLightColor ( );
};

UClass* UDirectionalLightComponent::pClassPointer = NULL;

// Class Engine.DominantDirectionalLightComponent
// 0x00CC (0x02B0 - 0x01E4)
class UDominantDirectionalLightComponent : public UDirectionalLightComponent
{
public:
	unsigned char                                      UnknownData00[ 0xC ];                             		// 0x01E4 (0x000C) MISSED OFFSET
	struct FDominantShadowInfo                         DominantLightShadowInfo;                          		// 0x01F0 (0x00B0) [0x0000000000000000]              
	struct FArray_Mirror                               DominantLightShadowMap;                           		// 0x02A0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DominantDirectionalLightComponent" );

		return pClassPointer;
	};

};

UClass* UDominantDirectionalLightComponent::pClassPointer = NULL;

// Class Engine.PointLightComponent
// 0x00A8 (0x026C - 0x01C4)
class UPointLightComponent : public ULightComponent
{
public:
	float                                              ShadowRadiusMultiplier;                           		// 0x01C4 (0x0004) [0x0000000000000000]              
	float                                              Radius;                                           		// 0x01C8 (0x0004) [0x0000000000000000]              
	float                                              FalloffExponent;                                  		// 0x01CC (0x0004) [0x0000000000000000]              
	float                                              ShadowFalloffExponent;                            		// 0x01D0 (0x0004) [0x0000000000000000]              
	float                                              MinShadowFalloffRadius;                           		// 0x01D4 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x01D8 (0x0008) MISSED OFFSET
	struct FMatrix                                     CachedParentToWorld;                              		// 0x01E0 (0x0040) [0x0000000000000000]              
	struct FVector                                     Translation;                                      		// 0x0220 (0x000C) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x4 ];                             		// 0x022C (0x0004) MISSED OFFSET
	struct FPlane                                      ShadowPlane;                                      		// 0x0230 (0x0010) [0x0000000000000000]              
	class UDrawLightRadiusComponent*                   PreviewLightRadius;                               		// 0x0240 (0x0008) [0x0000000000000000]              
	struct FLightmassPointLightSettings                LightmassSettings;                                		// 0x0248 (0x0010) [0x0000000000000000]              
	class UDrawLightRadiusComponent*                   PreviewLightSourceRadius;                         		// 0x0258 (0x0008) [0x0000000000000000]              
	class USpriteComponent*                            LightSprite;                                      		// 0x0260 (0x0008) [0x0000000000000000]              
	DWORD                                              bAIIgnoreLuminosity : 1;                          		// 0x0268 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PointLightComponent" );

		return pClassPointer;
	};

	void OnUpdatePropertyBrightness ( );
	void OnUpdatePropertyLightColor ( );
	void SetRadius ( );
	void SetTranslation ( );
};

UClass* UPointLightComponent::pClassPointer = NULL;

// Class Engine.DominantPointLightComponent
// 0x0000 (0x026C - 0x026C)
class UDominantPointLightComponent : public UPointLightComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DominantPointLightComponent" );

		return pClassPointer;
	};

};

UClass* UDominantPointLightComponent::pClassPointer = NULL;

// Class Engine.SpotLightComponent
// 0x0028 (0x0294 - 0x026C)
class USpotLightComponent : public UPointLightComponent
{
public:
	float                                              InnerConeAngle;                                   		// 0x026C (0x0004) [0x0000000000000000]              
	float                                              OuterConeAngle;                                   		// 0x0270 (0x0004) [0x0000000000000000]              
	float                                              LightShaftConeAngle;                              		// 0x0274 (0x0004) [0x0000000000000000]              
	class UDrawLightConeComponent*                     PreviewInnerCone;                                 		// 0x0278 (0x0008) [0x0000000000000000]              
	class UDrawLightConeComponent*                     PreviewOuterCone;                                 		// 0x0280 (0x0008) [0x0000000000000000]              
	struct FRotator                                    Rotation;                                         		// 0x0288 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SpotLightComponent" );

		return pClassPointer;
	};

	void SetRotation ( );
};

UClass* USpotLightComponent::pClassPointer = NULL;

// Class Engine.DominantSpotLightComponent
// 0x00CC (0x0360 - 0x0294)
class UDominantSpotLightComponent : public USpotLightComponent
{
public:
	unsigned char                                      UnknownData00[ 0xC ];                             		// 0x0294 (0x000C) MISSED OFFSET
	struct FDominantShadowInfo                         DominantLightShadowInfo;                          		// 0x02A0 (0x00B0) [0x0000000000000000]              
	struct FArray_Mirror                               DominantLightShadowMap;                           		// 0x0350 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DominantSpotLightComponent" );

		return pClassPointer;
	};

};

UClass* UDominantSpotLightComponent::pClassPointer = NULL;

// Class Engine.SkyLightComponent
// 0x0008 (0x01CC - 0x01C4)
class USkyLightComponent : public ULightComponent
{
public:
	float                                              LowerBrightness;                                  		// 0x01C4 (0x0004) [0x0000000000000000]              
	struct FColor                                      LowerColor;                                       		// 0x01C8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkyLightComponent" );

		return pClassPointer;
	};

};

UClass* USkyLightComponent::pClassPointer = NULL;

// Class Engine.SphericalHarmonicLightComponent
// 0x00A0 (0x0264 - 0x01C4)
class USphericalHarmonicLightComponent : public ULightComponent
{
public:
	unsigned char                                      UnknownData00[ 0xC ];                             		// 0x01C4 (0x000C) MISSED OFFSET
	struct FSHVectorRGB                                WorldSpaceIncidentLighting;                       		// 0x01D0 (0x0090) [0x0000000000000000]              
	DWORD                                              bRenderBeforeModShadows : 1;                      		// 0x0260 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SphericalHarmonicLightComponent" );

		return pClassPointer;
	};

};

UClass* USphericalHarmonicLightComponent::pClassPointer = NULL;

// Class Engine.LightEnvironmentComponent
// 0x0023 (0x00A8 - 0x0085)
class ULightEnvironmentComponent : public UActorComponent
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bForceNonCompositeDynamicLights : 1;              		// 0x0088 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAllowDynamicShadowsOnTranslucency : 1;           		// 0x0088 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bAllowPreShadow : 1;                              		// 0x0088 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bTranslucencyShadowed : 1;                        		// 0x0088 (0x0004) [0x0000000000000000] [0x00000010] 
	float                                              DominantShadowFactor;                             		// 0x008C (0x0004) [0x0000000000000000]              
	class ULightComponent*                             AffectingDominantLight;                           		// 0x0090 (0x0008) [0x0000000000000000]              
	TArray< class UPrimitiveComponent* >               AffectedComponents;                               		// 0x0098 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LightEnvironmentComponent" );

		return pClassPointer;
	};

	void IsEnabled ( );
	void SetEnabled ( );
};

UClass* ULightEnvironmentComponent::pClassPointer = NULL;

// Class Engine.DynamicLightEnvironmentComponent
// 0x00B0 (0x0158 - 0x00A8)
class UDynamicLightEnvironmentComponent : public ULightEnvironmentComponent
{
public:
	struct FPointer                                    State;                                            		// 0x00A8 (0x0008) [0x0000000000000000]              
	float                                              InvisibleUpdateTime;                              		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              MinTimeBetweenFullUpdates;                        		// 0x00B4 (0x0004) [0x0000000000000000]              
	float                                              VelocityUpdateTimeScale;                          		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              ShadowInterpolationSpeed;                         		// 0x00BC (0x0004) [0x0000000000000000]              
	int                                                NumVolumeVisibilitySamples;                       		// 0x00C0 (0x0004) [0x0000000000000000]              
	float                                              LightingBoundsScale;                              		// 0x00C4 (0x0004) [0x0000000000000000]              
	struct FLinearColor                                AmbientShadowColor;                               		// 0x00C8 (0x0010) [0x0000000000000000]              
	struct FVector                                     AmbientShadowSourceDirection;                     		// 0x00D8 (0x000C) [0x0000000000000000]              
	struct FLinearColor                                AmbientGlow;                                      		// 0x00E4 (0x0010) [0x0000000000000000]              
	float                                              LightDistance;                                    		// 0x00F4 (0x0004) [0x0000000000000000]              
	float                                              ShadowDistance;                                   		// 0x00F8 (0x0004) [0x0000000000000000]              
	DWORD                                              bCastShadows : 1;                                 		// 0x00FC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bCompositeShadowsFromDynamicLights : 1;           		// 0x00FC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bForceCompositeAllLights : 1;                     		// 0x00FC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bAffectedBySmallDynamicLights : 1;                		// 0x00FC (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bUseBooleanEnvironmentShadowing : 1;              		// 0x00FC (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bShadowFromEnvironment : 1;                       		// 0x00FC (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bDynamic : 1;                                     		// 0x00FC (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bSynthesizeDirectionalLight : 1;                  		// 0x00FC (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bSynthesizeSHLight : 1;                           		// 0x00FC (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bRequiresNonLatentUpdates : 1;                    		// 0x00FC (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bTraceFromClosestBoundsPoint : 1;                 		// 0x00FC (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bIsCharacterLightEnvironment : 1;                 		// 0x00FC (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bOverrideOwnerLightingChannels : 1;               		// 0x00FC (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bAlwaysInfluencedByDominantDirectionalLight : 1;  		// 0x00FC (0x0004) [0x0000000000000000] [0x00002000] 
	float                                              ModShadowFadeoutTime;                             		// 0x0100 (0x0004) [0x0000000000000000]              
	float                                              ModShadowFadeoutExponent;                         		// 0x0104 (0x0004) [0x0000000000000000]              
	struct FLinearColor                                MaxModulatedShadowColor;                          		// 0x0108 (0x0010) [0x0000000000000000]              
	float                                              DominantShadowTransitionStartDistance;            		// 0x0118 (0x0004) [0x0000000000000000]              
	float                                              DominantShadowTransitionEndDistance;              		// 0x011C (0x0004) [0x0000000000000000]              
	float                                              MinShadowAngle;                                   		// 0x0120 (0x0004) [0x0000000000000000]              
	unsigned char                                      BoundsMethod;                                     		// 0x0124 (0x0001) [0x0000000000000000]              
	struct FBoxSphereBounds                            OverriddenBounds;                                 		// 0x0128 (0x001C) [0x0000000000000000]              
	struct FLightingChannelContainer                   OverriddenLightingChannels;                       		// 0x0144 (0x0004) [0x0000000000000000]              
	TArray< class ULightComponent* >                   OverriddenLightComponents;                        		// 0x0148 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DynamicLightEnvironmentComponent" );

		return pClassPointer;
	};

	void ResetEnvironment ( );
};

UClass* UDynamicLightEnvironmentComponent::pClassPointer = NULL;

// Class Engine.ParticleLightEnvironmentComponent
// 0x001C (0x0174 - 0x0158)
class UParticleLightEnvironmentComponent : public UDynamicLightEnvironmentComponent
{
public:
	int                                                ReferenceCount;                                   		// 0x0158 (0x0004) [0x0000000000000000]              
	int                                                NumPooledReuses;                                  		// 0x015C (0x0004) [0x0000000000000000]              
	class AActor*                                      SharedInstigator;                                 		// 0x0160 (0x0008) [0x0000000000000000]              
	class UParticleSystem*                             SharedParticleSystem;                             		// 0x0168 (0x0008) [0x0000000000000000]              
	DWORD                                              bAllowDLESharing : 1;                             		// 0x0170 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleLightEnvironmentComponent" );

		return pClassPointer;
	};

};

UClass* UParticleLightEnvironmentComponent::pClassPointer = NULL;

// Class Engine.DrawLightConeComponent
// 0x0000 (0x0248 - 0x0248)
class UDrawLightConeComponent : public UDrawConeComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DrawLightConeComponent" );

		return pClassPointer;
	};

};

UClass* UDrawLightConeComponent::pClassPointer = NULL;

// Class Engine.DrawLightRadiusComponent
// 0x0000 (0x0250 - 0x0250)
class UDrawLightRadiusComponent : public UDrawSphereComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DrawLightRadiusComponent" );

		return pClassPointer;
	};

};

UClass* UDrawLightRadiusComponent::pClassPointer = NULL;

// Class Engine.LightFunction
// 0x0018 (0x0078 - 0x0060)
class ULightFunction : public UObject
{
public:
	class UMaterialInterface*                          SourceMaterial;                                   		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FVector                                     Scale;                                            		// 0x0068 (0x000C) [0x0000000000000000]              
	float                                              DisabledBrightness;                               		// 0x0074 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LightFunction" );

		return pClassPointer;
	};

};

UClass* ULightFunction::pClassPointer = NULL;

// Class Engine.SkeletalMeshComponent
// 0x05D8 (0x0820 - 0x0248)
class USkeletalMeshComponent : public UMeshComponent
{
public:
	class USkeletalMesh*                               SkeletalMesh;                                     		// 0x0248 (0x0008) [0x0000000000000000]              
	class USkeletalMeshComponent*                      AttachedToSkelComponent;                          		// 0x0250 (0x0008) [0x0000000000000000]              
	class UAnimTree*                                   AnimTreeTemplate;                                 		// 0x0258 (0x0008) [0x0000000000000000]              
	class UAnimNode*                                   Animations;                                       		// 0x0260 (0x0008) [0x0000000000000000]              
	TArray< class UAnimNode* >                         AnimTickArray;                                    		// 0x0268 (0x0010) [0x0000000000000000]              
	TArray< class UAnimNode* >                         AnimAlwaysTickArray;                              		// 0x0278 (0x0010) [0x0000000000000000]              
	TArray< int >                                      AnimTickRelevancyArray;                           		// 0x0288 (0x0010) [0x0000000000000000]              
	TArray< float >                                    AnimTickWeightsArray;                             		// 0x0298 (0x0010) [0x0000000000000000]              
	TArray< class USkelControlBase* >                  SkelControlTickArray;                             		// 0x02A8 (0x0010) [0x0000000000000000]              
	class UPhysicsAsset*                               PhysicsAsset;                                     		// 0x02B8 (0x0008) [0x0000000000000000]              
	class UPhysicsAssetInstance*                       PhysicsAssetInstance;                             		// 0x02C0 (0x0008) [0x0000000000000000]              
	class UPhysicsAsset*                               PhysicsAssetForFlex;                              		// 0x02C8 (0x0008) [0x0000000000000000]              
	class UPhysicsAssetInstance*                       PhysicsAssetInstanceForFlex;                      		// 0x02D0 (0x0008) [0x0000000000000000]              
	DWORD                                              bUpdateFlexKinematicBonesFromAnimation : 1;       		// 0x02D8 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FPointer                                    ApexClothing;                                     		// 0x02DC (0x0008) [0x0000000000000000]              
	float                                              PhysicsWeight;                                    		// 0x02E4 (0x0004) [0x0000000000000000]              
	float                                              GlobalAnimRateScale;                              		// 0x02E8 (0x0004) [0x0000000000000000]              
	float                                              StreamingDistanceMultiplier;                      		// 0x02EC (0x0004) [0x0000000000000000]              
	struct FPointer                                    MeshObject;                                       		// 0x02F0 (0x0008) [0x0000000000000000]              
	struct FColor                                      WireframeColor;                                   		// 0x02F8 (0x0004) [0x0000000000000000]              
	TArray< struct FBoneAtom >                         SpaceBases;                                       		// 0x02FC (0x0010) [0x0000000000000000]              
	TArray< struct FBoneAtom >                         LocalAtoms;                                       		// 0x030C (0x0010) [0x0000000000000000]              
	TArray< struct FBoneAtom >                         CachedLocalAtoms;                                 		// 0x031C (0x0010) [0x0000000000000000]              
	TArray< struct FBoneAtom >                         CachedSpaceBases;                                 		// 0x032C (0x0010) [0x0000000000000000]              
	int                                                LowUpdateFrameRate;                               		// 0x033C (0x0004) [0x0000000000000000]              
	TArray< unsigned char >                            RequiredBones;                                    		// 0x0340 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            ComposeOrderedRequiredBones;                      		// 0x0350 (0x0010) [0x0000000000000000]              
	class USkeletalMeshComponent*                      ParentAnimComponent;                              		// 0x0360 (0x0008) [0x0000000000000000]              
	TArray< int >                                      ParentBoneMap;                                    		// 0x0368 (0x0010) [0x0000000000000000]              
	TArray< class UAnimSet* >                          AnimSets;                                         		// 0x0378 (0x0010) [0x0000000000000000]              
	TArray< class UAnimSet* >                          TemporarySavedAnimSets;                           		// 0x0388 (0x0010) [0x0000000000000000]              
	TArray< class UMorphTargetSet* >                   MorphSets;                                        		// 0x0398 (0x0010) [0x0000000000000000]              
	TArray< struct FActiveMorph >                      ActiveMorphs;                                     		// 0x03A8 (0x0010) [0x0000000000000000]              
	TArray< struct FActiveMorph >                      ActiveCurveMorphs;                                		// 0x03B8 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x03C8 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.SkeletalMeshComponent.MorphTargetIndexMap
	TArray< struct FAttachment >                       Attachments;                                      		// 0x0410 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            SkelControlIndex;                                 		// 0x0420 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            PostPhysSkelControlIndex;                         		// 0x0430 (0x0010) [0x0000000000000000]              
	int                                                ForcedLodModel;                                   		// 0x0440 (0x0004) [0x0000000000000000]              
	int                                                MinLodModel;                                      		// 0x0444 (0x0004) [0x0000000000000000]              
	int                                                PredictedLODLevel;                                		// 0x0448 (0x0004) [0x0000000000000000]              
	int                                                OldPredictedLODLevel;                             		// 0x044C (0x0004) [0x0000000000000000]              
	float                                              AnimationLODDistanceFactor;                       		// 0x0450 (0x0004) [0x0000000000000000]              
	int                                                AnimationLODFrameRate;                            		// 0x0454 (0x0004) [0x0000000000000000]              
	float                                              MaxDistanceFactor;                                		// 0x0458 (0x0004) [0x0000000000000000]              
	int                                                ChunkIndexPreview;                                		// 0x045C (0x0004) [0x0000000000000000]              
	int                                                SectionIndexPreview;                              		// 0x0460 (0x0004) [0x0000000000000000]              
	int                                                bForceWireframe;                                  		// 0x0464 (0x0004) [0x0000000000000000]              
	int                                                bForceRefpose;                                    		// 0x0468 (0x0004) [0x0000000000000000]              
	int                                                bOldForceRefPose;                                 		// 0x046C (0x0004) [0x0000000000000000]              
	DWORD                                              bNoSkeletonUpdate : 1;                            		// 0x0470 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                bDisplayBones;                                    		// 0x0474 (0x0004) [0x0000000000000000]              
	int                                                bShowPrePhysBones;                                		// 0x0478 (0x0004) [0x0000000000000000]              
	int                                                bHideSkin;                                        		// 0x047C (0x0004) [0x0000000000000000]              
	int                                                bForceRawOffset;                                  		// 0x0480 (0x0004) [0x0000000000000000]              
	int                                                bIgnoreControllers;                               		// 0x0484 (0x0004) [0x0000000000000000]              
	int                                                bTransformFromAnimParent;                         		// 0x0488 (0x0004) [0x0000000000000000]              
	int                                                TickTag;                                          		// 0x048C (0x0004) [0x0000000000000000]              
	int                                                InitTag;                                          		// 0x0490 (0x0004) [0x0000000000000000]              
	int                                                CachedAtomsTag;                                   		// 0x0494 (0x0004) [0x0000000000000000]              
	int                                                bUseSingleBodyPhysics;                            		// 0x0498 (0x0004) [0x0000000000000000]              
	int                                                bRequiredBonesUpToDate;                           		// 0x049C (0x0004) [0x0000000000000000]              
	float                                              MinDistFactorForKinematicUpdate;                  		// 0x04A0 (0x0004) [0x0000000000000000]              
	int                                                FramesPhysicsAsleep;                              		// 0x04A4 (0x0004) [0x0000000000000000]              
	int                                                SkipRateForTickAnimNodesAndGetBoneAtoms;          		// 0x04A8 (0x0004) [0x0000000000000000]              
	DWORD                                              bSkipTickAnimNodes : 1;                           		// 0x04AC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bSkipGetBoneAtoms : 1;                            		// 0x04AC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bInterpolateBoneAtoms : 1;                        		// 0x04AC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bHasValidBodies : 1;                              		// 0x04AC (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bSkipAllUpdateWhenPhysicsAsleep : 1;              		// 0x04AC (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bComponentUseFixedSkelBounds : 1;                 		// 0x04AC (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bUseBoundsFromParentAnimComponent : 1;            		// 0x04AC (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bConsiderAllBodiesForBounds : 1;                  		// 0x04AC (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bUpdateSkelWhenNotRendered : 1;                   		// 0x04AC (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bIgnoreControllersWhenNotRendered : 1;            		// 0x04AC (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bTickAnimNodesWhenNotRendered : 1;                		// 0x04AC (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bNotUpdatingKinematicDueToDistance : 1;           		// 0x04AC (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bForceDiscardRootMotion : 1;                      		// 0x04AC (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bNotifyRootMotionProcessed : 1;                   		// 0x04AC (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bRootMotionModeChangeNotify : 1;                  		// 0x04AC (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bRootMotionExtractedNotify : 1;                   		// 0x04AC (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bProcessingRootMotion : 1;                        		// 0x04AC (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bDisableFaceFXMaterialInstanceCreation : 1;       		// 0x04AC (0x0004) [0x0000000000000000] [0x00020000] 
	DWORD                                              bDisableFaceFX : 1;                               		// 0x04AC (0x0004) [0x0000000000000000] [0x00040000] 
	DWORD                                              bAnimTreeInitialised : 1;                         		// 0x04AC (0x0004) [0x0000000000000000] [0x00080000] 
	DWORD                                              bForceMeshObjectUpdate : 1;                       		// 0x04AC (0x0004) [0x0000000000000000] [0x00100000] 
	DWORD                                              bHasPhysicsAssetInstance : 1;                     		// 0x04AC (0x0004) [0x0000000000000000] [0x00200000] 
	DWORD                                              bUpdateKinematicBonesFromAnimation : 1;           		// 0x04AC (0x0004) [0x0000000000000000] [0x00400000] 
	DWORD                                              bUpdateJointsFromAnimation : 1;                   		// 0x04AC (0x0004) [0x0000000000000000] [0x00800000] 
	DWORD                                              bSkelCompFixed : 1;                               		// 0x04AC (0x0004) [0x0000000000000000] [0x01000000] 
	DWORD                                              bHasHadPhysicsBlendedIn : 1;                      		// 0x04AC (0x0004) [0x0000000000000000] [0x02000000] 
	DWORD                                              bForceUpdateAttachmentsInTick : 1;                		// 0x04AC (0x0004) [0x0000000000000000] [0x04000000] 
	DWORD                                              bEnableFullAnimWeightBodies : 1;                  		// 0x04AC (0x0004) [0x0000000000000000] [0x08000000] 
	DWORD                                              bPerBoneVolumeEffects : 1;                        		// 0x04AC (0x0004) [0x0000000000000000] [0x10000000] 
	DWORD                                              bPerBoneMotionBlur : 1;                           		// 0x04AC (0x0004) [0x0000000000000000] [0x20000000] 
	DWORD                                              bSyncActorLocationToRootRigidBody : 1;            		// 0x04AC (0x0004) [0x0000000000000000] [0x40000000] 
	DWORD                                              bUseRawData : 1;                                  		// 0x04AC (0x0004) [0x0000000000000000] [0x80000000] 
	DWORD                                              bDisableWarningWhenAnimNotFound : 1;              		// 0x04B0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bOverrideAttachmentOwnerVisibility : 1;           		// 0x04B0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bNeedsToDeleteHitMask : 1;                        		// 0x04B0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bPauseAnims : 1;                                  		// 0x04B0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bChartDistanceFactor : 1;                         		// 0x04B0 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bEnableLineCheckWithBounds : 1;                   		// 0x04B0 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bCanHighlightSelectedSections : 1;                		// 0x04B0 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bUpdateMorphWhenParentAnimComponentExists : 1;    		// 0x04B0 (0x0004) [0x0000000000000000] [0x00000080] 
	struct FVector                                     LineCheckBoundsScale;                             		// 0x04B4 (0x000C) [0x0000000000000000]              
	DWORD                                              bEnableClothSimulation : 1;                       		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDisableClothCollision : 1;                       		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bClothFrozen : 1;                                 		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bAutoFreezeClothWhenNotRendered : 1;              		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bClothAwakeOnStartup : 1;                         		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bClothBaseVelClamp : 1;                           		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bClothBaseVelInterp : 1;                          		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bAttachClothVertsToBaseBody : 1;                  		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bIsClothOnStaticObject : 1;                       		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bUpdatedFixedClothVerts : 1;                      		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000200] 
	DWORD                                              bClothPositionalDampening : 1;                    		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000400] 
	DWORD                                              bClothWindRelativeToOwner : 1;                    		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000800] 
	DWORD                                              bRecentlyRendered : 1;                            		// 0x04C0 (0x0004) [0x0000000000000000] [0x00001000] 
	DWORD                                              bCacheAnimSequenceNodes : 1;                      		// 0x04C0 (0x0004) [0x0000000000000000] [0x00002000] 
	DWORD                                              bNeedsInstanceWeightUpdate : 1;                   		// 0x04C0 (0x0004) [0x0000000000000000] [0x00004000] 
	DWORD                                              bAlwaysUseInstanceWeights : 1;                    		// 0x04C0 (0x0004) [0x0000000000000000] [0x00008000] 
	DWORD                                              bUpdateComposeSkeletonPasses : 1;                 		// 0x04C0 (0x0004) [0x0000000000000000] [0x00010000] 
	DWORD                                              bValidTemporarySavedAnimSets : 1;                 		// 0x04C0 (0x0004) [0x0000000000000000] [0x00020000] 
	TArray< struct FBonePair >                         InstanceVertexWeightBones;                        		// 0x04C4 (0x0010) [0x0000000000000000]              
	TArray< struct FSkelMeshComponentLODInfo >         LODInfo;                                          		// 0x04D4 (0x0010) [0x0000000000000000]              
	struct FVector                                     FrozenLocalToWorldPos;                            		// 0x04E4 (0x000C) [0x0000000000000000]              
	struct FRotator                                    FrozenLocalToWorldRot;                            		// 0x04F0 (0x000C) [0x0000000000000000]              
	struct FVector                                     ClothExternalForce;                               		// 0x04FC (0x000C) [0x0000000000000000]              
	struct FVector                                     ClothWind;                                        		// 0x0508 (0x000C) [0x0000000000000000]              
	float                                              ClothWindBlendTime;                               		// 0x0514 (0x0004) [0x0000000000000000]              
	float                                              ClothWindDirectionDeviationAngle;                 		// 0x0518 (0x0004) [0x0000000000000000]              
	float                                              ClothWindDirectionOscillationPeriod;              		// 0x051C (0x0004) [0x0000000000000000]              
	float                                              ClothWindStrengthDeviationPercentage;             		// 0x0520 (0x0004) [0x0000000000000000]              
	float                                              ClothWindStrengthOscillationPeriod;               		// 0x0524 (0x0004) [0x0000000000000000]              
	struct FPointer                                    ClothWindDirectionVO1;                            		// 0x0528 (0x0008) [0x0000000000000000]              
	struct FPointer                                    ClothWindDirectionVO2;                            		// 0x0530 (0x0008) [0x0000000000000000]              
	struct FPointer                                    ClothWindStrengthVO;                              		// 0x0538 (0x0008) [0x0000000000000000]              
	struct FMatrix                                     ClothWindDirectionMatrix;                         		// 0x0540 (0x0040) [0x0000000000000000]              
	float                                              ClothWindStrength;                                		// 0x0580 (0x0004) [0x0000000000000000]              
	struct FVector                                     ClothBaseVelClampRange;                           		// 0x0584 (0x000C) [0x0000000000000000]              
	float                                              ClothBlendWeight;                                 		// 0x0590 (0x0004) [0x0000000000000000]              
	float                                              ClothDynamicBlendWeight;                          		// 0x0594 (0x0004) [0x0000000000000000]              
	float                                              ClothBlendMinDistanceFactor;                      		// 0x0598 (0x0004) [0x0000000000000000]              
	float                                              ClothBlendMaxDistanceFactor;                      		// 0x059C (0x0004) [0x0000000000000000]              
	struct FVector                                     MinPosDampRange;                                  		// 0x05A0 (0x000C) [0x0000000000000000]              
	struct FVector                                     MaxPosDampRange;                                  		// 0x05AC (0x000C) [0x0000000000000000]              
	struct FVector                                     MinPosDampScale;                                  		// 0x05B8 (0x000C) [0x0000000000000000]              
	struct FVector                                     MaxPosDampScale;                                  		// 0x05C4 (0x000C) [0x0000000000000000]              
	struct FPointer                                    ClothSim;                                         		// 0x05D0 (0x0008) [0x0000000000000000]              
	int                                                SceneIndex;                                       		// 0x05D8 (0x0004) [0x0000000000000000]              
	TArray< struct FVector >                           ClothMeshPosData;                                 		// 0x05DC (0x0010) [0x0000000000000000]              
	TArray< struct FVector >                           ClothMeshNormalData;                              		// 0x05EC (0x0010) [0x0000000000000000]              
	TArray< int >                                      ClothMeshIndexData;                               		// 0x05FC (0x0010) [0x0000000000000000]              
	int                                                NumClothMeshVerts;                                		// 0x060C (0x0004) [0x0000000000000000]              
	int                                                NumClothMeshIndices;                              		// 0x0610 (0x0004) [0x0000000000000000]              
	TArray< int >                                      ClothMeshParentData;                              		// 0x0614 (0x0010) [0x0000000000000000]              
	int                                                NumClothMeshParentIndices;                        		// 0x0624 (0x0004) [0x0000000000000000]              
	TArray< struct FVector >                           ClothMeshWeldedPosData;                           		// 0x0628 (0x0010) [0x0000000000000000]              
	TArray< struct FVector >                           ClothMeshWeldedNormalData;                        		// 0x0638 (0x0010) [0x0000000000000000]              
	TArray< int >                                      ClothMeshWeldedIndexData;                         		// 0x0648 (0x0010) [0x0000000000000000]              
	int                                                ClothDirtyBufferFlag;                             		// 0x0658 (0x0004) [0x0000000000000000]              
	unsigned char                                      ClothRBChannel;                                   		// 0x065C (0x0001) [0x0000000000000000]              
	struct FRBCollisionChannelContainer                ClothRBCollideWithChannels;                       		// 0x0660 (0x0004) [0x0000000000000000]              
	float                                              ClothForceScale;                                  		// 0x0664 (0x0004) [0x0000000000000000]              
	float                                              ClothImpulseScale;                                		// 0x0668 (0x0004) [0x0000000000000000]              
	float                                              ClothAttachmentTearFactor;                        		// 0x066C (0x0004) [0x0000000000000000]              
	DWORD                                              bClothUseCompartment : 1;                         		// 0x0670 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bClothUseSceneCollision : 1;                      		// 0x0670 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              MinDistanceForClothReset;                         		// 0x0674 (0x0004) [0x0000000000000000]              
	struct FVector                                     LastClothLocation;                                		// 0x0678 (0x000C) [0x0000000000000000]              
	unsigned char                                      ApexClothingRBChannel;                            		// 0x0684 (0x0001) [0x0000000000000000]              
	struct FRBCollisionChannelContainer                ApexClothingRBCollideWithChannels;                		// 0x0688 (0x0004) [0x0000000000000000]              
	unsigned char                                      ApexClothingCollisionRBChannel;                   		// 0x068C (0x0001) [0x0000000000000000]              
	DWORD                                              bAutoFreezeApexClothingWhenNotRendered : 1;       		// 0x0690 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bLocalSpaceWind : 1;                              		// 0x0690 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FVector                                     WindVelocity;                                     		// 0x0694 (0x000C) [0x0000000000000000]              
	float                                              WindVelocityBlendTime;                            		// 0x06A0 (0x0004) [0x0000000000000000]              
	float                                              WindStrengthNoiseBounds;                          		// 0x06A4 (0x0004) [0x0000000000000000]              
	float                                              WindStrengthNoiseStepSize;                        		// 0x06A8 (0x0004) [0x0000000000000000]              
	DWORD                                              bWindStrengthNoiseCentered : 1;                   		// 0x06AC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              WindDirNoiseBounds;                               		// 0x06B0 (0x0004) [0x0000000000000000]              
	float                                              WindDirNoiseStepSize;                             		// 0x06B4 (0x0004) [0x0000000000000000]              
	DWORD                                              bWindDirNoiseCentered : 1;                        		// 0x06B8 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              WindCurrentStrengthNoise;                         		// 0x06BC (0x0004) [0x0000000000000000]              
	struct FVector                                     WindCurrentDirNoise;                              		// 0x06C0 (0x000C) [0x0000000000000000]              
	DWORD                                              bSkipInitClothing : 1;                            		// 0x06CC (0x0004) [0x0000000000000000] [0x00000001] 
	struct FPointer                                    SoftBodySim;                                      		// 0x06D0 (0x0008) [0x0000000000000000]              
	int                                                SoftBodySceneIndex;                               		// 0x06D8 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnableSoftBodySimulation : 1;                    		// 0x06DC (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< struct FVector >                           SoftBodyTetraPosData;                             		// 0x06E0 (0x0010) [0x0000000000000000]              
	TArray< int >                                      SoftBodyTetraIndexData;                           		// 0x06F0 (0x0010) [0x0000000000000000]              
	int                                                NumSoftBodyTetraVerts;                            		// 0x0700 (0x0004) [0x0000000000000000]              
	int                                                NumSoftBodyTetraIndices;                          		// 0x0704 (0x0004) [0x0000000000000000]              
	float                                              SoftBodyImpulseScale;                             		// 0x0708 (0x0004) [0x0000000000000000]              
	DWORD                                              bSoftBodyFrozen : 1;                              		// 0x070C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAutoFreezeSoftBodyWhenNotRendered : 1;           		// 0x070C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bSoftBodyAwakeOnStartup : 1;                      		// 0x070C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bSoftBodyUseCompartment : 1;                      		// 0x070C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned char                                      SoftBodyRBChannel;                                		// 0x0710 (0x0001) [0x0000000000000000]              
	struct FRBCollisionChannelContainer                SoftBodyRBCollideWithChannels;                    		// 0x0714 (0x0004) [0x0000000000000000]              
	struct FPointer                                    SoftBodyASVPlane;                                 		// 0x0718 (0x0008) [0x0000000000000000]              
	class UMaterial*                                   LimitMaterial;                                    		// 0x0720 (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x8 ];                             		// 0x0728 (0x0008) MISSED OFFSET
	struct FBoneAtom                                   RootMotionDelta;                                  		// 0x0730 (0x0020) [0x0000000000000000]              
	struct FVector                                     RootMotionVelocity;                               		// 0x0750 (0x000C) [0x0000000000000000]              
	struct FVector                                     RootBoneTranslation;                              		// 0x075C (0x000C) [0x0000000000000000]              
	struct FVector                                     RootMotionAccelScale;                             		// 0x0768 (0x000C) [0x0000000000000000]              
	unsigned char                                      RootMotionMode;                                   		// 0x0774 (0x0001) [0x0000000000000000]              
	unsigned char                                      PreviousRMM;                                      		// 0x0775 (0x0001) [0x0000000000000000]              
	unsigned char                                      PendingRMM;                                       		// 0x0776 (0x0001) [0x0000000000000000]              
	unsigned char                                      OldPendingRMM;                                    		// 0x0777 (0x0001) [0x0000000000000000]              
	int                                                bRMMOneFrameDelay;                                		// 0x0778 (0x0004) [0x0000000000000000]              
	unsigned char                                      RootMotionRotationMode;                           		// 0x077C (0x0001) [0x0000000000000000]              
	unsigned char                                      AnimRotationOnly;                                 		// 0x077D (0x0001) [0x0000000000000000]              
	unsigned char                                      FaceFXBlendMode;                                  		// 0x077E (0x0001) [0x0000000000000000]              
	struct FPointer                                    FaceFXActorInstance;                              		// 0x0780 (0x0008) [0x0000000000000000]              
	class UAudioComponent*                             CachedFaceFXAudioComp;                            		// 0x0788 (0x0008) [0x0000000000000000]              
	TArray< unsigned char >                            BoneVisibilityStates;                             		// 0x0790 (0x0010) [0x0000000000000000]              
	class UAkEvent*                                    CachedFaceFxAkEvent;                              		// 0x07A0 (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x8 ];                             		// 0x07A8 (0x0008) MISSED OFFSET
	struct FBoneAtom                                   LocalToWorldBoneAtom;                             		// 0x07B0 (0x0020) [0x0000000000000000]              
	float                                              ProgressiveDrawingFraction;                       		// 0x07D0 (0x0004) [0x0000000000000000]              
	unsigned char                                      CustomSortAlternateIndexMode;                     		// 0x07D4 (0x0001) [0x0000000000000000]              
	TArray< struct FName >                             MorphTargetsQueried;                              		// 0x07D8 (0x0010) [0x0000000000000000]              
	class USkeletalMeshComponent*                      LODParent;                                        		// 0x07E8 (0x0008) [0x0000000000000000]              
	DWORD                                              bAllowBooleanPreshadows : 1;                      		// 0x07F0 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              InterpolatedBooleanPreshadowFactor;               		// 0x07F4 (0x0004) [0x0000000000000000]              
	float                                              CurrentBooleanPreshadowFactor;                    		// 0x07F8 (0x0004) [0x0000000000000000]              
	float                                              LastBooleanPreshadowFactor;                       		// 0x07FC (0x0004) [0x0000000000000000]              
	struct FDouble                                     LastBooleanPreshadowUpdateTime;                   		// 0x0800 (0x0008) [0x0000000000000000]              
	DWORD                                              bUseTickOptimization : 1;                         		// 0x0808 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                TickCount;                                        		// 0x080C (0x0004) [0x0000000000000000]              
	int                                                LastDropRate;                                     		// 0x0810 (0x0004) [0x0000000000000000]              
	float                                              LastDropRateChange;                               		// 0x0814 (0x0004) [0x0000000000000000]              
	float                                              AccumulatedDroppedDeltaTime;                      		// 0x0818 (0x0004) [0x0000000000000000]              
	float                                              ComponentDroppedDeltaTime;                        		// 0x081C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkeletalMeshComponent" );

		return pClassPointer;
	};

	void SetLODParent ( );
	void SetMaterial ( );
	void GetRotation ( );
	void GetPosition ( );
	void IsBrokenConstraint ( );
	void BreakConstraint ( );
	void ToggleAlternateBoneWeights ( );
	void SkelMeshCompOnParticleSystemFinished ( );
	void eventPlayParticleEffect ( );
	void eventCreateForceField ( );
	void StopAnim ( );
	void PlayAnim ( );
	void ShowMaterialSection ( );
	void UpdateMeshForBrokenConstraints ( );
	void UnHideBoneByName ( );
	void HideBoneByName ( );
	void IsBoneHidden ( );
	void UnHideBone ( );
	void HideBone ( );
	void SetFaceFXRegisterEx ( );
	void SetFaceFXRegister ( );
	void GetFaceFXRegister ( );
	void DeclareFaceFXRegister ( );
	void IsPlayingFaceFXAnim ( );
	void StopFaceFXAnim ( );
	void PlayFaceFXAnim ( );
	void ToggleInstanceVertexWeights ( );
	void UpdateInstanceVertexWeightBones ( );
	void FindInstanceVertexweightBonePair ( );
	void RemoveInstanceVertexWeightBoneParented ( );
	void AddInstanceVertexWeightBoneParented ( );
	void GetBonesWithinRadius ( );
	void UpdateAnimations ( );
	void ForceSkelUpdate ( );
	void UpdateRBBonesFromSpaceBases ( );
	void SetHasPhysicsAssetInstance ( );
	void FindBodyInstanceNamed ( );
	void FindConstraintBoneName ( );
	void FindConstraintIndex ( );
	void InitMorphTargets ( );
	void InitSkelControls ( );
	void UpdateParentBoneMap ( );
	void SetParentAnimComponent ( );
	void SetAnimTreeTemplate ( );
	void GetClosestCollidingBoneLocation ( );
	void FindClosestBones ( );
	void FindClosestBone ( );
	void TransformFromBoneSpace ( );
	void TransformToBoneSpace ( );
	void GetBoneAxis ( );
	void GetRefPosePosition ( );
	void BoneIsChildOf ( );
	void GetBoneNames ( );
	void GetParentBone ( );
	void GetBoneMatrix ( );
	void GetBoneName ( );
	void MatchRefBone ( );
	void GetBoneLocation(FName Name, FVector &Out);
	void GetBoneQuaternion ( );
	void FindMorphNode ( );
	void FindSkelControl ( );
	void AllAnimNodes ( );
	void FindAnimNode ( );
	void FindMorphTarget ( );
	void GetAnimLength ( );
	void GetAnimRateByDuration ( );
	void RestoreSavedAnimSets ( );
	void SaveAnimSets ( );
	void FindAnimSequence ( );
	void WakeSoftBody ( );
	void SetSoftBodyFrozen ( );
	void UpdateSoftBodyParams ( );
	void SetClothValidBounds ( );
	void EnableClothValidBounds ( );
	void AttachClothToCollidingShapes ( );
	void SetClothVelocity ( );
	void SetClothPosition ( );
	void SetClothSleep ( );
	void SetClothThickness ( );
	void SetClothTearFactor ( );
	void SetClothStretchingStiffness ( );
	void SetClothSolverIterations ( );
	void SetClothSleepLinearVelocity ( );
	void SetClothPressure ( );
	void SetClothFriction ( );
	void SetClothFlags ( );
	void SetClothDampingCoefficient ( );
	void SetClothCollisionResponseCoefficient ( );
	void SetClothBendingStiffness ( );
	void SetClothAttachmentTearFactor ( );
	void SetClothAttachmentResponseCoefficient ( );
	void GetClothThickness ( );
	void GetClothTearFactor ( );
	void GetClothStretchingStiffness ( );
	void GetClothSolverIterations ( );
	void GetClothSleepLinearVelocity ( );
	void GetClothPressure ( );
	void GetClothFriction ( );
	void GetClothFlags ( );
	void GetClothDampingCoefficient ( );
	void GetClothCollisionResponseCoefficient ( );
	void GetClothBendingStiffness ( );
	void GetClothAttachmentTearFactor ( );
	void GetClothAttachmentResponseCoefficient ( );
	void ForceApexClothingTeleport ( );
	void ForceApexClothingTeleportAndReset ( );
	void ResetClothVertsToRefPose ( );
	void SetAttachClothVertsToBaseBody ( );
	void SetClothExternalForce ( );
	void UpdateClothParams ( );
	void SetEnableClothingSimulation ( );
	void SetClothFrozen ( );
	void SetEnableClothSimulation ( );
	void SetForceRefPose ( );
	void SetPhysicsAsset ( );
	void SetSkeletalMesh ( );
	void GetTransformMatrix ( );
	void AttachedComponents ( );
	void IsComponentAttached ( );
	void FindComponentAttachedToBone ( );
	void GetSocketBoneName ( );
	void GetSocketByName ( );
	void GetSocketMatrix ( );
	void GetSocketWorldLocationAndRotation ( );
	void AttachComponentToSocket ( );
	void DetachComponent ( );
	void AttachComponent ( );
};

UClass* USkeletalMeshComponent::pClassPointer = NULL;

// Class Engine.SkeletalMesh
// 0x0470 (0x04D0 - 0x0060)
class USkeletalMesh : public UObject
{
public:
	struct FBoxSphereBounds                            Bounds;                                           		// 0x0060 (0x001C) [0x0000000000000000]              
	TArray< class UMaterialInterface* >                Materials;                                        		// 0x007C (0x0010) [0x0000000000000000]              
	TArray< class UApexClothingAsset* >                ClothingAssets;                                   		// 0x008C (0x0010) [0x0000000000000000]              
	TArray< struct FApexClothingAssetInfo >            ClothingLodMap;                                   		// 0x009C (0x0010) [0x0000000000000000]              
	struct FVector                                     Origin;                                           		// 0x00AC (0x000C) [0x0000000000000000]              
	struct FRotator                                    RotOrigin;                                        		// 0x00B8 (0x000C) [0x0000000000000000]              
	TArray< int >                                      RefSkeleton;                                      		// 0x00C4 (0x0010) [0x0000000000000000]              
	int                                                SkeletalDepth;                                    		// 0x00D4 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x48 ];                            		// 0x00D8 (0x0048) UNKNOWN PROPERTY: MapProperty Engine.SkeletalMesh.NameIndexMap
	struct FIndirectArray_Mirror                       LODModels;                                        		// 0x0120 (0x0010) [0x0000000000000000]              
	struct FPointer                                    SourceData;                                       		// 0x0130 (0x0008) [0x0000000000000000]              
	TArray< struct FBoneAtom >                         RefBasesInvMatrix;                                		// 0x0138 (0x0010) [0x0000000000000000]              
	TArray< struct FBoneMirrorInfo >                   SkelMirrorTable;                                  		// 0x0148 (0x0010) [0x0000000000000000]              
	unsigned char                                      SkelMirrorAxis;                                   		// 0x0158 (0x0001) [0x0000000000000000]              
	unsigned char                                      SkelMirrorFlipAxis;                               		// 0x0159 (0x0001) [0x0000000000000000]              
	TArray< class USkeletalMeshSocket* >               Sockets;                                          		// 0x015C (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           BoneBreakNames;                                   		// 0x016C (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            BoneBreakOptions;                                 		// 0x017C (0x0010) [0x0000000000000000]              
	TArray< struct FSkeletalMeshLODInfo >              LODInfo;                                          		// 0x018C (0x0010) [0x0000000000000000]              
	TArray< struct FSkeletalMeshOptimizationSettings > OptimizationSettings;                             		// 0x019C (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             PerPolyCollisionBones;                            		// 0x01AC (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             AddToParentPerPolyCollisionBone;                  		// 0x01BC (0x0010) [0x0000000000000000]              
	TArray< int >                                      PerPolyBoneKDOPs;                                 		// 0x01CC (0x0010) [0x0000000000000000]              
	DWORD                                              bPerPolyUseSoftWeighting : 1;                     		// 0x01DC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseSimpleLineCollision : 1;                      		// 0x01DC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUseSimpleBoxCollision : 1;                       		// 0x01DC (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bForceCPUSkinning : 1;                            		// 0x01DC (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bUseFullPrecisionUVs : 1;                         		// 0x01DC (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bHasBeenSimplified : 1;                           		// 0x01DC (0x0004) [0x0000000000000000] [0x00000020] 
	class UFaceFXAsset*                                FaceFXAsset;                                      		// 0x01E0 (0x0008) [0x0000000000000000]              
	class UPhysicsAsset*                               BoundsPreviewAsset;                               		// 0x01E8 (0x0008) [0x0000000000000000]              
	TArray< class UMorphTargetSet* >                   PreviewMorphSets;                                 		// 0x01F0 (0x0010) [0x0000000000000000]              
	int                                                LODBiasPC;                                        		// 0x0200 (0x0004) [0x0000000000000000]              
	int                                                LODBiasPS3;                                       		// 0x0204 (0x0004) [0x0000000000000000]              
	int                                                LODBiasXbox360;                                   		// 0x0208 (0x0004) [0x0000000000000000]              
	int                                                LODBiasOrbis;                                     		// 0x020C (0x0004) [0x0000000000000000]              
	struct FString                                     SourceFilePath;                                   		// 0x0210 (0x0010) [0x0000000000000000]              
	struct FString                                     SourceFileTimestamp;                              		// 0x0220 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          ClothMesh;                                        		// 0x0230 (0x0010) [0x0000000000000000]              
	TArray< float >                                    ClothMeshScale;                                   		// 0x0240 (0x0010) [0x0000000000000000]              
	TArray< int >                                      ClothToGraphicsVertMap;                           		// 0x0250 (0x0010) [0x0000000000000000]              
	TArray< float >                                    ClothMovementScale;                               		// 0x0260 (0x0010) [0x0000000000000000]              
	unsigned char                                      ClothMovementScaleGenMode;                        		// 0x0270 (0x0001) [0x0000000000000000]              
	float                                              ClothToAnimMeshMaxDist;                           		// 0x0274 (0x0004) [0x0000000000000000]              
	DWORD                                              bLimitClothToAnimMesh : 1;                        		// 0x0278 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< int >                                      ClothWeldingMap;                                  		// 0x027C (0x0010) [0x0000000000000000]              
	int                                                ClothWeldingDomain;                               		// 0x028C (0x0004) [0x0000000000000000]              
	TArray< int >                                      ClothWeldedIndices;                               		// 0x0290 (0x0010) [0x0000000000000000]              
	DWORD                                              bForceNoWelding : 1;                              		// 0x02A0 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                NumFreeClothVerts;                                		// 0x02A4 (0x0004) [0x0000000000000000]              
	TArray< int >                                      ClothIndexBuffer;                                 		// 0x02A8 (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             ClothBones;                                       		// 0x02B8 (0x0010) [0x0000000000000000]              
	int                                                ClothHierarchyLevels;                             		// 0x02C8 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnableClothBendConstraints : 1;                  		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnableClothDamping : 1;                          		// 0x02CC (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUseClothCOMDamping : 1;                          		// 0x02CC (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              ClothStretchStiffness;                            		// 0x02D0 (0x0004) [0x0000000000000000]              
	float                                              ClothBendStiffness;                               		// 0x02D4 (0x0004) [0x0000000000000000]              
	float                                              ClothDensity;                                     		// 0x02D8 (0x0004) [0x0000000000000000]              
	float                                              ClothThickness;                                   		// 0x02DC (0x0004) [0x0000000000000000]              
	float                                              ClothDamping;                                     		// 0x02E0 (0x0004) [0x0000000000000000]              
	int                                                ClothIterations;                                  		// 0x02E4 (0x0004) [0x0000000000000000]              
	int                                                ClothHierarchicalIterations;                      		// 0x02E8 (0x0004) [0x0000000000000000]              
	float                                              ClothFriction;                                    		// 0x02EC (0x0004) [0x0000000000000000]              
	float                                              ClothRelativeGridSpacing;                         		// 0x02F0 (0x0004) [0x0000000000000000]              
	float                                              ClothPressure;                                    		// 0x02F4 (0x0004) [0x0000000000000000]              
	float                                              ClothCollisionResponseCoefficient;                		// 0x02F8 (0x0004) [0x0000000000000000]              
	float                                              ClothAttachmentResponseCoefficient;               		// 0x02FC (0x0004) [0x0000000000000000]              
	float                                              ClothAttachmentTearFactor;                        		// 0x0300 (0x0004) [0x0000000000000000]              
	float                                              ClothSleepLinearVelocity;                         		// 0x0304 (0x0004) [0x0000000000000000]              
	float                                              HardStretchLimitFactor;                           		// 0x0308 (0x0004) [0x0000000000000000]              
	DWORD                                              bHardStretchLimit : 1;                            		// 0x030C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnableClothOrthoBendConstraints : 1;             		// 0x030C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bEnableClothSelfCollision : 1;                    		// 0x030C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bEnableClothPressure : 1;                         		// 0x030C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bEnableClothTwoWayCollision : 1;                  		// 0x030C (0x0004) [0x0000000000000000] [0x00000010] 
	TArray< struct FClothSpecialBoneInfo >             ClothSpecialBones;                                		// 0x0310 (0x0010) [0x0000000000000000]              
	DWORD                                              bEnableClothLineChecks : 1;                       		// 0x0320 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bClothMetal : 1;                                  		// 0x0320 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              ClothMetalImpulseThreshold;                       		// 0x0324 (0x0004) [0x0000000000000000]              
	float                                              ClothMetalPenetrationDepth;                       		// 0x0328 (0x0004) [0x0000000000000000]              
	float                                              ClothMetalMaxDeformationDistance;                 		// 0x032C (0x0004) [0x0000000000000000]              
	DWORD                                              bEnableClothTearing : 1;                          		// 0x0330 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              ClothTearFactor;                                  		// 0x0334 (0x0004) [0x0000000000000000]              
	int                                                ClothTearReserve;                                 		// 0x0338 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnableValidBounds : 1;                           		// 0x033C (0x0004) [0x0000000000000000] [0x00000001] 
	struct FVector                                     ValidBoundsMin;                                   		// 0x0340 (0x000C) [0x0000000000000000]              
	struct FVector                                     ValidBoundsMax;                                   		// 0x034C (0x000C) [0x0000000000000000]              
	TArray< struct FSphere >                           ClothCollisionSpheres;                            		// 0x0358 (0x0010) [0x0000000000000000]              
	TArray< int >                                      ClothCollisionCapsuleIndices;                     		// 0x0368 (0x0010) [0x0000000000000000]              
	struct FMap_Mirror                                 ClothTornTriMap;                                  		// 0x0378 (0x0048) [0x0000000000000000]              
	TArray< int >                                      SoftBodySurfaceToGraphicsVertMap;                 		// 0x03C0 (0x0010) [0x0000000000000000]              
	TArray< int >                                      SoftBodySurfaceIndices;                           		// 0x03D0 (0x0010) [0x0000000000000000]              
	TArray< struct FVector >                           SoftBodyTetraVertsUnscaled;                       		// 0x03E0 (0x0010) [0x0000000000000000]              
	TArray< int >                                      SoftBodyTetraIndices;                             		// 0x03F0 (0x0010) [0x0000000000000000]              
	TArray< struct FSoftBodyTetraLink >                SoftBodyTetraLinks;                               		// 0x0400 (0x0010) [0x0000000000000000]              
	TArray< struct FPointer >                          CachedSoftBodyMeshes;                             		// 0x0410 (0x0010) [0x0000000000000000]              
	TArray< float >                                    CachedSoftBodyMeshScales;                         		// 0x0420 (0x0010) [0x0000000000000000]              
	TArray< struct FName >                             SoftBodyBones;                                    		// 0x0430 (0x0010) [0x0000000000000000]              
	TArray< struct FSoftBodySpecialBoneInfo >          SoftBodySpecialBones;                             		// 0x0440 (0x0010) [0x0000000000000000]              
	float                                              SoftBodyVolumeStiffness;                          		// 0x0450 (0x0004) [0x0000000000000000]              
	float                                              SoftBodyStretchingStiffness;                      		// 0x0454 (0x0004) [0x0000000000000000]              
	float                                              SoftBodyDensity;                                  		// 0x0458 (0x0004) [0x0000000000000000]              
	float                                              SoftBodyParticleRadius;                           		// 0x045C (0x0004) [0x0000000000000000]              
	float                                              SoftBodyDamping;                                  		// 0x0460 (0x0004) [0x0000000000000000]              
	int                                                SoftBodySolverIterations;                         		// 0x0464 (0x0004) [0x0000000000000000]              
	float                                              SoftBodyFriction;                                 		// 0x0468 (0x0004) [0x0000000000000000]              
	float                                              SoftBodyRelativeGridSpacing;                      		// 0x046C (0x0004) [0x0000000000000000]              
	float                                              SoftBodySleepLinearVelocity;                      		// 0x0470 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnableSoftBodySelfCollision : 1;                 		// 0x0474 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              SoftBodyAttachmentResponse;                       		// 0x0478 (0x0004) [0x0000000000000000]              
	float                                              SoftBodyCollisionResponse;                        		// 0x047C (0x0004) [0x0000000000000000]              
	float                                              SoftBodyDetailLevel;                              		// 0x0480 (0x0004) [0x0000000000000000]              
	int                                                SoftBodySubdivisionLevel;                         		// 0x0484 (0x0004) [0x0000000000000000]              
	DWORD                                              bSoftBodyIsoSurface : 1;                          		// 0x0488 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnableSoftBodyDamping : 1;                       		// 0x0488 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUseSoftBodyCOMDamping : 1;                       		// 0x0488 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              SoftBodyAttachmentThreshold;                      		// 0x048C (0x0004) [0x0000000000000000]              
	DWORD                                              bEnableSoftBodyTwoWayCollision : 1;               		// 0x0490 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              SoftBodyAttachmentTearFactor;                     		// 0x0494 (0x0004) [0x0000000000000000]              
	DWORD                                              bEnableSoftBodyLineChecks : 1;                    		// 0x0498 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bHasVertexColors : 1;                             		// 0x0498 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< DWORD >                                    GraphicsIndexIsCloth;                             		// 0x049C (0x0010) [0x0000000000000000]              
	TArray< float >                                    CachedStreamingTextureFactors;                    		// 0x04AC (0x0010) [0x0000000000000000]              
	float                                              StreamingDistanceMultiplier;                      		// 0x04BC (0x0004) [0x0000000000000000]              
	int                                                ReleaseResourcesFence;                            		// 0x04C0 (0x0004) [0x0000000000000000]              
	struct FQWord                                      SkelMeshRUID;                                     		// 0x04C4 (0x0008) [0x0000000000000000]              
	DWORD                                              bUseClothingAssetMaterial : 1;                    		// 0x04CC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkeletalMesh" );

		return pClassPointer;
	};

};

UClass* USkeletalMesh::pClassPointer = NULL;

// Class Engine.SkeletalMeshSocket
// 0x0054 (0x00B4 - 0x0060)
class USkeletalMeshSocket : public UObject
{
public:
	struct FName                                       SocketName;                                       		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FName                                       BoneName;                                         		// 0x0068 (0x0008) [0x0000000000000000]              
	struct FVector                                     RelativeLocation;                                 		// 0x0070 (0x000C) [0x0000000000000000]              
	struct FRotator                                    RelativeRotation;                                 		// 0x007C (0x000C) [0x0000000000000000]              
	struct FVector                                     RelativeScale;                                    		// 0x0088 (0x000C) [0x0000000000000000]              
	class USkeletalMesh*                               PreviewSkelMesh;                                  		// 0x0094 (0x0008) [0x0000000000000000]              
	class USkeletalMeshComponent*                      PreviewSkelComp;                                  		// 0x009C (0x0008) [0x0000000000000000]              
	class UStaticMesh*                                 PreviewStaticMesh;                                		// 0x00A4 (0x0008) [0x0000000000000000]              
	class UParticleSystem*                             PreviewParticleSystem;                            		// 0x00AC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkeletalMeshSocket" );

		return pClassPointer;
	};

};

UClass* USkeletalMeshSocket::pClassPointer = NULL;

// Class Engine.SplineActor
// 0x0068 (0x02AC - 0x0244)
class ASplineActor : public AActor
{
public:
	TArray< struct FSplineConnection >                 Connections;                                      		// 0x0244 (0x0010) [0x0000000000000000]              
	struct FVector                                     SplineActorTangent;                               		// 0x0254 (0x000C) [0x0000000000000000]              
	struct FColor                                      SplineColor;                                      		// 0x0260 (0x0004) [0x0000000000000000]              
	DWORD                                              bDisableDestination : 1;                          		// 0x0264 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAlreadyVisited : 1;                              		// 0x0264 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< class ASplineActor* >                      LinksFrom;                                        		// 0x0268 (0x0010) [0x0000000000000000]              
	class ASplineActor*                                nextOrdered;                                      		// 0x0278 (0x0008) [0x0000000000000000]              
	class ASplineActor*                                prevOrdered;                                      		// 0x0280 (0x0008) [0x0000000000000000]              
	class ASplineActor*                                previousPath;                                     		// 0x0288 (0x0008) [0x0000000000000000]              
	int                                                bestPathWeight;                                   		// 0x0290 (0x0004) [0x0000000000000000]              
	int                                                visitedWeight;                                    		// 0x0294 (0x0004) [0x0000000000000000]              
	struct FInterpCurveFloat                           SplineVelocityOverTime;                           		// 0x0298 (0x0014) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SplineActor" );

		return pClassPointer;
	};

	void OnToggleHidden ( );
	void OnToggle ( );
	void GetAllConnectedSplineActors ( );
	void FindSplinePathTo ( );
	void GetBestConnectionInDirection ( );
	void GetRandomConnection ( );
	void BreakAllConnectionsFrom ( );
	void BreakAllConnections ( );
	void BreakConnectionTo ( );
	void FindTargetForComponent ( );
	void FindSplineComponentTo ( );
	void IsConnectedTo ( );
	void AddConnectionTo ( );
	void UpdateConnectedSplineComponents ( );
	void UpdateSplineComponents ( );
	void GetWorldSpaceTangent ( );
};

UClass* ASplineActor::pClassPointer = NULL;

// Class Engine.SplineLoftActor
// 0x0058 (0x0304 - 0x02AC)
class ASplineLoftActor : public ASplineActor
{
public:
	float                                              ScaleX;                                           		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              ScaleY;                                           		// 0x02B0 (0x0004) [0x0000000000000000]              
	TArray< class USplineMeshComponent* >              SplineMeshComps;                                  		// 0x02B4 (0x0010) [0x0000000000000000]              
	class UStaticMesh*                                 DeformMesh;                                       		// 0x02C4 (0x0008) [0x0000000000000000]              
	TArray< class UMaterialInterface* >                DeformMeshMaterials;                              		// 0x02CC (0x0010) [0x0000000000000000]              
	float                                              Roll;                                             		// 0x02DC (0x0004) [0x0000000000000000]              
	struct FVector                                     WorldXDir;                                        		// 0x02E0 (0x000C) [0x0000000000000000]              
	struct FVector2D                                   Offset;                                           		// 0x02EC (0x0008) [0x0000000000000000]              
	DWORD                                              bSmoothInterpRollAndScale : 1;                    		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAcceptsLights : 1;                               		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000002] 
	class UDynamicLightEnvironmentComponent*           MeshLightEnvironment;                             		// 0x02F8 (0x0008) [0x0000000000000000]              
	float                                              MeshMaxDrawDistance;                              		// 0x0300 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SplineLoftActor" );

		return pClassPointer;
	};

	void UpdateSplineParams ( );
	void ClearLoftMesh ( );
};

UClass* ASplineLoftActor::pClassPointer = NULL;

// Class Engine.SplineLoftActorMovable
// 0x0000 (0x0304 - 0x0304)
class ASplineLoftActorMovable : public ASplineLoftActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SplineLoftActorMovable" );

		return pClassPointer;
	};

};

UClass* ASplineLoftActorMovable::pClassPointer = NULL;

// Class Engine.SplineComponent
// 0x003C (0x0274 - 0x0238)
class USplineComponent : public UPrimitiveComponent
{
public:
	struct FInterpCurveVector                          SplineInfo;                                       		// 0x0238 (0x0014) [0x0000000000000000]              
	float                                              SplineCurviness;                                  		// 0x024C (0x0004) [0x0000000000000000]              
	struct FColor                                      SplineColor;                                      		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              SplineDrawRes;                                    		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              SplineArrowSize;                                  		// 0x0258 (0x0004) [0x0000000000000000]              
	DWORD                                              bSplineDisabled : 1;                              		// 0x025C (0x0004) [0x0000000000000000] [0x00000001] 
	struct FInterpCurveFloat                           SplineReparamTable;                               		// 0x0260 (0x0014) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SplineComponent" );

		return pClassPointer;
	};

	void GetTangentAtDistanceAlongSpline ( );
	void GetLocationAtDistanceAlongSpline ( );
	void GetSplineLength ( );
	void UpdateSplineReparamTable ( );
	void UpdateSplineCurviness ( );
};

UClass* USplineComponent::pClassPointer = NULL;

// Class Engine.ProcBuilding
// 0x0118 (0x0398 - 0x0280)
class AProcBuilding : public AVolume
{
public:
	class UProcBuildingRuleset*                        Ruleset;                                          		// 0x0280 (0x0008) [0x0000000000000000]              
	TArray< struct FPBMeshCompInfo >                   BuildingMeshCompInfos;                            		// 0x0288 (0x0010) [0x0000000000000000]              
	TArray< struct FPBFracMeshCompInfo >               BuildingFracMeshCompInfos;                        		// 0x0298 (0x0010) [0x0000000000000000]              
	class UStaticMeshComponent*                        SimpleMeshComp;                                   		// 0x02A8 (0x0008) [0x0000000000000000]              
	DWORD                                              bGenerateRoofMesh : 1;                            		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bGenerateFloorMesh : 1;                           		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bApplyRulesToRoof : 1;                            		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bApplyRulesToFloor : 1;                           		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bSplitWallsAtRoofLevels : 1;                      		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bSplitWallsAtWallEdges : 1;                       		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bQuickEdited : 1;                                 		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bBuildingBrushCollision : 1;                      		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bDebugDrawEdgeInfo : 1;                           		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bDebugDrawScopes : 1;                             		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000200] 
	TArray< class UStaticMeshComponent* >              LODMeshComps;                                     		// 0x02B4 (0x0010) [0x0000000000000000]              
	TArray< struct FPBFaceUVInfo >                     LODMeshUVInfos;                                   		// 0x02C4 (0x0010) [0x0000000000000000]              
	TArray< struct FPBScope2D >                        TopLevelScopes;                                   		// 0x02D4 (0x0010) [0x0000000000000000]              
	int                                                NumMeshedTopLevelScopes;                          		// 0x02E4 (0x0004) [0x0000000000000000]              
	TArray< struct FPBFaceUVInfo >                     TopLevelScopeUVInfos;                             		// 0x02E8 (0x0010) [0x0000000000000000]              
	TArray< struct FPBScopeProcessInfo >               TopLevelScopeInfos;                               		// 0x02F8 (0x0010) [0x0000000000000000]              
	TArray< struct FPBEdgeInfo >                       EdgeInfos;                                        		// 0x0308 (0x0010) [0x0000000000000000]              
	float                                              MaxFacadeZ;                                       		// 0x0318 (0x0004) [0x0000000000000000]              
	float                                              MinFacadeZ;                                       		// 0x031C (0x0004) [0x0000000000000000]              
	TArray< class AProcBuilding* >                     OverlappingBuildings;                             		// 0x0320 (0x0010) [0x0000000000000000]              
	float                                              SimpleMeshMassiveLODDistance;                     		// 0x0330 (0x0004) [0x0000000000000000]              
	float                                              RenderToTexturePullBackAmount;                    		// 0x0334 (0x0004) [0x0000000000000000]              
	int                                                RoofLightmapRes;                                  		// 0x0338 (0x0004) [0x0000000000000000]              
	int                                                NonRectWallLightmapRes;                           		// 0x033C (0x0004) [0x0000000000000000]              
	float                                              LODRenderToTextureScale;                          		// 0x0340 (0x0004) [0x0000000000000000]              
	struct FName                                       ParamSwatchName;                                  		// 0x0344 (0x0008) [0x0000000000000000]              
	TArray< struct FPBMaterialParam >                  BuildingMaterialParams;                           		// 0x034C (0x0010) [0x0000000000000000]              
	TArray< class UMaterialInstanceConstant* >         BuildingMatParamMICs;                             		// 0x035C (0x0010) [0x0000000000000000]              
	class AStaticMeshActor*                            LowLODPersistentActor;                            		// 0x036C (0x0008) [0x0000000000000000]              
	class UStaticMeshComponent*                        CurrentSimpleMeshComp;                            		// 0x0374 (0x0008) [0x0000000000000000]              
	class AActor*                                      CurrentSimpleMeshActor;                           		// 0x037C (0x0008) [0x0000000000000000]              
	TArray< class AProcBuilding* >                     AttachedBuildings;                                		// 0x0384 (0x0010) [0x0000000000000000]              
	int                                                BuildingInstanceVersion;                          		// 0x0394 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ProcBuilding" );

		return pClassPointer;
	};

	void FindEdgeForTopLevelScope ( );
	void BreakFractureComponent ( );
	void GetAllGroupedProcBuildings ( );
	void GetBaseMostBuilding ( );
	void FindComponentsForTopLevelScope ( );
	void ClearBuildingMeshes ( );
};

UClass* AProcBuilding::pClassPointer = NULL;

// Class Engine.ProcBuilding_SimpleLODActor
// 0x0000 (0x02B0 - 0x02B0)
class AProcBuilding_SimpleLODActor : public AStaticMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ProcBuilding_SimpleLODActor" );

		return pClassPointer;
	};

};

UClass* AProcBuilding_SimpleLODActor::pClassPointer = NULL;

// Class Engine.PBRuleNodeBase
// 0x0034 (0x0094 - 0x0060)
class UPBRuleNodeBase : public UObject
{
public:
	TArray< struct FPBRuleLink >                       NextRules;                                        		// 0x0060 (0x0010) [0x0000000000000000]              
	struct FString                                     Comment;                                          		// 0x0070 (0x0010) [0x0000000000000000]              
	int                                                RulePosX;                                         		// 0x0080 (0x0004) [0x0000000000000000]              
	int                                                RulePosY;                                         		// 0x0084 (0x0004) [0x0000000000000000]              
	int                                                InDrawY;                                          		// 0x0088 (0x0004) [0x0000000000000000]              
	int                                                DrawWidth;                                        		// 0x008C (0x0004) [0x0000000000000000]              
	int                                                DrawHeight;                                       		// 0x0090 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeBase" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeBase::pClassPointer = NULL;

// Class Engine.PBRuleNodeAlternate
// 0x0010 (0x00A4 - 0x0094)
class UPBRuleNodeAlternate : public UPBRuleNodeBase
{
public:
	unsigned char                                      RepeatAxis;                                       		// 0x0094 (0x0001) [0x0000000000000000]              
	float                                              ASize;                                            		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              BMaxSize;                                         		// 0x009C (0x0004) [0x0000000000000000]              
	DWORD                                              bInvertPatternOrder : 1;                          		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEqualSizeAB : 1;                                 		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeAlternate" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeAlternate::pClassPointer = NULL;

// Class Engine.PBRuleNodeComment
// 0x0018 (0x00AC - 0x0094)
class UPBRuleNodeComment : public UPBRuleNodeBase
{
public:
	int                                                SizeX;                                            		// 0x0094 (0x0004) [0x0000000000000000]              
	int                                                SizeY;                                            		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                BorderWidth;                                      		// 0x009C (0x0004) [0x0000000000000000]              
	struct FColor                                      BorderColor;                                      		// 0x00A0 (0x0004) [0x0000000000000000]              
	DWORD                                              bFilled : 1;                                      		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FColor                                      FillColor;                                        		// 0x00A8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeComment" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeComment::pClassPointer = NULL;

// Class Engine.PBRuleNodeCorner
// 0x002C (0x00C0 - 0x0094)
class UPBRuleNodeCorner : public UPBRuleNodeBase
{
public:
	float                                              CornerSize;                                       		// 0x0094 (0x0004) [0x0000000000000000]              
	TArray< struct FRBCornerAngleInfo >                Angles;                                           		// 0x0098 (0x0010) [0x0000000000000000]              
	float                                              FlatThreshold;                                    		// 0x00A8 (0x0004) [0x0000000000000000]              
	DWORD                                              bNoMeshForConcaveCorners : 1;                     		// 0x00AC (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bUseAdjacentRulesetForRightGap : 1;               		// 0x00AC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned char                                      CornerType;                                       		// 0x00B0 (0x0001) [0x0000000000000000]              
	float                                              CornerShapeOffset;                                		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                RoundTesselation;                                 		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              RoundCurvature;                                   		// 0x00BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeCorner" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeCorner::pClassPointer = NULL;

// Class Engine.PBRuleNodeCycle
// 0x0010 (0x00A4 - 0x0094)
class UPBRuleNodeCycle : public UPBRuleNodeBase
{
public:
	unsigned char                                      RepeatAxis;                                       		// 0x0094 (0x0001) [0x0000000000000000]              
	float                                              RepeatSize;                                       		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                CycleSize;                                        		// 0x009C (0x0004) [0x0000000000000000]              
	DWORD                                              bFixRepeatSize : 1;                               		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeCycle" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeCycle::pClassPointer = NULL;

// Class Engine.PBRuleNodeEdgeAngle
// 0x0014 (0x00A8 - 0x0094)
class UPBRuleNodeEdgeAngle : public UPBRuleNodeBase
{
public:
	unsigned char                                      Edge;                                             		// 0x0094 (0x0001) [0x0000000000000000]              
	TArray< struct FRBEdgeAngleInfo >                  Angles;                                           		// 0x0098 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeEdgeAngle" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeEdgeAngle::pClassPointer = NULL;

// Class Engine.PBRuleNodeEdgeMesh
// 0x0008 (0x009C - 0x0094)
class UPBRuleNodeEdgeMesh : public UPBRuleNodeBase
{
public:
	float                                              FlatThreshold;                                    		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              MainXPullIn;                                      		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeEdgeMesh" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeEdgeMesh::pClassPointer = NULL;

// Class Engine.PBRuleNodeExtractTopBottom
// 0x0010 (0x00A4 - 0x0094)
class UPBRuleNodeExtractTopBottom : public UPBRuleNodeBase
{
public:
	float                                              ExtractTopZ;                                      		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              ExtractNotTopZ;                                   		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              ExtractBottomZ;                                   		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              ExtractNotBottomZ;                                		// 0x00A0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeExtractTopBottom" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeExtractTopBottom::pClassPointer = NULL;

// Class Engine.PBRuleNodeLODQuad
// 0x0004 (0x0098 - 0x0094)
class UPBRuleNodeLODQuad : public UPBRuleNodeBase
{
public:
	float                                              MassiveLODDistanceScale;                          		// 0x0094 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeLODQuad" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeLODQuad::pClassPointer = NULL;

// Class Engine.PBRuleNodeMesh
// 0x0060 (0x00F4 - 0x0094)
class UPBRuleNodeMesh : public UPBRuleNodeBase
{
public:
	TArray< struct FBuildingMeshInfo >                 BuildingMeshes;                                   		// 0x0094 (0x0010) [0x0000000000000000]              
	struct FBuildingMeshInfo                           PartialOccludedBuildingMesh;                      		// 0x00A4 (0x004C) [0x0000000000000000]              
	DWORD                                              bDoOcclusionTest : 1;                             		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bBlockAll : 1;                                    		// 0x00F0 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeMesh" );

		return pClassPointer;
	};

	void PickRandomBuildingMesh ( );
};

UClass* UPBRuleNodeMesh::pClassPointer = NULL;

// Class Engine.PBRuleNodeOcclusion
// 0x0000 (0x0094 - 0x0094)
class UPBRuleNodeOcclusion : public UPBRuleNodeBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeOcclusion" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeOcclusion::pClassPointer = NULL;

// Class Engine.PBRuleNodeQuad
// 0x001C (0x00B0 - 0x0094)
class UPBRuleNodeQuad : public UPBRuleNodeBase
{
public:
	class UMaterialInterface*                          Material;                                         		// 0x0094 (0x0008) [0x0000000000000000]              
	float                                              RepeatMaxSizeX;                                   		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              RepeatMaxSizeZ;                                   		// 0x00A0 (0x0004) [0x0000000000000000]              
	int                                                QuadLightmapRes;                                  		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              YOffset;                                          		// 0x00A8 (0x0004) [0x0000000000000000]              
	DWORD                                              bDisableMaterialRepeat : 1;                       		// 0x00AC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeQuad" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeQuad::pClassPointer = NULL;

// Class Engine.PBRuleNodeRandom
// 0x000C (0x00A0 - 0x0094)
class UPBRuleNodeRandom : public UPBRuleNodeBase
{
public:
	int                                                NumOutputs;                                       		// 0x0094 (0x0004) [0x0000000000000000]              
	int                                                MinNumExecuted;                                   		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                MaxNumExecuted;                                   		// 0x009C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeRandom" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeRandom::pClassPointer = NULL;

// Class Engine.PBRuleNodeRepeat
// 0x0008 (0x009C - 0x0094)
class UPBRuleNodeRepeat : public UPBRuleNodeBase
{
public:
	unsigned char                                      RepeatAxis;                                       		// 0x0094 (0x0001) [0x0000000000000000]              
	float                                              RepeatMaxSize;                                    		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeRepeat" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeRepeat::pClassPointer = NULL;

// Class Engine.PBRuleNodeSize
// 0x000C (0x00A0 - 0x0094)
class UPBRuleNodeSize : public UPBRuleNodeBase
{
public:
	unsigned char                                      SizeAxis;                                         		// 0x0094 (0x0001) [0x0000000000000000]              
	float                                              DecisionSize;                                     		// 0x0098 (0x0004) [0x0000000000000000]              
	DWORD                                              bUseTopLevelScopeSize : 1;                        		// 0x009C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeSize" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeSize::pClassPointer = NULL;

// Class Engine.PBRuleNodeSplit
// 0x0014 (0x00A8 - 0x0094)
class UPBRuleNodeSplit : public UPBRuleNodeBase
{
public:
	unsigned char                                      SplitAxis;                                        		// 0x0094 (0x0001) [0x0000000000000000]              
	TArray< struct FRBSplitInfo >                      SplitSetup;                                       		// 0x0098 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeSplit" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeSplit::pClassPointer = NULL;

// Class Engine.PBRuleNodeSubRuleset
// 0x0008 (0x009C - 0x0094)
class UPBRuleNodeSubRuleset : public UPBRuleNodeBase
{
public:
	class UProcBuildingRuleset*                        SubRuleset;                                       		// 0x0094 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeSubRuleset" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeSubRuleset::pClassPointer = NULL;

// Class Engine.PBRuleNodeTransform
// 0x0018 (0x00AC - 0x0094)
class UPBRuleNodeTransform : public UPBRuleNodeBase
{
public:
	class UDistributionVector*                         Translation;                                      		// 0x0094 (0x0008) [0x0000000000000000]              
	class UDistributionVector*                         Rotation;                                         		// 0x009C (0x0008) [0x0000000000000000]              
	class UDistributionVector*                         Scale;                                            		// 0x00A4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeTransform" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeTransform::pClassPointer = NULL;

// Class Engine.PBRuleNodeVariation
// 0x0004 (0x0098 - 0x0094)
class UPBRuleNodeVariation : public UPBRuleNodeBase
{
public:
	DWORD                                              bVariationOfScopeOnLeft : 1;                      		// 0x0094 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeVariation" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeVariation::pClassPointer = NULL;

// Class Engine.PBRuleNodeWindowWall
// 0x0028 (0x00BC - 0x0094)
class UPBRuleNodeWindowWall : public UPBRuleNodeBase
{
public:
	float                                              CellMaxSizeX;                                     		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              CellMaxSizeZ;                                     		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              WindowSizeX;                                      		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              WindowSizeZ;                                      		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              WindowPosX;                                       		// 0x00A4 (0x0004) [0x0000000000000000]              
	float                                              WindowPosZ;                                       		// 0x00A8 (0x0004) [0x0000000000000000]              
	DWORD                                              bScaleWindowWithCell : 1;                         		// 0x00AC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              YOffset;                                          		// 0x00B0 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          Material;                                         		// 0x00B4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PBRuleNodeWindowWall" );

		return pClassPointer;
	};

};

UClass* UPBRuleNodeWindowWall::pClassPointer = NULL;

// Class Engine.ProcBuildingRuleset
// 0x0084 (0x00E4 - 0x0060)
class UProcBuildingRuleset : public UObject
{
public:
	class UPBRuleNodeBase*                             RootRule;                                         		// 0x0060 (0x0008) [0x0000000000000000]              
	DWORD                                              bBeingEdited : 1;                                 		// 0x0068 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnableInteriorTexture : 1;                       		// 0x0068 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bLODOnlyRoof : 1;                                 		// 0x0068 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bPickRandomSwatch : 1;                            		// 0x0068 (0x0004) [0x0000000000000000] [0x00000008] 
	class UMaterialInterface*                          DefaultRoofMaterial;                              		// 0x006C (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          DefaultFloorMaterial;                             		// 0x0074 (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          DefaultNonRectWallMaterial;                       		// 0x007C (0x0008) [0x0000000000000000]              
	float                                              RoofZOffset;                                      		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              NotRoofZOffset;                                   		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              FloorZOffset;                                     		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              NotFloorZOffset;                                  		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              RoofPolyInset;                                    		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              FloorPolyInset;                                   		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              BuildingLODSpecular;                              		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              RoofEdgeScopeRaise;                               		// 0x00A0 (0x0004) [0x0000000000000000]              
	class UTexture*                                    LODCubemap;                                       		// 0x00A4 (0x0008) [0x0000000000000000]              
	class UTexture*                                    InteriorTexture;                                  		// 0x00AC (0x0008) [0x0000000000000000]              
	TArray< struct FPBVariationInfo >                  Variations;                                       		// 0x00B4 (0x0010) [0x0000000000000000]              
	TArray< struct FPBParamSwatch >                    ParamSwatches;                                    		// 0x00C4 (0x0010) [0x0000000000000000]              
	TArray< class UPBRuleNodeComment* >                Comments;                                         		// 0x00D4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ProcBuildingRuleset" );

		return pClassPointer;
	};

};

UClass* UProcBuildingRuleset::pClassPointer = NULL;

// Class Engine.ReplicationInfo
// 0x0000 (0x0244 - 0x0244)
class AReplicationInfo : public AInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ReplicationInfo" );

		return pClassPointer;
	};

};

UClass* AReplicationInfo::pClassPointer = NULL;

// Class Engine.GameReplicationInfo
// 0x0068 (0x02AC - 0x0244)
class AGameReplicationInfo : public AReplicationInfo
{
public:
	class UClass*                                      GameClass;                                        		// 0x0244 (0x0008) [0x0000000000150025]              ( CPF_Edit | CPF_Input | CPF_Net | CPF_Travel | CPF_GlobalConfig )
	DWORD                                              bStopCountDown : 1;                               		// 0x024C (0x0004) [0x0000000000160000] [0x00000001] ( CPF_EditConst | CPF_GlobalConfig )
	DWORD                                              bMatchHasBegun : 1;                               		// 0x024C (0x0004) [0x0000000000170000] [0x00000002] ( CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
	DWORD                                              bMatchIsOver : 1;                                 		// 0x024C (0x0004) [0x0000000000180000] [0x00000004] ( CPF_Component )
	DWORD                                              bRoundIsOver : 1;                                 		// 0x024C (0x0004) [0x0000000000190000] [0x00000008] ( CPF_Travel | CPF_Component )
	DWORD                                              bWaitingForAAR : 1;                               		// 0x024C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bPendingMusicTrackChange : 1;                     		// 0x024C (0x0004) [0x0000000000000000] [0x00000020] 
	int                                                RemainingTime;                                    		// 0x0250 (0x0004) [0x00000000001A0025]              ( CPF_Edit | CPF_Input | CPF_Net | CPF_EditConst | CPF_Component )
	int                                                ElapsedTime;                                      		// 0x0254 (0x0004) [0x00000000001B0025]              ( CPF_Edit | CPF_Input | CPF_Net | CPF_Travel | CPF_EditConst | CPF_Component )
	int                                                RemainingMinute;                                  		// 0x0258 (0x0004) [0x00000000001C000A]              ( CPF_Const | CPF_ExportObject | CPF_GlobalConfig | CPF_Component )
	int                                                GoalScore;                                        		// 0x025C (0x0004) [0x00000000001D0025]              ( CPF_Edit | CPF_Input | CPF_Net | CPF_Travel | CPF_GlobalConfig | CPF_Component )
	int                                                TimeLimit;                                        		// 0x0260 (0x0004) [0x00000000001E0025]              ( CPF_Edit | CPF_Input | CPF_Net | CPF_EditConst | CPF_GlobalConfig | CPF_Component )
	TArray< class ATeamInfo* >                         Teams;                                            		// 0x0264 (0x0010) [0x0000000000000000]              
	struct FString                                     ServerName;                                       		// 0x0274 (0x0010) [0x00000000001F0025]              ( CPF_Edit | CPF_Input | CPF_Net | CPF_Travel | CPF_EditConst | CPF_GlobalConfig | CPF_Component )
	class AActor*                                      Winner;                                           		// 0x0284 (0x0008) [0x0000000000200000]              
	TArray< class APlayerReplicationInfo* >            PRIArray;                                         		// 0x028C (0x0010) [0x0000000000000000]              
	TArray< class APlayerReplicationInfo* >            InactivePRIArray;                                 		// 0x029C (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GameReplicationInfo" );

		return pClassPointer;
	};

	void eventIsStatsSessionValid ( );
	void eventGetPRIByPlayfabId ( );
	void eventShouldShowGore ( );
	void IsCoopMultiplayerGame ( );
	void IsMultiplayerGame ( );
	void EndGame ( );
	void StartMatch ( );
	void SetTeam ( );
	void RemovePRI ( );
	void AddPRI ( );
	void OnSameTeam ( );
	void eventTimer ( );
	void Reset ( );
	void ReceivedGameClass ( );
	void eventReplicatedEvent ( );
	void eventPostBeginPlay ( );
};

UClass* AGameReplicationInfo::pClassPointer = NULL;

// Class Engine.PlayerReplicationInfo
// 0x00E0 (0x0324 - 0x0244)
class APlayerReplicationInfo : public AReplicationInfo
{
public:
	float                                              Score;                                            		// 0x0244 (0x0004) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )
	int                                                Deaths;                                           		// 0x0248 (0x0004) [0x0000000000160000]              ( CPF_EditConst | CPF_GlobalConfig )
	unsigned char                                      Ping;                                             		// 0x024C (0x0001) [0x000000000017000A]              ( CPF_Const | CPF_ExportObject | CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
	unsigned char                                      TTSSpeaker;                                       		// 0x024D (0x0001) [0x0000000000000000]              
	int                                                NumLives;                                         		// 0x0250 (0x0004) [0x0000000000000000]              
	struct FString                                     PlayerName;                                       		// 0x0254 (0x0010) [0x0000000000180000]              ( CPF_Component )
	struct FString                                     OldName;                                          		// 0x0264 (0x0010) [0x0000000000000000]              
	int                                                PlayerID;                                         		// 0x0274 (0x0004) [0x0000000000190025]              ( CPF_Edit | CPF_Input | CPF_Net | CPF_Travel | CPF_Component )
	class ATeamInfo*                                   Team;                                             		// 0x0278 (0x0008) [0x00000000001A0000]              ( CPF_EditConst | CPF_Component )
	DWORD                                              bAdmin : 1;                                       		// 0x0280 (0x0004) [0x00000000001B0000] [0x00000001] ( CPF_Travel | CPF_EditConst | CPF_Component )
	DWORD                                              bIsSpectator : 1;                                 		// 0x0280 (0x0004) [0x00000000001C0000] [0x00000002] ( CPF_GlobalConfig | CPF_Component )
	DWORD                                              bOnlySpectator : 1;                               		// 0x0280 (0x0004) [0x00000000001D0000] [0x00000004] ( CPF_Travel | CPF_GlobalConfig | CPF_Component )
	DWORD                                              bWaitingPlayer : 1;                               		// 0x0280 (0x0004) [0x00000000001E0000] [0x00000008] ( CPF_EditConst | CPF_GlobalConfig | CPF_Component )
	DWORD                                              bReadyToPlay : 1;                                 		// 0x0280 (0x0004) [0x00000000001F0000] [0x00000010] ( CPF_Travel | CPF_EditConst | CPF_GlobalConfig | CPF_Component )
	DWORD                                              bOutOfLives : 1;                                  		// 0x0280 (0x0004) [0x0000000000200000] [0x00000020] 
	DWORD                                              bBot : 1;                                         		// 0x0280 (0x0004) [0x0000000000210025] [0x00000040] ( CPF_Edit | CPF_Input | CPF_Net | CPF_Travel )
	DWORD                                              bHasBeenWelcomed : 1;                             		// 0x0280 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bIsInactive : 1;                                  		// 0x0280 (0x0004) [0x0000000000220025] [0x00000100] ( CPF_Edit | CPF_Input | CPF_Net | CPF_EditConst )
	DWORD                                              bFromPreviousLevel : 1;                           		// 0x0280 (0x0004) [0x0000000000230000] [0x00000200] ( CPF_Travel | CPF_EditConst )
	int                                                StartTime;                                        		// 0x0284 (0x0004) [0x0000000000240000]              ( CPF_GlobalConfig )
	struct FString                                     StringSpectating;                                 		// 0x0288 (0x0010) [0x0000000000000000]              
	struct FString                                     StringUnknown;                                    		// 0x0298 (0x0010) [0x0000000000000000]              
	int                                                Kills;                                            		// 0x02A8 (0x0004) [0x0000000000250000]              ( CPF_Travel | CPF_GlobalConfig )
	class UClass*                                      GameMessageClass;                                 		// 0x02AC (0x0008) [0x0000000000000000]              
	float                                              ExactPing;                                        		// 0x02B4 (0x0004) [0x0000000000000000]              
	struct FString                                     SavedNetworkAddress;                              		// 0x02B8 (0x0010) [0x0000000000000000]              
	struct FUniqueNetId                                UniqueId;                                         		// 0x02C8 (0x0008) [0x0000000000260000]              ( CPF_EditConst | CPF_GlobalConfig )
	struct FName                                       SessionName;                                      		// 0x02D0 (0x0008) [0x0000000000000000]              
	struct FAutomatedTestingDatum                      AutomatedTestingData;                             		// 0x02D8 (0x0008) [0x0000000000000000]              
	int                                                StatConnectionCounts;                             		// 0x02E0 (0x0004) [0x0000000000000000]              
	int                                                StatPingTotals;                                   		// 0x02E4 (0x0004) [0x0000000000000000]              
	int                                                StatPingMin;                                      		// 0x02E8 (0x0004) [0x0000000000000000]              
	int                                                StatPingMax;                                      		// 0x02EC (0x0004) [0x0000000000000000]              
	int                                                StatPKLTotal;                                     		// 0x02F0 (0x0004) [0x0000000000000000]              
	int                                                StatPKLMin;                                       		// 0x02F4 (0x0004) [0x0000000000000000]              
	int                                                StatPKLMax;                                       		// 0x02F8 (0x0004) [0x0000000000000000]              
	int                                                StatMaxInBPS;                                     		// 0x02FC (0x0004) [0x0000000000000000]              
	int                                                StatAvgInBPS;                                     		// 0x0300 (0x0004) [0x0000000000000000]              
	int                                                StatMaxOutBPS;                                    		// 0x0304 (0x0004) [0x0000000000000000]              
	int                                                StatAvgOutBPS;                                    		// 0x0308 (0x0004) [0x0000000000000000]              
	class UTexture2D*                                  Avatar;                                           		// 0x030C (0x0008) [0x0000000000000000]              
	struct FString                                     PlayfabPlayerId;                                  		// 0x0314 (0x0010) [0x0000000000270000]              ( CPF_Travel | CPF_EditConst | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PlayerReplicationInfo" );

		return pClassPointer;
	};

	void HasHadInitialSpawn ( );
	void IsPrimaryPlayer ( );
	void UnregisterPlayerFromSession ( );
	void RegisterPlayerWithSession ( );
	void IsInvalidName ( );
	void GetTeamNum ( );
	void SetUniqueId ( );
	void SeamlessTravelTo ( );
	void IncrementDeaths ( );
	void CopyProperties ( );
	void OverrideWith ( );
	void Duplicate ( );
	void SetWaitingPlayer ( );
	void eventSetPlayerName ( );
	void DisplayDebug ( );
	void GetHumanReadableName ( );
	void Reset ( );
	void eventDestroyed ( );
	void ShouldBroadCastWelcomeMessage ( );
	void UpdatePing ( );
	void eventReplicatedEvent ( );
	void SetPlayerTeam ( );
	void ClientInitialize ( );
	void eventPostBeginPlay ( );
};

UClass* APlayerReplicationInfo::pClassPointer = NULL;

// Class Engine.TeamInfo
// 0x0020 (0x0264 - 0x0244)
class ATeamInfo : public AReplicationInfo
{
public:
	struct FString                                     TeamName;                                         		// 0x0244 (0x0010) [0x0000000000150020]              ( CPF_Net | CPF_Travel | CPF_GlobalConfig )
	int                                                Size;                                             		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              Score;                                            		// 0x0258 (0x0004) [0x0000000000160000]              ( CPF_EditConst | CPF_GlobalConfig )
	int                                                TeamIndex;                                        		// 0x025C (0x0004) [0x0000000000170020]              ( CPF_Net | CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
	struct FColor                                      TeamColor;                                        		// 0x0260 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TeamInfo" );

		return pClassPointer;
	};

	void GetTeamNum ( );
	void GetHumanReadableName ( );
	void RemoveFromTeam ( );
	void AddToTeam ( );
	void eventDestroyed ( );
	void eventReplicatedEvent ( );
};

UClass* ATeamInfo::pClassPointer = NULL;

// Class Engine.Camera
// 0x0408 (0x064C - 0x0244)
class ACamera : public AActor
{
public:
	class APlayerController*                           PCOwner;                                          		// 0x0244 (0x0008) [0x0000000000000000]              
	struct FName                                       CameraStyle;                                      		// 0x024C (0x0008) [0x0000000000000000]              
	float                                              DefaultFOV;                                       		// 0x0254 (0x0004) [0x0000000000000000]              
	DWORD                                              bLockedFOV : 1;                                   		// 0x0258 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bConstrainAspectRatio : 1;                        		// 0x0258 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bEnableFading : 1;                                		// 0x0258 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bFadeAudio : 1;                                   		// 0x0258 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bForceDisableTemporalAA : 1;                      		// 0x0258 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bEnableColorScaling : 1;                          		// 0x0258 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bEnableColorScaleInterp : 1;                      		// 0x0258 (0x0004) [0x0000000000000000] [0x00000040] 
	DWORD                                              bUseClientSideCameraUpdates : 1;                  		// 0x0258 (0x0004) [0x0000000000000000] [0x00000080] 
	DWORD                                              bDebugClientSideCamera : 1;                       		// 0x0258 (0x0004) [0x0000000000000000] [0x00000100] 
	DWORD                                              bShouldSendClientSideCameraUpdate : 1;            		// 0x0258 (0x0004) [0x0000000000000000] [0x00000200] 
	float                                              LockedFOV;                                        		// 0x025C (0x0004) [0x0000000000000000]              
	float                                              UnmodifiedFOV;                                    		// 0x0260 (0x0004) [0x0000000000000000]              
	float                                              ConstrainedAspectRatio;                           		// 0x0264 (0x0004) [0x0000000000000000]              
	float                                              DefaultAspectRatio;                               		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              OffAxisYawAngle;                                  		// 0x026C (0x0004) [0x0000000000000000]              
	float                                              OffAxisPitchAngle;                                		// 0x0270 (0x0004) [0x0000000000000000]              
	struct FColor                                      FadeColor;                                        		// 0x0274 (0x0004) [0x0000000000000000]              
	float                                              FadeAmount;                                       		// 0x0278 (0x0004) [0x0000000000000000]              
	float                                              CamOverridePostProcessAlpha;                      		// 0x027C (0x0004) [0x0000000000000000]              
	struct FPostProcessSettings                        CamPostProcessSettings;                           		// 0x0280 (0x0220) [0x0000000000000000]              
	struct FRenderingPerformanceOverrides              RenderingOverrides;                               		// 0x04A0 (0x0004) [0x0000000000000000]              
	struct FVector                                     ColorScale;                                       		// 0x04A4 (0x000C) [0x0000000000000000]              
	struct FVector                                     DesiredColorScale;                                		// 0x04B0 (0x000C) [0x0000000000000000]              
	struct FVector                                     OriginalColorScale;                               		// 0x04BC (0x000C) [0x0000000000000000]              
	float                                              ColorScaleInterpDuration;                         		// 0x04C8 (0x0004) [0x0000000000000000]              
	float                                              ColorScaleInterpStartTime;                        		// 0x04CC (0x0004) [0x0000000000000000]              
	struct FTCameraCache                               CameraCache;                                      		// 0x04D0 (0x0020) [0x0000000000000000]              
	struct FTCameraCache                               LastFrameCameraCache;                             		// 0x04F0 (0x0020) [0x0000000000000000]              
	struct FTViewTarget                                ViewTarget;                                       		// 0x0510 (0x0038) [0x0000000000000000]              
	struct FTViewTarget                                PendingViewTarget;                                		// 0x0548 (0x0038) [0x0000000000000000]              
	float                                              BlendTimeToGo;                                    		// 0x0580 (0x0004) [0x0000000000000000]              
	struct FViewTargetTransitionParams                 BlendParams;                                      		// 0x0584 (0x0010) [0x0000000000000000]              
	TArray< class UCameraModifier* >                   ModifierList;                                     		// 0x0594 (0x0010) [0x0000000000000000]              
	float                                              FreeCamDistance;                                  		// 0x05A4 (0x0004) [0x0000000000000000]              
	struct FVector                                     FreeCamOffset;                                    		// 0x05A8 (0x000C) [0x0000000000000000]              
	struct FVector2D                                   FadeAlpha;                                        		// 0x05B4 (0x0008) [0x0000000000000000]              
	float                                              FadeTime;                                         		// 0x05BC (0x0004) [0x0000000000000000]              
	float                                              FadeTimeRemaining;                                		// 0x05C0 (0x0004) [0x0000000000000000]              
	TArray< class AEmitterCameraLensEffectBase* >      CameraLensEffects;                                		// 0x05C4 (0x0010) [0x0000000000000000]              
	class UCameraModifier_CameraShake*                 CameraShakeCamMod;                                		// 0x05D4 (0x0008) [0x0000000000000000]              
	class UClass*                                      CameraShakeCamModClass;                           		// 0x05DC (0x0008) [0x0000000000000000]              
	class UCameraAnimInst*                             AnimInstPool[ 0x8 ];                              		// 0x05E4 (0x0040) [0x0000000000000000]              
	TArray< class UCameraAnimInst* >                   ActiveAnims;                                      		// 0x0624 (0x0010) [0x0000000000000000]              
	TArray< class UCameraAnimInst* >                   FreeAnims;                                        		// 0x0634 (0x0010) [0x0000000000000000]              
	class ADynamicCameraActor*                         AnimCameraActor;                                  		// 0x0644 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Camera" );

		return pClassPointer;
	};

	void StopCameraAnim ( );
	void StopAllCameraAnimsByType ( );
	void StopAllCameraAnims ( );
	void PlayCameraAnim ( );
	void ClearAllCameraShakes ( );
	void PlayWorldCameraShake ( );
	void CalcRadialShakeScale ( );
	void StopCameraShake ( );
	void PlayCameraShake ( );
	void ClearCameraLensEffects ( );
	void RemoveCameraLensEffect ( );
	void AddCameraLensEffect ( );
	void FindCameraLensEffect ( );
	void DisplayDebug ( );
	void ProcessViewRotation ( );
	void SetViewTarget ( );
	void UpdateViewTarget ( );
	void CheckViewTarget ( );
	void FillCameraCache ( );
	void BlendViewTargets ( );
	void ApplyAudioFade ( );
	void DoUpdateCamera ( );
	void eventUpdateCamera ( );
	void SetDesiredColorScale ( );
	void GetCameraRotation ( );
	void GetCameraViewPoint ( );
	void GetActualFOV ( );
	void SetUnmodifiedFOV ( );
	void SetFOV ( );
	void GetFOVAngle ( );
	void InitializeFor ( );
	void ApplyCameraModifiers ( );
	void eventDestroyed ( );
	void PostBeginPlay ( );
	void CreateCameraModifier ( );
};

UClass* ACamera::pClassPointer = NULL;

// Class Engine.CameraActor
// 0x0240 (0x0484 - 0x0244)
class ACameraActor : public AActor
{
public:
	DWORD                                              bConstrainAspectRatio : 1;                        		// 0x0244 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bCamOverridePostProcess : 1;                      		// 0x0244 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              AspectRatio;                                      		// 0x0248 (0x0004) [0x0000000000150000]              ( CPF_Travel | CPF_GlobalConfig )
	float                                              FOVAngle;                                         		// 0x024C (0x0004) [0x0000000000160000]              ( CPF_EditConst | CPF_GlobalConfig )
	float                                              CamOverridePostProcessAlpha;                      		// 0x0250 (0x0004) [0x0000000000000000]              
	struct FPostProcessSettings                        CamOverridePostProcess;                           		// 0x0254 (0x0220) [0x0000000000000000]              
	class UDrawFrustumComponent*                       DrawFrustum;                                      		// 0x0474 (0x0008) [0x0000000000000000]              
	class UStaticMeshComponent*                        MeshComp;                                         		// 0x047C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CameraActor" );

		return pClassPointer;
	};

	void DisplayDebug ( );
	void GetCameraView ( );
};

UClass* ACameraActor::pClassPointer = NULL;

// Class Engine.DynamicCameraActor
// 0x0000 (0x0484 - 0x0484)
class ADynamicCameraActor : public ACameraActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DynamicCameraActor" );

		return pClassPointer;
	};

};

UClass* ADynamicCameraActor::pClassPointer = NULL;

// Class Engine.CameraAnim
// 0x0258 (0x02B8 - 0x0060)
class UCameraAnim : public UObject
{
public:
	class UInterpGroupCamera*                          CameraInterpGroup;                                		// 0x0060 (0x0008) [0x0000000000000000]              
	class UInterpGroup*                                PreviewInterpGroup;                               		// 0x0068 (0x0008) [0x0000000000000000]              
	float                                              AnimLength;                                       		// 0x0070 (0x0004) [0x0000000000000000]              
	struct FBox                                        BoundingBox;                                      		// 0x0074 (0x001C) [0x0000000000000000]              
	struct FPostProcessSettings                        BasePPSettings;                                   		// 0x0090 (0x0220) [0x0000000000000000]              
	float                                              BasePPSettingsAlpha;                              		// 0x02B0 (0x0004) [0x0000000000000000]              
	float                                              BaseFOV;                                          		// 0x02B4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CameraAnim" );

		return pClassPointer;
	};

};

UClass* UCameraAnim::pClassPointer = NULL;

// Class Engine.CameraAnimInst
// 0x02D0 (0x0330 - 0x0060)
class UCameraAnimInst : public UObject
{
public:
	class UCameraAnim*                                 CamAnim;                                          		// 0x0060 (0x0008) [0x0000000000000000]              
	class UInterpGroupInst*                            InterpGroupInst;                                  		// 0x0068 (0x0008) [0x0000000000000000]              
	float                                              CurTime;                                          		// 0x0070 (0x0004) [0x0000000000000000]              
	DWORD                                              bLooping : 1;                                     		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bFinished : 1;                                    		// 0x0074 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAutoReleaseWhenFinished : 1;                     		// 0x0074 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bBlendingIn : 1;                                  		// 0x0074 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bBlendingOut : 1;                                 		// 0x0074 (0x0004) [0x0000000000000000] [0x00000010] 
	float                                              BlendInTime;                                      		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              BlendOutTime;                                     		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              CurBlendInTime;                                   		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              CurBlendOutTime;                                  		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              PlayRate;                                         		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              BasePlayScale;                                    		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              TransientScaleModifier;                           		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              CurrentBlendWeight;                               		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              RemainingTime;                                    		// 0x0098 (0x0004) [0x0000000000000000]              
	class UInterpTrackMove*                            MoveTrack;                                        		// 0x009C (0x0008) [0x0000000000000000]              
	class UInterpTrackInstMove*                        MoveInst;                                         		// 0x00A4 (0x0008) [0x0000000000000000]              
	class UAnimNodeSequence*                           SourceAnimNode;                                   		// 0x00AC (0x0008) [0x0000000000000000]              
	unsigned char                                      PlaySpace;                                        		// 0x00B4 (0x0001) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0xB ];                             		// 0x00B5 (0x000B) MISSED OFFSET
	struct FMatrix                                     UserPlaySpaceMatrix;                              		// 0x00C0 (0x0040) [0x0000000000000000]              
	struct FPostProcessSettings                        LastPPSettings;                                   		// 0x0100 (0x0220) [0x0000000000000000]              
	float                                              LastPPSettingsAlpha;                              		// 0x0320 (0x0004) [0x0000000000000000]              
	struct FVector                                     LastCameraLoc;                                    		// 0x0324 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CameraAnimInst" );

		return pClassPointer;
	};

	void SetPlaySpace ( );
	void ApplyTransientScaling ( );
	void Stop ( );
	void AdvanceAnim ( );
	void Update ( );
	void Play ( );
};

UClass* UCameraAnimInst::pClassPointer = NULL;

// Class Engine.CameraModifier
// 0x0020 (0x0080 - 0x0060)
class UCameraModifier : public UObject
{
public:
	DWORD                                              bDisabled : 1;                                    		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bPendingDisable : 1;                              		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bExclusive : 1;                                   		// 0x0060 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bDebug : 1;                                       		// 0x0060 (0x0004) [0x0000000000000000] [0x00000008] 
	class ACamera*                                     CameraOwner;                                      		// 0x0064 (0x0008) [0x0000000000000000]              
	unsigned char                                      Priority;                                         		// 0x006C (0x0001) [0x0000000000000000]              
	float                                              AlphaInTime;                                      		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              AlphaOutTime;                                     		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              Alpha;                                            		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              TargetAlpha;                                      		// 0x007C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CameraModifier" );

		return pClassPointer;
	};

	void UpdateAlpha ( );
	void ProcessViewRotation ( );
	void ToggleModifier ( );
	void EnableModifier ( );
	void eventDisableModifier ( );
	void RemoveCameraModifier ( );
	void AddCameraModifier ( );
	void IsDisabled ( );
	void ModifyCamera ( );
	void Init ( );
};

UClass* UCameraModifier::pClassPointer = NULL;

// Class Engine.CameraModifier_CameraShake
// 0x0014 (0x0094 - 0x0080)
class UCameraModifier_CameraShake : public UCameraModifier
{
public:
	TArray< struct FCameraShakeInstance >              ActiveShakes;                                     		// 0x0080 (0x0010) [0x0000000000000000]              
	float                                              SplitScreenShakeScale;                            		// 0x0090 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CameraModifier_CameraShake" );

		return pClassPointer;
	};

	void ModifyCamera ( );
	void UpdateCameraShake ( );
	void RemoveAllCameraShakes ( );
	void RemoveCameraShake ( );
	void AddCameraShake ( );
	void InitializeShake ( );
	void ReinitShake ( );
	void InitializeOffset ( );
};

UClass* UCameraModifier_CameraShake::pClassPointer = NULL;

// Class Engine.CameraShake
// 0x0080 (0x00E0 - 0x0060)
class UCameraShake : public UObject
{
public:
	DWORD                                              bSingleInstance : 1;                              		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bRandomAnimSegment : 1;                           		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              OscillationDuration;                              		// 0x0064 (0x0004) [0x0000000000000000]              
	float                                              OscillationBlendInTime;                           		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              OscillationBlendOutTime;                          		// 0x006C (0x0004) [0x0000000000000000]              
	struct FROscillator                                RotOscillation;                                   		// 0x0070 (0x0024) [0x0000000000000000]              
	struct FVOscillator                                LocOscillation;                                   		// 0x0094 (0x0024) [0x0000000000000000]              
	struct FFOscillator                                FOVOscillation;                                   		// 0x00B8 (0x000C) [0x0000000000000000]              
	class UCameraAnim*                                 Anim;                                             		// 0x00C4 (0x0008) [0x0000000000000000]              
	float                                              AnimPlayRate;                                     		// 0x00CC (0x0004) [0x0000000000000000]              
	float                                              AnimScale;                                        		// 0x00D0 (0x0004) [0x0000000000000000]              
	float                                              AnimBlendInTime;                                  		// 0x00D4 (0x0004) [0x0000000000000000]              
	float                                              AnimBlendOutTime;                                 		// 0x00D8 (0x0004) [0x0000000000000000]              
	float                                              RandomAnimSegmentDuration;                        		// 0x00DC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CameraShake" );

		return pClassPointer;
	};

	void GetLocOscillationMagnitude ( );
	void GetRotOscillationMagnitude ( );
};

UClass* UCameraShake::pClassPointer = NULL;

// Class Engine.CloudStorageUpgradeHelper
// 0x0000 (0x0060 - 0x0060)
class UCloudStorageUpgradeHelper : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CloudStorageUpgradeHelper" );

		return pClassPointer;
	};

	void eventGetCloudUpgradeKeys ( );
	void eventHandleLocalKeyValue ( );
	void eventHandleLocalDocument ( );
};

UClass* UCloudStorageUpgradeHelper::pClassPointer = NULL;

// Class Engine.AlienFXLEDInterface
// 0x000C (0x008C - 0x0080)
class UAlienFXLEDInterface : public UPlatformInterfaceBase
{
public:
	int                                                Red;                                              		// 0x0080 (0x0004) [0x0000000000000000]              
	int                                                Green;                                            		// 0x0084 (0x0004) [0x0000000000000000]              
	int                                                Blue;                                             		// 0x0088 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AlienFXLEDInterface" );

		return pClassPointer;
	};

	void eventLEDPulseLighting ( );
	void eventLEDSetFlashingRBG ( );
	void UpdateAlienFX ( );
	void eventLedStopEffects ( );
	void eventLedRestoreLighting ( );
	void eventSetColor ( );
	void eventActivate ( );
	void eventInit ( );
};

UClass* UAlienFXLEDInterface::pClassPointer = NULL;

// Class Engine.AnalyticEventsBase
// 0x0018 (0x0098 - 0x0080)
class UAnalyticEventsBase : public UPlatformInterfaceBase
{
public:
	DWORD                                              bSessionInProgress : 1;                           		// 0x0080 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAutoStartSession : 1;                            		// 0x0080 (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                SessionPauseThresholdSec;                         		// 0x0084 (0x0004) [0x0000000000000000]              
	struct FString                                     UserId;                                           		// 0x0088 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnalyticEventsBase" );

		return pClassPointer;
	};

	void eventSendCachedEvents ( );
	void eventLogCurrencyGivenEvent ( );
	void eventLogCurrencyPurchaseEvent ( );
	void eventLogItemPurchaseEvent ( );
	void eventLogUserAttributeUpdateArray ( );
	void eventLogUserAttributeUpdate ( );
	void eventLogErrorMessage ( );
	void eventEndStringEventParamArray ( );
	void eventLogStringEventParamArray ( );
	void eventEndStringEventParam ( );
	void eventLogStringEventParam ( );
	void eventEndStringEvent ( );
	void eventLogStringEvent ( );
	void eventEndSession ( );
	void eventStartSession ( );
	void eventSetUserId ( );
	void eventInit ( );
	void IsSessionInProgress ( );
};

UClass* UAnalyticEventsBase::pClassPointer = NULL;

// Class Engine.MultiProviderAnalytics
// 0x0020 (0x00B8 - 0x0098)
class UMultiProviderAnalytics : public UAnalyticEventsBase
{
public:
	TArray< struct FString >                           AnalyticsProviderClassNames;                      		// 0x0098 (0x0010) [0x0000000000000000]              
	TArray< class UAnalyticEventsBase* >               AnalyticsProviders;                               		// 0x00A8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MultiProviderAnalytics" );

		return pClassPointer;
	};

	void eventSendCachedEvents ( );
	void eventLogCurrencyGivenEvent ( );
	void eventLogCurrencyPurchaseEvent ( );
	void eventLogItemPurchaseEvent ( );
	void eventLogUserAttributeUpdateArray ( );
	void eventLogUserAttributeUpdate ( );
	void eventLogErrorMessage ( );
	void eventEndStringEventParamArray ( );
	void eventLogStringEventParamArray ( );
	void eventEndStringEventParam ( );
	void eventLogStringEventParam ( );
	void eventEndStringEvent ( );
	void eventLogStringEvent ( );
	void eventEndSession ( );
	void eventStartSession ( );
	void eventSetUserId ( );
	void Init ( );
};

UClass* UMultiProviderAnalytics::pClassPointer = NULL;

// Class Engine.AppNotificationsBase
// 0x004C (0x00CC - 0x0080)
class UAppNotificationsBase : public UPlatformInterfaceBase
{
public:
	struct FLaunchNotificationInfo                     AppLaunchNotification;                            		// 0x0080 (0x002C) [0x0000000000000000]              
	struct FScriptDelegate                             __OnReceivedLocalNotification__Delegate;          		// 0x00AC (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x00B0 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __OnReceivedRemoteNotification__Delegate;         		// 0x00BC (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x4 ];                             		// 0x00C0 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AppNotificationsBase" );

		return pClassPointer;
	};

	void DebugLogNotification ( );
	void OnReceivedRemoteNotification ( );
	void OnReceivedLocalNotification ( );
	void CancelAllScheduledLocalNotifications ( );
	void ScheduleLocalNotification ( );
	void WasLaunchedViaNotification ( );
	void eventInit ( );
};

UClass* UAppNotificationsBase::pClassPointer = NULL;

// Class Engine.CloudStorageBase
// 0x0014 (0x0094 - 0x0080)
class UCloudStorageBase : public UPlatformInterfaceBase
{
public:
	TArray< struct FString >                           LocalCloudFiles;                                  		// 0x0080 (0x0010) [0x0000000000000000]              
	DWORD                                              bSuppressDelegateCalls : 1;                       		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CloudStorageBase" );

		return pClassPointer;
	};

	void eventUpgradeLocalStorageToCloud ( );
	void eventResolveConflictWithVersionIndex ( );
	void eventResolveConflictWithNewestDocument ( );
	void eventWaitForWritesToFinish ( );
	void eventIsStillWritingFiles ( );
	void eventSaveDocumentWithObject ( );
	void eventSaveDocumentWithBytes ( );
	void eventSaveDocumentWithString ( );
	void eventWriteCloudDocument ( );
	void eventParseDocumentAsObject ( );
	void eventParseDocumentAsBytes ( );
	void eventParseDocumentAsString ( );
	void eventReadCloudDocument ( );
	void eventDeleteAllCloudDocuments ( );
	void eventCreateCloudDocument ( );
	void eventGetCloudDocumentName ( );
	void eventGetNumCloudDocuments ( );
	void eventQueryForCloudDocuments ( );
	void eventWriteKeyValue ( );
	void eventReadKeyValueFromLocalStore ( );
	void eventReadKeyValue ( );
	void IsUsingLocalStorage ( );
	void eventInit ( );
};

UClass* UCloudStorageBase::pClassPointer = NULL;

// Class Engine.DiscordRPCIntegration
// 0x0014 (0x0094 - 0x0080)
class UDiscordRPCIntegration : public UPlatformInterfaceBase
{
public:
	DWORD                                              bDiscordReady : 1;                                		// 0x0080 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FScriptDelegate                             __JoinLobby__Delegate;                            		// 0x0084 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0088 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DiscordRPCIntegration" );

		return pClassPointer;
	};

	void CreateGamePresence ( );
	void CreateMenuPresence ( );
	void TickDiscord ( );
	void ShutDown ( );
	void eventInit ( );
	void InternalJoinLobby ( );
	void JoinLobby ( );
};

UClass* UDiscordRPCIntegration::pClassPointer = NULL;

// Class Engine.FacebookIntegration
// 0x0060 (0x00E0 - 0x0080)
class UFacebookIntegration : public UPlatformInterfaceBase
{
public:
	struct FString                                     AppID;                                            		// 0x0080 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           Permissions;                                      		// 0x0090 (0x0010) [0x0000000000000000]              
	struct FString                                     UserName;                                         		// 0x00A0 (0x0010) [0x0000000000000000]              
	struct FString                                     UserId;                                           		// 0x00B0 (0x0010) [0x0000000000000000]              
	struct FString                                     AccessToken;                                      		// 0x00C0 (0x0010) [0x0000000000000000]              
	TArray< struct FFacebookFriend >                   FriendsList;                                      		// 0x00D0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FacebookIntegration" );

		return pClassPointer;
	};

	void eventDisconnect ( );
	void eventFacebookDialog ( );
	void eventFacebookRequest ( );
	void eventIsAuthorized ( );
	void eventAuthorize ( );
	void eventInit ( );
};

UClass* UFacebookIntegration::pClassPointer = NULL;

// Class Engine.InAppMessageBase
// 0x0000 (0x0080 - 0x0080)
class UInAppMessageBase : public UPlatformInterfaceBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InAppMessageBase" );

		return pClassPointer;
	};

	void eventShowInAppEmailUI ( );
	void eventShowInAppSMSUI ( );
	void eventInit ( );
};

UClass* UInAppMessageBase::pClassPointer = NULL;

// Class Engine.InGameAdManager
// 0x0004 (0x0084 - 0x0080)
class UInGameAdManager : public UPlatformInterfaceBase
{
public:
	DWORD                                              bShouldPauseWhileAdOpen : 1;                      		// 0x0080 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InGameAdManager" );

		return pClassPointer;
	};

	void SetPauseWhileAdOpen ( );
	void ForceCloseAd ( );
	void HideBanner ( );
	void ShowBanner ( );
	void eventInit ( );
};

UClass* UInGameAdManager::pClassPointer = NULL;

// Class Engine.LogitechLEDInterface
// 0x000C (0x008C - 0x0080)
class ULogitechLEDInterface : public UPlatformInterfaceBase
{
public:
	int                                                Red;                                              		// 0x0080 (0x0004) [0x0000000000000000]              
	int                                                Green;                                            		// 0x0084 (0x0004) [0x0000000000000000]              
	int                                                Blue;                                             		// 0x0088 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LogitechLEDInterface" );

		return pClassPointer;
	};

	void eventLedStopEffects ( );
	void eventLedRestoreLighting ( );
	void eventLEDPulseLighting ( );
	void eventLEDSetFlashingRBG ( );
	void eventSetColor ( );
	void eventInit ( );
};

UClass* ULogitechLEDInterface::pClassPointer = NULL;

// Class Engine.MixerIntegration
// 0x0044 (0x00C4 - 0x0080)
class UMixerIntegration : public UPlatformInterfaceBase
{
public:
	DWORD                                              bStartMixer : 1;                                  		// 0x0080 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FScriptDelegate                             __MixerStartupComplete__Delegate;                 		// 0x0084 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0088 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __HandleMixerButtonEvent__Delegate;               		// 0x0094 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x4 ];                             		// 0x0098 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __GetGroupBuildList__Delegate;                    		// 0x00A4 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x4 ];                             		// 0x00A8 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __GetIntendedDefaultScene__Delegate;              		// 0x00B4 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData03[ 0x4 ];                             		// 0x00B8 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MixerIntegration" );

		return pClassPointer;
	};

	void ForceMixerScene ( );
	void MoveUserToGroup ( );
	void MoveAllUsersToGroup ( );
	void CreateParticipantGroup ( );
	void SendMixerEventResult ( );
	void SetSceneActive ( );
	void StopInteractiveSession ( );
	void StartInteractiveSession ( );
	void TickMixer ( );
	void IsMixerInteractionEnabled ( );
	void eventInit ( );
	void GetIntendedDefaultScene ( );
	void GetGroupBuildList ( );
	void HandleMixerButtonEvent ( );
	void MixerStartupComplete ( );
};

UClass* UMixerIntegration::pClassPointer = NULL;

// Class Engine.RazerLEDInterface
// 0x000C (0x008C - 0x0080)
class URazerLEDInterface : public UPlatformInterfaceBase
{
public:
	int                                                Red;                                              		// 0x0080 (0x0004) [0x0000000000000000]              
	int                                                Green;                                            		// 0x0084 (0x0004) [0x0000000000000000]              
	int                                                Blue;                                             		// 0x0088 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RazerLEDInterface" );

		return pClassPointer;
	};

	void eventLedStopEffects ( );
	void eventLedRestoreLighting ( );
	void eventLEDPulseLighting ( );
	void eventLEDSetFlashingRBG ( );
	void eventSetColor ( );
	void eventInit ( );
};

UClass* URazerLEDInterface::pClassPointer = NULL;

// Class Engine.TwitterIntegrationBase
// 0x0000 (0x0080 - 0x0080)
class UTwitterIntegrationBase : public UPlatformInterfaceBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TwitterIntegrationBase" );

		return pClassPointer;
	};

	void eventTwitterRequest ( );
	void eventGetAccountId ( );
	void eventGetAccountName ( );
	void eventGetNumAccounts ( );
	void eventAuthorizeAccounts ( );
	void eventShowTweetUI ( );
	void eventCanShowTweetUI ( );
	void eventInit ( );
};

UClass* UTwitterIntegrationBase::pClassPointer = NULL;

// Class Engine.PlatformInterfaceWebResponse
// 0x0080 (0x00E0 - 0x0060)
class UPlatformInterfaceWebResponse : public UObject
{
public:
	struct FString                                     OriginalURL;                                      		// 0x0060 (0x0010) [0x0000000000000000]              
	int                                                ResponseCode;                                     		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                Tag;                                              		// 0x0074 (0x0004) [0x0000000000000000]              
	struct FMap_Mirror                                 Headers;                                          		// 0x0078 (0x0048) [0x0000000000000000]              
	struct FString                                     StringResponse;                                   		// 0x00C0 (0x0010) [0x0000000000000000]              
	TArray< unsigned char >                            BinaryResponse;                                   		// 0x00D0 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PlatformInterfaceWebResponse" );

		return pClassPointer;
	};

	void GetHeaderValue ( );
	void GetHeader ( );
	void GetNumHeaders ( );
};

UClass* UPlatformInterfaceWebResponse::pClassPointer = NULL;

// Class Engine.TWIndoorLightingVolume
// 0x0008 (0x0288 - 0x0280)
class ATWIndoorLightingVolume : public AVolume
{
public:
	struct FLightingChannelContainer                   IndoorLightingChannel;                            		// 0x0280 (0x0004) [0x0000000000000000]              
	struct FLightingChannelContainer                   OutdoorLightingChannel;                           		// 0x0284 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWIndoorLightingVolume" );

		return pClassPointer;
	};

	void eventUnTouch ( );
	void eventTouch ( );
};

UClass* ATWIndoorLightingVolume::pClassPointer = NULL;

// Class Engine.TWOutdoorLightingVolume
// 0x0008 (0x0288 - 0x0280)
class ATWOutdoorLightingVolume : public AVolume
{
public:
	struct FLightingChannelContainer                   IndoorLightingChannel;                            		// 0x0280 (0x0004) [0x0000000000000000]              
	struct FLightingChannelContainer                   OutdoorLightingChannel;                           		// 0x0284 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWOutdoorLightingVolume" );

		return pClassPointer;
	};

	void eventUnTouch ( );
	void eventTouch ( );
};

UClass* ATWOutdoorLightingVolume::pClassPointer = NULL;

// Class Engine.TWDeferredWorkManager
// 0x0030 (0x0274 - 0x0244)
class ATWDeferredWorkManager : public AActor
{
public:
	TArray< struct FAnimNotifyData >                   AnimNotifyDataArray;                              		// 0x0244 (0x0010) [0x0000000000000000]              
	TArray< struct FAnimNotifyTickData >               AnimNotifyTickDataArray;                          		// 0x0254 (0x0010) [0x0000000000000000]              
	TArray< struct FAnimNotifyEndData >                AnimNotifyEndDataArray;                           		// 0x0264 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWDeferredWorkManager" );

		return pClassPointer;
	};

	void DeferSpecialMoveAnimEnd ( );
	void DeferNotifyEnd ( );
	void DeferNotifyTick ( );
	void DeferNotify ( );
	void IsDuringAsyncWork ( );
};

UClass* ATWDeferredWorkManager::pClassPointer = NULL;

// Class Engine.TWSceneCapture2DDPGComponent
// 0x0004 (0x0174 - 0x0170)
class UTWSceneCapture2DDPGComponent : public USceneCapture2DComponent
{
public:
	DWORD                                              bRenderForegroundDPG : 1;                         		// 0x0170 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bRenderWorldDPG : 1;                              		// 0x0170 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWSceneCapture2DDPGComponent" );

		return pClassPointer;
	};

};

UClass* UTWSceneCapture2DDPGComponent::pClassPointer = NULL;

// Class Engine.TWMaterialExpressionLightBrightnessMultiplier
// 0x0000 (0x00DC - 0x00DC)
class UTWMaterialExpressionLightBrightnessMultiplier : public UMaterialExpressionScalarParameter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWMaterialExpressionLightBrightnessMultiplier" );

		return pClassPointer;
	};

};

UClass* UTWMaterialExpressionLightBrightnessMultiplier::pClassPointer = NULL;

// Class Engine.SeqEvent_MobileTouch
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_MobileTouch : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_MobileTouch" );

		return pClassPointer;
	};

};

UClass* USeqEvent_MobileTouch::pClassPointer = NULL;

// Class Engine.SeqAct_AttachToActor
// 0x0024 (0x0174 - 0x0150)
class USeqAct_AttachToActor : public USequenceAction
{
public:
	DWORD                                              bDetach : 1;                                      		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bHardAttach : 1;                                  		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bUseRelativeOffset : 1;                           		// 0x0150 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bUseRelativeRotation : 1;                         		// 0x0150 (0x0004) [0x0000000000000000] [0x00000008] 
	struct FName                                       BoneName;                                         		// 0x0154 (0x0008) [0x0000000000000000]              
	struct FVector                                     RelativeOffset;                                   		// 0x015C (0x000C) [0x0000000000000000]              
	struct FRotator                                    RelativeRotation;                                 		// 0x0168 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_AttachToActor" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_AttachToActor::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleHidden
// 0x0014 (0x0164 - 0x0150)
class USeqAct_ToggleHidden : public USeqAct_Toggle
{
public:
	DWORD                                              bToggleBasedActors : 1;                           		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class UClass* >                            IgnoreBasedClasses;                               		// 0x0154 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ToggleHidden" );

		return pClassPointer;
	};

};

UClass* USeqAct_ToggleHidden::pClassPointer = NULL;

// Class Engine.SeqAct_SetVelocity
// 0x0014 (0x0164 - 0x0150)
class USeqAct_SetVelocity : public USequenceAction
{
public:
	struct FVector                                     VelocityDir;                                      		// 0x0150 (0x000C) [0x0000000000000000]              
	float                                              VelocityMag;                                      		// 0x015C (0x0004) [0x0000000000000000]              
	DWORD                                              bVelocityRelativeToActorRotation : 1;             		// 0x0160 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetVelocity" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_SetVelocity::pClassPointer = NULL;

// Class Engine.SeqAct_Teleport
// 0x0018 (0x0168 - 0x0150)
class USeqAct_Teleport : public USequenceAction
{
public:
	DWORD                                              bUpdateRotation : 1;                              		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bCheckOverlap : 1;                                		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              TeleportDistance;                                 		// 0x0154 (0x0004) [0x0000000000000000]              
	TArray< class AVolume* >                           TeleportVolumes;                                  		// 0x0158 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_Teleport" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
	void ShouldTeleport ( );
};

UClass* USeqAct_Teleport::pClassPointer = NULL;

// Class Engine.SeqAct_Destroy
// 0x0014 (0x0164 - 0x0150)
class USeqAct_Destroy : public USequenceAction
{
public:
	DWORD                                              bDestroyBasedActors : 1;                          		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class UClass* >                            IgnoreBasedClasses;                               		// 0x0154 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_Destroy" );

		return pClassPointer;
	};

};

UClass* USeqAct_Destroy::pClassPointer = NULL;

// Class Engine.LocalMessage
// 0x0014 (0x0074 - 0x0060)
class ULocalMessage : public UObject
{
public:
	DWORD                                              bIsSpecial : 1;                                   		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIsUnique : 1;                                    		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bIsPartiallyUnique : 1;                           		// 0x0060 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bIsConsoleMessage : 1;                            		// 0x0060 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bBeep : 1;                                        		// 0x0060 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bCountInstances : 1;                              		// 0x0060 (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              Lifetime;                                         		// 0x0064 (0x0004) [0x0000000000000000]              
	struct FColor                                      DrawColor;                                        		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              PosY;                                             		// 0x006C (0x0004) [0x0000000000000000]              
	int                                                FontSize;                                         		// 0x0070 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.LocalMessage" );

		return pClassPointer;
	};

	void PartiallyDuplicates ( );
	void IsConsoleMessage ( );
	void GetLifeTime ( );
	void GetFontSize ( );
	void GetPos ( );
	void GetColor ( );
	void GetConsoleColor ( );
	void GetString ( );
	void ClientReceive ( );
};

UClass* ULocalMessage::pClassPointer = NULL;

// Class Engine.SeqEvent_HitWall
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_HitWall : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_HitWall" );

		return pClassPointer;
	};

};

UClass* USeqEvent_HitWall::pClassPointer = NULL;

// Class Engine.OnlinePlayerInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlinePlayerInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlinePlayerInterface" );

		return pClassPointer;
	};

	void GetAchievements ( );
	void ClearReadAchievementsCompleteDelegate ( );
	void AddReadAchievementsCompleteDelegate ( );
	void OnReadAchievementsComplete ( );
	void ReadAchievements ( );
	void ClearUnlockAchievementCompleteDelegate ( );
	void AddUnlockAchievementCompleteDelegate ( );
	void OnUnlockAchievementComplete ( );
	void UnlockAchievement ( );
	void DeleteMessage ( );
	void ClearFriendMessageReceivedDelegate ( );
	void AddFriendMessageReceivedDelegate ( );
	void OnFriendMessageReceived ( );
	void GetFriendMessages ( );
	void ClearJoinFriendGameCompleteDelegate ( );
	void AddJoinFriendGameCompleteDelegate ( );
	void OnJoinFriendGameComplete ( );
	void JoinFriendGame ( );
	void CheckForGameInviteOnLaunch ( );
	void ClearReceivedGameInviteByIdDelegate ( );
	void ClearReceivedGameInviteDelegate ( );
	void AddReceivedGameInviteByIdDelegate ( );
	void AddReceivedGameInviteDelegate ( );
	void OnReceivedGameInviteById ( );
	void OnReceivedGameInvite ( );
	void SendGameInviteToUsers ( );
	void SendGameInviteToFriends ( );
	void SendGameInviteToFriend ( );
	void SendMessageToFriend ( );
	void ClearFriendInviteReceivedDelegate ( );
	void AddFriendInviteReceivedDelegate ( );
	void OnFriendInviteReceived ( );
	void RemoveFriend ( );
	void DenyFriendInvite ( );
	void AcceptFriendInvite ( );
	void ClearAddFriendByNameCompleteDelegate ( );
	void AddAddFriendByNameCompleteDelegate ( );
	void OnAddFriendByNameComplete ( );
	void AddFriendByName ( );
	void AddFriend ( );
	void GetKeyboardInputResults ( );
	void ClearKeyboardInputDoneDelegate ( );
	void AddKeyboardInputDoneDelegate ( );
	void OnKeyboardInputComplete ( );
	void HideKeyboardUI ( );
	void ShowKeyboardUI ( );
	void SetOnlineStatus ( );
	void GetFriendsList ( );
	void ClearReadFriendsCompleteDelegate ( );
	void AddReadFriendsCompleteDelegate ( );
	void OnReadFriendsComplete ( );
	void ReadFriendsList ( );
	void ClearWritePlayerStorageCompleteDelegate ( );
	void AddWritePlayerStorageCompleteDelegate ( );
	void OnWritePlayerStorageComplete ( );
	void WritePlayerStorage ( );
	void GetPlayerStorage ( );
	void ClearReadPlayerStorageForNetIdCompleteDelegate ( );
	void AddReadPlayerStorageForNetIdCompleteDelegate ( );
	void OnReadPlayerStorageForNetIdComplete ( );
	void ReadPlayerStorageForNetId ( );
	void ClearReadPlayerStorageCompleteDelegate ( );
	void AddReadPlayerStorageCompleteDelegate ( );
	void OnReadPlayerStorageComplete ( );
	void ReadPlayerStorage ( );
	void ClearWriteProfileSettingsCompleteDelegate ( );
	void AddWriteProfileSettingsCompleteDelegate ( );
	void OnWriteProfileSettingsComplete ( );
	void WriteProfileSettings ( );
	void GetProfileSettings ( );
	void ClearReadProfileSettingsCompleteDelegate ( );
	void AddReadProfileSettingsCompleteDelegate ( );
	void OnReadProfileSettingsComplete ( );
	void ReadProfileSettings ( );
	void ClearFriendsChangeDelegate ( );
	void AddFriendsChangeDelegate ( );
	void ClearMutingChangeDelegate ( );
	void AddMutingChangeDelegate ( );
	void ClearCurrentUserChangedDelegate ( );
	void AddCurrentUserChangedDelegate ( );
	void ClearLoginCancelledDelegate ( );
	void AddLoginCancelledDelegate ( );
	void ClearLoginStatusChangeDelegate ( );
	void AddLoginStatusChangeDelegate ( );
	void OnLoginStatusChange ( );
	void ClearLoginChangeDelegate ( );
	void AddLoginChangeDelegate ( );
	void ShowFriendsUI ( );
	void IsMuted ( );
	void AreAnyFriends ( );
	void IsFriend ( );
	void CanUploadFitnessData ( );
	void CanShareKinectContent ( );
	void CanShareWithSocialNetwork ( );
	void CanBrowseInternet ( );
	void CanAccessPremiumVideoContent ( );
	void CanAccessPremiumContent ( );
	void CanUseCloudStorage ( );
	void CanRecordDVRClips ( );
	void CanShowPresenceInformation ( );
	void CanViewPlayerProfiles ( );
	void CanPurchaseContent ( );
	void CanShareUserCreatedContent ( );
	void CanCommunicateVoice ( );
	void CanCommunicateVideo ( );
	void CanCommunicateText ( );
	void CanPlayOnline ( );
	void ClearPrivilegeLevelCheckedDelegate ( );
	void AddPrivilegeLevelCheckedDelegate ( );
	void OnPrivilegeLevelChecked ( );
	void IsLocalLogin ( );
	void IsGuestLogin ( );
	void GetPlayerNickname ( );
	void GetControllerIdFromNetId ( );
	void GetUniquePlayerId ( );
	void GetLoginStatus ( );
	void PairUserAndControllerAtIndex ( );
	void ClearSystemUserContrllerPairingChangedDelegate ( );
	void AddSystemUserContrllerPairingChangedDelegate ( );
	void OnSystemUserControllerPairingChanged ( );
	void ClearLogoutCompletedDelegate ( );
	void AddLogoutCompletedDelegate ( );
	void OnLogoutCompleted ( );
	void Logout ( );
	void ClearLoginFailedDelegate ( );
	void AddLoginFailedDelegate ( );
	void OnLoginFailed ( );
	void AutoLogin ( );
	void ClearLoginCompleteDelegate ( );
	void AddLoginCompleteDelegate ( );
	void OnLoginComplete ( );
	void Login ( );
	void ShowLoginUI ( );
	void OnFriendsChange ( );
	void OnMutingChange ( );
	void ClearURLTokenRetrievedDelegate ( );
	void AddURLTokenRetrievedDelegate ( );
	void GetTokenAndSignatureForURL ( );
	void OnTokenAndSignatureRetrieved ( );
	void OnCurrentUserChanged ( );
	void OnLoginCancelled ( );
	void OnLoginChange ( );
};

UClass* UOnlinePlayerInterface::pClassPointer = NULL;

// Class Engine.OnlineCommunityContentInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineCommunityContentInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineCommunityContentInterface" );

		return pClassPointer;
	};

	void RateContent ( );
	void ClearGetContentPayloadCompleteDelegate ( );
	void AddGetContentPayloadCompleteDelegate ( );
	void OnGetContentPayloadComplete ( );
	void GetContentPayload ( );
	void ClearDownloadContentCompleteDelegate ( );
	void AddDownloadContentCompleteDelegate ( );
	void OnDownloadContentComplete ( );
	void DownloadContent ( );
	void ClearUploadContentCompleteDelegate ( );
	void AddUploadContentCompleteDelegate ( );
	void OnUploadContentComplete ( );
	void UploadContent ( );
	void GetFriendsContentList ( );
	void ClearReadFriendsContentListCompleteDelegate ( );
	void AddReadFriendsContentListCompleteDelegate ( );
	void OnReadFriendsContentListComplete ( );
	void ReadFriendsContentList ( );
	void GetContentList ( );
	void ClearReadContentListCompleteDelegate ( );
	void AddReadContentListCompleteDelegate ( );
	void OnReadContentListComplete ( );
	void ReadContentList ( );
	void Exit ( );
	void Init ( );
};

UClass* UOnlineCommunityContentInterface::pClassPointer = NULL;

// Class Engine.OnlineGameDVRInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineGameDVRInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineGameDVRInterface" );

		return pClassPointer;
	};

	void CancelRecordingEvent ( );
	void RecordPreviousTimespan ( );
	void EndRecordingEvent ( );
	void ClearRecordEventCompleteDelegate ( );
	void AddRecordEventCompleteDelegate ( );
	void OnRecordEventComplete ( );
	void BeginRecordingEvent ( );
	void ClearReadRecordedClipsCompleteDelegate ( );
	void AddReadRecordedClipsCompleteDelegate ( );
	void ClearCachedRecordedClips ( );
	void OnReadRecordedClipsComplete ( );
	void ReadRecordedClips ( );
	void DisableRecording ( );
	void EnableRecording ( );
};

UClass* UOnlineGameDVRInterface::pClassPointer = NULL;

// Class Engine.SharedCloudFileInterface
// 0x0000 (0x0060 - 0x0060)
class USharedCloudFileInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SharedCloudFileInterface" );

		return pClassPointer;
	};

	void ClearWriteSharedFileCompleteDelegate ( );
	void AddWriteSharedFileCompleteDelegate ( );
	void WriteSharedFile ( );
	void OnWriteSharedFileComplete ( );
	void ClearReadSharedFileCompleteDelegate ( );
	void AddReadSharedFileCompleteDelegate ( );
	void ReadSharedFile ( );
	void OnReadSharedFileComplete ( );
	void ClearSharedFile ( );
	void ClearSharedFiles ( );
	void GetSharedFileContents ( );
};

UClass* USharedCloudFileInterface::pClassPointer = NULL;

// Class Engine.UserCloudFileInterface
// 0x0000 (0x0060 - 0x0060)
class UUserCloudFileInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UserCloudFileInterface" );

		return pClassPointer;
	};

	void ClearAllDelegates ( );
	void ClearDeleteUserFileCompleteDelegate ( );
	void AddDeleteUserFileCompleteDelegate ( );
	void DeleteUserFile ( );
	void OnDeleteUserFileComplete ( );
	void ClearWriteUserFileCompleteDelegate ( );
	void AddWriteUserFileCompleteDelegate ( );
	void WriteUserFile ( );
	void OnWriteUserFileComplete ( );
	void ClearReadUserFileCompleteDelegate ( );
	void AddReadUserFileCompleteDelegate ( );
	void ReadUserFile ( );
	void OnReadUserFileComplete ( );
	void GetUserFileList ( );
	void ClearEnumerateUserFileCompleteDelegate ( );
	void AddEnumerateUserFileCompleteDelegate ( );
	void EnumerateUserFiles ( );
	void OnEnumerateUserFilesComplete ( );
	void ClearFile ( );
	void ClearFiles ( );
	void GetFileContents ( );
};

UClass* UUserCloudFileInterface::pClassPointer = NULL;

// Class Engine.OnlineSocialInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineSocialInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineSocialInterface" );

		return pClassPointer;
	};

	void ClearPostLinkCompleted ( );
	void AddPostLinkCompleted ( );
	void OnPostLinkCompleted ( );
	void PostLink ( );
	void ClearPostImageCompleted ( );
	void AddPostImageCompleted ( );
	void OnPostImageCompleted ( );
	void PostImage ( );
	void ClearQuerySocialPostPrivilegesCompleted ( );
	void AddQuerySocialPostPrivilegesCompleted ( );
	void OnQuerySocialPostPrivilegesCompleted ( );
	void QuerySocialPostPrivileges ( );
};

UClass* UOnlineSocialInterface::pClassPointer = NULL;

// Class Engine.OnlineTitleFileCacheInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineTitleFileCacheInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineTitleFileCacheInterface" );

		return pClassPointer;
	};

	void DeleteTitleFile ( );
	void DeleteTitleFiles ( );
	void ClearCachedFile ( );
	void ClearCachedFiles ( );
	void GetTitleFileLogicalName ( );
	void GetTitleFileHash ( );
	void GetTitleFileState ( );
	void GetTitleFileContents ( );
	void ClearSaveTitleFileCompleteDelegate ( );
	void AddSaveTitleFileCompleteDelegate ( );
	void OnSaveTitleFileComplete ( );
	void SaveTitleFile ( );
	void ClearLoadTitleFileCompleteDelegate ( );
	void AddLoadTitleFileCompleteDelegate ( );
	void OnLoadTitleFileComplete ( );
	void LoadTitleFile ( );
};

UClass* UOnlineTitleFileCacheInterface::pClassPointer = NULL;

// Class Engine.OnlineTitleFileInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineTitleFileInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineTitleFileInterface" );

		return pClassPointer;
	};

	void ClearRequestTitleFileListCompleteDelegate ( );
	void AddRequestTitleFileListCompleteDelegate ( );
	void OnRequestTitleFileListComplete ( );
	void RequestTitleFileList ( );
	void ClearDownloadedFile ( );
	void ClearDownloadedFiles ( );
	void GetTitleFileState ( );
	void GetTitleFileContents ( );
	void ClearReadTitleFileCompleteDelegate ( );
	void AddReadTitleFileCompleteDelegate ( );
	void ReadTitleFile ( );
	void OnReadTitleFileComplete ( );
};

UClass* UOnlineTitleFileInterface::pClassPointer = NULL;

// Class Engine.OnlinePartyInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlinePartyInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlinePartyInterface" );

		return pClassPointer;
	};

	void ClearNotifyStatusUpdatedDelegate ( );
	void AddNotifyStatusUpdatedDelegate ( );
	void OnNotifyStatusUpdated ( );
	void ClearNotifyLeaderChangedDelegate ( );
	void AddNotifyLeaderChangedDelegate ( );
	void OnNotifyLeaderChanged ( );
	void ClearNotifyPartyMembersUpdatedDelegate ( );
	void AddNotifyPartyMembersUpdatedDelegate ( );
	void OnNotifyPartyMembersUpdated ( );
	void ClearNotifyMessageReceivedDelegate ( );
	void AddNotifyMessageReceivedDelegate ( );
	void OnNotifyMessageReceived ( );
	void SendMessage ( );
	void LeaveParty ( );
	void CreateParty ( );
	void InviteToPartyByUserNames ( );
	void GetMyMemberId ( );
	void GetLeaderMemberId ( );
	void GetPartyMembers ( );
};

UClass* UOnlinePartyInterface::pClassPointer = NULL;

// Class Engine.OnlinePartyChatInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlinePartyChatInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlinePartyChatInterface" );

		return pClassPointer;
	};

	void IsInPartyChat ( );
	void ShowCommunitySessionsUI ( );
	void ShowVoiceChannelUI ( );
	void ShowPartyUI ( );
	void GetPartyBandwidth ( );
	void SetPartyMemberCustomData ( );
	void ClearPartyMembersInfoChangedDelegate ( );
	void AddPartyMembersInfoChangedDelegate ( );
	void OnPartyMembersInfoChanged ( );
	void ClearReservedPartyMemberListChangedDelegate ( );
	void AddReservedPartyMemberListChangedDelegate ( );
	void OnReservedPartyMemberListChanged ( );
	void ClearPartyMemberListChangedDelegate ( );
	void AddPartyMemberListChangedDelegate ( );
	void OnPartyMemberListChanged ( );
	void GetPartyMemberInformation ( );
	void GetPartyMembersInformation ( );
	void ClearSendPartyGameInvitesCompleteDelegate ( );
	void AddSendPartyGameInvitesCompleteDelegate ( );
	void OnSendPartyGameInvitesComplete ( );
	void SendPartyGameInvites ( );
};

UClass* UOnlinePartyChatInterface::pClassPointer = NULL;

// Class Engine.OnlineNewsInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineNewsInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineNewsInterface" );

		return pClassPointer;
	};

	void GetNews ( );
	void ClearReadNewsCompletedDelegate ( );
	void AddReadNewsCompletedDelegate ( );
	void OnReadNewsCompleted ( );
	void ReadNews ( );
};

UClass* UOnlineNewsInterface::pClassPointer = NULL;

// Class Engine.OnlineStatsInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineStatsInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineStatsInterface" );

		return pClassPointer;
	};

	void SendTestEvent ( );
	void SendPlayerSessionResume ( );
	void SendPlayerSessionPause ( );
	void SendPlayerSessionEnd ( );
	void SendPlayerSessionStart ( );
	void UnsubscribeToStatisticEvent ( );
	void SubscribeToStatisticEvent ( );
	void OnStatisticChanged ( );
	void CalcAggregateSkill ( );
	void RegisterStatGuid ( );
	void GetClientStatGuid ( );
	void ClearRegisterHostStatGuidCompleteDelegateDelegate ( );
	void AddRegisterHostStatGuidCompleteDelegate ( );
	void OnRegisterHostStatGuidComplete ( );
	void RegisterHostStatGuid ( );
	void GetHostStatGuid ( );
	void WriteOnlinePlayerScores ( );
	void ClearFlushOnlineStatsCompleteDelegate ( );
	void AddFlushOnlineStatsCompleteDelegate ( );
	void OnFlushOnlineStatsComplete ( );
	void FlushOnlineStats ( );
	void WriteOnlineStats ( );
	void FreeStats ( );
	void ClearReadOnlineStatsCompleteDelegate ( );
	void AddReadOnlineStatsCompleteDelegate ( );
	void OnReadOnlineStatsComplete ( );
	void ReadOnlineStatsByRankAroundPlayer ( );
	void ReadOnlineStatsByRank ( );
	void ReadOnlineStatsForFriends ( );
	void ReadOnlineStats ( );
	void ReadOnlineStatsForPlayer ( );
};

UClass* UOnlineStatsInterface::pClassPointer = NULL;

// Class Engine.OnlineVoiceInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineVoiceInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineVoiceInterface" );

		return pClassPointer;
	};

	void UnmuteAll ( );
	void MuteAll ( );
	void SetSpeechRecognitionObject ( );
	void SelectVocabulary ( );
	void ClearRecognitionCompleteDelegate ( );
	void AddRecognitionCompleteDelegate ( );
	void OnRecognitionComplete ( );
	void GetRecognitionResults ( );
	void StopSpeechRecognition ( );
	void StartSpeechRecognition ( );
	void StopNetworkedVoice ( );
	void StartNetworkedVoice ( );
	void ClearPlayerTalkingDelegate ( );
	void AddPlayerTalkingDelegate ( );
	void OnPlayerTalkingStateChange ( );
	void IsTalkerMuted ( );
	void UnmuteRemoteTalker ( );
	void MuteRemoteTalker ( );
	void UpdatePlayerMuteSetting ( );
	void SetRemoteTalkerPriority ( );
	void IsHeadsetPresent ( );
	void IsRemotePlayerTalking ( );
	void IsLocalPlayerTalking ( );
	void UnregisterRemoteTalker ( );
	void RegisterRemoteTalker ( );
	void ReceiveReliableVoicePacket ( );
	void AreAnyLocalTalkersRegistered ( );
	void UnregisterLocalTalker ( );
	void RegisterLocalTalker ( );
};

UClass* UOnlineVoiceInterface::pClassPointer = NULL;

// Class Engine.OnlineContentInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineContentInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineContentInterface" );

		return pClassPointer;
	};

	void GetDownloadableContentList ( );
	void ClearDownloadableContentList ( );
	void ReadDownloadableContentList ( );
	void ClearSaveGames ( );
	void DeleteSaveGame ( );
	void ClearWriteSaveGameDataComplete ( );
	void AddWriteSaveGameDataComplete ( );
	void OnWriteSaveGameDataComplete ( );
	void WriteSaveGameData ( );
	void ClearReadSaveGameDataComplete ( );
	void AddReadSaveGameDataComplete ( );
	void OnReadSaveGameDataComplete ( );
	void GetSaveGameData ( );
	void ReadSaveGameData ( );
	void GetAvailableDownloadCounts ( );
	void ClearQueryAvailableDownloadsComplete ( );
	void AddQueryAvailableDownloadsComplete ( );
	void OnQueryAvailableDownloadsComplete ( );
	void QueryAvailableDownloads ( );
	void ClearCrossTitleSaveGames ( );
	void ClearReadCrossTitleSaveGameDataComplete ( );
	void AddReadCrossTitleSaveGameDataComplete ( );
	void OnReadCrossTitleSaveGameDataComplete ( );
	void GetCrossTitleSaveGameData ( );
	void ReadCrossTitleSaveGameData ( );
	void ClearReadCrossTitleContentCompleteDelegate ( );
	void AddReadCrossTitleContentCompleteDelegate ( );
	void OnReadCrossTitleContentComplete ( );
	void GetCrossTitleContentList ( );
	void ClearCrossTitleContentList ( );
	void ReadCrossTitleContentList ( );
	void GetContentList ( );
	void ClearContentList ( );
	void ReadContentList ( );
	void ClearReadContentComplete ( );
	void AddReadContentComplete ( );
	void OnReadContentComplete ( );
	void ClearContentChangeDelegate ( );
	void AddContentChangeDelegate ( );
	void OnContentChange ( );
};

UClass* UOnlineContentInterface::pClassPointer = NULL;

// Class Engine.OnlineSystemInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineSystemInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineSystemInterface" );

		return pClassPointer;
	};

	void GetLocale ( );
	void ClearStorageDeviceChangeDelegate ( );
	void AddStorageDeviceChangeDelegate ( );
	void OnStorageDeviceChange ( );
	void GetNATType ( );
	void ClearConnectionStatusChangeDelegate ( );
	void AddConnectionStatusChangeDelegate ( );
	void OnConnectionStatusChange ( );
	void GetCurrentConnectionStatus ( );
	void IsControllerConnected ( );
	void ClearControllerChangeDelegate ( );
	void AddControllerChangeDelegate ( );
	void OnControllerChange ( );
	void SetNetworkNotificationPosition ( );
	void GetNetworkNotificationPosition ( );
	void ClearExternalUIChangeDelegate ( );
	void AddExternalUIChangeDelegate ( );
	void OnExternalUIChange ( );
	void ClearLinkStatusChangeDelegate ( );
	void AddLinkStatusChangeDelegate ( );
	void OnLinkStatusChange ( );
	void HasLinkConnection ( );
};

UClass* UOnlineSystemInterface::pClassPointer = NULL;

// Class Engine.OnlineMarketplaceInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineMarketplaceInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineMarketplaceInterface" );

		return pClassPointer;
	};

	void ClearMarketplaceItemPurchasedDelegate ( );
	void AddMarketplaceItemPurchasedDelegate ( );
	void OnMarketplaceItemPurchased ( );
	void ClearConsumeInventoryItemCompleteDelegate ( );
	void AddConsumeInventoryItemCompleteDelegate ( );
	void OnConsumeInventoryItemComplete ( );
	void ConsumeInventoryItem ( );
	void ResetInventoryItems ( );
	void GetInventoryItems ( );
	void ClearReadInventoryItemsCompleteDelegate ( );
	void AddReadInventoryItemsCompleteDelegate ( );
	void OnReadInventoryItemsComplete ( );
	void ReadInventoryItems ( );
	void ClearReadAdditionalProductDetailsCompleteDelegate ( );
	void AddReadAdditionalProductDetailsCompleteDelegate ( );
	void OnReadAdditionalProductDetailsComplete ( );
	void ReadAdditionalDetailsForProducts ( );
	void ResetAvailableProducts ( );
	void GetAvailableProducts ( );
	void ClearReadAvailableProductsCompleteDelegate ( );
	void AddReadAvailableProductsCompleteDelegate ( );
	void OnReadAvailableProductsComplete ( );
	void ReadAvailableProducts ( );
};

UClass* UOnlineMarketplaceInterface::pClassPointer = NULL;

// Class Engine.OnlinePlayerInterfaceEx
// 0x0000 (0x0060 - 0x0060)
class UOnlinePlayerInterfaceEx : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlinePlayerInterfaceEx" );

		return pClassPointer;
	};

	void ClearPlayerTalkingDelegate ( );
	void AddPlayerTalkingDelegate ( );
	void OnRemoteTalkerStatusChange ( );
	void ClearUnregisterRemoteTalkerCompleteDelegate ( );
	void AddUnregisterRemoteTalkerCompleteDelegate ( );
	void OnUnregisterRemoteTalkerComplete ( );
	void ClearUnregisterLocalTalkerCompleteDelegate ( );
	void AddUnregisterLocalTalkerCompleteDelegate ( );
	void OnUnregisterLocalTalkerComplete ( );
	void ClearRegisterLocalTalkerCompleteDelegate ( );
	void AddRegisterLocalTalkerCompleteDelegate ( );
	void OnRegisterLocalTalkerComplete ( );
	void ClearReadOnlineProfilesCompleteDelegate ( );
	void AddReadOnlineProfilesCompleteDelegate ( );
	void OnReadOnlineProfilesComplete ( );
	void ReadOnlineProfilesForPlayers ( );
	void GetPlayerIDForPlayerNickname ( );
	void GetPlayerNicknameForPlayerId ( );
	void ShowCustomErrorUI ( );
	void ShowSystemErrorUI ( );
	void UpsellPremiumOnlineService ( );
	void ClearOnEntitlementsReadDelegate ( );
	void AddOnEntitlementsReadDelegate ( );
	void OnEntitlementsRead ( );
	void ReadEntitlements ( );
	void ClearStoreDataReadCompleteDelegate ( );
	void AddStoreDataReadCompleteDelegate ( );
	void OnStoreDataRead ( );
	void ReadStoreData ( );
	void PostActivityFeedPerkLevelUp ( );
	void PostActivityFeedTeamAward ( );
	void PostActivityFeedBossKill ( );
	void ShowCustomMessageUI ( );
	void ClearCrossTitleProfileSettings ( );
	void GetCrossTitleProfileSettings ( );
	void ClearReadCrossTitleProfileSettingsCompleteDelegate ( );
	void AddReadCrossTitleProfileSettingsCompleteDelegate ( );
	void OnReadCrossTitleProfileSettingsComplete ( );
	void ReadCrossTitleProfileSettings ( );
	void UnlockAvatarAward ( );
	void AddInGamePost ( );
	void RecordPlayersRecentlyMet ( );
	void ShowCustomPlayersUI ( );
	void ShowPlayersUI ( );
	void ShowFriendsInviteUI ( );
	void ClearProfileDataChangedDelegate ( );
	void AddProfileDataChangedDelegate ( );
	void OnProfileDataChanged ( );
	void UnlockGamerPicture ( );
	void IsDeviceValid ( );
	void GetDeviceSelectionResults ( );
	void ClearDeviceSelectionDoneDelegate ( );
	void AddDeviceSelectionDoneDelegate ( );
	void OnDeviceSelectionComplete ( );
	void ShowDeviceSelectionUI ( );
	void ShowMembershipMarketplaceUI ( );
	void CloseCurrentContentUI ( );
	void ShowContentRedeemCodeUI ( );
	void ShowContentPurchaseUI ( );
	void ShowContentMarketplaceUI ( );
	void ShowProductDetailsUI ( );
	void ClearAcceptReceivedDataDelegate ( );
	void AddAcceptReceivedDataDelegate ( );
	void OnAcceptReceivedData ( );
	void ShowDataSendingUI ( );
	void ClearPeoplePickerCompleteDelegate ( );
	void AddPeoplePickerCompleteDelegate ( );
	void OnPeoplePickerComplete ( );
	void ShowPeoplePickerUI ( );
	void ShowInviteUI ( );
	void ShowAchievementsUI ( );
	void ShowMessagesUI ( );
	void ShowGamerCardUIByUsername ( );
	void ShowGamerCardUI ( );
	void ClearShowGamerCardCompleteDelegate ( );
	void AddShowGamerCardCompleteDelegate ( );
	void OnShowGamerCardComplete ( );
	void ShowVideo ( );
	void ClearShowHelpCompleteDelegate ( );
	void AddShowHelpCompleteDelegate ( );
	void OnShowHelpComplete ( );
	void ShowHelpForErrorUI ( );
	void ShowHelpUI ( );
	void ShowFeedbackUI ( );
};

UClass* UOnlinePlayerInterfaceEx::pClassPointer = NULL;

// Class Engine.OnlineAccountInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineAccountInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineAccountInterface" );

		return pClassPointer;
	};

	void GetLocalAccountNames ( );
	void DeleteLocalAccount ( );
	void RenameLocalAccount ( );
	void CreateLocalAccount ( );
	void ClearCreateOnlineAccountCompletedDelegate ( );
	void AddCreateOnlineAccountCompletedDelegate ( );
	void OnCreateOnlineAccountCompleted ( );
	void CreateOnlineAccount ( );
};

UClass* UOnlineAccountInterface::pClassPointer = NULL;

// Class Engine.AccessControl
// 0x0164 (0x03A8 - 0x0244)
class AAccessControl : public AInfo
{
public:
	TArray< struct FString >                           IPPolicies;                                       		// 0x0244 (0x0010) [0x0000000000000000]              
	TArray< struct FUniqueNetId >                      BannedIDs;                                        		// 0x0254 (0x0010) [0x0000000000000000]              
	struct FString                                     IPBanned;                                         		// 0x0264 (0x0010) [0x0000000000000000]              
	struct FString                                     WrongPassword;                                    		// 0x0274 (0x0010) [0x0000000000000000]              
	struct FString                                     NeedPassword;                                     		// 0x0284 (0x0010) [0x0000000000000000]              
	struct FString                                     SessionBanned;                                    		// 0x0294 (0x0010) [0x0000000000000000]              
	struct FString                                     KickedMsg;                                        		// 0x02A4 (0x0010) [0x0000000000000000]              
	struct FString                                     DefaultKickReason;                                		// 0x02B4 (0x0010) [0x0000000000000000]              
	struct FString                                     IdleKickReason;                                   		// 0x02C4 (0x0010) [0x0000000000000000]              
	class UClass*                                      AdminClass;                                       		// 0x02D4 (0x0008) [0x0000000000000000]              
	struct FString                                     AdminPassword;                                    		// 0x02DC (0x0010) [0x0000000000000000]              
	struct FString                                     GamePassword;                                     		// 0x02EC (0x0010) [0x0000000000000000]              
	struct FString                                     ACDisplayText[ 0x3 ];                             		// 0x02FC (0x0030) [0x0000000000000000]              
	struct FString                                     ACDescText[ 0x3 ];                                		// 0x032C (0x0030) [0x0000000000000000]              
	DWORD                                              bDontAddDefaultAdmin : 1;                         		// 0x035C (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bAuthenticateClients : 1;                         		// 0x035C (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bAuthenticateServer : 1;                          		// 0x035C (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bAuthenticateListenHost : 1;                      		// 0x035C (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bAuthDelegatesRegistered : 1;                     		// 0x035C (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bPendingListenAuth : 1;                           		// 0x035C (0x0004) [0x0000000000000000] [0x00000020] 
	int                                                MaxAuthRetryCount;                                		// 0x0360 (0x0004) [0x0000000000000000]              
	int                                                AuthRetryDelay;                                   		// 0x0364 (0x0004) [0x0000000000000000]              
	class UOnlineSubsystem*                            OnlineSub;                                        		// 0x0368 (0x0008) [0x0000000000000000]              
	class UOnlineAuthInterface*                        CachedAuthInt;                                    		// 0x0370 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0378 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	TArray< struct FPendingClientAuth >                ClientsPendingAuth;                               		// 0x0380 (0x0010) [0x0000000000000000]              
	TArray< struct FServerAuthRetry >                  ServerAuthRetries;                                		// 0x0390 (0x0010) [0x0000000000000000]              
	int                                                ListenAuthTicketUID;                              		// 0x03A0 (0x0004) [0x0000000000000000]              
	int                                                ListenAuthRetryCount;                             		// 0x03A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AccessControl" );

		return pClassPointer;
	};

	void IsPendingAuth ( );
	void Cleanup ( );
	void NotifyExit ( );
	void NotifyGameEnding ( );
	void NotifyServerTravel ( );
	void OnDestroyOnlineGameComplete ( );
	void StaticOnClientConnectionClose ( );
	void OnClientConnectionClose ( );
	void ListenHostAuthTimeout ( );
	void EndListenHostAuth ( );
	void ContinueListenHostAuth ( );
	void BeginListenHostAuth ( );
	void ProcessServerAuthRetryRequest ( );
	void ProcessServerAuthRequest ( );
	void OnClientAuthComplete ( );
	void ProcessClientAuthResponse ( );
	void OnAuthReady ( );
	void PendingAuthTimer ( );
	void PostLogin ( );
	void eventPreLogin ( );
	void ClearAuthDelegates ( );
	void RegisterAuthDelegates ( );
	void InitAuthHooks ( );
	void IsIDBanned ( );
	void CheckIPPolicy ( );
	void ValidLogin ( );
	void ParseAdminOptions ( );
	void AdminExited ( );
	void AdminEntered ( );
	void AdminLogout ( );
	void AdminLogin ( );
	void KickPlayer ( );
	void ForceKickPlayer ( );
	void KickBan ( );
	void Kick ( );
	void GetControllerFromString ( );
	void RequiresPassword ( );
	void SetGamePassword ( );
	void SetAdminPassword ( );
	void IsAdmin ( );
	void Destroyed ( );
	void PostBeginPlay ( );
};

UClass* AAccessControl::pClassPointer = NULL;

// Class Engine.Admin
// 0x0000 (0x0770 - 0x0770)
class AAdmin : public APlayerController
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Admin" );

		return pClassPointer;
	};

	void ServerSwitch ( );
	void Switch ( );
	void ServerRestartMap ( );
	void RestartMap ( );
	void PlayerList ( );
	void ServerKick ( );
	void Kick ( );
	void ServerKickBan ( );
	void KickBan ( );
	void ServerAdmin ( );
	void Admin ( );
	void eventPostBeginPlay ( );
};

UClass* AAdmin::pClassPointer = NULL;

// Class Engine.ApexDestructibleActorSpawnable
// 0x0000 (0x029C - 0x029C)
class AApexDestructibleActorSpawnable : public AApexDestructibleActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ApexDestructibleActorSpawnable" );

		return pClassPointer;
	};

};

UClass* AApexDestructibleActorSpawnable::pClassPointer = NULL;

// Class Engine.EmitterSpawnable
// 0x0008 (0x0260 - 0x0258)
class AEmitterSpawnable : public AEmitter
{
public:
	class UParticleSystem*                             ParticleTemplate;                                 		// 0x0258 (0x0008) [0x0000000000160000]              ( CPF_EditConst | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.EmitterSpawnable" );

		return pClassPointer;
	};

	void eventReplicatedEvent ( );
	void eventSetTemplate ( );
};

UClass* AEmitterSpawnable::pClassPointer = NULL;

// Class Engine.KAssetSpawnable
// 0x0000 (0x0260 - 0x0260)
class AKAssetSpawnable : public AKAsset
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.KAssetSpawnable" );

		return pClassPointer;
	};

};

UClass* AKAssetSpawnable::pClassPointer = NULL;

// Class Engine.ActorFactorySkeletalMeshCinematic
// 0x0000 (0x00B4 - 0x00B4)
class UActorFactorySkeletalMeshCinematic : public UActorFactorySkeletalMesh
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactorySkeletalMeshCinematic" );

		return pClassPointer;
	};

};

UClass* UActorFactorySkeletalMeshCinematic::pClassPointer = NULL;

// Class Engine.ActorFactorySkeletalMeshMAT
// 0x0000 (0x00B4 - 0x00B4)
class UActorFactorySkeletalMeshMAT : public UActorFactorySkeletalMesh
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ActorFactorySkeletalMeshMAT" );

		return pClassPointer;
	};

};

UClass* UActorFactorySkeletalMeshMAT::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleGodMode
// 0x0000 (0x0150 - 0x0150)
class USeqAct_ToggleGodMode : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ToggleGodMode" );

		return pClassPointer;
	};

};

UClass* USeqAct_ToggleGodMode::pClassPointer = NULL;

// Class Engine.SeqEvent_Death
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_Death : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_Death" );

		return pClassPointer;
	};

};

UClass* USeqEvent_Death::pClassPointer = NULL;

// Class Engine.SeqAct_ControlMovieTexture
// 0x0008 (0x0158 - 0x0150)
class USeqAct_ControlMovieTexture : public USequenceAction
{
public:
	class UTextureMovie*                               MovieTexture;                                     		// 0x0150 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ControlMovieTexture" );

		return pClassPointer;
	};

	void eventActivated ( );
};

UClass* USeqAct_ControlMovieTexture::pClassPointer = NULL;

// Class Engine.SeqAct_SetSoundMode
// 0x000C (0x015C - 0x0150)
class USeqAct_SetSoundMode : public USequenceAction
{
public:
	class USoundMode*                                  SoundMode;                                        		// 0x0150 (0x0008) [0x0000000000000000]              
	DWORD                                              bTopPriority : 1;                                 		// 0x0158 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetSoundMode" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
	void eventActivated ( );
};

UClass* USeqAct_SetSoundMode::pClassPointer = NULL;

// Class Engine.SeqAct_FlyThroughHasEnded
// 0x0000 (0x0150 - 0x0150)
class USeqAct_FlyThroughHasEnded : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_FlyThroughHasEnded" );

		return pClassPointer;
	};

};

UClass* USeqAct_FlyThroughHasEnded::pClassPointer = NULL;

// Class Engine.SeqAct_ConsoleCommand
// 0x0020 (0x0170 - 0x0150)
class USeqAct_ConsoleCommand : public USequenceAction
{
public:
	struct FString                                     Command;                                          		// 0x0150 (0x0010) [0x0000000000000000]              
	TArray< struct FString >                           Commands;                                         		// 0x0160 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ConsoleCommand" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
	void VersionUpdated ( );
};

UClass* USeqAct_ConsoleCommand::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleCinematicMode
// 0x0004 (0x0154 - 0x0150)
class USeqAct_ToggleCinematicMode : public USequenceAction
{
public:
	DWORD                                              bDisableMovement : 1;                             		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bDisableTurning : 1;                              		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bHidePlayer : 1;                                  		// 0x0150 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bDisableInput : 1;                                		// 0x0150 (0x0004) [0x0000000000000000] [0x00000008] 
	DWORD                                              bHideHUD : 1;                                     		// 0x0150 (0x0004) [0x0000000000000000] [0x00000010] 
	DWORD                                              bDeadBodies : 1;                                  		// 0x0150 (0x0004) [0x0000000000000000] [0x00000020] 
	DWORD                                              bDroppedPickups : 1;                              		// 0x0150 (0x0004) [0x0000000000000000] [0x00000040] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ToggleCinematicMode" );

		return pClassPointer;
	};

	void eventActivated ( );
};

UClass* USeqAct_ToggleCinematicMode::pClassPointer = NULL;

// Class Engine.SeqAct_ForceFeedback
// 0x0010 (0x0160 - 0x0150)
class USeqAct_ForceFeedback : public USequenceAction
{
public:
	class UForceFeedbackWaveform*                      FFWaveform;                                       		// 0x0150 (0x0008) [0x0000000000000000]              
	class UClass*                                      PredefinedWaveForm;                               		// 0x0158 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ForceFeedback" );

		return pClassPointer;
	};

};

UClass* USeqAct_ForceFeedback::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleHUD
// 0x0000 (0x0150 - 0x0150)
class USeqAct_ToggleHUD : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ToggleHUD" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_ToggleHUD::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleInput
// 0x0004 (0x0154 - 0x0150)
class USeqAct_ToggleInput : public USeqAct_Toggle
{
public:
	DWORD                                              bToggleMovement : 1;                              		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bToggleTurning : 1;                               		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ToggleInput" );

		return pClassPointer;
	};

};

UClass* USeqAct_ToggleInput::pClassPointer = NULL;

// Class Engine.DmgType_Suicided
// 0x0000 (0x0090 - 0x0090)
class UDmgType_Suicided : public UKillZDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DmgType_Suicided" );

		return pClassPointer;
	};

};

UClass* UDmgType_Suicided::pClassPointer = NULL;

// Class Engine.GameMessage
// 0x0170 (0x01E4 - 0x0074)
class UGameMessage : public ULocalMessage
{
public:
	struct FString                                     SwitchLevelMessage;                               		// 0x0074 (0x0010) [0x0000000000000000]              
	struct FString                                     LeftMessage;                                      		// 0x0084 (0x0010) [0x0000000000000000]              
	struct FString                                     FailedTeamMessage;                                		// 0x0094 (0x0010) [0x0000000000000000]              
	struct FString                                     FailedPlaceMessage;                               		// 0x00A4 (0x0010) [0x0000000000000000]              
	struct FString                                     FailedSpawnMessage;                               		// 0x00B4 (0x0010) [0x0000000000000000]              
	struct FString                                     EnteredMessage;                                   		// 0x00C4 (0x0010) [0x0000000000000000]              
	struct FString                                     MaxedOutMessage;                                  		// 0x00D4 (0x0010) [0x0000000000000000]              
	struct FString                                     ArbitrationMessage;                               		// 0x00E4 (0x0010) [0x0000000000000000]              
	struct FString                                     OvertimeMessage;                                  		// 0x00F4 (0x0010) [0x0000000000000000]              
	struct FString                                     GlobalNameChange;                                 		// 0x0104 (0x0010) [0x0000000000000000]              
	struct FString                                     NewTeamMessage;                                   		// 0x0114 (0x0010) [0x0000000000000000]              
	struct FString                                     NewTeamMessageTrailer;                            		// 0x0124 (0x0010) [0x0000000000000000]              
	struct FString                                     NoNameChange;                                     		// 0x0134 (0x0010) [0x0000000000000000]              
	struct FString                                     VoteStarted;                                      		// 0x0144 (0x0010) [0x0000000000000000]              
	struct FString                                     VotePassed;                                       		// 0x0154 (0x0010) [0x0000000000000000]              
	struct FString                                     MustHaveStats;                                    		// 0x0164 (0x0010) [0x0000000000000000]              
	struct FString                                     CantBeSpectator;                                  		// 0x0174 (0x0010) [0x0000000000000000]              
	struct FString                                     CantBePlayer;                                     		// 0x0184 (0x0010) [0x0000000000000000]              
	struct FString                                     BecameSpectator;                                  		// 0x0194 (0x0010) [0x0000000000000000]              
	struct FString                                     NewPlayerMessage;                                 		// 0x01A4 (0x0010) [0x0000000000000000]              
	struct FString                                     KickWarning;                                      		// 0x01B4 (0x0010) [0x0000000000000000]              
	struct FString                                     NewSpecMessage;                                   		// 0x01C4 (0x0010) [0x0000000000000000]              
	struct FString                                     SpecEnteredMessage;                               		// 0x01D4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.GameMessage" );

		return pClassPointer;
	};

	void GetString ( );
};

UClass* UGameMessage::pClassPointer = NULL;

// Class Engine.CoverReplicator
// 0x0010 (0x0254 - 0x0244)
class ACoverReplicator : public AReplicationInfo
{
public:
	TArray< struct FCoverReplicationInfo >             CoverReplicationData;                             		// 0x0244 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CoverReplicator" );

		return pClassPointer;
	};

	void ClientReceiveLinkDisabledState ( );
	void ServerSendLinkDisabledState ( );
	void NotifyLinkDisabledStateChange ( );
	void ClientReceiveManualCoverTypeSlots ( );
	void ServerSendManualCoverTypeSlots ( );
	void NotifySetManualCoverTypeForSlots ( );
	void ClientReceiveAdjustedSlots ( );
	void ServerSendAdjustedSlots ( );
	void NotifyAutoAdjustSlots ( );
	void ClientReceiveDisabledSlots ( );
	void ServerSendDisabledSlots ( );
	void NotifyDisabledSlots ( );
	void ClientReceiveEnabledSlots ( );
	void ServerSendEnabledSlots ( );
	void NotifyEnabledSlots ( );
	void ClientReceiveInitialCoverReplicationInfo ( );
	void ServerSendInitialCoverReplicationInfo ( );
	void ClientSetOwner ( );
	void ReplicateInitialCoverInfo ( );
	void PurgeOldEntries ( );
};

UClass* ACoverReplicator::pClassPointer = NULL;

// Class Engine.SplineComponentSimplified
// 0x0000 (0x0274 - 0x0274)
class USplineComponentSimplified : public USplineComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SplineComponentSimplified" );

		return pClassPointer;
	};

};

UClass* USplineComponentSimplified::pClassPointer = NULL;

// Class Engine.AmbientSoundSimpleSplineNonLoop
// 0x0000 (0x0274 - 0x0274)
class AAmbientSoundSimpleSplineNonLoop : public AAmbientSoundSimpleSpline
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AmbientSoundSimpleSplineNonLoop" );

		return pClassPointer;
	};

};

UClass* AAmbientSoundSimpleSplineNonLoop::pClassPointer = NULL;

// Class Engine.AnimNotify_PlayFaceFXAnim
// 0x0040 (0x00A4 - 0x0064)
class UAnimNotify_PlayFaceFXAnim : public UAnimNotify_Scripted
{
public:
	class UFaceFXAnimSet*                              FaceFXAnimSetRef;                                 		// 0x0064 (0x0008) [0x0000000000000000]              
	struct FString                                     GroupName;                                        		// 0x006C (0x0010) [0x0000000000000000]              
	struct FString                                     AnimName;                                         		// 0x007C (0x0010) [0x0000000000000000]              
	class USoundCue*                                   SoundCueToPlay;                                   		// 0x008C (0x0008) [0x0000000000000000]              
	class UAkEvent*                                    AkEventToPlay;                                    		// 0x0094 (0x0008) [0x0000000000000000]              
	DWORD                                              bOverridePlayingAnim : 1;                         		// 0x009C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              PlayFrequency;                                    		// 0x00A0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.AnimNotify_PlayFaceFXAnim" );

		return pClassPointer;
	};

	void eventNotify ( );
};

UClass* UAnimNotify_PlayFaceFXAnim::pClassPointer = NULL;

// Class Engine.BroadcastHandler
// 0x0008 (0x024C - 0x0244)
class ABroadcastHandler : public AInfo
{
public:
	int                                                SentText;                                         		// 0x0244 (0x0004) [0x0000000000000000]              
	DWORD                                              bMuteSpectators : 1;                              		// 0x0248 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.BroadcastHandler" );

		return pClassPointer;
	};

	void eventAllowBroadcastLocalizedTeam ( );
	void eventAllowBroadcastLocalized ( );
	void BroadcastTeam ( );
	void Broadcast ( );
	void BroadcastLocalized ( );
	void BroadcastText ( );
	void AllowsBroadcast ( );
	void UpdateSentText ( );
};

UClass* ABroadcastHandler::pClassPointer = NULL;

// Class Engine.HttpFactory
// 0x0010 (0x0070 - 0x0060)
class UHttpFactory : public UObject
{
public:
	struct FString                                     HttpRequestClassName;                             		// 0x0060 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.HttpFactory" );

		return pClassPointer;
	};

	void CreateRequest ( );
};

UClass* UHttpFactory::pClassPointer = NULL;

// Class Engine.CloudSaveSystemKVSInterface
// 0x0000 (0x0060 - 0x0060)
class UCloudSaveSystemKVSInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CloudSaveSystemKVSInterface" );

		return pClassPointer;
	};

	void WriteKeyValue ( );
	void ReadKeyValue ( );
};

UClass* UCloudSaveSystemKVSInterface::pClassPointer = NULL;

// Class Engine.CloudSaveSystemDataBlobStoreInterface
// 0x0000 (0x0060 - 0x0060)
class UCloudSaveSystemDataBlobStoreInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CloudSaveSystemDataBlobStoreInterface" );

		return pClassPointer;
	};

	void DeleteDataBlob ( );
	void DeleteDataBlobCallbackDelegate ( );
	void SetDataBlob ( );
	void SetDataBlobCallbackDelegate ( );
	void GetDataBlob ( );
	void GetDataBlobCallbackDelegate ( );
};

UClass* UCloudSaveSystemDataBlobStoreInterface::pClassPointer = NULL;

// Class Engine.CloudStorageBaseCloudSaveSystemKVS
// 0x0008 (0x0068 - 0x0060)
class UCloudStorageBaseCloudSaveSystemKVS : public UObject
{
public:
	class UCloudStorageBase*                           CloudStorage;                                     		// 0x0060 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.CloudStorageBaseCloudSaveSystemKVS" );

		return pClassPointer;
	};

	void GenerateKeyNameForSaveSlot ( );
	void WriteKeyValue ( );
	void ReadKeyValue ( );
	void Init ( );
};

UClass* UCloudStorageBaseCloudSaveSystemKVS::pClassPointer = NULL;

// Class Engine.ColorScaleVolume
// 0x0010 (0x0290 - 0x0280)
class AColorScaleVolume : public AVolume
{
public:
	struct FVector                                     ColorScale;                                       		// 0x0280 (0x000C) [0x0000000000000000]              
	float                                              InterpTime;                                       		// 0x028C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ColorScaleVolume" );

		return pClassPointer;
	};

	void eventUnTouch ( );
	void eventTouch ( );
};

UClass* AColorScaleVolume::pClassPointer = NULL;

// Class Engine.SeqAct_SetDamageInstigator
// 0x0008 (0x0158 - 0x0150)
class USeqAct_SetDamageInstigator : public USequenceAction
{
public:
	class AActor*                                      DamageInstigator;                                 		// 0x0150 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetDamageInstigator" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetDamageInstigator::pClassPointer = NULL;

// Class Engine.VolumeTimer
// 0x0008 (0x024C - 0x0244)
class AVolumeTimer : public AInfo
{
public:
	class APhysicsVolume*                              V;                                                		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.VolumeTimer" );

		return pClassPointer;
	};

	void eventTimer ( );
	void eventPostBeginPlay ( );
};

UClass* AVolumeTimer::pClassPointer = NULL;

// Class Engine.TWSeqEvent_LightFlicker
// 0x0000 (0x0170 - 0x0170)
class UTWSeqEvent_LightFlicker : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TWSeqEvent_LightFlicker" );

		return pClassPointer;
	};

};

UClass* UTWSeqEvent_LightFlicker::pClassPointer = NULL;

// Class Engine.DmgType_Crushed
// 0x0000 (0x0090 - 0x0090)
class UDmgType_Crushed : public UDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DmgType_Crushed" );

		return pClassPointer;
	};

};

UClass* UDmgType_Crushed::pClassPointer = NULL;

// Class Engine.DmgType_Fell
// 0x0000 (0x0090 - 0x0090)
class UDmgType_Fell : public UDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DmgType_Fell" );

		return pClassPointer;
	};

};

UClass* UDmgType_Fell::pClassPointer = NULL;

// Class Engine.DmgType_Telefragged
// 0x0000 (0x0090 - 0x0090)
class UDmgType_Telefragged : public UDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DmgType_Telefragged" );

		return pClassPointer;
	};

};

UClass* UDmgType_Telefragged::pClassPointer = NULL;

// Class Engine.DynamicPhysicsVolume
// 0x0004 (0x02D4 - 0x02D0)
class ADynamicPhysicsVolume : public APhysicsVolume
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x02D0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DynamicPhysicsVolume" );

		return pClassPointer;
	};

	void eventPostBeginPlay ( );
};

UClass* ADynamicPhysicsVolume::pClassPointer = NULL;

// Class Engine.DynamicSMActor_Spawnable
// 0x0000 (0x0294 - 0x0294)
class ADynamicSMActor_Spawnable : public ADynamicSMActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DynamicSMActor_Spawnable" );

		return pClassPointer;
	};

};

UClass* ADynamicSMActor_Spawnable::pClassPointer = NULL;

// Class Engine.DynamicTriggerVolume
// 0x0004 (0x0284 - 0x0280)
class ADynamicTriggerVolume : public ATriggerVolume
{
public:
	DWORD                                              bEnabled : 1;                                     		// 0x0280 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.DynamicTriggerVolume" );

		return pClassPointer;
	};

	void eventPostBeginPlay ( );
};

UClass* ADynamicTriggerVolume::pClassPointer = NULL;

// Class Engine.SeqAct_SetParticleSysParam
// 0x0018 (0x0168 - 0x0150)
class USeqAct_SetParticleSysParam : public USequenceAction
{
public:
	TArray< struct FParticleSysParam >                 InstanceParameters;                               		// 0x0150 (0x0010) [0x0000000000000000]              
	DWORD                                              bOverrideScalar : 1;                              		// 0x0160 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              ScalarValue;                                      		// 0x0164 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetParticleSysParam" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetParticleSysParam::pClassPointer = NULL;

// Class Engine.ExponentialHeightFog
// 0x000C (0x0250 - 0x0244)
class AExponentialHeightFog : public AInfo
{
public:
	class UExponentialHeightFogComponent*              Component;                                        		// 0x0244 (0x0008) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x024C (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ExponentialHeightFog" );

		return pClassPointer;
	};

	void OnToggle ( );
	void eventReplicatedEvent ( );
	void eventPostBeginPlay ( );
};

UClass* AExponentialHeightFog::pClassPointer = NULL;

// Class Engine.FailedConnect
// 0x0040 (0x00B4 - 0x0074)
class UFailedConnect : public ULocalMessage
{
public:
	struct FString                                     FailMessage[ 0x4 ];                               		// 0x0074 (0x0040) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FailedConnect" );

		return pClassPointer;
	};

	void GetString ( );
	void GetFailSwitch ( );
};

UClass* UFailedConnect::pClassPointer = NULL;

// Class Engine.FracturedSMActorSpawnable
// 0x0000 (0x02D8 - 0x02D8)
class AFracturedSMActorSpawnable : public AFracturedStaticMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FracturedSMActorSpawnable" );

		return pClassPointer;
	};

};

UClass* AFracturedSMActorSpawnable::pClassPointer = NULL;

// Class Engine.FracturedStaticMeshActor_Spawnable
// 0x0000 (0x02D8 - 0x02D8)
class AFracturedStaticMeshActor_Spawnable : public AFracturedStaticMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.FracturedStaticMeshActor_Spawnable" );

		return pClassPointer;
	};

};

UClass* AFracturedStaticMeshActor_Spawnable::pClassPointer = NULL;

// Class Engine.SeqEvent_PlayerSpawned
// 0x0008 (0x0178 - 0x0170)
class USeqEvent_PlayerSpawned : public USequenceEvent
{
public:
	class UObject*                                     SpawnPoint;                                       		// 0x0170 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_PlayerSpawned" );

		return pClassPointer;
	};

};

UClass* USeqEvent_PlayerSpawned::pClassPointer = NULL;

// Class Engine.HeightFog
// 0x000C (0x0250 - 0x0244)
class AHeightFog : public AInfo
{
public:
	class UHeightFogComponent*                         Component;                                        		// 0x0244 (0x0008) [0x0000000000000000]              
	DWORD                                              bEnabled : 1;                                     		// 0x024C (0x0004) [0x0000000000150000] [0x00000001] ( CPF_Travel | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.HeightFog" );

		return pClassPointer;
	};

	void OnToggle ( );
	void eventReplicatedEvent ( );
	void eventPostBeginPlay ( );
};

UClass* AHeightFog::pClassPointer = NULL;

// Class Engine.InterpActor_ForCinematic
// 0x0000 (0x02E0 - 0x02E0)
class AInterpActor_ForCinematic : public AInterpActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.InterpActor_ForCinematic" );

		return pClassPointer;
	};

};

UClass* AInterpActor_ForCinematic::pClassPointer = NULL;

// Class Engine.MaterialInstanceTimeVaryingActor
// 0x0008 (0x024C - 0x0244)
class AMaterialInstanceTimeVaryingActor : public AActor
{
public:
	class UMaterialInstanceTimeVarying*                MatInst;                                          		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.MaterialInstanceTimeVaryingActor" );

		return pClassPointer;
	};

};

UClass* AMaterialInstanceTimeVaryingActor::pClassPointer = NULL;

// Class Engine.SeqAct_GiveInventory
// 0x0014 (0x0164 - 0x0150)
class USeqAct_GiveInventory : public USequenceAction
{
public:
	TArray< class UClass* >                            InventoryList;                                    		// 0x0150 (0x0010) [0x0000000000000000]              
	DWORD                                              bClearExisting : 1;                               		// 0x0160 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bForceReplace : 1;                                		// 0x0160 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_GiveInventory" );

		return pClassPointer;
	};

};

UClass* USeqAct_GiveInventory::pClassPointer = NULL;

// Class Engine.SeqAct_AssignController
// 0x0008 (0x0158 - 0x0150)
class USeqAct_AssignController : public USequenceAction
{
public:
	class UClass*                                      ControllerClass;                                  		// 0x0150 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_AssignController" );

		return pClassPointer;
	};

};

UClass* USeqAct_AssignController::pClassPointer = NULL;

// Class Engine.NavMeshBoundsVolume
// 0x0000 (0x0280 - 0x0280)
class ANavMeshBoundsVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.NavMeshBoundsVolume" );

		return pClassPointer;
	};

};

UClass* ANavMeshBoundsVolume::pClassPointer = NULL;

// Class Engine.OnlineEventsInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineEventsInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineEventsInterface" );

		return pClassPointer;
	};

	void UpdatePlaylistPopulation ( );
	void UploadGameplayEventsData ( );
	void UploadPlayerData ( );
};

UClass* UOnlineEventsInterface::pClassPointer = NULL;

// Class Engine.OnlineGameDownloadInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineGameDownloadInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineGameDownloadInterface" );

		return pClassPointer;
	};

	void ClearOnChunkCompleteDelegate ( );
	void AddOnChunkCompleteDelegate ( );
	void OnChunkComplete ( );
	void SetDownloadSpeed ( );
	void SetChunksHighPriority ( );
	void GetTodoList ( );
	void GetOverallProgress ( );
	void GetChunksProgress ( );
	void GetChunkProgress ( );
	void GetChunksETA ( );
	void GetChunkETA ( );
	void RefreshGame ( );
	void DoesGameNeedRefresh ( );
	void AreChunksComplete ( );
	void IsChunkComplete ( );
	void IsGameComplete ( );
};

UClass* UOnlineGameDownloadInterface::pClassPointer = NULL;

// Class Engine.OnlinePlaylistGameTypeProvider
// 0x002C (0x00C0 - 0x0094)
class UOnlinePlaylistGameTypeProvider : public UUIResourceDataProvider
{
public:
	struct FName                                       PlaylistGameTypeName;                             		// 0x0094 (0x0008) [0x0000000000000000]              
	struct FString                                     DisplayName;                                      		// 0x009C (0x0010) [0x0000000000000000]              
	struct FString                                     Description;                                      		// 0x00AC (0x0010) [0x0000000000000000]              
	int                                                GameTypeId;                                       		// 0x00BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlinePlaylistGameTypeProvider" );

		return pClassPointer;
	};

};

UClass* UOnlinePlaylistGameTypeProvider::pClassPointer = NULL;

// Class Engine.OnlineRecentPlayersList
// 0x0058 (0x00B8 - 0x0060)
class UOnlineRecentPlayersList : public UObject
{
public:
	TArray< struct FUniqueNetId >                      RecentPlayers;                                    		// 0x0060 (0x0010) [0x0000000000000000]              
	TArray< struct FRecentParty >                      RecentParties;                                    		// 0x0070 (0x0010) [0x0000000000000000]              
	struct FRecentParty                                LastParty;                                        		// 0x0080 (0x0018) [0x0000000000000000]              
	int                                                MaxRecentPlayers;                                 		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                MaxRecentParties;                                 		// 0x009C (0x0004) [0x0000000000000000]              
	int                                                RecentPlayersAddIndex;                            		// 0x00A0 (0x0004) [0x0000000000000000]              
	int                                                RecentPartiesAddIndex;                            		// 0x00A4 (0x0004) [0x0000000000000000]              
	TArray< struct FCurrentPlayerMet >                 CurrentPlayers;                                   		// 0x00A8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineRecentPlayersList" );

		return pClassPointer;
	};

	void GetCurrentPlayersListCount ( );
	void SetCurrentPlayersList ( );
	void DumpCurrentPlayers ( );
	void DumpPlayersList ( );
	void ShowCurrentPlayersList ( );
	void ShowLastPartyPlayerList ( );
	void ShowRecentPartiesPlayerList ( );
	void ShowRecentPlayerList ( );
	void SetLastParty ( );
	void GetTeamForCurrentPlayer ( );
	void GetSkillForCurrentPlayer ( );
	void GetPlayersFromCurrentPlayers ( );
	void GetPlayersFromRecentParties ( );
	void ClearRecentParties ( );
	void AddPartyToRecentParties ( );
	void ClearRecentPlayers ( );
	void AddPlayerToRecentPlayers ( );
};

UClass* UOnlineRecentPlayersList::pClassPointer = NULL;

// Class Engine.OnlineSuppliedUIInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineSuppliedUIInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.OnlineSuppliedUIInterface" );

		return pClassPointer;
	};

	void ShowMatchmakingUI ( );
	void ClearShowOnlineStatsUICompleteDelegate ( );
	void AddShowOnlineStatsUICompleteDelegate ( );
	void ShowOnlineStatsUI ( );
	void OnShowOnlineStatsUIComplete ( );
};

UClass* UOnlineSuppliedUIInterface::pClassPointer = NULL;

// Class Engine.ParticleModuleForceFieldCylindrical
// 0x0000 (0x0074 - 0x0074)
class UParticleModuleForceFieldCylindrical : public UParticleModuleForceFieldBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleForceFieldCylindrical" );

		return pClassPointer;
	};

};

UClass* UParticleModuleForceFieldCylindrical::pClassPointer = NULL;

// Class Engine.ParticleModuleForceFieldGeneric
// 0x0000 (0x0074 - 0x0074)
class UParticleModuleForceFieldGeneric : public UParticleModuleForceFieldBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleForceFieldGeneric" );

		return pClassPointer;
	};

};

UClass* UParticleModuleForceFieldGeneric::pClassPointer = NULL;

// Class Engine.ParticleModuleForceFieldRadial
// 0x0000 (0x0074 - 0x0074)
class UParticleModuleForceFieldRadial : public UParticleModuleForceFieldBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleForceFieldRadial" );

		return pClassPointer;
	};

};

UClass* UParticleModuleForceFieldRadial::pClassPointer = NULL;

// Class Engine.ParticleModuleForceFieldTornado
// 0x0000 (0x0074 - 0x0074)
class UParticleModuleForceFieldTornado : public UParticleModuleForceFieldBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ParticleModuleForceFieldTornado" );

		return pClassPointer;
	};

};

UClass* UParticleModuleForceFieldTornado::pClassPointer = NULL;

// Class Engine.PathNode_Dynamic
// 0x0000 (0x037C - 0x037C)
class APathNode_Dynamic : public APathNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.PathNode_Dynamic" );

		return pClassPointer;
	};

	void eventGetDebugAbbrev ( );
};

UClass* APathNode_Dynamic::pClassPointer = NULL;

// Class Engine.SeqEvent_AIReachedRouteActor
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_AIReachedRouteActor : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_AIReachedRouteActor" );

		return pClassPointer;
	};

};

UClass* USeqEvent_AIReachedRouteActor::pClassPointer = NULL;

// Class Engine.SeqEvent_PickupStatusChange
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_PickupStatusChange : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_PickupStatusChange" );

		return pClassPointer;
	};

};

UClass* USeqEvent_PickupStatusChange::pClassPointer = NULL;

// Class Engine.RadialBlurActor
// 0x0008 (0x024C - 0x0244)
class ARadialBlurActor : public AActor
{
public:
	class URadialBlurComponent*                        RadialBlur;                                       		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RadialBlurActor" );

		return pClassPointer;
	};

};

UClass* ARadialBlurActor::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleConstraintDrive
// 0x0004 (0x0154 - 0x0150)
class USeqAct_ToggleConstraintDrive : public USequenceAction
{
public:
	DWORD                                              bEnableAngularPositionDrive : 1;                  		// 0x0150 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bEnableAngularVelocityDrive : 1;                  		// 0x0150 (0x0004) [0x0000000000000000] [0x00000002] 
	DWORD                                              bEnableLinearPositionDrive : 1;                   		// 0x0150 (0x0004) [0x0000000000000000] [0x00000004] 
	DWORD                                              bEnableLinearvelocityDrive : 1;                   		// 0x0150 (0x0004) [0x0000000000000000] [0x00000008] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ToggleConstraintDrive" );

		return pClassPointer;
	};

};

UClass* USeqAct_ToggleConstraintDrive::pClassPointer = NULL;

// Class Engine.RB_BSJointActor
// 0x0000 (0x0278 - 0x0278)
class ARB_BSJointActor : public ARB_ConstraintActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_BSJointActor" );

		return pClassPointer;
	};

};

UClass* ARB_BSJointActor::pClassPointer = NULL;

// Class Engine.RB_ConstraintActorSpawnable
// 0x0000 (0x0278 - 0x0278)
class ARB_ConstraintActorSpawnable : public ARB_ConstraintActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_ConstraintActorSpawnable" );

		return pClassPointer;
	};

};

UClass* ARB_ConstraintActorSpawnable::pClassPointer = NULL;

// Class Engine.RB_HingeActor
// 0x0000 (0x0278 - 0x0278)
class ARB_HingeActor : public ARB_ConstraintActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_HingeActor" );

		return pClassPointer;
	};

};

UClass* ARB_HingeActor::pClassPointer = NULL;

// Class Engine.RB_PrismaticActor
// 0x0000 (0x0278 - 0x0278)
class ARB_PrismaticActor : public ARB_ConstraintActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_PrismaticActor" );

		return pClassPointer;
	};

};

UClass* ARB_PrismaticActor::pClassPointer = NULL;

// Class Engine.RB_PulleyJointActor
// 0x0000 (0x0278 - 0x0278)
class ARB_PulleyJointActor : public ARB_ConstraintActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.RB_PulleyJointActor" );

		return pClassPointer;
	};

};

UClass* ARB_PulleyJointActor::pClassPointer = NULL;

// Class Engine.ReverbVolumeToggleable
// 0x0000 (0x02C4 - 0x02C4)
class AReverbVolumeToggleable : public AReverbVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.ReverbVolumeToggleable" );

		return pClassPointer;
	};

	void OnToggle ( );
};

UClass* AReverbVolumeToggleable::pClassPointer = NULL;

// Class Engine.SeqAct_AddRemoveFaceFXAnimSet
// 0x0010 (0x0160 - 0x0150)
class USeqAct_AddRemoveFaceFXAnimSet : public USequenceAction
{
public:
	TArray< class UFaceFXAnimSet* >                    FaceFXAnimSets;                                   		// 0x0150 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_AddRemoveFaceFXAnimSet" );

		return pClassPointer;
	};

};

UClass* USeqAct_AddRemoveFaceFXAnimSet::pClassPointer = NULL;

// Class Engine.SeqAct_AIAbortMoveToActor
// 0x0000 (0x0150 - 0x0150)
class USeqAct_AIAbortMoveToActor : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_AIAbortMoveToActor" );

		return pClassPointer;
	};

};

UClass* USeqAct_AIAbortMoveToActor::pClassPointer = NULL;

// Class Engine.SeqAct_MITV_Activate
// 0x0004 (0x0154 - 0x0150)
class USeqAct_MITV_Activate : public USequenceAction
{
public:
	float                                              DurationOfMITV;                                   		// 0x0150 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_MITV_Activate" );

		return pClassPointer;
	};

	void eventActivated ( );
	void eventGetObjClassVersion ( );
};

UClass* USeqAct_MITV_Activate::pClassPointer = NULL;

// Class Engine.SeqAct_SetMatInstTexParam
// 0x0018 (0x0168 - 0x0150)
class USeqAct_SetMatInstTexParam : public USequenceAction
{
public:
	class UMaterialInstanceConstant*                   MatInst;                                          		// 0x0150 (0x0008) [0x0000000000000000]              
	class UTexture*                                    NewTexture;                                       		// 0x0158 (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName;                                        		// 0x0160 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetMatInstTexParam" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetMatInstTexParam::pClassPointer = NULL;

// Class Engine.SeqAct_SetMatInstVectorParam
// 0x0020 (0x0170 - 0x0150)
class USeqAct_SetMatInstVectorParam : public USequenceAction
{
public:
	class UMaterialInstanceConstant*                   MatInst;                                          		// 0x0150 (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName;                                        		// 0x0158 (0x0008) [0x0000000000000000]              
	struct FLinearColor                                VectorValue;                                      		// 0x0160 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetMatInstVectorParam" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_SetMatInstVectorParam::pClassPointer = NULL;

// Class Engine.SeqAct_SetSkelControlTarget
// 0x0018 (0x0168 - 0x0150)
class USeqAct_SetSkelControlTarget : public USequenceAction
{
public:
	struct FName                                       SkelControlName;                                  		// 0x0150 (0x0008) [0x0000000000000000]              
	TArray< class UObject* >                           TargetActors;                                     		// 0x0158 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetSkelControlTarget" );

		return pClassPointer;
	};

};

UClass* USeqAct_SetSkelControlTarget::pClassPointer = NULL;

// Class Engine.SeqAct_SetVector
// 0x000C (0x015C - 0x0150)
class USeqAct_SetVector : public USeqAct_SetSequenceVariable
{
public:
	struct FVector                                     DefaultValue;                                     		// 0x0150 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_SetVector" );

		return pClassPointer;
	};

	void eventActivated ( );
};

UClass* USeqAct_SetVector::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleAffectedByHitEffects
// 0x0000 (0x0150 - 0x0150)
class USeqAct_ToggleAffectedByHitEffects : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_ToggleAffectedByHitEffects" );

		return pClassPointer;
	};

};

UClass* USeqAct_ToggleAffectedByHitEffects::pClassPointer = NULL;

// Class Engine.SeqAct_UpdatePhysBonesFromAnim
// 0x0000 (0x0150 - 0x0150)
class USeqAct_UpdatePhysBonesFromAnim : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqAct_UpdatePhysBonesFromAnim" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqAct_UpdatePhysBonesFromAnim::pClassPointer = NULL;

// Class Engine.SeqEvent_LOS
// 0x000C (0x017C - 0x0170)
class USeqEvent_LOS : public USequenceEvent
{
public:
	float                                              ScreenCenterDistance;                             		// 0x0170 (0x0004) [0x0000000000000000]              
	float                                              TriggerDistance;                                  		// 0x0174 (0x0004) [0x0000000000000000]              
	DWORD                                              bCheckForObstructions : 1;                        		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqEvent_LOS" );

		return pClassPointer;
	};

	void eventGetObjClassVersion ( );
};

UClass* USeqEvent_LOS::pClassPointer = NULL;

// Class Engine.SeqVar_Byte
// 0x0000 (0x00D4 - 0x00D4)
class USeqVar_Byte : public USequenceVariable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_Byte" );

		return pClassPointer;
	};

};

UClass* USeqVar_Byte::pClassPointer = NULL;

// Class Engine.SeqVar_Name
// 0x0000 (0x00D4 - 0x00D4)
class USeqVar_Name : public USequenceVariable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_Name" );

		return pClassPointer;
	};

};

UClass* USeqVar_Name::pClassPointer = NULL;

// Class Engine.SeqVar_Union
// 0x0000 (0x00D4 - 0x00D4)
class USeqVar_Union : public USequenceVariable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SeqVar_Union" );

		return pClassPointer;
	};

};

UClass* USeqVar_Union::pClassPointer = NULL;

// Class Engine.SkeletalMeshActorMATSpawnable
// 0x0000 (0x02B4 - 0x02B4)
class ASkeletalMeshActorMATSpawnable : public ASkeletalMeshActorMAT
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkeletalMeshActorMATSpawnable" );

		return pClassPointer;
	};

};

UClass* ASkeletalMeshActorMATSpawnable::pClassPointer = NULL;

// Class Engine.SkeletalMeshActorMATWalkable
// 0x0000 (0x02B4 - 0x02B4)
class ASkeletalMeshActorMATWalkable : public ASkeletalMeshActorMAT
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.SkeletalMeshActorMATWalkable" );

		return pClassPointer;
	};

};

UClass* ASkeletalMeshActorMATWalkable::pClassPointer = NULL;

// Class Engine.Trigger_Dynamic
// 0x0000 (0x0254 - 0x0254)
class ATrigger_Dynamic : public ATrigger
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Trigger_Dynamic" );

		return pClassPointer;
	};

};

UClass* ATrigger_Dynamic::pClassPointer = NULL;

// Class Engine.Trigger_LOS
// 0x0010 (0x0264 - 0x0254)
class ATrigger_LOS : public ATrigger
{
public:
	TArray< class APlayerController* >                 PCsWithLOS;                                       		// 0x0254 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.Trigger_LOS" );

		return pClassPointer;
	};

	void eventTick ( );
};

UClass* ATrigger_LOS::pClassPointer = NULL;

// Class Engine.TriggeredPath
// 0x000C (0x0388 - 0x037C)
class ATriggeredPath : public ANavigationPoint
{
public:
	DWORD                                              bOpen : 1;                                        		// 0x037C (0x0004) [0x0000000000000000] [0x00000001] 
	class AActor*                                      MyTrigger;                                        		// 0x0380 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TriggeredPath" );

		return pClassPointer;
	};

	void eventSuggestMovePreparation ( );
	void eventSpecialHandling ( );
	void OnToggle ( );
};

UClass* ATriggeredPath::pClassPointer = NULL;

// Class Engine.TriggerStreamingLevel
// 0x0010 (0x0264 - 0x0254)
class ATriggerStreamingLevel : public ATrigger
{
public:
	TArray< struct FLevelStreamingData >               Levels;                                           		// 0x0254 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.TriggerStreamingLevel" );

		return pClassPointer;
	};

	void eventTouch ( );
};

UClass* ATriggerStreamingLevel::pClassPointer = NULL;

// Class Engine.UICharacterSummary
// 0x0034 (0x00C8 - 0x0094)
class UUICharacterSummary : public UUIResourceDataProvider
{
public:
	struct FString                                     ClassPathName;                                    		// 0x0094 (0x0010) [0x0000000000000000]              
	struct FString                                     CharacterName;                                    		// 0x00A4 (0x0010) [0x0000000000000000]              
	struct FString                                     CharacterBio;                                     		// 0x00B4 (0x0010) [0x0000000000000000]              
	DWORD                                              bIsDisabled : 1;                                  		// 0x00C4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UICharacterSummary" );

		return pClassPointer;
	};

};

UClass* UUICharacterSummary::pClassPointer = NULL;

// Class Engine.UIGameInfoSummary
// 0x0064 (0x00F8 - 0x0094)
class UUIGameInfoSummary : public UUIResourceDataProvider
{
public:
	struct FString                                     ClassName;                                        		// 0x0094 (0x0010) [0x0000000000000000]              
	struct FString                                     GameAcronym;                                      		// 0x00A4 (0x0010) [0x0000000000000000]              
	struct FString                                     MapPrefix;                                        		// 0x00B4 (0x0010) [0x0000000000000000]              
	DWORD                                              bIsTeamGame : 1;                                  		// 0x00C4 (0x0004) [0x0000000000000000] [0x00000001] 
	DWORD                                              bIsDisabled : 1;                                  		// 0x00C4 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FString                                     GameSettingsClassName;                            		// 0x00C8 (0x0010) [0x0000000000000000]              
	struct FString                                     GameName;                                         		// 0x00D8 (0x0010) [0x0000000000000000]              
	struct FString                                     Description;                                      		// 0x00E8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIGameInfoSummary" );

		return pClassPointer;
	};

};

UClass* UUIGameInfoSummary::pClassPointer = NULL;

// Class Engine.UIMapSummary
// 0x0040 (0x00D4 - 0x0094)
class UUIMapSummary : public UUIResourceDataProvider
{
public:
	struct FString                                     MapName;                                          		// 0x0094 (0x0010) [0x0000000000000000]              
	struct FString                                     ScreenshotPathName;                               		// 0x00A4 (0x0010) [0x0000000000000000]              
	struct FString                                     DisplayName;                                      		// 0x00B4 (0x0010) [0x0000000000000000]              
	struct FString                                     Description;                                      		// 0x00C4 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIMapSummary" );

		return pClassPointer;
	};

};

UClass* UUIMapSummary::pClassPointer = NULL;

// Class Engine.UIWeaponSummary
// 0x0034 (0x00C8 - 0x0094)
class UUIWeaponSummary : public UUIResourceDataProvider
{
public:
	struct FString                                     ClassPathName;                                    		// 0x0094 (0x0010) [0x0000000000000000]              
	struct FString                                     FriendlyName;                                     		// 0x00A4 (0x0010) [0x0000000000000000]              
	struct FString                                     WeaponDescription;                                		// 0x00B4 (0x0010) [0x0000000000000000]              
	DWORD                                              bIsDisabled : 1;                                  		// 0x00C4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UIWeaponSummary" );

		return pClassPointer;
	};

};

UClass* UUIWeaponSummary::pClassPointer = NULL;

// Class Engine.UserCloudFileCloudSaveSystemDataBlobStore
// 0x0070 (0x00D0 - 0x0060)
class UUserCloudFileCloudSaveSystemDataBlobStore : public UObject
{
public:
	class UUserCloudFileInterface*                     UserCloudFile;                                    		// 0x0060 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0068 (0x0008) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             GetDataBlobCallback;                              		// 0x0070 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x4 ];                             		// 0x0074 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             SetDataBlobCallback;                              		// 0x0080 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData02[ 0x4 ];                             		// 0x0084 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             DeleteDataBlobCallback;                           		// 0x0090 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData03[ 0x4 ];                             		// 0x0094 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __GetDataBlobCallbackDelegate__Delegate;          		// 0x00A0 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData04[ 0x4 ];                             		// 0x00A4 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __SetDataBlobCallbackDelegate__Delegate;          		// 0x00B0 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData05[ 0x4 ];                             		// 0x00B4 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FScriptDelegate                             __DeleteDataBlobCallbackDelegate__Delegate;       		// 0x00C0 (0x0010) [0x0000000000000000]              
	unsigned char                                      UnknownData06[ 0x4 ];                             		// 0x00C4 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.UserCloudFileCloudSaveSystemDataBlobStore" );

		return pClassPointer;
	};

	void OnDeleteUserFileComplete ( );
	void DeleteDataBlob ( );
	void OnWriteUserFileComplete ( );
	void SetDataBlob ( );
	void OnReadUserFileComplete ( );
	void GetDataBlob ( );
	void Init ( );
	void DeleteDataBlobCallbackDelegate ( );
	void SetDataBlobCallbackDelegate ( );
	void GetDataBlobCallbackDelegate ( );
};

UClass* UUserCloudFileCloudSaveSystemDataBlobStore::pClassPointer = NULL;

// Class Engine.WaterVolume
// 0x0020 (0x02F0 - 0x02D0)
class AWaterVolume : public APhysicsVolume
{
public:
	class USoundCue*                                   EntrySound;                                       		// 0x02D0 (0x0008) [0x0000000000000000]              
	class UClass*                                      EntryActor;                                       		// 0x02D8 (0x0008) [0x0000000000000000]              
	class USoundCue*                                   ExitSound;                                        		// 0x02E0 (0x0008) [0x0000000000000000]              
	class UClass*                                      ExitActor;                                        		// 0x02E8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.WaterVolume" );

		return pClassPointer;
	};

	void PlayExitSplash ( );
	void eventUnTouch ( );
	void PlayEntrySplash ( );
	void eventTouch ( );
};

UClass* AWaterVolume::pClassPointer = NULL;

// Class Engine.WindDirectionalSource
// 0x0008 (0x024C - 0x0244)
class AWindDirectionalSource : public AInfo
{
public:
	class UWindDirectionalSourceComponent*             Component;                                        		// 0x0244 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = UObject::FindClass ( "Class Engine.WindDirectionalSource" );

		return pClassPointer;
	};

};

UClass* AWindDirectionalSource::pClassPointer = NULL;


#ifdef _MSC_VER
	#pragma pack ( pop )
#endif